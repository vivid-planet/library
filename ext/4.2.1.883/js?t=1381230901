/* *** /var/www/library/ext/4.2.1.883/src/Ext.js */
(function(Ext) {
Ext.buildSettings = { baseCSSPrefix: "x4-", scopeResetCSS: true };
Ext.isSandboxed = true;
Ext.sandboxName = 'Ext4';
// @tag foundation,core
// @define Ext
var Ext = Ext || {};
Ext._startTime = new Date().getTime();
(function() {
var global = this,
objectPrototype = Object.prototype,
toString = objectPrototype.toString,
enumerables = true,
enumerablesTest = {toString: 1},
emptyFn = function () {},
// This is the "$previous" method of a hook function on an instance. When called, it
// calls through the class prototype by the name of the called method.
callOverrideParent = function () {
var method = callOverrideParent.caller.caller; // skip callParent (our caller)
return method.$owner.prototype[method.$name].apply(this, arguments);
},
i,
nonWhitespaceRe = /\S/,
ExtApp,
iterableRe = /\[object\s*(?:Array|Arguments|\w*Collection|\w*List|HTML\s+document\.all\s+class)\]/;
Function.prototype.$extIsFunction = true;
Ext.global = global;
for (i in enumerablesTest) {
enumerables = null;
}
if (enumerables) {
enumerables = ['hasOwnProperty', 'valueOf', 'isPrototypeOf', 'propertyIsEnumerable',
'toLocaleString', 'toString', 'constructor'];
}

Ext.enumerables = enumerables;

Ext.apply = function(object, config, defaults) {
if (defaults) {
Ext.apply(object, defaults);
}
if (object && config && typeof config === 'object') {
var i, j, k;
for (i in config) {
object[i] = config[i];
}
if (enumerables) {
for (j = enumerables.length; j--;) {
k = enumerables[j];
if (config.hasOwnProperty(k)) {
object[k] = config[k];
}
}
}
}
return object;
};
Ext.buildSettings = Ext.apply({
baseCSSPrefix: 'x-'
}, Ext.buildSettings || {});
Ext.apply(Ext, {

name: Ext.sandboxName || 'Ext',

emptyFn: emptyFn,


identityFn: function(o) {
return o;
},

emptyString: new String(),
baseCSSPrefix: Ext.buildSettings.baseCSSPrefix,

applyIf: function(object, config) {
var property;
if (object) {
for (property in config) {
if (object[property] === undefined) {
object[property] = config[property];
}
}
}
return object;
},

iterate: function(object, fn, scope) {
if (Ext.isEmpty(object)) {
return;
}
if (scope === undefined) {
scope = object;
}
if (Ext.isIterable(object)) {
Ext.Array.each.call(Ext.Array, object, fn, scope);
}
else {
Ext.Object.each.call(Ext.Object, object, fn, scope);
}
}
});
Ext.apply(Ext, {

extend: (function() {
// inline overrides
var objectConstructor = objectPrototype.constructor,
inlineOverrides = function(o) {
for (var m in o) {
if (!o.hasOwnProperty(m)) {
continue;
}
this[m] = o[m];
}
};
return function(subclass, superclass, overrides) {
// First we check if the user passed in just the superClass with overrides
if (Ext.isObject(superclass)) {
overrides = superclass;
superclass = subclass;
subclass = overrides.constructor !== objectConstructor ? overrides.constructor : function() {
superclass.apply(this, arguments);
};
}
//<debug>
if (!superclass) {
Ext.Error.raise({
sourceClass: 'Ext',
sourceMethod: 'extend',
msg: 'Attempting to extend from a class which has not been loaded on the page.'
});
}
//</debug>
// We create a new temporary class
var F = function() {},
subclassProto, superclassProto = superclass.prototype;
F.prototype = superclassProto;
subclassProto = subclass.prototype = new F();
subclassProto.constructor = subclass;
subclass.superclass = superclassProto;
if (superclassProto.constructor === objectConstructor) {
superclassProto.constructor = superclass;
}
subclass.override = function(overrides) {
Ext.override(subclass, overrides);
};
subclassProto.override = inlineOverrides;
subclassProto.proto = subclassProto;
subclass.override(overrides);
subclass.extend = function(o) {
return Ext.extend(subclass, o);
};
return subclass;
};
}()),

override: function (target, overrides) {
if (target.$isClass) {
target.override(overrides);
} else if (typeof target == 'function') {
Ext.apply(target.prototype, overrides);
} else {
var owner = target.self,
name, value;
if (owner && owner.$isClass) { // if (instance of Ext.define'd class)
for (name in overrides) {
if (overrides.hasOwnProperty(name)) {
value = overrides[name];
if (typeof value == 'function') {
//<debug>
if (owner.$className) {
value.displayName = owner.$className + '#' + name;
}
//</debug>
value.$name = name;
value.$owner = owner;
value.$previous = target.hasOwnProperty(name)
? target[name] // already hooked, so call previous hook
: callOverrideParent; // calls by name on prototype
}
target[name] = value;
}
}
} else {
Ext.apply(target, overrides);
}
}
return target;
}
});
// A full set of static methods to do type checking
Ext.apply(Ext, {

valueFrom: function(value, defaultValue, allowBlank){
return Ext.isEmpty(value, allowBlank) ? defaultValue : value;
},

typeOf: function(value) {
var type,
typeToString;

if (value === null) {
return 'null';
}
type = typeof value;
if (type === 'undefined' || type === 'string' || type === 'number' || type === 'boolean') {
return type;
}
typeToString = toString.call(value);
switch(typeToString) {
case '[object Array]':
return 'array';
case '[object Date]':
return 'date';
case '[object Boolean]':
return 'boolean';
case '[object Number]':
return 'number';
case '[object RegExp]':
return 'regexp';
}
if (type === 'function') {
return 'function';
}
if (type === 'object') {
if (value.nodeType !== undefined) {
if (value.nodeType === 3) {
return (nonWhitespaceRe).test(value.nodeValue) ? 'textnode' : 'whitespace';
}
else {
return 'element';
}
}
return 'object';
}
//<debug error>
Ext.Error.raise({
sourceClass: 'Ext',
sourceMethod: 'typeOf',
msg: 'Failed to determine the type of the specified value "' + value + '". This is most likely a bug.'
});
//</debug>
},

coerce: function(from, to) {
var fromType = Ext.typeOf(from),
toType = Ext.typeOf(to),
isString = typeof from === 'string';
if (fromType !== toType) {
switch (toType) {
case 'string':
return String(from);
case 'number':
return Number(from);
case 'boolean':
return isString && (!from || from === 'false') ? false : Boolean(from);
case 'null':
return isString && (!from || from === 'null') ? null : from;
case 'undefined':
return isString && (!from || from === 'undefined') ? undefined : from;
case 'date':
return isString && isNaN(from) ? Ext.Date.parse(from, Ext.Date.defaultFormat) : Date(Number(from));
}
}
return from;
},

isEmpty: function(value, allowEmptyString) {
return (value === null) || (value === undefined) || (!allowEmptyString ? value === '' : false) || (Ext.isArray(value) && value.length === 0);
},

isArray: ('isArray' in Array) ? Array.isArray : function(value) {
return toString.call(value) === '[object Array]';
},

isDate: function(value) {
return toString.call(value) === '[object Date]';
},

isObject: (toString.call(null) === '[object Object]') ?
function(value) {
// check ownerDocument here as well to exclude DOM nodes
return value !== null && value !== undefined && toString.call(value) === '[object Object]' && value.ownerDocument === undefined;
} :
function(value) {
return toString.call(value) === '[object Object]';
},

isSimpleObject: function(value) {
return value instanceof Object && value.constructor === Object;
},

isPrimitive: function(value) {
var type = typeof value;
return type === 'string' || type === 'number' || type === 'boolean';
},

isFunction: function(value) {
return !!(value && value.$extIsFunction);
},

isNumber: function(value) {
return typeof value === 'number' && isFinite(value);
},

isNumeric: function(value) {
return !isNaN(parseFloat(value)) && isFinite(value);
},

isString: function(value) {
return typeof value === 'string';
},

isBoolean: function(value) {
return typeof value === 'boolean';
},

isElement: function(value) {
return value ? value.nodeType === 1 : false;
},

isTextNode: function(value) {
return value ? value.nodeName === "#text" : false;
},

isDefined: function(value) {
return typeof value !== 'undefined';
},

isIterable: function(value) {
// To be iterable, the object must have a numeric length property and must not be a string or function.
if (!value || typeof value.length !== 'number' || typeof value === 'string' || value.$extIsFunction) {
return false;
}
// Certain "standard" collections in IE (such as document.images) do not offer the correct
// Javascript Object interface; specifically, they lack the propertyIsEnumerable method.
// And the item property while it does exist is not typeof "function"
if (!value.propertyIsEnumerable) {
return !!value.item;
}
// If it is a regular, interrogatable JS object (not an IE ActiveX object), then...
// If it has its own property called "length", but not enumerable, it's iterable
if (value.hasOwnProperty('length') && !value.propertyIsEnumerable('length')) {
return true;
}
// Test against whitelist which includes known iterable collection types
return iterableRe.test(toString.call(value));
}
});
Ext.apply(Ext, {

clone: function(item) {
var type,
i,
j,
k,
clone,
key;

if (item === null || item === undefined) {
return item;
}
// DOM nodes
// TODO proxy this to Ext.Element.clone to handle automatic id attribute changing
// recursively
if (item.nodeType && item.cloneNode) {
return item.cloneNode(true);
}
type = toString.call(item);
// Date
if (type === '[object Date]') {
return new Date(item.getTime());
}
// Array
if (type === '[object Array]') {
i = item.length;
clone = [];
while (i--) {
clone[i] = Ext.clone(item[i]);
}
}
// Object
else if (type === '[object Object]' && item.constructor === Object) {
clone = {};
for (key in item) {
clone[key] = Ext.clone(item[key]);
}
if (enumerables) {
for (j = enumerables.length; j--;) {
k = enumerables[j];
if (item.hasOwnProperty(k)) {
clone[k] = item[k];
}
}
}
}
return clone || item;
},

getUniqueGlobalNamespace: function() {
var uniqueGlobalNamespace = this.uniqueGlobalNamespace,
i;
if (uniqueGlobalNamespace === undefined) {
i = 0;
do {
uniqueGlobalNamespace = 'ExtBox' + (++i);
} while (Ext.global[uniqueGlobalNamespace] !== undefined);
Ext.global[uniqueGlobalNamespace] = Ext;
this.uniqueGlobalNamespace = uniqueGlobalNamespace;
}
return uniqueGlobalNamespace;
},


functionFactoryCache: {},

cacheableFunctionFactory: function() {
var me = this,
args = Array.prototype.slice.call(arguments),
cache = me.functionFactoryCache,
idx, fn, ln;

if (Ext.isSandboxed) {
ln = args.length;
if (ln > 0) {
ln--;
args[ln] = 'var Ext=window.' + Ext.name + ';' + args[ln];
}
}
idx = args.join('');
fn = cache[idx];
if (!fn) {
fn = Function.prototype.constructor.apply(Function.prototype, args);

cache[idx] = fn;
}
return fn;
},

functionFactory: function() {
var me = this,
args = Array.prototype.slice.call(arguments),
ln;

if (Ext.isSandboxed) {
ln = args.length;
if (ln > 0) {
ln--;
args[ln] = 'var Ext=window.' + Ext.name + ';' + args[ln];
}
}

return Function.prototype.constructor.apply(Function.prototype, args);
},

Logger: {
verbose: emptyFn,
log: emptyFn,
info: emptyFn,
warn: emptyFn,
error: function(message) {
throw new Error(message);
},
deprecate: emptyFn
}
});

Ext.type = Ext.typeOf;

// When using Cmd optimizations, the namespace Ext.app may already be defined
// by this point since it's done up front by the tool. Check if app already
// exists before overwriting it.
ExtApp = Ext.app;
if (!ExtApp) {
ExtApp = Ext.app = {};
}
Ext.apply(ExtApp, {
namespaces: {},


collectNamespaces: function(paths) {
var namespaces = Ext.app.namespaces,
path;

for (path in paths) {
if (paths.hasOwnProperty(path)) {
namespaces[path] = true;
}
}
},

addNamespaces: function(ns) {
var namespaces = Ext.app.namespaces,
i, l;
if (!Ext.isArray(ns)) {
ns = [ns];
}
for (i = 0, l = ns.length; i < l; i++) {
namespaces[ns[i]] = true;
}
},

clearNamespaces: function() {
Ext.app.namespaces = {};
},

getNamespace: function(className) {
var namespaces = Ext.app.namespaces,
deepestPrefix = '',
prefix;
for (prefix in namespaces) {
if (namespaces.hasOwnProperty(prefix) &&
prefix.length > deepestPrefix.length &&
(prefix + '.' === className.substring(0, prefix.length + 1))) {
deepestPrefix = prefix;
}
}
return deepestPrefix === '' ? undefined : deepestPrefix;
}
});
}());
Ext.globalEval = Ext.global.execScript
? function(code) {
execScript(code);
}
: function($$code) {
// IMPORTANT: because we use eval we cannot place this in the above function or it
// will break the compressor's ability to rename local variables...
(function(){
// This var should not be replaced by the compressor. We need to do this so
// that Ext refers to the global Ext, if we're sandboxing it may
// refer to the local instance inside the closure
var Ext = this.Ext;
eval($$code);
}());
};
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/version/Version.js */
(function(Ext) {
// @tag foundation,core
// @require ../Ext.js
// @define Ext.Version
(function() {
// Current core version
// also fix Ext-more.js
var version = '4.2.1.883', Version;
Ext.Version = Version = Ext.extend(Object, {

constructor: function(version) {
var parts, releaseStartIndex;
if (version instanceof Version) {
return version;
}
this.version = this.shortVersion = String(version).toLowerCase().replace(/_/g, '.').replace(/[\-+]/g, '');
releaseStartIndex = this.version.search(/([^\d\.])/);
if (releaseStartIndex !== -1) {
this.release = this.version.substr(releaseStartIndex, version.length);
this.shortVersion = this.version.substr(0, releaseStartIndex);
}
this.shortVersion = this.shortVersion.replace(/[^\d]/g, '');
parts = this.version.split('.');
this.major = parseInt(parts.shift() || 0, 10);
this.minor = parseInt(parts.shift() || 0, 10);
this.patch = parseInt(parts.shift() || 0, 10);
this.build = parseInt(parts.shift() || 0, 10);
return this;
},

toString: function() {
return this.version;
},

valueOf: function() {
return this.version;
},

getMajor: function() {
return this.major || 0;
},

getMinor: function() {
return this.minor || 0;
},

getPatch: function() {
return this.patch || 0;
},

getBuild: function() {
return this.build || 0;
},

getRelease: function() {
return this.release || '';
},

isGreaterThan: function(target) {
return Version.compare(this.version, target) === 1;
},

isGreaterThanOrEqual: function(target) {
return Version.compare(this.version, target) >= 0;
},

isLessThan: function(target) {
return Version.compare(this.version, target) === -1;
},

isLessThanOrEqual: function(target) {
return Version.compare(this.version, target) <= 0;
},

equals: function(target) {
return Version.compare(this.version, target) === 0;
},

match: function(target) {
target = String(target);
return this.version.substr(0, target.length) === target;
},

toArray: function() {
return [this.getMajor(), this.getMinor(), this.getPatch(), this.getBuild(), this.getRelease()];
},

getShortVersion: function() {
return this.shortVersion;
},

gt: function() {
return this.isGreaterThan.apply(this, arguments);
},

lt: function() {
return this.isLessThan.apply(this, arguments);
},

gtEq: function() {
return this.isGreaterThanOrEqual.apply(this, arguments);
},

ltEq: function() {
return this.isLessThanOrEqual.apply(this, arguments);
}
});
Ext.apply(Version, {
// @private
releaseValueMap: {
'dev': -6,
'alpha': -5,
'a': -5,
'beta': -4,
'b': -4,
'rc': -3,
'#': -2,
'p': -1,
'pl': -1
},

getComponentValue: function(value) {
return !value ? 0 : (isNaN(value) ? this.releaseValueMap[value] || value : parseInt(value, 10));
},

compare: function(current, target) {
var currentValue, targetValue, i;
current = new Version(current).toArray();
target = new Version(target).toArray();
for (i = 0; i < Math.max(current.length, target.length); i++) {
currentValue = this.getComponentValue(current[i]);
targetValue = this.getComponentValue(target[i]);
if (currentValue < targetValue) {
return -1;
} else if (currentValue > targetValue) {
return 1;
}
}
return 0;
}
});

Ext.apply(Ext, {

versions: {},

lastRegisteredVersion: null,

setVersion: function(packageName, version) {
Ext.versions[packageName] = new Version(version);
Ext.lastRegisteredVersion = Ext.versions[packageName];
return this;
},

getVersion: function(packageName) {
if (packageName === undefined) {
return Ext.lastRegisteredVersion;
}
return Ext.versions[packageName];
},

deprecate: function(packageName, since, closure, scope) {
if (Version.compare(Ext.getVersion(packageName), since) < 1) {
closure.call(scope);
}
}
}); // End Versioning
Ext.setVersion('core', version);
}());
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/lang/String.js */
(function(Ext) {
// @tag foundation,core
// @require ../version/Version.js
// @define Ext.String
Ext.String = (function() {
var trimRegex = /^[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000]+|[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000]+$/g,
escapeRe = /('|\\)/g,
formatRe = /\{(\d+)\}/g,
escapeRegexRe = /([-.*+?\^${}()|\[\]\/\\])/g,
basicTrimRe = /^\s+|\s+$/g,
whitespaceRe = /\s+/,
varReplace = /(^[^a-z]*|[^\w])/gi,
charToEntity,
entityToChar,
charToEntityRegex,
entityToCharRegex,
htmlEncodeReplaceFn = function(match, capture) {
return charToEntity[capture];
},
htmlDecodeReplaceFn = function(match, capture) {
return (capture in entityToChar) ? entityToChar[capture] : String.fromCharCode(parseInt(capture.substr(2), 10));
},
boundsCheck = function(s, other){
if (s === null || s === undefined || other === null || other === undefined) {
return false;
}

return other.length <= s.length; 
};
return {


insert: function(s, value, index) {
if (!s) {
return value;
}

if (!value) {
return s;
}

var len = s.length;

if (!index && index !== 0) {
index = len;
}

if (index < 0) {
index *= -1;
if (index >= len) {
// negative overflow, insert at start
index = 0;
} else {
index = len - index;
}
}

if (index === 0) {
s = value + s;
} else if (index >= s.length) {
s += value;
} else {
s = s.substr(0, index) + value + s.substr(index);
}
return s;
},


startsWith: function(s, start, ignoreCase){
var result = boundsCheck(s, start);

if (result) {
if (ignoreCase) {
s = s.toLowerCase();
start = start.toLowerCase();
}
result = s.lastIndexOf(start, 0) === 0;
}
return result;
},


endsWith: function(s, end, ignoreCase){
var result = boundsCheck(s, end);

if (result) {
if (ignoreCase) {
s = s.toLowerCase();
end = end.toLowerCase();
}
result = s.indexOf(end, s.length - end.length) !== -1;
}
return result;
},

createVarName: function(s) {
return s.replace(varReplace, '');
},

htmlEncode: function(value) {
return (!value) ? value : String(value).replace(charToEntityRegex, htmlEncodeReplaceFn);
},

htmlDecode: function(value) {
return (!value) ? value : String(value).replace(entityToCharRegex, htmlDecodeReplaceFn);
},

addCharacterEntities: function(newEntities) {
var charKeys = [],
entityKeys = [],
key, echar;
for (key in newEntities) {
echar = newEntities[key];
entityToChar[key] = echar;
charToEntity[echar] = key;
charKeys.push(echar);
entityKeys.push(key);
}
charToEntityRegex = new RegExp('(' + charKeys.join('|') + ')', 'g');
entityToCharRegex = new RegExp('(' + entityKeys.join('|') + '|&#[0-9]{1,5};' + ')', 'g');
},

resetCharacterEntities: function() {
charToEntity = {};
entityToChar = {};
// add the default set
this.addCharacterEntities({
'&amp;' : '&',
'&gt;' : '>',
'&lt;' : '<',
'&quot;' : '"',
'&#39;' : "'"
});
},

urlAppend : function(url, string) {
if (!Ext.isEmpty(string)) {
return url + (url.indexOf('?') === -1 ? '?' : '&') + string;
}
return url;
},

trim: function(string) {
return string.replace(trimRegex, "");
},

capitalize: function(string) {
return string.charAt(0).toUpperCase() + string.substr(1);
},

uncapitalize: function(string) {
return string.charAt(0).toLowerCase() + string.substr(1);
},

ellipsis: function(value, len, word) {
if (value && value.length > len) {
if (word) {
var vs = value.substr(0, len - 2),
index = Math.max(vs.lastIndexOf(' '), vs.lastIndexOf('.'), vs.lastIndexOf('!'), vs.lastIndexOf('?'));
if (index !== -1 && index >= (len - 15)) {
return vs.substr(0, index) + "...";
}
}
return value.substr(0, len - 3) + "...";
}
return value;
},

escapeRegex: function(string) {
return string.replace(escapeRegexRe, "\\$1");
},

escape: function(string) {
return string.replace(escapeRe, "\\$1");
},

toggle: function(string, value, other) {
return string === value ? other : value;
},

leftPad: function(string, size, character) {
var result = String(string);
character = character || " ";
while (result.length < size) {
result = character + result;
}
return result;
},

format: function(format) {
var args = Ext.Array.toArray(arguments, 1);
return format.replace(formatRe, function(m, i) {
return args[i];
});
},

repeat: function(pattern, count, sep) {
if (count < 1) {
count = 0;
}
for (var buf = [], i = count; i--; ) {
buf.push(pattern);
}
return buf.join(sep || '');
},

splitWords: function (words) {
if (words && typeof words == 'string') {
return words.replace(basicTrimRe, '').split(whitespaceRe);
}
return words || [];
}
};
}());
// initialize the default encode / decode entities
Ext.String.resetCharacterEntities();
Ext.htmlEncode = Ext.String.htmlEncode;
Ext.htmlDecode = Ext.String.htmlDecode;
Ext.urlAppend = Ext.String.urlAppend;
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/lang/Number.js */
(function(Ext) {
// @tag foundation,core
// @require String.js
// @define Ext.Number
Ext.Number = new function() {
var me = this,
isToFixedBroken = (0.9).toFixed() !== '1',
math = Math;
Ext.apply(this, {

constrain: function(number, min, max) {
var x = parseFloat(number);
// Watch out for NaN in Chrome 18
// V8bug: http://code.google.com/p/v8/issues/detail?id=2056
// Operators are faster than Math.min/max. See http://jsperf.com/number-constrain
// ... and (x < Nan) || (x < undefined) == false
// ... same for (x > NaN) || (x > undefined)
// so if min or max are undefined or NaN, we never return them... sadly, this
// is not true of null (but even Math.max(-1,null)==0 and isNaN(null)==false)
return (x < min) ? min : ((x > max) ? max : x);
},

snap : function(value, increment, minValue, maxValue) {
var m;
// If no value passed, or minValue was passed and value is less than minValue (anything < undefined is false)
// Then use the minValue (or zero if the value was undefined)
if (value === undefined || value < minValue) {
return minValue || 0;
}
if (increment) {
m = value % increment;
if (m !== 0) {
value -= m;
if (m * 2 >= increment) {
value += increment;
} else if (m * 2 < -increment) {
value -= increment;
}
}
}
return me.constrain(value, minValue, maxValue);
},

snapInRange : function(value, increment, minValue, maxValue) {
var tween;
// default minValue to zero
minValue = (minValue || 0);
// If value is undefined, or less than minValue, use minValue
if (value === undefined || value < minValue) {
return minValue;
}
// Calculate how many snap points from the minValue the passed value is.
if (increment && (tween = ((value - minValue) % increment))) {
value -= tween;
tween *= 2;
if (tween >= increment) {
value += increment;
}
}
// If constraining within a maximum, ensure the maximum is on a snap point
if (maxValue !== undefined) {
if (value > (maxValue = me.snapInRange(maxValue, increment, minValue))) {
value = maxValue;
}
}
return value;
},

toFixed: isToFixedBroken ? function(value, precision) {
precision = precision || 0;
var pow = math.pow(10, precision);
return (math.round(value * pow) / pow).toFixed(precision);
} : function(value, precision) {
return value.toFixed(precision);
},

from: function(value, defaultValue) {
if (isFinite(value)) {
value = parseFloat(value);
}
return !isNaN(value) ? value : defaultValue;
},

randomInt: function (from, to) {
return math.floor(math.random() * (to - from + 1) + from);
},


correctFloat: function(n) {
// This is to correct the type of errors where 2 floats end with
// a long string of decimals, eg 0.1 + 0.2. When they overflow in this
// manner, they usually go to 15-16 decimals, so we cut it off at 14.
return parseFloat(n.toPrecision(14));
}
});

Ext.num = function() {
return me.from.apply(this, arguments);
};
};
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/lang/Array.js */
(function(Ext) {
// @tag foundation,core
// @require Number.js
// @define Ext.Array
(function() {
var arrayPrototype = Array.prototype,
slice = arrayPrototype.slice,
supportsSplice = (function () {
var array = [],
lengthBefore,
j = 20;
if (!array.splice) {
return false;
}
// This detects a bug in IE8 splice method:
// see http://social.msdn.microsoft.com/Forums/en-US/iewebdevelopment/thread/6e946d03-e09f-4b22-a4dd-cd5e276bf05a/
while (j--) {
array.push("A");
}
array.splice(15, 0, "F", "F", "F", "F", "F","F","F","F","F","F","F","F","F","F","F","F","F","F","F","F","F");
lengthBefore = array.length; //41
array.splice(13, 0, "XXX"); // add one element
if (lengthBefore+1 != array.length) {
return false;
}
// end IE8 bug
return true;
}()),
supportsForEach = 'forEach' in arrayPrototype,
supportsMap = 'map' in arrayPrototype,
supportsIndexOf = 'indexOf' in arrayPrototype,
supportsEvery = 'every' in arrayPrototype,
supportsSome = 'some' in arrayPrototype,
supportsFilter = 'filter' in arrayPrototype,
supportsSort = (function() {
var a = [1,2,3,4,5].sort(function(){ return 0; });
return a[0] === 1 && a[1] === 2 && a[2] === 3 && a[3] === 4 && a[4] === 5;
}()),
supportsSliceOnNodeList = true,
ExtArray,
erase,
replace,
splice;
try {
// IE 6 - 8 will throw an error when using Array.prototype.slice on NodeList
if (typeof document !== 'undefined') {
slice.call(document.getElementsByTagName('body'));
}
} catch (e) {
supportsSliceOnNodeList = false;
}
function fixArrayIndex (array, index) {
return (index < 0) ? Math.max(0, array.length + index)
: Math.min(array.length, index);
}

function replaceSim (array, index, removeCount, insert) {
var add = insert ? insert.length : 0,
length = array.length,
pos = fixArrayIndex(array, index),
remove,
tailOldPos,
tailNewPos,
tailCount,
lengthAfterRemove,
i;
// we try to use Array.push when we can for efficiency...
if (pos === length) {
if (add) {
array.push.apply(array, insert);
}
} else {
remove = Math.min(removeCount, length - pos);
tailOldPos = pos + remove;
tailNewPos = tailOldPos + add - remove;
tailCount = length - tailOldPos;
lengthAfterRemove = length - remove;
if (tailNewPos < tailOldPos) { // case A
for (i = 0; i < tailCount; ++i) {
array[tailNewPos+i] = array[tailOldPos+i];
}
} else if (tailNewPos > tailOldPos) { // case B
for (i = tailCount; i--; ) {
array[tailNewPos+i] = array[tailOldPos+i];
}
} // else, add == remove (nothing to do)
if (add && pos === lengthAfterRemove) {
array.length = lengthAfterRemove; // truncate array
array.push.apply(array, insert);
} else {
array.length = lengthAfterRemove + add; // reserves space
for (i = 0; i < add; ++i) {
array[pos+i] = insert[i];
}
}
}
return array;
}
function replaceNative (array, index, removeCount, insert) {
if (insert && insert.length) {
// Inserting at index zero with no removing: use unshift
if (index === 0 && !removeCount) {
array.unshift.apply(array, insert);
}
// Inserting/replacing in middle of array
else if (index < array.length) {
array.splice.apply(array, [index, removeCount].concat(insert));
}
// Appending to array
else {
array.push.apply(array, insert);
}
} else {
array.splice(index, removeCount);
}
return array;
}
function eraseSim (array, index, removeCount) {
return replaceSim(array, index, removeCount);
}
function eraseNative (array, index, removeCount) {
array.splice(index, removeCount);
return array;
}
function spliceSim (array, index, removeCount) {
var pos = fixArrayIndex(array, index),
removed = array.slice(index, fixArrayIndex(array, pos+removeCount));
if (arguments.length < 4) {
replaceSim(array, pos, removeCount);
} else {
replaceSim(array, pos, removeCount, slice.call(arguments, 3));
}
return removed;
}
function spliceNative (array) {
return array.splice.apply(array, slice.call(arguments, 1));
}
erase = supportsSplice ? eraseNative : eraseSim;
replace = supportsSplice ? replaceNative : replaceSim;
splice = supportsSplice ? spliceNative : spliceSim;
// NOTE: from here on, use erase, replace or splice (not native methods)...
ExtArray = Ext.Array = {

each: function(array, fn, scope, reverse) {
array = ExtArray.from(array);
var i,
ln = array.length;
if (reverse !== true) {
for (i = 0; i < ln; i++) {
if (fn.call(scope || array[i], array[i], i, array) === false) {
return i;
}
}
}
else {
for (i = ln - 1; i > -1; i--) {
if (fn.call(scope || array[i], array[i], i, array) === false) {
return i;
}
}
}
return true;
},

forEach: supportsForEach ? function(array, fn, scope) {
array.forEach(fn, scope);
} : function(array, fn, scope) {
var i = 0,
ln = array.length;
for (; i < ln; i++) {
fn.call(scope, array[i], i, array);
}
},

indexOf: supportsIndexOf ? function(array, item, from) {
return arrayPrototype.indexOf.call(array, item, from);
} : function(array, item, from) {
var i, length = array.length;
for (i = (from < 0) ? Math.max(0, length + from) : from || 0; i < length; i++) {
if (array[i] === item) {
return i;
}
}
return -1;
},

contains: supportsIndexOf ? function(array, item) {
return arrayPrototype.indexOf.call(array, item) !== -1;
} : function(array, item) {
var i, ln;
for (i = 0, ln = array.length; i < ln; i++) {
if (array[i] === item) {
return true;
}
}
return false;
},

toArray: function(iterable, start, end){
if (!iterable || !iterable.length) {
return [];
}
if (typeof iterable === 'string') {
iterable = iterable.split('');
}
if (supportsSliceOnNodeList) {
return slice.call(iterable, start || 0, end || iterable.length);
}
var array = [],
i;
start = start || 0;
end = end ? ((end < 0) ? iterable.length + end : end) : iterable.length;
for (i = start; i < end; i++) {
array.push(iterable[i]);
}
return array;
},

pluck: function(array, propertyName) {
var ret = [],
i, ln, item;
for (i = 0, ln = array.length; i < ln; i++) {
item = array[i];
ret.push(item[propertyName]);
}
return ret;
},

map: supportsMap ? function(array, fn, scope) {
//<debug>
if (!fn) {
Ext.Error.raise('Ext.Array.map must have a callback function passed as second argument.');
}
//</debug>
return array.map(fn, scope);
} : function(array, fn, scope) {
//<debug>
if (!fn) {
Ext.Error.raise('Ext.Array.map must have a callback function passed as second argument.');
}
//</debug>
var results = [],
i = 0,
len = array.length;
for (; i < len; i++) {
results[i] = fn.call(scope, array[i], i, array);
}
return results;
},

every: supportsEvery ? function(array, fn, scope) {
//<debug>
if (!fn) {
Ext.Error.raise('Ext.Array.every must have a callback function passed as second argument.');
}
//</debug>
return array.every(fn, scope);
} : function(array, fn, scope) {
//<debug>
if (!fn) {
Ext.Error.raise('Ext.Array.every must have a callback function passed as second argument.');
}
//</debug>
var i = 0,
ln = array.length;
for (; i < ln; ++i) {
if (!fn.call(scope, array[i], i, array)) {
return false;
}
}
return true;
},

some: supportsSome ? function(array, fn, scope) {
//<debug>
if (!fn) {
Ext.Error.raise('Ext.Array.some must have a callback function passed as second argument.');
}
//</debug>
return array.some(fn, scope);
} : function(array, fn, scope) {
//<debug>
if (!fn) {
Ext.Error.raise('Ext.Array.some must have a callback function passed as second argument.');
}
//</debug>
var i = 0,
ln = array.length;
for (; i < ln; ++i) {
if (fn.call(scope, array[i], i, array)) {
return true;
}
}
return false;
},


equals: function(array1, array2) {
var len1 = array1.length,
len2 = array2.length,
i;

// Short circuit if the same array is passed twice
if (array1 === array2) {
return true;
}

if (len1 !== len2) {
return false;
}

for (i = 0; i < len1; ++i) {
if (array1[i] !== array2[i]) {
return false;
}
}

return true;
},

clean: function(array) {
var results = [],
i = 0,
ln = array.length,
item;
for (; i < ln; i++) {
item = array[i];
if (!Ext.isEmpty(item)) {
results.push(item);
}
}
return results;
},

unique: function(array) {
var clone = [],
i = 0,
ln = array.length,
item;
for (; i < ln; i++) {
item = array[i];
if (ExtArray.indexOf(clone, item) === -1) {
clone.push(item);
}
}
return clone;
},

filter: supportsFilter ? function(array, fn, scope) {
//<debug>
if (!fn) {
Ext.Error.raise('Ext.Array.filter must have a filter function passed as second argument.');
}
//</debug>
return array.filter(fn, scope);
} : function(array, fn, scope) {
//<debug>
if (!fn) {
Ext.Error.raise('Ext.Array.filter must have a filter function passed as second argument.');
}
//</debug>
var results = [],
i = 0,
ln = array.length;
for (; i < ln; i++) {
if (fn.call(scope, array[i], i, array)) {
results.push(array[i]);
}
}
return results;
},

findBy : function(array, fn, scope) {
var i = 0,
len = array.length;
for (; i < len; i++) {
if (fn.call(scope || array, array[i], i)) {
return array[i];
}
}
return null;
},

from: function(value, newReference) {
if (value === undefined || value === null) {
return [];
}
if (Ext.isArray(value)) {
return (newReference) ? slice.call(value) : value;
}
var type = typeof value;
// Both strings and functions will have a length property. In phantomJS, NodeList
// instances report typeof=='function' but don't have an apply method...
if (value && value.length !== undefined && type !== 'string' && (type !== 'function' || !value.apply)) {
return ExtArray.toArray(value);
}
return [value];
},

remove: function(array, item) {
var index = ExtArray.indexOf(array, item);
if (index !== -1) {
erase(array, index, 1);
}
return array;
},

include: function(array, item) {
if (!ExtArray.contains(array, item)) {
array.push(item);
}
},

clone: function(array) {
return slice.call(array);
},

merge: function() {
var args = slice.call(arguments),
array = [],
i, ln;
for (i = 0, ln = args.length; i < ln; i++) {
array = array.concat(args[i]);
}
return ExtArray.unique(array);
},

intersect: function() {
var intersection = [],
arrays = slice.call(arguments),
arraysLength,
array,
arrayLength,
minArray,
minArrayIndex,
minArrayCandidate,
minArrayLength,
element,
elementCandidate,
elementCount,
i, j, k;
if (!arrays.length) {
return intersection;
}
// Find the smallest array
arraysLength = arrays.length;
for (i = minArrayIndex = 0; i < arraysLength; i++) {
minArrayCandidate = arrays[i];
if (!minArray || minArrayCandidate.length < minArray.length) {
minArray = minArrayCandidate;
minArrayIndex = i;
}
}
minArray = ExtArray.unique(minArray);
erase(arrays, minArrayIndex, 1);
// Use the smallest unique'd array as the anchor loop. If the other array(s) do contain
// an item in the small array, we're likely to find it before reaching the end
// of the inner loop and can terminate the search early.
minArrayLength = minArray.length;
arraysLength = arrays.length;
for (i = 0; i < minArrayLength; i++) {
element = minArray[i];
elementCount = 0;
for (j = 0; j < arraysLength; j++) {
array = arrays[j];
arrayLength = array.length;
for (k = 0; k < arrayLength; k++) {
elementCandidate = array[k];
if (element === elementCandidate) {
elementCount++;
break;
}
}
}
if (elementCount === arraysLength) {
intersection.push(element);
}
}
return intersection;
},

difference: function(arrayA, arrayB) {
var clone = slice.call(arrayA),
ln = clone.length,
i, j, lnB;
for (i = 0,lnB = arrayB.length; i < lnB; i++) {
for (j = 0; j < ln; j++) {
if (clone[j] === arrayB[i]) {
erase(clone, j, 1);
j--;
ln--;
}
}
}
return clone;
},

// Note: IE6 will return [] on slice.call(x, undefined).
slice: ([1,2].slice(1, undefined).length ?
function (array, begin, end) {
return slice.call(array, begin, end);
} :
// at least IE6 uses arguments.length for variadic signature
function (array, begin, end) {
// After tested for IE 6, the one below is of the best performance
// see http://jsperf.com/slice-fix
if (typeof begin === 'undefined') {
return slice.call(array);
}
if (typeof end === 'undefined') {
return slice.call(array, begin);
}
return slice.call(array, begin, end);
}
),

sort: supportsSort ? function(array, sortFn) {
if (sortFn) {
return array.sort(sortFn);
} else {
return array.sort();
}
} : function(array, sortFn) {
var length = array.length,
i = 0,
comparison,
j, min, tmp;
for (; i < length; i++) {
min = i;
for (j = i + 1; j < length; j++) {
if (sortFn) {
comparison = sortFn(array[j], array[min]);
if (comparison < 0) {
min = j;
}
} else if (array[j] < array[min]) {
min = j;
}
}
if (min !== i) {
tmp = array[i];
array[i] = array[min];
array[min] = tmp;
}
}
return array;
},

flatten: function(array) {
var worker = [];
function rFlatten(a) {
var i, ln, v;
for (i = 0, ln = a.length; i < ln; i++) {
v = a[i];
if (Ext.isArray(v)) {
rFlatten(v);
} else {
worker.push(v);
}
}
return worker;
}
return rFlatten(array);
},

min: function(array, comparisonFn) {
var min = array[0],
i, ln, item;
for (i = 0, ln = array.length; i < ln; i++) {
item = array[i];
if (comparisonFn) {
if (comparisonFn(min, item) === 1) {
min = item;
}
}
else {
if (item < min) {
min = item;
}
}
}
return min;
},

max: function(array, comparisonFn) {
var max = array[0],
i, ln, item;
for (i = 0, ln = array.length; i < ln; i++) {
item = array[i];
if (comparisonFn) {
if (comparisonFn(max, item) === -1) {
max = item;
}
}
else {
if (item > max) {
max = item;
}
}
}
return max;
},

mean: function(array) {
return array.length > 0 ? ExtArray.sum(array) / array.length : undefined;
},

sum: function(array) {
var sum = 0,
i, ln, item;
for (i = 0,ln = array.length; i < ln; i++) {
item = array[i];
sum += item;
}
return sum;
},

toMap: function(array, getKey, scope) {
var map = {},
i = array.length;
if (!getKey) {
while (i--) {
map[array[i]] = i+1;
}
} else if (typeof getKey == 'string') {
while (i--) {
map[array[i][getKey]] = i+1;
}
} else {
while (i--) {
map[getKey.call(scope, array[i])] = i+1;
}
}
return map;
},

toValueMap: function(array, getKey, scope) {
var map = {},
i = array.length;
if (!getKey) {
while (i--) {
map[array[i]] = array[i];
}
} else if (typeof getKey == 'string') {
while (i--) {
map[array[i][getKey]] = array[i];
}
} else {
while (i--) {
map[getKey.call(scope, array[i])] = array[i];
}
}
return map;
},
//<debug>
_replaceSim: replaceSim, // for unit testing
_spliceSim: spliceSim,
//</debug>

erase: erase,

insert: function (array, index, items) {
return replace(array, index, 0, items);
},

replace: replace,

splice: splice,

push: function(array) {
var len = arguments.length,
i = 1,
newItem;
if (array === undefined) {
array = [];
} else if (!Ext.isArray(array)) {
array = [array];
}
for (; i < len; i++) {
newItem = arguments[i];
Array.prototype.push[Ext.isIterable(newItem) ? 'apply' : 'call'](array, newItem);
}
return array;
}
};

Ext.each = ExtArray.each;

ExtArray.union = ExtArray.merge;

Ext.min = ExtArray.min;

Ext.max = ExtArray.max;

Ext.sum = ExtArray.sum;

Ext.mean = ExtArray.mean;

Ext.flatten = ExtArray.flatten;

Ext.clean = ExtArray.clean;

Ext.unique = ExtArray.unique;

Ext.pluck = ExtArray.pluck;

Ext.toArray = function() {
return ExtArray.toArray.apply(ExtArray, arguments);
};
}());
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/lang/Function.js */
(function(Ext) {
// @tag foundation,core
// @require Array.js
// @define Ext.Function
Ext.Function = {

flexSetter: function(fn) {
return function(a, b) {
var k, i;
if (a === null) {
return this;
}
if (typeof a !== 'string') {
for (k in a) {
if (a.hasOwnProperty(k)) {
fn.call(this, k, a[k]);
}
}
if (Ext.enumerables) {
for (i = Ext.enumerables.length; i--;) {
k = Ext.enumerables[i];
if (a.hasOwnProperty(k)) {
fn.call(this, k, a[k]);
}
}
}
} else {
fn.call(this, a, b);
}
return this;
};
},

bind: function(fn, scope, args, appendArgs) {
if (arguments.length === 2) {
return function() {
return fn.apply(scope, arguments);
};
}
var method = fn,
slice = Array.prototype.slice;
return function() {
var callArgs = args || arguments;
if (appendArgs === true) {
callArgs = slice.call(arguments, 0);
callArgs = callArgs.concat(args);
}
else if (typeof appendArgs == 'number') {
callArgs = slice.call(arguments, 0); // copy arguments first
Ext.Array.insert(callArgs, appendArgs, args);
}
return method.apply(scope || Ext.global, callArgs);
};
},

pass: function(fn, args, scope) {
if (!Ext.isArray(args)) {
if (Ext.isIterable(args)) {
args = Ext.Array.clone(args);
} else {
args = args !== undefined ? [args] : [];
}
}
return function() {
var fnArgs = [].concat(args);
fnArgs.push.apply(fnArgs, arguments);
return fn.apply(scope || this, fnArgs);
};
},

alias: function(object, methodName) {
return function() {
return object[methodName].apply(object, arguments);
};
},

clone: function(method) {
return function() {
return method.apply(this, arguments);
};
},

createInterceptor: function(origFn, newFn, scope, returnValue) {
var method = origFn;
if (!Ext.isFunction(newFn)) {
return origFn;
} else {
returnValue = Ext.isDefined(returnValue) ? returnValue : null;
return function() {
var me = this,
args = arguments;

newFn.target = me;
newFn.method = origFn;
return (newFn.apply(scope || me || Ext.global, args) !== false) ? origFn.apply(me || Ext.global, args) : returnValue;
};
}
},

createDelayed: function(fn, delay, scope, args, appendArgs) {
if (scope || args) {
fn = Ext.Function.bind(fn, scope, args, appendArgs);
}
return function() {
var me = this,
args = Array.prototype.slice.call(arguments);
setTimeout(function() {
fn.apply(me, args);
}, delay);
};
},

defer: function(fn, millis, scope, args, appendArgs) {
fn = Ext.Function.bind(fn, scope, args, appendArgs);
if (millis > 0) {
return setTimeout(Ext.supports.TimeoutActualLateness ? function () {
fn();
} : fn, millis);
}
fn();
return 0;
},

createSequence: function(originalFn, newFn, scope) {
if (!newFn) {
return originalFn;
}
else {
return function() {
var result = originalFn.apply(this, arguments);
newFn.apply(scope || this, arguments);
return result;
};
}
},

createBuffered: function(fn, buffer, scope, args) {
var timerId;
return function() {
var callArgs = args || Array.prototype.slice.call(arguments, 0),
me = scope || this;
if (timerId) {
clearTimeout(timerId);
}
timerId = setTimeout(function(){
fn.apply(me, callArgs);
}, buffer);
};
},

createThrottled: function(fn, interval, scope) {
var lastCallTime, elapsed, lastArgs, timer, execute = function() {
fn.apply(scope || this, lastArgs);
lastCallTime = Ext.Date.now();
};
return function() {
elapsed = Ext.Date.now() - lastCallTime;
lastArgs = arguments;
clearTimeout(timer);
if (!lastCallTime || (elapsed >= interval)) {
execute();
} else {
timer = setTimeout(execute, interval - elapsed);
}
};
},

interceptBefore: function(object, methodName, fn, scope) {
var method = object[methodName] || Ext.emptyFn;
return (object[methodName] = function() {
var ret = fn.apply(scope || this, arguments);
method.apply(this, arguments);
return ret;
});
},

interceptAfter: function(object, methodName, fn, scope) {
var method = object[methodName] || Ext.emptyFn;
return (object[methodName] = function() {
method.apply(this, arguments);
return fn.apply(scope || this, arguments);
});
}
};
Ext.defer = Ext.Function.alias(Ext.Function, 'defer');
Ext.pass = Ext.Function.alias(Ext.Function, 'pass');
Ext.bind = Ext.Function.alias(Ext.Function, 'bind');
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/lang/Object.js */
(function(Ext) {
// @tag foundation,core
// @require Function.js
// @define Ext.Object
(function() {
// The "constructor" for chain:
var TemplateClass = function(){},
ExtObject = Ext.Object = {

chain: Object.create || function (object) {
TemplateClass.prototype = object;
var result = new TemplateClass();
TemplateClass.prototype = null;
return result;
},

toQueryObjects: function(name, value, recursive) {
var self = ExtObject.toQueryObjects,
objects = [],
i, ln;
if (Ext.isArray(value)) {
for (i = 0, ln = value.length; i < ln; i++) {
if (recursive) {
objects = objects.concat(self(name + '[' + i + ']', value[i], true));
}
else {
objects.push({
name: name,
value: value[i]
});
}
}
}
else if (Ext.isObject(value)) {
for (i in value) {
if (value.hasOwnProperty(i)) {
if (recursive) {
objects = objects.concat(self(name + '[' + i + ']', value[i], true));
}
else {
objects.push({
name: name,
value: value[i]
});
}
}
}
}
else {
objects.push({
name: name,
value: value
});
}
return objects;
},

toQueryString: function(object, recursive) {
var paramObjects = [],
params = [],
i, j, ln, paramObject, value;
for (i in object) {
if (object.hasOwnProperty(i)) {
paramObjects = paramObjects.concat(ExtObject.toQueryObjects(i, object[i], recursive));
}
}
for (j = 0, ln = paramObjects.length; j < ln; j++) {
paramObject = paramObjects[j];
value = paramObject.value;
if (Ext.isEmpty(value)) {
value = '';
} else if (Ext.isDate(value)) {
value = Ext.Date.toString(value);
}
params.push(encodeURIComponent(paramObject.name) + '=' + encodeURIComponent(String(value)));
}
return params.join('&');
},

fromQueryString: function(queryString, recursive) {
var parts = queryString.replace(/^\?/, '').split('&'),
object = {},
temp, components, name, value, i, ln,
part, j, subLn, matchedKeys, matchedName,
keys, key, nextKey;
for (i = 0, ln = parts.length; i < ln; i++) {
part = parts[i];
if (part.length > 0) {
components = part.split('=');
name = decodeURIComponent(components[0]);
value = (components[1] !== undefined) ? decodeURIComponent(components[1]) : '';
if (!recursive) {
if (object.hasOwnProperty(name)) {
if (!Ext.isArray(object[name])) {
object[name] = [object[name]];
}
object[name].push(value);
}
else {
object[name] = value;
}
}
else {
matchedKeys = name.match(/(\[):?([^\]]*)\]/g);
matchedName = name.match(/^([^\[]+)/);
//<debug error>
if (!matchedName) {
throw new Error('[Ext.Object.fromQueryString] Malformed query string given, failed parsing name from "' + part + '"');
}
//</debug>
name = matchedName[0];
keys = [];
if (matchedKeys === null) {
object[name] = value;
continue;
}
for (j = 0, subLn = matchedKeys.length; j < subLn; j++) {
key = matchedKeys[j];
key = (key.length === 2) ? '' : key.substring(1, key.length - 1);
keys.push(key);
}
keys.unshift(name);
temp = object;
for (j = 0, subLn = keys.length; j < subLn; j++) {
key = keys[j];
if (j === subLn - 1) {
if (Ext.isArray(temp) && key === '') {
temp.push(value);
}
else {
temp[key] = value;
}
}
else {
if (temp[key] === undefined || typeof temp[key] === 'string') {
nextKey = keys[j+1];
temp[key] = (Ext.isNumeric(nextKey) || nextKey === '') ? [] : {};
}
temp = temp[key];
}
}
}
}
}
return object;
},

each: function(object, fn, scope) {
for (var property in object) {
if (object.hasOwnProperty(property)) {
if (fn.call(scope || object, property, object[property], object) === false) {
return;
}
}
}
},

merge: function(destination) {
var i = 1,
ln = arguments.length,
mergeFn = ExtObject.merge,
cloneFn = Ext.clone,
object, key, value, sourceKey;
for (; i < ln; i++) {
object = arguments[i];
for (key in object) {
value = object[key];
if (value && value.constructor === Object) {
sourceKey = destination[key];
if (sourceKey && sourceKey.constructor === Object) {
mergeFn(sourceKey, value);
}
else {
destination[key] = cloneFn(value);
}
}
else {
destination[key] = value;
}
}
}
return destination;
},

mergeIf: function(destination) {
var i = 1,
ln = arguments.length,
cloneFn = Ext.clone,
object, key, value;
for (; i < ln; i++) {
object = arguments[i];
for (key in object) {
if (!(key in destination)) {
value = object[key];
if (value && value.constructor === Object) {
destination[key] = cloneFn(value);
}
else {
destination[key] = value;
}
}
}
}
return destination;
},

getKey: function(object, value) {
for (var property in object) {
if (object.hasOwnProperty(property) && object[property] === value) {
return property;
}
}
return null;
},

getValues: function(object) {
var values = [],
property;
for (property in object) {
if (object.hasOwnProperty(property)) {
values.push(object[property]);
}
}
return values;
},

getKeys: (typeof Object.keys == 'function')
? function(object){
if (!object) {
return [];
}
return Object.keys(object);
}
: function(object) {
var keys = [],
property;
for (property in object) {
if (object.hasOwnProperty(property)) {
keys.push(property);
}
}
return keys;
},

getSize: function(object) {
var size = 0,
property;
for (property in object) {
if (object.hasOwnProperty(property)) {
size++;
}
}
return size;
},


isEmpty: function(object){
for (var key in object) {
if (object.hasOwnProperty(key)) {
return false;
}
}
return true; 
},


equals: (function() {
var check = function(o1, o2) {
var key;

for (key in o1) {
if (o1.hasOwnProperty(key)) {
if (o1[key] !== o2[key]) {
return false;
} 
}
} 
return true;
};

return function(object1, object2) {

// Short circuit if the same object is passed twice
if (object1 === object2) {
return true;
} if (object1 && object2) {
// Do the second check because we could have extra keys in
// object2 that don't exist in object1.
return check(object1, object2) && check(object2, object1); 
} else if (!object1 && !object2) {
return object1 === object2;
} else {
return false;
}
};
})(),

classify: function(object) {
var prototype = object,
objectProperties = [],
propertyClassesMap = {},
objectClass = function() {
var i = 0,
ln = objectProperties.length,
property;
for (; i < ln; i++) {
property = objectProperties[i];
this[property] = new propertyClassesMap[property]();
}
},
key, value;
for (key in object) {
if (object.hasOwnProperty(key)) {
value = object[key];
if (value && value.constructor === Object) {
objectProperties.push(key);
propertyClassesMap[key] = ExtObject.classify(value);
}
}
}
objectClass.prototype = prototype;
return objectClass;
}
};
Ext.merge = Ext.Object.merge;
Ext.mergeIf = Ext.Object.mergeIf;
Ext.urlEncode = function() {
var args = Ext.Array.from(arguments),
prefix = '';
// Support for the old `pre` argument
if ((typeof args[1] === 'string')) {
prefix = args[1] + '&';
args[1] = false;
}
return prefix + ExtObject.toQueryString.apply(ExtObject, args);
};
Ext.urlDecode = function() {
return ExtObject.fromQueryString.apply(ExtObject, arguments);
};
}());
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/lang/Date.js */
(function(Ext) {
// @tag foundation,core
// @require Object.js
// @define Ext.Date
Ext.Date = new function() {
var utilDate = this,
stripEscapeRe = /(\\.)/g,
hourInfoRe = /([gGhHisucUOPZ]|MS)/,
dateInfoRe = /([djzmnYycU]|MS)/,
slashRe = /\\/gi,
numberTokenRe = /\{(\d+)\}/g,
MSFormatRe = new RegExp('\\/Date\\(([-+])?(\\d+)(?:[+-]\\d{4})?\\)\\/'),
code = [
// date calculations (note: the code below creates a dependency on Ext.Number.from())
"var me = this, dt, y, m, d, h, i, s, ms, o, O, z, zz, u, v, W, year, jan4, week1monday, daysInMonth, dayMatched,",
"def = me.defaults,",
"from = Ext.Number.from,",
"results = String(input).match(me.parseRegexes[{0}]);", // either null, or an array of matched strings
"if(results){",
"{1}",
"if(u != null){", // i.e. unix time is defined
"v = new Date(u * 1000);", // give top priority to UNIX time
"}else{",
// create Date object representing midnight of the current day;
// this will provide us with our date defaults
// (note: clearTime() handles Daylight Saving Time automatically)
"dt = me.clearTime(new Date);",
"y = from(y, from(def.y, dt.getFullYear()));",
"m = from(m, from(def.m - 1, dt.getMonth()));",
"dayMatched = d !== undefined;",
"d = from(d, from(def.d, dt.getDate()));",

// Attempt to validate the day. Since it defaults to today, it may go out
// of range, for example parsing m/Y where the value is 02/2000 on the 31st of May.
// It will attempt to parse 2000/02/31, which will overflow to March and end up
// returning 03/2000. We only do this when we default the day. If an invalid day value
// was set to be parsed by the user, continue on and either let it overflow or return null
// depending on the strict value. This will be in line with the normal Date behaviour.

"if (!dayMatched) {", 
"dt.setDate(1);",
"dt.setMonth(m);",
"dt.setFullYear(y);",

"daysInMonth = me.getDaysInMonth(dt);",
"if (d > daysInMonth) {",
"d = daysInMonth;",
"}",
"}",
"h = from(h, from(def.h, dt.getHours()));",
"i = from(i, from(def.i, dt.getMinutes()));",
"s = from(s, from(def.s, dt.getSeconds()));",
"ms = from(ms, from(def.ms, dt.getMilliseconds()));",
"if(z >= 0 && y >= 0){",
// both the year and zero-based day of year are defined and >= 0.
// these 2 values alone provide sufficient info to create a full date object
// create Date object representing January 1st for the given year
// handle years < 100 appropriately
"v = me.add(new Date(y < 100 ? 100 : y, 0, 1, h, i, s, ms), me.YEAR, y < 100 ? y - 100 : 0);",
// then add day of year, checking for Date "rollover" if necessary
"v = !strict? v : (strict === true && (z <= 364 || (me.isLeapYear(v) && z <= 365))? me.add(v, me.DAY, z) : null);",
"}else if(strict === true && !me.isValid(y, m + 1, d, h, i, s, ms)){", // check for Date "rollover"
"v = null;", // invalid date, so return null
"}else{",
"if (W) {", // support ISO-8601
// http://en.wikipedia.org/wiki/ISO_week_date
//
// Mutually equivalent definitions for week 01 are:
// a. the week starting with the Monday which is nearest in time to 1 January
// b. the week with 4 January in it
// ... there are many others ...
//
// We'll use letter b above to determine the first week of the year.
//
// So, first get a Date object for January 4th of whatever calendar year is desired.
//
// Then, the first Monday of the year can easily be determined by (operating on this Date):
// 1. Getting the day of the week.
// 2. Subtracting that by one.
// 3. Multiplying that by 86400000 (one day in ms).
// 4. Subtracting this number of days (in ms) from the January 4 date (represented in ms).
// 
// Example #1 ...
//
// January 2012
// Su Mo Tu We Th Fr Sa
// 1 2 3 4 5 6 7
// 8 9 10 11 12 13 14
// 15 16 17 18 19 20 21
// 22 23 24 25 26 27 28
// 29 30 31
//
// 1. January 4th is a Wednesday.
// 2. Its day number is 3.
// 3. Simply substract 2 days from Wednesday.
// 4. The first week of the year begins on Monday, January 2. Simple!
//
// Example #2 ...
// January 1992
// Su Mo Tu We Th Fr Sa
// 1 2 3 4
// 5 6 7 8 9 10 11
// 12 13 14 15 16 17 18
// 19 20 21 22 23 24 25
// 26 27 28 29 30 31
// 
// 1. January 4th is a Saturday.
// 2. Its day number is 6.
// 3. Simply subtract 5 days from Saturday.
// 4. The first week of the year begins on Monday, December 30. Simple!
//
// v = Ext.Date.clearTime(new Date(week1monday.getTime() + ((W - 1) * 604800000)));
// (This is essentially doing the same thing as above but for the week rather than the day)
"year = y || (new Date()).getFullYear(),",
"jan4 = new Date(year, 0, 4, 0, 0, 0),",
"week1monday = new Date(jan4.getTime() - ((jan4.getDay() - 1) * 86400000));",
"v = Ext.Date.clearTime(new Date(week1monday.getTime() + ((W - 1) * 604800000)));",
"} else {",
// plain old Date object
// handle years < 100 properly
"v = me.add(new Date(y < 100 ? 100 : y, m, d, h, i, s, ms), me.YEAR, y < 100 ? y - 100 : 0);",
"}",
"}",
"}",
"}",
"if(v){",
// favor UTC offset over GMT offset
"if(zz != null){",
// reset to UTC, then add offset
"v = me.add(v, me.SECOND, -v.getTimezoneOffset() * 60 - zz);",
"}else if(o){",
// reset to GMT, then add offset
"v = me.add(v, me.MINUTE, -v.getTimezoneOffset() + (sn == '+'? -1 : 1) * (hr * 60 + mn));",
"}",
"}",
"return v;"
].join('\n');
// create private copy of Ext JS's `Ext.util.Format.format()` method
// - to remove unnecessary dependency
// - to resolve namespace conflict with MS-Ajax's implementation
function xf(format) {
var args = Array.prototype.slice.call(arguments, 1);
return format.replace(numberTokenRe, function(m, i) {
return args[i];
});
}
Ext.apply(utilDate, {

now: Date.now || function() {
return +new Date();
},

toString: function(date) {
var pad = Ext.String.leftPad;
return date.getFullYear() + "-"
+ pad(date.getMonth() + 1, 2, '0') + "-"
+ pad(date.getDate(), 2, '0') + "T"
+ pad(date.getHours(), 2, '0') + ":"
+ pad(date.getMinutes(), 2, '0') + ":"
+ pad(date.getSeconds(), 2, '0');
},

getElapsed: function(dateA, dateB) {
return Math.abs(dateA - (dateB || utilDate.now()));
},

useStrict: false,
// private
formatCodeToRegex: function(character, currentGroup) {
// Note: currentGroup - position in regex result array (see notes for Ext.Date.parseCodes below)
var p = utilDate.parseCodes[character];
if (p) {
p = typeof p == 'function'? p() : p;
utilDate.parseCodes[character] = p; // reassign function result to prevent repeated execution
}
return p ? Ext.applyIf({
c: p.c ? xf(p.c, currentGroup || "{0}") : p.c
}, p) : {
g: 0,
c: null,
s: Ext.String.escapeRegex(character) // treat unrecognized characters as literals
};
},

parseFunctions: {
"MS": function(input, strict) {
// note: the timezone offset is ignored since the MS Ajax server sends
// a UTC milliseconds-since-Unix-epoch value (negative values are allowed)
var r = (input || '').match(MSFormatRe);
return r ? new Date(((r[1] || '') + r[2]) * 1) : null;
},
"time": function(input, strict) {
var num = parseInt(input, 10);
if (num || num === 0) {
return new Date(num);
}
return null;
},
"timestamp": function(input, strict) {
var num = parseInt(input, 10);
if (num || num === 0) {
return new Date(num * 1000);
}
return null;
}
},
parseRegexes: [],

formatFunctions: {
"MS": function() {
// UTC milliseconds since Unix epoch (MS-AJAX serialized date format (MRSF))
return '\\/Date(' + this.getTime() + ')\\/';
},
"time": function(){
return this.getTime().toString();
},
"timestamp": function(){
return utilDate.format(this, 'U');
}
},
y2kYear : 50,

MILLI : "ms",

SECOND : "s",

MINUTE : "mi",

HOUR : "h",

DAY : "d",

MONTH : "mo",

YEAR : "y",

defaults: {},
//<locale type="array">

dayNames : [
"Sunday",
"Monday",
"Tuesday",
"Wednesday",
"Thursday",
"Friday",
"Saturday"
],
//</locale>
//<locale type="array">

monthNames : [
"January",
"February",
"March",
"April",
"May",
"June",
"July",
"August",
"September",
"October",
"November",
"December"
],
//</locale>
//<locale type="object">

monthNumbers : {
January: 0,
Jan: 0,
February: 1,
Feb: 1,
March: 2,
Mar: 2,
April: 3,
Apr: 3,
May: 4,
June: 5,
Jun: 5,
July: 6,
Jul: 6,
August: 7,
Aug: 7,
September: 8,
Sep: 8,
October: 9,
Oct: 9,
November: 10,
Nov: 10,
December: 11,
Dec: 11
},
//</locale>

//<locale>

defaultFormat : "m/d/Y",
//</locale>
//<locale type="function">

getShortMonthName : function(month) {
return Ext.Date.monthNames[month].substring(0, 3);
},
//</locale>
//<locale type="function">

getShortDayName : function(day) {
return Ext.Date.dayNames[day].substring(0, 3);
},
//</locale>
//<locale type="function">

getMonthNumber : function(name) {
// handle camel casing for English month names (since the keys for the Ext.Date.monthNumbers hash are case sensitive)
return Ext.Date.monthNumbers[name.substring(0, 1).toUpperCase() + name.substring(1, 3).toLowerCase()];
},
//</locale>

formatContainsHourInfo : function(format){
return hourInfoRe.test(format.replace(stripEscapeRe, ''));
},

formatContainsDateInfo : function(format){
return dateInfoRe.test(format.replace(stripEscapeRe, ''));
},


unescapeFormat: function(format) {
// Escape the format, since \ can be used to escape special
// characters in a date format. For example, in a Spanish
// locale the format may be: 'd \\de F \\de Y'
return format.replace(slashRe, '');
},

formatCodes : {
d: "Ext.String.leftPad(this.getDate(), 2, '0')",
D: "Ext.Date.getShortDayName(this.getDay())", // get localized short day name
j: "this.getDate()",
l: "Ext.Date.dayNames[this.getDay()]",
N: "(this.getDay() ? this.getDay() : 7)",
S: "Ext.Date.getSuffix(this)",
w: "this.getDay()",
z: "Ext.Date.getDayOfYear(this)",
W: "Ext.String.leftPad(Ext.Date.getWeekOfYear(this), 2, '0')",
F: "Ext.Date.monthNames[this.getMonth()]",
m: "Ext.String.leftPad(this.getMonth() + 1, 2, '0')",
M: "Ext.Date.getShortMonthName(this.getMonth())", // get localized short month name
n: "(this.getMonth() + 1)",
t: "Ext.Date.getDaysInMonth(this)",
L: "(Ext.Date.isLeapYear(this) ? 1 : 0)",
o: "(this.getFullYear() + (Ext.Date.getWeekOfYear(this) == 1 && this.getMonth() > 0 ? +1 : (Ext.Date.getWeekOfYear(this) >= 52 && this.getMonth() < 11 ? -1 : 0)))",
Y: "Ext.String.leftPad(this.getFullYear(), 4, '0')",
y: "('' + this.getFullYear()).substring(2, 4)",
a: "(this.getHours() < 12 ? 'am' : 'pm')",
A: "(this.getHours() < 12 ? 'AM' : 'PM')",
g: "((this.getHours() % 12) ? this.getHours() % 12 : 12)",
G: "this.getHours()",
h: "Ext.String.leftPad((this.getHours() % 12) ? this.getHours() % 12 : 12, 2, '0')",
H: "Ext.String.leftPad(this.getHours(), 2, '0')",
i: "Ext.String.leftPad(this.getMinutes(), 2, '0')",
s: "Ext.String.leftPad(this.getSeconds(), 2, '0')",
u: "Ext.String.leftPad(this.getMilliseconds(), 3, '0')",
O: "Ext.Date.getGMTOffset(this)",
P: "Ext.Date.getGMTOffset(this, true)",
T: "Ext.Date.getTimezone(this)",
Z: "(this.getTimezoneOffset() * -60)",
c: function() { // ISO-8601 -- GMT format
var c, code, i, l, e;
for (c = "Y-m-dTH:i:sP", code = [], i = 0, l = c.length; i < l; ++i) {
e = c.charAt(i);
code.push(e == "T" ? "'T'" : utilDate.getFormatCode(e)); // treat T as a character literal
}
return code.join(" + ");
},

U: "Math.round(this.getTime() / 1000)"
},

isValid : function(y, m, d, h, i, s, ms) {
// setup defaults
h = h || 0;
i = i || 0;
s = s || 0;
ms = ms || 0;
// Special handling for year < 100
var dt = utilDate.add(new Date(y < 100 ? 100 : y, m - 1, d, h, i, s, ms), utilDate.YEAR, y < 100 ? y - 100 : 0);
return y == dt.getFullYear() &&
m == dt.getMonth() + 1 &&
d == dt.getDate() &&
h == dt.getHours() &&
i == dt.getMinutes() &&
s == dt.getSeconds() &&
ms == dt.getMilliseconds();
},

parse : function(input, format, strict) {
var p = utilDate.parseFunctions;
if (p[format] == null) {
utilDate.createParser(format);
}
return p[format].call(utilDate, input, Ext.isDefined(strict) ? strict : utilDate.useStrict);
},
// Backwards compat
parseDate: function(input, format, strict){
return utilDate.parse(input, format, strict);
},
// private
getFormatCode : function(character) {
var f = utilDate.formatCodes[character];
if (f) {
f = typeof f == 'function'? f() : f;
utilDate.formatCodes[character] = f; // reassign function result to prevent repeated execution
}
// note: unknown characters are treated as literals
return f || ("'" + Ext.String.escape(character) + "'");
},
// private
createFormat : function(format) {
var code = [],
special = false,
ch = '',
i;
for (i = 0; i < format.length; ++i) {
ch = format.charAt(i);
if (!special && ch == "\\") {
special = true;
} else if (special) {
special = false;
code.push("'" + Ext.String.escape(ch) + "'");
} else {
code.push(utilDate.getFormatCode(ch));
}
}
utilDate.formatFunctions[format] = Ext.functionFactory("return " + code.join('+'));
},
// private
createParser : function(format) {
var regexNum = utilDate.parseRegexes.length,
currentGroup = 1,
calc = [],
regex = [],
special = false,
ch = "",
i = 0,
len = format.length,
atEnd = [],
obj;
for (; i < len; ++i) {
ch = format.charAt(i);
if (!special && ch == "\\") {
special = true;
} else if (special) {
special = false;
regex.push(Ext.String.escape(ch));
} else {
obj = utilDate.formatCodeToRegex(ch, currentGroup);
currentGroup += obj.g;
regex.push(obj.s);
if (obj.g && obj.c) {
if (obj.calcAtEnd) {
atEnd.push(obj.c);
} else {
calc.push(obj.c);
}
}
}
}
calc = calc.concat(atEnd);
utilDate.parseRegexes[regexNum] = new RegExp("^" + regex.join('') + "$", 'i');
utilDate.parseFunctions[format] = Ext.functionFactory("input", "strict", xf(code, regexNum, calc.join('')));
},
// private
parseCodes : {

d: {
g:1,
c:"d = parseInt(results[{0}], 10);\n",
s:"(3[0-1]|[1-2][0-9]|0[1-9])" // day of month with leading zeroes (01 - 31)
},
j: {
g:1,
c:"d = parseInt(results[{0}], 10);\n",
s:"(3[0-1]|[1-2][0-9]|[1-9])" // day of month without leading zeroes (1 - 31)
},
D: function() {
for (var a = [], i = 0; i < 7; a.push(utilDate.getShortDayName(i)), ++i); // get localised short day names
return {
g:0,
c:null,
s:"(?:" + a.join("|") +")"
};
},
l: function() {
return {
g:0,
c:null,
s:"(?:" + utilDate.dayNames.join("|") + ")"
};
},
N: {
g:0,
c:null,
s:"[1-7]" // ISO-8601 day number (1 (monday) - 7 (sunday))
},
//<locale type="object" property="parseCodes">
S: {
g:0,
c:null,
s:"(?:st|nd|rd|th)"
},
//</locale>
w: {
g:0,
c:null,
s:"[0-6]" // JavaScript day number (0 (sunday) - 6 (saturday))
},
z: {
g:1,
c:"z = parseInt(results[{0}], 10);\n",
s:"(\\d{1,3})" // day of the year (0 - 364 (365 in leap years))
},
W: {
g:1,
c:"W = parseInt(results[{0}], 10);\n",
s:"(\\d{2})" // ISO-8601 week number (with leading zero)
},
F: function() {
return {
g:1,
c:"m = parseInt(me.getMonthNumber(results[{0}]), 10);\n", // get localised month number
s:"(" + utilDate.monthNames.join("|") + ")"
};
},
M: function() {
for (var a = [], i = 0; i < 12; a.push(utilDate.getShortMonthName(i)), ++i); // get localised short month names
return Ext.applyIf({
s:"(" + a.join("|") + ")"
}, utilDate.formatCodeToRegex("F"));
},
m: {
g:1,
c:"m = parseInt(results[{0}], 10) - 1;\n",
s:"(1[0-2]|0[1-9])" // month number with leading zeros (01 - 12)
},
n: {
g:1,
c:"m = parseInt(results[{0}], 10) - 1;\n",
s:"(1[0-2]|[1-9])" // month number without leading zeros (1 - 12)
},
t: {
g:0,
c:null,
s:"(?:\\d{2})" // no. of days in the month (28 - 31)
},
L: {
g:0,
c:null,
s:"(?:1|0)"
},
o: { 
g: 1,
c: "y = parseInt(results[{0}], 10);\n",
s: "(\\d{4})" // ISO-8601 year number (with leading zero)
},
Y: {
g:1,
c:"y = parseInt(results[{0}], 10);\n",
s:"(\\d{4})" // 4-digit year
},
y: {
g:1,
c:"var ty = parseInt(results[{0}], 10);\n"
+ "y = ty > me.y2kYear ? 1900 + ty : 2000 + ty;\n", // 2-digit year
s:"(\\d{1,2})"
},

//<locale type="object" property="parseCodes">
a: {
g:1,
c:"if (/(am)/i.test(results[{0}])) {\n"
+ "if (!h || h == 12) { h = 0; }\n"
+ "} else { if (!h || h < 12) { h = (h || 0) + 12; }}",
s:"(am|pm|AM|PM)",
calcAtEnd: true
},
//</locale>
//<locale type="object" property="parseCodes">
A: {
g:1,
c:"if (/(am)/i.test(results[{0}])) {\n"
+ "if (!h || h == 12) { h = 0; }\n"
+ "} else { if (!h || h < 12) { h = (h || 0) + 12; }}",
s:"(AM|PM|am|pm)",
calcAtEnd: true
},
//</locale>
g: {
g:1,
c:"h = parseInt(results[{0}], 10);\n",
s:"(1[0-2]|[0-9])" // 12-hr format of an hour without leading zeroes (1 - 12)
},
G: {
g:1,
c:"h = parseInt(results[{0}], 10);\n",
s:"(2[0-3]|1[0-9]|[0-9])" // 24-hr format of an hour without leading zeroes (0 - 23)
},
h: {
g:1,
c:"h = parseInt(results[{0}], 10);\n",
s:"(1[0-2]|0[1-9])" // 12-hr format of an hour with leading zeroes (01 - 12)
},
H: {
g:1,
c:"h = parseInt(results[{0}], 10);\n",
s:"(2[0-3]|[0-1][0-9])" // 24-hr format of an hour with leading zeroes (00 - 23)
},
i: {
g:1,
c:"i = parseInt(results[{0}], 10);\n",
s:"([0-5][0-9])" // minutes with leading zeros (00 - 59)
},
s: {
g:1,
c:"s = parseInt(results[{0}], 10);\n",
s:"([0-5][0-9])" // seconds with leading zeros (00 - 59)
},
u: {
g:1,
c:"ms = results[{0}]; ms = parseInt(ms, 10)/Math.pow(10, ms.length - 3);\n",
s:"(\\d+)" // decimal fraction of a second (minimum = 1 digit, maximum = unlimited)
},
O: {
g:1,
c:[
"o = results[{0}];",
"var sn = o.substring(0,1),", // get + / - sign
"hr = o.substring(1,3)*1 + Math.floor(o.substring(3,5) / 60),", // get hours (performs minutes-to-hour conversion also, just in case)
"mn = o.substring(3,5) % 60;", // get minutes
"o = ((-12 <= (hr*60 + mn)/60) && ((hr*60 + mn)/60 <= 14))? (sn + Ext.String.leftPad(hr, 2, '0') + Ext.String.leftPad(mn, 2, '0')) : null;\n" // -12hrs <= GMT offset <= 14hrs
].join("\n"),
s: "([+-]\\d{4})" // GMT offset in hrs and mins
},
P: {
g:1,
c:[
"o = results[{0}];",
"var sn = o.substring(0,1),", // get + / - sign
"hr = o.substring(1,3)*1 + Math.floor(o.substring(4,6) / 60),", // get hours (performs minutes-to-hour conversion also, just in case)
"mn = o.substring(4,6) % 60;", // get minutes
"o = ((-12 <= (hr*60 + mn)/60) && ((hr*60 + mn)/60 <= 14))? (sn + Ext.String.leftPad(hr, 2, '0') + Ext.String.leftPad(mn, 2, '0')) : null;\n" // -12hrs <= GMT offset <= 14hrs
].join("\n"),
s: "([+-]\\d{2}:\\d{2})" // GMT offset in hrs and mins (with colon separator)
},
T: {
g:0,
c:null,
s:"[A-Z]{1,5}" // timezone abbrev. may be between 1 - 5 chars
},
Z: {
g:1,
c:"zz = results[{0}] * 1;\n" // -43200 <= UTC offset <= 50400
+ "zz = (-43200 <= zz && zz <= 50400)? zz : null;\n",
s:"([+-]?\\d{1,5})" // leading '+' sign is optional for UTC offset
},
c: function() {
var calc = [],
arr = [
utilDate.formatCodeToRegex("Y", 1), // year
utilDate.formatCodeToRegex("m", 2), // month
utilDate.formatCodeToRegex("d", 3), // day
utilDate.formatCodeToRegex("H", 4), // hour
utilDate.formatCodeToRegex("i", 5), // minute
utilDate.formatCodeToRegex("s", 6), // second
{c:"ms = results[7] || '0'; ms = parseInt(ms, 10)/Math.pow(10, ms.length - 3);\n"}, // decimal fraction of a second (minimum = 1 digit, maximum = unlimited)
{c:[ // allow either "Z" (i.e. UTC) or "-0530" or "+08:00" (i.e. UTC offset) timezone delimiters. assumes local timezone if no timezone is specified
"if(results[8]) {", // timezone specified
"if(results[8] == 'Z'){",
"zz = 0;", // UTC
"}else if (results[8].indexOf(':') > -1){",
utilDate.formatCodeToRegex("P", 8).c, // timezone offset with colon separator
"}else{",
utilDate.formatCodeToRegex("O", 8).c, // timezone offset without colon separator
"}",
"}"
].join('\n')}
],
i,
l;
for (i = 0, l = arr.length; i < l; ++i) {
calc.push(arr[i].c);
}
return {
g:1,
c:calc.join(""),
s:[
arr[0].s, // year (required)
"(?:", "-", arr[1].s, // month (optional)
"(?:", "-", arr[2].s, // day (optional)
"(?:",
"(?:T| )?", // time delimiter -- either a "T" or a single blank space
arr[3].s, ":", arr[4].s, // hour AND minute, delimited by a single colon (optional). MUST be preceded by either a "T" or a single blank space
"(?::", arr[5].s, ")?", // seconds (optional)
"(?:(?:\\.|,)(\\d+))?", // decimal fraction of a second (e.g. ",12345" or ".98765") (optional)
"(Z|(?:[-+]\\d{2}(?::)?\\d{2}))?", // "Z" (UTC) or "-0530" (UTC offset without colon delimiter) or "+08:00" (UTC offset with colon delimiter) (optional)
")?",
")?",
")?"
].join("")
};
},
U: {
g:1,
c:"u = parseInt(results[{0}], 10);\n",
s:"(-?\\d+)" // leading minus sign indicates seconds before UNIX epoch
}
},
//Old Ext.Date prototype methods.
// private
dateFormat: function(date, format) {
return utilDate.format(date, format);
},

isEqual: function(date1, date2) {
// check we have 2 date objects
if (date1 && date2) {
return (date1.getTime() === date2.getTime());
}
// one or both isn't a date, only equal if both are falsey
return !(date1 || date2);
},

format: function(date, format) {
var formatFunctions = utilDate.formatFunctions;
if (!Ext.isDate(date)) {
return '';
}
if (formatFunctions[format] == null) {
utilDate.createFormat(format);
}
return formatFunctions[format].call(date) + '';
},

getTimezone : function(date) {
// the following list shows the differences between date strings from different browsers on a WinXP SP2 machine from an Asian locale:
//
// Opera : "Thu, 25 Oct 2007 22:53:45 GMT+0800" -- shortest (weirdest) date string of the lot
// Safari : "Thu Oct 25 2007 22:55:35 GMT+0800 (Malay Peninsula Standard Time)" -- value in parentheses always gives the correct timezone (same as FF)
// FF : "Thu Oct 25 2007 22:55:35 GMT+0800 (Malay Peninsula Standard Time)" -- value in parentheses always gives the correct timezone
// IE : "Thu Oct 25 22:54:35 UTC+0800 2007" -- (Asian system setting) look for 3-4 letter timezone abbrev
// IE : "Thu Oct 25 17:06:37 PDT 2007" -- (American system setting) look for 3-4 letter timezone abbrev
//
// this crazy regex attempts to guess the correct timezone abbreviation despite these differences.
// step 1: (?:\((.*)\) -- find timezone in parentheses
// step 2: ([A-Z]{1,4})(?:[\-+][0-9]{4})?(?: -?\d+)?) -- if nothing was found in step 1, find timezone from timezone offset portion of date string
// step 3: remove all non uppercase characters found in step 1 and 2
return date.toString().replace(/^.* (?:\((.*)\)|([A-Z]{1,5})(?:[\-+][0-9]{4})?(?: -?\d+)?)$/, "$1$2").replace(/[^A-Z]/g, "");
},

getGMTOffset : function(date, colon) {
var offset = date.getTimezoneOffset();
return (offset > 0 ? "-" : "+")
+ Ext.String.leftPad(Math.floor(Math.abs(offset) / 60), 2, "0")
+ (colon ? ":" : "")
+ Ext.String.leftPad(Math.abs(offset % 60), 2, "0");
},

getDayOfYear: function(date) {
var num = 0,
d = Ext.Date.clone(date),
m = date.getMonth(),
i;
for (i = 0, d.setDate(1), d.setMonth(0); i < m; d.setMonth(++i)) {
num += utilDate.getDaysInMonth(d);
}
return num + date.getDate() - 1;
},

getWeekOfYear : (function() {
// adapted from http://www.merlyn.demon.co.uk/weekcalc.htm
var ms1d = 864e5, // milliseconds in a day
ms7d = 7 * ms1d; // milliseconds in a week
return function(date) { // return a closure so constants get calculated only once
var DC3 = Date.UTC(date.getFullYear(), date.getMonth(), date.getDate() + 3) / ms1d, // an Absolute Day Number
AWN = Math.floor(DC3 / 7), // an Absolute Week Number
Wyr = new Date(AWN * ms7d).getUTCFullYear();
return AWN - Math.floor(Date.UTC(Wyr, 0, 7) / ms7d) + 1;
};
}()),

isLeapYear : function(date) {
var year = date.getFullYear();
return !!((year & 3) == 0 && (year % 100 || (year % 400 == 0 && year)));
},

getFirstDayOfMonth : function(date) {
var day = (date.getDay() - (date.getDate() - 1)) % 7;
return (day < 0) ? (day + 7) : day;
},

getLastDayOfMonth : function(date) {
return utilDate.getLastDateOfMonth(date).getDay();
},

getFirstDateOfMonth : function(date) {
return new Date(date.getFullYear(), date.getMonth(), 1);
},

getLastDateOfMonth : function(date) {
return new Date(date.getFullYear(), date.getMonth(), utilDate.getDaysInMonth(date));
},

getDaysInMonth: (function() {
var daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
return function(date) { // return a closure for efficiency
var m = date.getMonth();
return m == 1 && utilDate.isLeapYear(date) ? 29 : daysInMonth[m];
};
}()),
//<locale type="function">

getSuffix : function(date) {
switch (date.getDate()) {
case 1:
case 21:
case 31:
return "st";
case 2:
case 22:
return "nd";
case 3:
case 23:
return "rd";
default:
return "th";
}
},
//</locale>

clone : function(date) {
return new Date(date.getTime());
},

isDST : function(date) {
// adapted from http://sencha.com/forum/showthread.php?p=247172#post247172
// courtesy of @geoffrey.mcgill
return new Date(date.getFullYear(), 0, 1).getTimezoneOffset() != date.getTimezoneOffset();
},

clearTime : function(date, clone) {
if (clone) {
return Ext.Date.clearTime(Ext.Date.clone(date));
}
// get current date before clearing time
var d = date.getDate(),
hr,
c;
// clear time
date.setHours(0);
date.setMinutes(0);
date.setSeconds(0);
date.setMilliseconds(0);
if (date.getDate() != d) { // account for DST (i.e. day of month changed when setting hour = 0)
// note: DST adjustments are assumed to occur in multiples of 1 hour (this is almost always the case)
// refer to http://www.timeanddate.com/time/aboutdst.html for the (rare) exceptions to this rule
// increment hour until cloned date == current date
for (hr = 1, c = utilDate.add(date, Ext.Date.HOUR, hr); c.getDate() != d; hr++, c = utilDate.add(date, Ext.Date.HOUR, hr));
date.setDate(d);
date.setHours(c.getHours());
}
return date;
},

add : function(date, interval, value) {
var d = Ext.Date.clone(date),
Date = Ext.Date,
day, decimalValue, base = 0;
if (!interval || value === 0) {
return d;
}
decimalValue = value - parseInt(value, 10);
value = parseInt(value, 10);
if (value) {
switch(interval.toLowerCase()) {
// See EXTJSIV-7418. We use setTime() here to deal with issues related to
// the switchover that occurs when changing to daylight savings and vice
// versa. setTime() handles this correctly where setHour/Minute/Second/Millisecond
// do not. Let's assume the DST change occurs at 2am and we're incrementing using add
// for 15 minutes at time. When entering DST, we should see:
// 01:30am
// 01:45am
// 03:00am // skip 2am because the hour does not exist
// ...
// Similarly, leaving DST, we should see:
// 01:30am
// 01:45am
// 01:00am // repeat 1am because that's the change over
// 01:30am
// 01:45am
// 02:00am
// ....
// 
case Ext.Date.MILLI:
d.setTime(d.getTime() + value);
break;
case Ext.Date.SECOND:
d.setTime(d.getTime() + value * 1000);
break;
case Ext.Date.MINUTE:
d.setTime(d.getTime() + value * 60 * 1000);
break;
case Ext.Date.HOUR:
d.setTime(d.getTime() + value * 60 * 60 * 1000);
break;
case Ext.Date.DAY:
d.setDate(d.getDate() + value);
break;
case Ext.Date.MONTH:
day = date.getDate();
if (day > 28) {
day = Math.min(day, Ext.Date.getLastDateOfMonth(Ext.Date.add(Ext.Date.getFirstDateOfMonth(date), Ext.Date.MONTH, value)).getDate());
}
d.setDate(day);
d.setMonth(date.getMonth() + value);
break;
case Ext.Date.YEAR:
day = date.getDate();
if (day > 28) {
day = Math.min(day, Ext.Date.getLastDateOfMonth(Ext.Date.add(Ext.Date.getFirstDateOfMonth(date), Ext.Date.YEAR, value)).getDate());
}
d.setDate(day);
d.setFullYear(date.getFullYear() + value);
break;
}
}
if (decimalValue) {
switch (interval.toLowerCase()) {
case Ext.Date.MILLI: base = 1; break;
case Ext.Date.SECOND: base = 1000; break;
case Ext.Date.MINUTE: base = 1000*60; break;
case Ext.Date.HOUR: base = 1000*60*60; break;
case Ext.Date.DAY: base = 1000*60*60*24; break;
case Ext.Date.MONTH:
day = utilDate.getDaysInMonth(d);
base = 1000*60*60*24*day;
break;
case Ext.Date.YEAR:
day = (utilDate.isLeapYear(d) ? 366 : 365);
base = 1000*60*60*24*day;
break;
}
if (base) {
d.setTime(d.getTime() + base * decimalValue); 
}
}
return d;
},


subtract: function(date, interval, value){
return utilDate.add(date, interval, -value);
},

between : function(date, start, end) {
var t = date.getTime();
return start.getTime() <= t && t <= end.getTime();
},
//Maintains compatibility with old static and prototype window.Date methods.
compat: function() {
var nativeDate = window.Date,
p,
statics = ['useStrict', 'formatCodeToRegex', 'parseFunctions', 'parseRegexes', 'formatFunctions', 'y2kYear', 'MILLI', 'SECOND', 'MINUTE', 'HOUR', 'DAY', 'MONTH', 'YEAR', 'defaults', 'dayNames', 'monthNames', 'monthNumbers', 'getShortMonthName', 'getShortDayName', 'getMonthNumber', 'formatCodes', 'isValid', 'parseDate', 'getFormatCode', 'createFormat', 'createParser', 'parseCodes'],
proto = ['dateFormat', 'format', 'getTimezone', 'getGMTOffset', 'getDayOfYear', 'getWeekOfYear', 'isLeapYear', 'getFirstDayOfMonth', 'getLastDayOfMonth', 'getDaysInMonth', 'getSuffix', 'clone', 'isDST', 'clearTime', 'add', 'between'],
sLen = statics.length,
pLen = proto.length,
stat, prot, s;
//Append statics
for (s = 0; s < sLen; s++) {
stat = statics[s];
nativeDate[stat] = utilDate[stat];
}
//Append to prototype
for (p = 0; p < pLen; p++) {
prot = proto[p];
nativeDate.prototype[prot] = function() {
var args = Array.prototype.slice.call(arguments);
args.unshift(this);
return utilDate[prot].apply(utilDate, args);
};
}
}
});
};
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/class/Base.js */
(function(Ext) {
// @tag foundation,core
// @require ../lang/Date.js
// @define Ext.Base
(function(flexSetter) {
var noArgs = [],
Base = function(){},
hookFunctionFactory = function(hookFunction, underriddenFunction, methodName, owningClass) {
var result = function() {
var result = this.callParent(arguments);
hookFunction.apply(this, arguments);
return result;
};
result.$name = methodName;
result.$owner = owningClass;
if (underriddenFunction) {
result.$previous = underriddenFunction.$previous;
underriddenFunction.$previous = result;
}
return result;
};
// These static properties will be copied to every newly created class with {@link Ext#define}
Ext.apply(Base, {
$className: 'Ext.Base',
$isClass: true,

create: function() {
return Ext.create.apply(Ext, [this].concat(Array.prototype.slice.call(arguments, 0)));
},

extend: function(parent) {
var parentPrototype = parent.prototype,
basePrototype, prototype, i, ln, name, statics;
prototype = this.prototype = Ext.Object.chain(parentPrototype);
prototype.self = this;
this.superclass = prototype.superclass = parentPrototype;
if (!parent.$isClass) {
basePrototype = Ext.Base.prototype;
for (i in basePrototype) {
if (i in prototype) {
prototype[i] = basePrototype[i];
}
}
}
//<feature classSystem.inheritableStatics>
// Statics inheritance
statics = parentPrototype.$inheritableStatics;
if (statics) {
for (i = 0,ln = statics.length; i < ln; i++) {
name = statics[i];
if (!this.hasOwnProperty(name)) {
this[name] = parent[name];
}
}
}
//</feature>
if (parent.$onExtended) {
this.$onExtended = parent.$onExtended.slice();
}
//<feature classSystem.config>
prototype.config = new prototype.configClass();
prototype.initConfigList = prototype.initConfigList.slice();
prototype.initConfigMap = Ext.clone(prototype.initConfigMap);
prototype.configMap = Ext.Object.chain(prototype.configMap);
//</feature>
},

$onExtended: [],

triggerExtended: function() {
//<debug>
Ext.classSystemMonitor && Ext.classSystemMonitor(this, 'Ext.Base#triggerExtended', arguments);
//</debug>

var callbacks = this.$onExtended,
ln = callbacks.length,
i, callback;
if (ln > 0) {
for (i = 0; i < ln; i++) {
callback = callbacks[i];
callback.fn.apply(callback.scope || this, arguments);
}
}
},

onExtended: function(fn, scope) {
this.$onExtended.push({
fn: fn,
scope: scope
});
return this;
},

addConfig: function(config, fullMerge) {
var prototype = this.prototype,
configNameCache = Ext.Class.configNameCache,
hasConfig = prototype.configMap,
initConfigList = prototype.initConfigList,
initConfigMap = prototype.initConfigMap,
defaultConfig = prototype.config,
initializedName, name, value;
for (name in config) {
if (config.hasOwnProperty(name)) {
if (!hasConfig[name]) {
hasConfig[name] = true;
}
value = config[name];
initializedName = configNameCache[name].initialized;
if (!initConfigMap[name] && value !== null && !prototype[initializedName]) {
initConfigMap[name] = true;
initConfigList.push(name);
}
}
}
if (fullMerge) {
Ext.merge(defaultConfig, config);
}
else {
Ext.mergeIf(defaultConfig, config);
}
prototype.configClass = Ext.Object.classify(defaultConfig);
},

addStatics: function(members) {
var member, name;
for (name in members) {
if (members.hasOwnProperty(name)) {
member = members[name];
if (typeof member == 'function' && !member.$isClass && member !== Ext.emptyFn && member !== Ext.identityFn) {
member.$owner = this;
member.$name = name;
//<debug>
member.displayName = Ext.getClassName(this) + '.' + name;
//</debug>
}
this[name] = member;
}
}
return this;
},

addInheritableStatics: function(members) {
var inheritableStatics,
hasInheritableStatics,
prototype = this.prototype,
name, member;
inheritableStatics = prototype.$inheritableStatics;
hasInheritableStatics = prototype.$hasInheritableStatics;
if (!inheritableStatics) {
inheritableStatics = prototype.$inheritableStatics = [];
hasInheritableStatics = prototype.$hasInheritableStatics = {};
}
for (name in members) {
if (members.hasOwnProperty(name)) {
member = members[name];
//<debug>
if (typeof member == 'function') {
member.displayName = Ext.getClassName(this) + '.' + name;
}
//</debug>
this[name] = member;
if (!hasInheritableStatics[name]) {
hasInheritableStatics[name] = true;
inheritableStatics.push(name);
}
}
}
return this;
},

addMembers: function(members) {
var prototype = this.prototype,
enumerables = Ext.enumerables,
names = [],
i, ln, name, member;
for (name in members) {
names.push(name);
}
if (enumerables) {
names.push.apply(names, enumerables);
}
for (i = 0,ln = names.length; i < ln; i++) {
name = names[i];
if (members.hasOwnProperty(name)) {
member = members[name];
if (typeof member == 'function' && !member.$isClass && member !== Ext.emptyFn && member !== Ext.identityFn) {
member.$owner = this;
member.$name = name;
//<debug>
member.displayName = (this.$className || '') + '#' + name;
//</debug>
}
prototype[name] = member;
}
}
return this;
},

addMember: function(name, member) { 
if (typeof member == 'function' && !member.$isClass && member !== Ext.emptyFn && member !== Ext.identityFn) {
member.$owner = this;
member.$name = name;
//<debug>
member.displayName = (this.$className || '') + '#' + name;
//</debug>
}
this.prototype[name] = member;
return this;
},

implement: function() {
this.addMembers.apply(this, arguments);
},

borrow: function(fromClass, members) {
//<debug>
Ext.classSystemMonitor && Ext.classSystemMonitor(this, 'Ext.Base#borrow', arguments);
//</debug>

var prototype = this.prototype,
fromPrototype = fromClass.prototype,
//<debug>
className = Ext.getClassName(this),
//</debug>
i, ln, name, fn, toBorrow;
members = Ext.Array.from(members);
for (i = 0,ln = members.length; i < ln; i++) {
name = members[i];
toBorrow = fromPrototype[name];
if (typeof toBorrow == 'function') {
fn = Ext.Function.clone(toBorrow);
//<debug>
if (className) {
fn.displayName = className + '#' + name;
}
//</debug>
fn.$owner = this;
fn.$name = name;
prototype[name] = fn;
}
else {
prototype[name] = toBorrow;
}
}
return this;
},

override: function(members) {
var me = this,
enumerables = Ext.enumerables,
target = me.prototype,
cloneFunction = Ext.Function.clone,
name, index, member, statics, names, previous;
if (arguments.length === 2) {
name = members;
members = {};
members[name] = arguments[1];
enumerables = null;
}
do {
names = []; // clean slate for prototype (1st pass) and static (2nd pass)
statics = null; // not needed 1st pass, but needs to be cleared for 2nd pass
for (name in members) { // hasOwnProperty is checked in the next loop...
if (name == 'statics') {
statics = members[name];
} else if (name == 'inheritableStatics'){
me.addInheritableStatics(members[name]);
} else if (name == 'config') {
me.addConfig(members[name], true);
} else {
names.push(name);
}
}
if (enumerables) {
names.push.apply(names, enumerables);
}
for (index = names.length; index--; ) {
name = names[index];
if (members.hasOwnProperty(name)) {
member = members[name];
if (typeof member == 'function' && !member.$className && member !== Ext.emptyFn && member !== Ext.identityFn) {
if (typeof member.$owner != 'undefined') {
member = cloneFunction(member);
}
//<debug>
if (me.$className) {
member.displayName = me.$className + '#' + name;
}
//</debug>
member.$owner = me;
member.$name = name;
previous = target[name];
if (previous) {
member.$previous = previous;
}
}
target[name] = member;
}
}
target = me; // 2nd pass is for statics
members = statics; // statics will be null on 2nd pass
} while (members);
return this;
},
// Documented downwards
callParent: function(args) {
var method;
// This code is intentionally inlined for the least number of debugger stepping
return (method = this.callParent.caller) && (method.$previous ||
((method = method.$owner ? method : method.caller) &&
method.$owner.superclass.self[method.$name])).apply(this, args || noArgs);
},
// Documented downwards
callSuper: function(args) {
var method;
// This code is intentionally inlined for the least number of debugger stepping
return (method = this.callSuper.caller) &&
((method = method.$owner ? method : method.caller) &&
method.$owner.superclass.self[method.$name]).apply(this, args || noArgs);
},
//<feature classSystem.mixins>

mixin: function(name, mixinClass) {
var me = this,
mixin = mixinClass.prototype,
prototype = me.prototype,
key, statics, i, ln, staticName,
mixinValue, hookKey, hookFunction;
if (typeof mixin.onClassMixedIn != 'undefined') {
mixin.onClassMixedIn.call(mixinClass, me);
}
if (!prototype.hasOwnProperty('mixins')) {
if ('mixins' in prototype) {
prototype.mixins = Ext.Object.chain(prototype.mixins);
}
else {
prototype.mixins = {};
}
}
for (key in mixin) {
mixinValue = mixin[key];
if (key === 'mixins') {
Ext.merge(prototype.mixins, mixinValue);
}
else if (key === 'xhooks') {
for (hookKey in mixinValue) {
hookFunction = mixinValue[hookKey];
// Mixed in xhook methods cannot call a parent.
hookFunction.$previous = Ext.emptyFn;
if (prototype.hasOwnProperty(hookKey)) {
// Pass the hook function, and the existing function which it is to underride.
// The existing function has its $previous pointer replaced by a closure
// which calls the hookFunction and then the existing function's original $previous
hookFunctionFactory(hookFunction, prototype[hookKey], hookKey, me);
} else {
// There's no original function, so generate an implementation which calls
// the hook function. It will not get any $previous pointer.
prototype[hookKey] = hookFunctionFactory(hookFunction, null, hookKey, me);
}
}
}
else if (!(key === 'mixinId' || key === 'config') && (prototype[key] === undefined)) {
prototype[key] = mixinValue;
}
}
//<feature classSystem.inheritableStatics>
// Mixin statics inheritance
statics = mixin.$inheritableStatics;
if (statics) {
for (i = 0, ln = statics.length; i < ln; i++) {
staticName = statics[i];
if (!me.hasOwnProperty(staticName)) {
me[staticName] = mixinClass[staticName];
}
}
}
//</feature>
//<feature classSystem.config>
if ('config' in mixin) {
me.addConfig(mixin.config, false);
}
//</feature>
prototype.mixins[name] = mixin;
return me;
},
//</feature>

getName: function() {
return Ext.getClassName(this);
},

createAlias: flexSetter(function(alias, origin) {
this.override(alias, function() {
return this[origin].apply(this, arguments);
});
}),

addXtype: function(xtype) {
var prototype = this.prototype,
xtypesMap = prototype.xtypesMap,
xtypes = prototype.xtypes,
xtypesChain = prototype.xtypesChain;
if (!prototype.hasOwnProperty('xtypesMap')) {
xtypesMap = prototype.xtypesMap = Ext.merge({}, prototype.xtypesMap || {});
xtypes = prototype.xtypes = prototype.xtypes ? [].concat(prototype.xtypes) : [];
xtypesChain = prototype.xtypesChain = prototype.xtypesChain ? [].concat(prototype.xtypesChain) : [];
prototype.xtype = xtype;
}
if (!xtypesMap[xtype]) {
xtypesMap[xtype] = true;
xtypes.push(xtype);
xtypesChain.push(xtype);
Ext.ClassManager.setAlias(this, 'widget.' + xtype);
}
return this;
}
});
Base.implement({

isInstance: true,

$className: 'Ext.Base',

configClass: Ext.emptyFn,

initConfigList: [],

configMap: {},

initConfigMap: {},

statics: function() {
var method = this.statics.caller,
self = this.self;
if (!method) {
return self;
}
return method.$owner;
},

callParent: function(args) {
// NOTE: this code is deliberately as few expressions (and no function calls)
// as possible so that a debugger can skip over this noise with the minimum number
// of steps. Basically, just hit Step Into until you are where you really wanted
// to be.
var method,
superMethod = (method = this.callParent.caller) && (method.$previous ||
((method = method.$owner ? method : method.caller) &&
method.$owner.superclass[method.$name]));
//<debug error>
if (!superMethod) {
method = this.callParent.caller;
var parentClass, methodName;
if (!method.$owner) {
if (!method.caller) {
throw new Error("Attempting to call a protected method from the public scope, which is not allowed");
}
method = method.caller;
}
parentClass = method.$owner.superclass;
methodName = method.$name;
if (!(methodName in parentClass)) {
throw new Error("this.callParent() was called but there's no such method (" + methodName +
") found in the parent class (" + (Ext.getClassName(parentClass) || 'Object') + ")");
}
}
//</debug>
return superMethod.apply(this, args || noArgs);
},

callSuper: function(args) {
// NOTE: this code is deliberately as few expressions (and no function calls)
// as possible so that a debugger can skip over this noise with the minimum number
// of steps. Basically, just hit Step Into until you are where you really wanted
// to be.
var method,
superMethod = (method = this.callSuper.caller) &&
((method = method.$owner ? method : method.caller) &&
method.$owner.superclass[method.$name]);
//<debug error>
if (!superMethod) {
method = this.callSuper.caller;
var parentClass, methodName;
if (!method.$owner) {
if (!method.caller) {
throw new Error("Attempting to call a protected method from the public scope, which is not allowed");
}
method = method.caller;
}
parentClass = method.$owner.superclass;
methodName = method.$name;
if (!(methodName in parentClass)) {
throw new Error("this.callSuper() was called but there's no such method (" + methodName +
") found in the parent class (" + (Ext.getClassName(parentClass) || 'Object') + ")");
}
}
//</debug>
return superMethod.apply(this, args || noArgs);
},

self: Base,
// Default constructor, simply returns `this`
constructor: function() {
return this;
},
//<feature classSystem.config>

initConfig: function(config) {
var instanceConfig = config,
configNameCache = Ext.Class.configNameCache,
defaultConfig = new this.configClass(),
defaultConfigList = this.initConfigList,
hasConfig = this.configMap,
nameMap, i, ln, name, initializedName;
this.initConfig = Ext.emptyFn;
this.initialConfig = instanceConfig || {};
this.config = config = (instanceConfig) ? Ext.merge(defaultConfig, config) : defaultConfig;
if (instanceConfig) {
defaultConfigList = defaultConfigList.slice();
for (name in instanceConfig) {
if (hasConfig[name]) {
if (instanceConfig[name] !== null) {
defaultConfigList.push(name);
this[configNameCache[name].initialized] = false;
}
}
}
}
for (i = 0,ln = defaultConfigList.length; i < ln; i++) {
name = defaultConfigList[i];
nameMap = configNameCache[name];
initializedName = nameMap.initialized;
if (!this[initializedName]) {
this[initializedName] = true;
this[nameMap.set].call(this, config[name]);
}
}
return this;
},

hasConfig: function(name) {
return Boolean(this.configMap[name]);
},

setConfig: function(config, applyIfNotSet) {
if (!config) {
return this;
}
var configNameCache = Ext.Class.configNameCache,
currentConfig = this.config,
hasConfig = this.configMap,
initialConfig = this.initialConfig,
name, value;
applyIfNotSet = Boolean(applyIfNotSet);
for (name in config) {
if (applyIfNotSet && initialConfig.hasOwnProperty(name)) {
continue;
}
value = config[name];
currentConfig[name] = value;
if (hasConfig[name]) {
this[configNameCache[name].set](value);
}
}
return this;
},

getConfig: function(name) {
var configNameCache = Ext.Class.configNameCache;
return this[configNameCache[name].get]();
},

getInitialConfig: function(name) {
var config = this.config;
if (!name) {
return config;
}
else {
return config[name];
}
},

onConfigUpdate: function(names, callback, scope) {
var self = this.self,
//<debug>
className = self.$className,
//</debug>
i, ln, name,
updaterName, updater, newUpdater;
names = Ext.Array.from(names);
scope = scope || this;
for (i = 0,ln = names.length; i < ln; i++) {
name = names[i];
updaterName = 'update' + Ext.String.capitalize(name);
updater = this[updaterName] || Ext.emptyFn;
newUpdater = function() {
updater.apply(this, arguments);
scope[callback].apply(scope, arguments);
};
newUpdater.$name = updaterName;
newUpdater.$owner = self;
//<debug>
newUpdater.displayName = className + '#' + updaterName;
//</debug>
this[updaterName] = newUpdater;
}
},
//</feature>

destroy: function() {
this.destroy = Ext.emptyFn;
}
});

Base.prototype.callOverridden = Base.prototype.callParent;
Ext.Base = Base;
}(Ext.Function.flexSetter));
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/class/Class.js */
(function(Ext) {
// @tag foundation,core
// @require Base.js
// @define Ext.Class
(function() {
var ExtClass,
Base = Ext.Base,
baseStaticMembers = [],
baseStaticMember, baseStaticMemberLength;
for (baseStaticMember in Base) {
if (Base.hasOwnProperty(baseStaticMember)) {
baseStaticMembers.push(baseStaticMember);
}
}
baseStaticMemberLength = baseStaticMembers.length;
// Creates a constructor that has nothing extra in its scope chain.
function makeCtor (className) {
function constructor () {
// Opera has some problems returning from a constructor when Dragonfly isn't running. The || null seems to
// be sufficient to stop it misbehaving. Known to be required against 10.53, 11.51 and 11.61.
return this.constructor.apply(this, arguments) || null;
}
//<debug>
if (className) {
constructor.displayName = className;
}
//</debug>
return constructor;
}

Ext.Class = ExtClass = function(Class, data, onCreated) {
if (typeof Class != 'function') {
onCreated = data;
data = Class;
Class = null;
}
if (!data) {
data = {};
}
Class = ExtClass.create(Class, data);
ExtClass.process(Class, data, onCreated);
return Class;
};
Ext.apply(ExtClass, {

onBeforeCreated: function(Class, data, hooks) {
//<debug>
Ext.classSystemMonitor && Ext.classSystemMonitor(Class, '>> Ext.Class#onBeforeCreated', arguments);
//</debug>

Class.addMembers(data);
hooks.onCreated.call(Class, Class);

//<debug>
Ext.classSystemMonitor && Ext.classSystemMonitor(Class, '<< Ext.Class#onBeforeCreated', arguments);
//</debug>
},

create: function(Class, data) {
var name, i;
if (!Class) {
Class = makeCtor(
//<debug>
data.$className
//</debug>
);
}
for (i = 0; i < baseStaticMemberLength; i++) {
name = baseStaticMembers[i];
Class[name] = Base[name];
}
return Class;
},

process: function(Class, data, onCreated) {
var preprocessorStack = data.preprocessors || ExtClass.defaultPreprocessors,
registeredPreprocessors = this.preprocessors,
hooks = {
onBeforeCreated: this.onBeforeCreated
},
preprocessors = [],
preprocessor, preprocessorsProperties,
i, ln, j, subLn, preprocessorProperty;
delete data.preprocessors;
for (i = 0,ln = preprocessorStack.length; i < ln; i++) {
preprocessor = preprocessorStack[i];
if (typeof preprocessor == 'string') {
preprocessor = registeredPreprocessors[preprocessor];
preprocessorsProperties = preprocessor.properties;
if (preprocessorsProperties === true) {
preprocessors.push(preprocessor.fn);
}
else if (preprocessorsProperties) {
for (j = 0,subLn = preprocessorsProperties.length; j < subLn; j++) {
preprocessorProperty = preprocessorsProperties[j];
if (data.hasOwnProperty(preprocessorProperty)) {
preprocessors.push(preprocessor.fn);
break;
}
}
}
}
else {
preprocessors.push(preprocessor);
}
}
hooks.onCreated = onCreated ? onCreated : Ext.emptyFn;
hooks.preprocessors = preprocessors;
this.doProcess(Class, data, hooks);
},

doProcess: function(Class, data, hooks) {
var me = this,
preprocessors = hooks.preprocessors,
preprocessor = preprocessors.shift(),
doProcess = me.doProcess;
for ( ; preprocessor ; preprocessor = preprocessors.shift()) {
// Returning false signifies an asynchronous preprocessor - it will call doProcess when we can continue
if (preprocessor.call(me, Class, data, hooks, doProcess) === false) {
return;
}
}
hooks.onBeforeCreated.apply(me, arguments);
},

preprocessors: {},

registerPreprocessor: function(name, fn, properties, position, relativeTo) {
if (!position) {
position = 'last';
}
if (!properties) {
properties = [name];
}
this.preprocessors[name] = {
name: name,
properties: properties || false,
fn: fn
};
this.setDefaultPreprocessorPosition(name, position, relativeTo);
return this;
},

getPreprocessor: function(name) {
return this.preprocessors[name];
},

getPreprocessors: function() {
return this.preprocessors;
},

defaultPreprocessors: [],

getDefaultPreprocessors: function() {
return this.defaultPreprocessors;
},

setDefaultPreprocessors: function(preprocessors) {
this.defaultPreprocessors = Ext.Array.from(preprocessors);
return this;
},

setDefaultPreprocessorPosition: function(name, offset, relativeName) {
var defaultPreprocessors = this.defaultPreprocessors,
index;
if (typeof offset == 'string') {
if (offset === 'first') {
defaultPreprocessors.unshift(name);
return this;
}
else if (offset === 'last') {
defaultPreprocessors.push(name);
return this;
}
offset = (offset === 'after') ? 1 : -1;
}
index = Ext.Array.indexOf(defaultPreprocessors, relativeName);
if (index !== -1) {
Ext.Array.splice(defaultPreprocessors, Math.max(0, index + offset), 0, name);
}
return this;
},
configNameCache: {},
getConfigNameMap: function(name) {
var cache = this.configNameCache,
map = cache[name],
capitalizedName;
if (!map) {
capitalizedName = name.charAt(0).toUpperCase() + name.substr(1);
map = cache[name] = {
internal: name,
initialized: '_is' + capitalizedName + 'Initialized',
apply: 'apply' + capitalizedName,
update: 'update' + capitalizedName,
'set': 'set' + capitalizedName,
'get': 'get' + capitalizedName,
doSet : 'doSet' + capitalizedName,
changeEvent: name.toLowerCase() + 'change'
};
}
return map;
}
});

ExtClass.registerPreprocessor('extend', function(Class, data, hooks) {
//<debug>
Ext.classSystemMonitor && Ext.classSystemMonitor(Class, 'Ext.Class#extendPreProcessor', arguments);
//</debug>

var Base = Ext.Base,
basePrototype = Base.prototype,
extend = data.extend,
Parent, parentPrototype, i;
delete data.extend;
if (extend && extend !== Object) {
Parent = extend;
}
else {
Parent = Base;
}
parentPrototype = Parent.prototype;
if (!Parent.$isClass) {
for (i in basePrototype) {
if (!parentPrototype[i]) {
parentPrototype[i] = basePrototype[i];
}
}
}
Class.extend(Parent);
Class.triggerExtended.apply(Class, arguments);
if (data.onClassExtended) {
Class.onExtended(data.onClassExtended, Class);
delete data.onClassExtended;
}
}, true);
//<feature classSystem.statics>

ExtClass.registerPreprocessor('statics', function(Class, data) {
//<debug>
Ext.classSystemMonitor && Ext.classSystemMonitor(Class, 'Ext.Class#staticsPreprocessor', arguments);
//</debug>

Class.addStatics(data.statics);
delete data.statics;
});
//</feature>
//<feature classSystem.inheritableStatics>

ExtClass.registerPreprocessor('inheritableStatics', function(Class, data) {
//<debug>
Ext.classSystemMonitor && Ext.classSystemMonitor(Class, 'Ext.Class#inheritableStaticsPreprocessor', arguments);
//</debug>

Class.addInheritableStatics(data.inheritableStatics);
delete data.inheritableStatics;
});
//</feature>
//<feature classSystem.config>

ExtClass.registerPreprocessor('config', function(Class, data) {
//<debug>
Ext.classSystemMonitor && Ext.classSystemMonitor(Class, 'Ext.Class#configPreProcessor', arguments);
//</debug>

var config = data.config,
prototype = Class.prototype;
delete data.config;
Ext.Object.each(config, function(name, value) {
var nameMap = ExtClass.getConfigNameMap(name),
internalName = nameMap.internal,
initializedName = nameMap.initialized,
applyName = nameMap.apply,
updateName = nameMap.update,
setName = nameMap.set,
getName = nameMap.get,
hasOwnSetter = (setName in prototype) || data.hasOwnProperty(setName),
hasOwnApplier = (applyName in prototype) || data.hasOwnProperty(applyName),
hasOwnUpdater = (updateName in prototype) || data.hasOwnProperty(updateName),
optimizedGetter, customGetter;
if (value === null || (!hasOwnSetter && !hasOwnApplier && !hasOwnUpdater)) {
prototype[internalName] = value;
prototype[initializedName] = true;
}
else {
prototype[initializedName] = false;
}
if (!hasOwnSetter) {
data[setName] = function(value) {
var oldValue = this[internalName],
applier = this[applyName],
updater = this[updateName];
if (!this[initializedName]) {
this[initializedName] = true;
}
if (applier) {
value = applier.call(this, value, oldValue);
}
if (typeof value != 'undefined') {
this[internalName] = value;
if (updater && value !== oldValue) {
updater.call(this, value, oldValue);
}
}
return this;
};
}
if (!(getName in prototype) || data.hasOwnProperty(getName)) {
customGetter = data[getName] || false;
if (customGetter) {
optimizedGetter = function() {
return customGetter.apply(this, arguments);
};
}
else {
optimizedGetter = function() {
return this[internalName];
};
}
data[getName] = function() {
var currentGetter;
if (!this[initializedName]) {
this[initializedName] = true;
this[setName](this.config[name]);
}
currentGetter = this[getName];
if ('$previous' in currentGetter) {
currentGetter.$previous = optimizedGetter;
}
else {
this[getName] = optimizedGetter;
}
return optimizedGetter.apply(this, arguments);
};
}
});
Class.addConfig(config, true);
});
//</feature>
//<feature classSystem.mixins>

ExtClass.registerPreprocessor('mixins', function(Class, data, hooks) {
//<debug>
Ext.classSystemMonitor && Ext.classSystemMonitor(Class, 'Ext.Class#mixinsPreprocessor', arguments);
//</debug>

var mixins = data.mixins,
name, mixin, i, ln;
delete data.mixins;
Ext.Function.interceptBefore(hooks, 'onCreated', function() {
//<debug>
Ext.classSystemMonitor && Ext.classSystemMonitor(Class, 'Ext.Class#mixinsPreprocessor#beforeCreated', arguments);
//</debug>

if (mixins instanceof Array) {
for (i = 0,ln = mixins.length; i < ln; i++) {
mixin = mixins[i];
name = mixin.prototype.mixinId || mixin.$className;
Class.mixin(name, mixin);
}
}
else {
for (var mixinName in mixins) {
if (mixins.hasOwnProperty(mixinName)) {
Class.mixin(mixinName, mixins[mixinName]);
}
}
}
});
});
//</feature>
//<feature classSystem.backwardsCompatible>
// Backwards compatible
Ext.extend = function(Class, Parent, members) {
//<debug>
Ext.classSystemMonitor && Ext.classSystemMonitor(Class, 'Ext.Class#extend-backwards-compatible', arguments);
//</debug>

if (arguments.length === 2 && Ext.isObject(Parent)) {
members = Parent;
Parent = Class;
Class = null;
}
var cls;
if (!Parent) {
throw new Error("[Ext.extend] Attempting to extend from a class which has not been loaded on the page.");
}
members.extend = Parent;
members.preprocessors = [
'extend'
//<feature classSystem.statics>
,'statics'
//</feature>
//<feature classSystem.inheritableStatics>
,'inheritableStatics'
//</feature>
//<feature classSystem.mixins>
,'mixins'
//</feature>
//<feature classSystem.config>
,'config'
//</feature>
];
if (Class) {
cls = new ExtClass(Class, members);
// The 'constructor' is given as 'Class' but also needs to be on prototype
cls.prototype.constructor = Class;
} else {
cls = new ExtClass(members);
}
cls.prototype.override = function(o) {
for (var m in o) {
if (o.hasOwnProperty(m)) {
this[m] = o[m];
}
}
};
return cls;
};
//</feature>
}());
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/class/ClassManager.js */
(function(Ext) {
// @tag foundation,core
// @require Class.js
// @define Ext.ClassManager
(function(Class, alias, arraySlice, arrayFrom, global) {
// Creates a constructor that has nothing extra in its scope chain.
function makeCtor () {
function constructor () {
// Opera has some problems returning from a constructor when Dragonfly isn't running. The || null seems to
// be sufficient to stop it misbehaving. Known to be required against 10.53, 11.51 and 11.61.
return this.constructor.apply(this, arguments) || null;
}
return constructor;
}
var Manager = Ext.ClassManager = {

classes: {},

existCache: {},

namespaceRewrites: [{
from: 'Ext.',
to: Ext
}],

maps: {
alternateToName: {},
aliasToName: {},
nameToAliases: {},
nameToAlternates: {}
},

enableNamespaceParseCache: true,

namespaceParseCache: {},

instantiators: [],

isCreated: function(className) {
var existCache = this.existCache,
i, ln, part, root, parts;
//<debug error>
if (typeof className != 'string' || className.length < 1) {
throw new Error("[Ext.ClassManager] Invalid classname, must be a string and must not be empty");
}
//</debug>
if (this.classes[className] || existCache[className]) {
return true;
}
root = global;
parts = this.parseNamespace(className);
for (i = 0, ln = parts.length; i < ln; i++) {
part = parts[i];
if (typeof part != 'string') {
root = part;
} else {
if (!root || !root[part]) {
return false;
}
root = root[part];
}
}
existCache[className] = true;
this.triggerCreated(className);
return true;
},

createdListeners: [],

nameCreatedListeners: {},

triggerCreated: function(className) {
var listeners = this.createdListeners,
nameListeners = this.nameCreatedListeners,
alternateNames = this.maps.nameToAlternates[className],
names = [className],
i, ln, j, subLn, listener, name;
for (i = 0,ln = listeners.length; i < ln; i++) {
listener = listeners[i];
listener.fn.call(listener.scope, className);
}
if (alternateNames) {
names.push.apply(names, alternateNames);
}
for (i = 0,ln = names.length; i < ln; i++) {
name = names[i];
listeners = nameListeners[name];
if (listeners) {
for (j = 0,subLn = listeners.length; j < subLn; j++) {
listener = listeners[j];
listener.fn.call(listener.scope, name);
}
delete nameListeners[name];
}
}
},

onCreated: function(fn, scope, className) {
//<debug>
Ext.classSystemMonitor && Ext.classSystemMonitor(className, 'Ext.ClassManager#onCreated', arguments);
//</debug>

var listeners = this.createdListeners,
nameListeners = this.nameCreatedListeners,
listener = {
fn: fn,
scope: scope
};
if (className) {
if (this.isCreated(className)) {
fn.call(scope, className);
return;
}
if (!nameListeners[className]) {
nameListeners[className] = [];
}
nameListeners[className].push(listener);
}
else {
listeners.push(listener);
}
},

parseNamespace: function(namespace) {
//<debug error>
if (typeof namespace != 'string') {
throw new Error("[Ext.ClassManager] Invalid namespace, must be a string");
}
//</debug>
var cache = this.namespaceParseCache,
parts,
rewrites,
root,
name,
rewrite, from, to, i, ln;
if (this.enableNamespaceParseCache) {
if (cache.hasOwnProperty(namespace)) {
return cache[namespace];
}
}
parts = [];
rewrites = this.namespaceRewrites;
root = global;
name = namespace;
for (i = 0, ln = rewrites.length; i < ln; i++) {
rewrite = rewrites[i];
from = rewrite.from;
to = rewrite.to;
if (name === from || name.substring(0, from.length) === from) {
name = name.substring(from.length);
if (typeof to != 'string') {
root = to;
} else {
parts = parts.concat(to.split('.'));
}
break;
}
}
parts.push(root);
parts = parts.concat(name.split('.'));
if (this.enableNamespaceParseCache) {
cache[namespace] = parts;
}
return parts;
},

setNamespace: function(name, value) {
var root = global,
parts = this.parseNamespace(name),
ln = parts.length - 1,
leaf = parts[ln],
i, part;
for (i = 0; i < ln; i++) {
part = parts[i];
if (typeof part != 'string') {
root = part;
} else {
if (!root[part]) {
root[part] = {};
}
root = root[part];
}
}
root[leaf] = value;
return root[leaf];
},

createNamespaces: function() {
var root = global,
parts, part, i, j, ln, subLn;
for (i = 0, ln = arguments.length; i < ln; i++) {
parts = this.parseNamespace(arguments[i]);
for (j = 0, subLn = parts.length; j < subLn; j++) {
part = parts[j];
if (typeof part != 'string') {
root = part;
} else {
if (!root[part]) {
root[part] = {};
}
root = root[part];
}
}
}
return root;
},

set: function(name, value) {
var me = this,
maps = me.maps,
nameToAlternates = maps.nameToAlternates,
targetName = me.getName(value),
alternates;
me.classes[name] = me.setNamespace(name, value);
if (targetName && targetName !== name) {
maps.alternateToName[name] = targetName;
alternates = nameToAlternates[targetName] || (nameToAlternates[targetName] = []);
alternates.push(name);
}
return this;
},

get: function(name) {
var classes = this.classes,
root,
parts,
part, i, ln;
if (classes[name]) {
return classes[name];
}
root = global;
parts = this.parseNamespace(name);
for (i = 0, ln = parts.length; i < ln; i++) {
part = parts[i];
if (typeof part != 'string') {
root = part;
} else {
if (!root || !root[part]) {
return null;
}
root = root[part];
}
}
return root;
},

setAlias: function(cls, alias) {
var aliasToNameMap = this.maps.aliasToName,
nameToAliasesMap = this.maps.nameToAliases,
className;
if (typeof cls == 'string') {
className = cls;
} else {
className = this.getName(cls);
}
if (alias && aliasToNameMap[alias] !== className) {
//<debug info>
if (aliasToNameMap[alias] && Ext.isDefined(global.console)) {
global.console.log("[Ext.ClassManager] Overriding existing alias: '" + alias + "' " +
"of: '" + aliasToNameMap[alias] + "' with: '" + className + "'. Be sure it's intentional.");
}
//</debug>
aliasToNameMap[alias] = className;
}
if (!nameToAliasesMap[className]) {
nameToAliasesMap[className] = [];
}
if (alias) {
Ext.Array.include(nameToAliasesMap[className], alias);
}
return this;
},

addNameAliasMappings: function(aliases){
var aliasToNameMap = this.maps.aliasToName,
nameToAliasesMap = this.maps.nameToAliases,
className, aliasList, alias, i;
for (className in aliases) {
aliasList = nameToAliasesMap[className] ||
(nameToAliasesMap[className] = []);
for (i = 0; i < aliases[className].length; i++) {
alias = aliases[className][i];
if (!aliasToNameMap[alias]) {
aliasToNameMap[alias] = className;
aliasList.push(alias);
}
}
}
return this;
},

addNameAlternateMappings: function(alternates) {
var alternateToName = this.maps.alternateToName,
nameToAlternates = this.maps.nameToAlternates,
className, aliasList, alternate, i;
for (className in alternates) {
aliasList = nameToAlternates[className] ||
(nameToAlternates[className] = []);
for (i = 0; i < alternates[className].length; i++) {
alternate = alternates[className][i];
if (!alternateToName[alternate]) {
alternateToName[alternate] = className;
aliasList.push(alternate);
}
}
}
return this;
},

getByAlias: function(alias) {
return this.get(this.getNameByAlias(alias));
},

getNameByAlias: function(alias) {
return this.maps.aliasToName[alias] || '';
},

getNameByAlternate: function(alternate) {
return this.maps.alternateToName[alternate] || '';
},

getAliasesByName: function(name) {
return this.maps.nameToAliases[name] || [];
},

getName: function(object) {
return object && object.$className || '';
},

getClass: function(object) {
return object && object.self || null;
},

create: function(className, data, createdFn) {
//<debug error>
if (className != null && typeof className != 'string') {
throw new Error("[Ext.define] Invalid class name '" + className + "' specified, must be a non-empty string");
}
//</debug>
var ctor = makeCtor();
if (typeof data == 'function') {
data = data(ctor);
}
//<debug>
if (className) {
ctor.displayName = className;
}
//</debug>
data.$className = className;
return new Class(ctor, data, function() {
var postprocessorStack = data.postprocessors || Manager.defaultPostprocessors,
registeredPostprocessors = Manager.postprocessors,
postprocessors = [],
postprocessor, i, ln, j, subLn, postprocessorProperties, postprocessorProperty;
delete data.postprocessors;
for (i = 0,ln = postprocessorStack.length; i < ln; i++) {
postprocessor = postprocessorStack[i];
if (typeof postprocessor == 'string') {
postprocessor = registeredPostprocessors[postprocessor];
postprocessorProperties = postprocessor.properties;
if (postprocessorProperties === true) {
postprocessors.push(postprocessor.fn);
}
else if (postprocessorProperties) {
for (j = 0,subLn = postprocessorProperties.length; j < subLn; j++) {
postprocessorProperty = postprocessorProperties[j];
if (data.hasOwnProperty(postprocessorProperty)) {
postprocessors.push(postprocessor.fn);
break;
}
}
}
}
else {
postprocessors.push(postprocessor);
}
}
data.postprocessors = postprocessors;
data.createdFn = createdFn;
Manager.processCreate(className, this, data);
});
},
processCreate: function(className, cls, clsData){
var me = this,
postprocessor = clsData.postprocessors.shift(),
createdFn = clsData.createdFn;
if (!postprocessor) {
//<debug>
Ext.classSystemMonitor && Ext.classSystemMonitor(className, 'Ext.ClassManager#classCreated', arguments);
//</debug>

if (className) {
me.set(className, cls);
}
if (createdFn) {
createdFn.call(cls, cls);
}
if (className) {
me.triggerCreated(className);
}
return;
}
if (postprocessor.call(me, className, cls, clsData, me.processCreate) !== false) {
me.processCreate(className, cls, clsData);
}
},
createOverride: function (className, data, createdFn) {
var me = this,
overriddenClassName = data.override,
requires = data.requires,
uses = data.uses,
classReady = function () {
var cls, temp;
if (requires) {
temp = requires;
requires = null; // do the real thing next time (which may be now)
// Since the override is going to be used (its target class is now
// created), we need to fetch the required classes for the override
// and call us back once they are loaded:
Ext.Loader.require(temp, classReady);
} else {
// The target class and the required classes for this override are
// ready, so we can apply the override now:
cls = me.get(overriddenClassName);
// We don't want to apply these:
delete data.override;
delete data.requires;
delete data.uses;
Ext.override(cls, data);
// This pushes the overridding file itself into Ext.Loader.history
// Hence if the target class never exists, the overriding file will
// never be included in the build.
me.triggerCreated(className);
if (uses) {
Ext.Loader.addUsedClasses(uses); // get these classes too!
}
if (createdFn) {
createdFn.call(cls); // last but not least!
}
}
};
me.existCache[className] = true;
// Override the target class right after it's created
me.onCreated(classReady, me, overriddenClassName);
return me;
},

instantiateByAlias: function() {
var alias = arguments[0],
args = arraySlice.call(arguments),
className = this.getNameByAlias(alias);
if (!className) {
className = this.maps.aliasToName[alias];
//<debug error>
if (!className) {
throw new Error("[Ext.createByAlias] Cannot create an instance of unrecognized alias: " + alias);
}
//</debug>
//<debug warn>
if (global.console) {
global.console.warn("[Ext.Loader] Synchronously loading '" + className + "'; consider adding " +
"Ext.require('" + alias + "') above Ext.onReady");
}
//</debug>
Ext.syncRequire(className);
}
args[0] = className;
return this.instantiate.apply(this, args);
},

instantiate: function() {
var name = arguments[0],
nameType = typeof name,
args = arraySlice.call(arguments, 1),
alias = name,
possibleName, cls;
if (nameType != 'function') {
if (nameType != 'string' && args.length === 0) {
args = [name];
name = name.xclass;
}
//<debug error>
if (typeof name != 'string' || name.length < 1) {
throw new Error("[Ext.create] Invalid class name or alias '" + name + "' specified, must be a non-empty string");
}
//</debug>
cls = this.get(name);
}
else {
cls = name;
}
// No record of this class name, it's possibly an alias, so look it up
if (!cls) {
possibleName = this.getNameByAlias(name);
if (possibleName) {
name = possibleName;
cls = this.get(name);
}
}
// Still no record of this class name, it's possibly an alternate name, so look it up
if (!cls) {
possibleName = this.getNameByAlternate(name);
if (possibleName) {
name = possibleName;
cls = this.get(name);
}
}
// Still not existing at this point, try to load it via synchronous mode as the last resort
if (!cls) {
//<debug warn>
if (global.console) {
global.console.warn("[Ext.Loader] Synchronously loading '" + name + "'; consider adding " +
"Ext.require('" + ((possibleName) ? alias : name) + "') above Ext.onReady");
}
//</debug>
Ext.syncRequire(name);
cls = this.get(name);
}
//<debug error>
if (!cls) {
throw new Error("[Ext.create] Cannot create an instance of unrecognized class name / alias: " + alias);
}
if (typeof cls != 'function') {
throw new Error("[Ext.create] '" + name + "' is a singleton and cannot be instantiated");
}
//</debug>
return this.getInstantiator(args.length)(cls, args);
},

dynInstantiate: function(name, args) {
args = arrayFrom(args, true);
args.unshift(name);
return this.instantiate.apply(this, args);
},

getInstantiator: function(length) {
var instantiators = this.instantiators,
instantiator,
i,
args;
instantiator = instantiators[length];
if (!instantiator) {
i = length;
args = [];
for (i = 0; i < length; i++) {
args.push('a[' + i + ']');
}
instantiator = instantiators[length] = new Function('c', 'a', 'return new c(' + args.join(',') + ')');
//<debug>
instantiator.displayName = "Ext.ClassManager.instantiate" + length;
//</debug>
}
return instantiator;
},

postprocessors: {},

defaultPostprocessors: [],

registerPostprocessor: function(name, fn, properties, position, relativeTo) {
if (!position) {
position = 'last';
}
if (!properties) {
properties = [name];
}
this.postprocessors[name] = {
name: name,
properties: properties || false,
fn: fn
};
this.setDefaultPostprocessorPosition(name, position, relativeTo);
return this;
},

setDefaultPostprocessors: function(postprocessors) {
this.defaultPostprocessors = arrayFrom(postprocessors);
return this;
},

setDefaultPostprocessorPosition: function(name, offset, relativeName) {
var defaultPostprocessors = this.defaultPostprocessors,
index;
if (typeof offset == 'string') {
if (offset === 'first') {
defaultPostprocessors.unshift(name);
return this;
}
else if (offset === 'last') {
defaultPostprocessors.push(name);
return this;
}
offset = (offset === 'after') ? 1 : -1;
}
index = Ext.Array.indexOf(defaultPostprocessors, relativeName);
if (index !== -1) {
Ext.Array.splice(defaultPostprocessors, Math.max(0, index + offset), 0, name);
}
return this;
},

getNamesByExpression: function(expression) {
var nameToAliasesMap = this.maps.nameToAliases,
names = [],
name, alias, aliases, possibleName, regex, i, ln;
//<debug error>
if (typeof expression != 'string' || expression.length < 1) {
throw new Error("[Ext.ClassManager.getNamesByExpression] Expression " + expression + " is invalid, must be a non-empty string");
}
//</debug>
if (expression.indexOf('*') !== -1) {
expression = expression.replace(/\*/g, '(.*?)');
regex = new RegExp('^' + expression + '$');
for (name in nameToAliasesMap) {
if (nameToAliasesMap.hasOwnProperty(name)) {
aliases = nameToAliasesMap[name];
if (name.search(regex) !== -1) {
names.push(name);
}
else {
for (i = 0, ln = aliases.length; i < ln; i++) {
alias = aliases[i];
if (alias.search(regex) !== -1) {
names.push(name);
break;
}
}
}
}
}
} else {
possibleName = this.getNameByAlias(expression);
if (possibleName) {
names.push(possibleName);
} else {
possibleName = this.getNameByAlternate(expression);
if (possibleName) {
names.push(possibleName);
} else {
names.push(expression);
}
}
}
return names;
}
};
//<feature classSystem.alias>

Manager.registerPostprocessor('alias', function(name, cls, data) {
//<debug>
Ext.classSystemMonitor && Ext.classSystemMonitor(name, 'Ext.ClassManager#aliasPostProcessor', arguments);
//</debug>

var aliases = data.alias,
i, ln;
for (i = 0,ln = aliases.length; i < ln; i++) {
alias = aliases[i];
this.setAlias(cls, alias);
}
}, ['xtype', 'alias']);
//</feature>
//<feature classSystem.singleton>

Manager.registerPostprocessor('singleton', function(name, cls, data, fn) {
//<debug>
Ext.classSystemMonitor && Ext.classSystemMonitor(name, 'Ext.ClassManager#singletonPostProcessor', arguments);
//</debug>

if (data.singleton) {
fn.call(this, name, new cls(), data);
}
else {
return true;
}
return false;
});
//</feature>
//<feature classSystem.alternateClassName>

Manager.registerPostprocessor('alternateClassName', function(name, cls, data) {
//<debug>
Ext.classSystemMonitor && Ext.classSystemMonitor(name, 'Ext.ClassManager#alternateClassNamePostprocessor', arguments);
//</debug>

var alternates = data.alternateClassName,
i, ln, alternate;
if (!(alternates instanceof Array)) {
alternates = [alternates];
}
for (i = 0, ln = alternates.length; i < ln; i++) {
alternate = alternates[i];
//<debug error>
if (typeof alternate != 'string') {
throw new Error("[Ext.define] Invalid alternate of: '" + alternate + "' for class: '" + name + "'; must be a valid string");
}
//</debug>
this.set(alternate, cls);
}
});
//</feature>
Ext.apply(Ext, {

create: alias(Manager, 'instantiate'),

widget: function(name, config) {
// forms:
// 1: (xtype)
// 2: (xtype, config)
// 3: (config)
// 4: (xtype, component)
// 5: (component)
// 
var xtype = name,
alias, className, T, load;
if (typeof xtype != 'string') { // if (form 3 or 5)
// first arg is config or component
config = name; // arguments[0]
xtype = config.xtype;
} else {
config = config || {};
}
if (config.isComponent) {
return config;
}
alias = 'widget.' + xtype;
className = Manager.getNameByAlias(alias);
// this is needed to support demand loading of the class
if (!className) {
load = true;
}
T = Manager.get(className);
if (load || !T) {
return Manager.instantiateByAlias(alias, config);
}
return new T(config);
},

createByAlias: alias(Manager, 'instantiateByAlias'),

define: function (className, data, createdFn) {
//<debug>
Ext.classSystemMonitor && Ext.classSystemMonitor(className, 'ClassManager#define', arguments);
//</debug>

if (data.override) {
return Manager.createOverride.apply(Manager, arguments);
}
return Manager.create.apply(Manager, arguments);
},

undefine: function(className) {
//<debug>
Ext.classSystemMonitor && Ext.classSystemMonitor(className, 'Ext.ClassManager#undefine', arguments);
//</debug>

var classes = Manager.classes,
maps = Manager.maps,
aliasToName = maps.aliasToName,
nameToAliases = maps.nameToAliases,
alternateToName = maps.alternateToName,
nameToAlternates = maps.nameToAlternates,
aliases = nameToAliases[className],
alternates = nameToAlternates[className],
parts, partCount, namespace, i;
delete Manager.namespaceParseCache[className];
delete nameToAliases[className];
delete nameToAlternates[className];
delete classes[className];
if (aliases) {
for (i = aliases.length; i--;) {
delete aliasToName[aliases[i]];
}
}
if (alternates) {
for (i = alternates.length; i--; ) {
delete alternateToName[alternates[i]];
}
}
parts = Manager.parseNamespace(className);
partCount = parts.length - 1;
namespace = parts[0];
for (i = 1; i < partCount; i++) {
namespace = namespace[parts[i]];
if (!namespace) {
return;
}
}
// Old IE blows up on attempt to delete window property
try {
delete namespace[parts[partCount]];
}
catch (e) {
namespace[parts[partCount]] = undefined;
}
},

getClassName: alias(Manager, 'getName'),

getDisplayName: function(object) {
if (object) {
if (object.displayName) {
return object.displayName;
}
if (object.$name && object.$class) {
return Ext.getClassName(object.$class) + '#' + object.$name;
}
if (object.$className) {
return object.$className;
}
}
return 'Anonymous';
},

getClass: alias(Manager, 'getClass'),

namespace: alias(Manager, 'createNamespaces')
});

Ext.createWidget = Ext.widget;

Ext.ns = Ext.namespace;
Class.registerPreprocessor('className', function(cls, data) {
if (data.$className) {
cls.$className = data.$className;
//<debug>
cls.displayName = cls.$className;
//</debug>
}

//<debug>
Ext.classSystemMonitor && Ext.classSystemMonitor(cls, 'Ext.ClassManager#classNamePreprocessor', arguments);
//</debug>
}, true, 'first');
Class.registerPreprocessor('alias', function(cls, data) {
//<debug>
Ext.classSystemMonitor && Ext.classSystemMonitor(cls, 'Ext.ClassManager#aliasPreprocessor', arguments);
//</debug>

var prototype = cls.prototype,
xtypes = arrayFrom(data.xtype),
aliases = arrayFrom(data.alias),
widgetPrefix = 'widget.',
widgetPrefixLength = widgetPrefix.length,
xtypesChain = Array.prototype.slice.call(prototype.xtypesChain || []),
xtypesMap = Ext.merge({}, prototype.xtypesMap || {}),
i, ln, alias, xtype;
for (i = 0,ln = aliases.length; i < ln; i++) {
alias = aliases[i];
//<debug error>
if (typeof alias != 'string' || alias.length < 1) {
throw new Error("[Ext.define] Invalid alias of: '" + alias + "' for class: '" + name + "'; must be a valid string");
}
//</debug>
if (alias.substring(0, widgetPrefixLength) === widgetPrefix) {
xtype = alias.substring(widgetPrefixLength);
Ext.Array.include(xtypes, xtype);
}
}
cls.xtype = data.xtype = xtypes[0];
data.xtypes = xtypes;
for (i = 0,ln = xtypes.length; i < ln; i++) {
xtype = xtypes[i];
if (!xtypesMap[xtype]) {
xtypesMap[xtype] = true;
xtypesChain.push(xtype);
}
}
data.xtypesChain = xtypesChain;
data.xtypesMap = xtypesMap;
Ext.Function.interceptAfter(data, 'onClassCreated', function() {
//<debug>
Ext.classSystemMonitor && Ext.classSystemMonitor(cls, 'Ext.ClassManager#aliasPreprocessor#afterClassCreated', arguments);
//</debug>

var mixins = prototype.mixins,
key, mixin;
for (key in mixins) {
if (mixins.hasOwnProperty(key)) {
mixin = mixins[key];
xtypes = mixin.xtypes;
if (xtypes) {
for (i = 0,ln = xtypes.length; i < ln; i++) {
xtype = xtypes[i];
if (!xtypesMap[xtype]) {
xtypesMap[xtype] = true;
xtypesChain.push(xtype);
}
}
}
}
}
});
for (i = 0,ln = xtypes.length; i < ln; i++) {
xtype = xtypes[i];
//<debug error>
if (typeof xtype != 'string' || xtype.length < 1) {
throw new Error("[Ext.define] Invalid xtype of: '" + xtype + "' for class: '" + name + "'; must be a valid non-empty string");
}
//</debug>
Ext.Array.include(aliases, widgetPrefix + xtype);
}
data.alias = aliases;
}, ['xtype', 'alias']);
}(Ext.Class, Ext.Function.alias, Array.prototype.slice, Ext.Array.from, Ext.global));
// simple mechanism for automated means of injecting large amounts of dependency info
// at the appropriate time in the load cycle
if (Ext._alternatesMetadata) {
Ext.ClassManager.addNameAlternateMappings(Ext._alternatesMetadata);
Ext._alternatesMetadata = null;
}
if (Ext._aliasMetadata) {
Ext.ClassManager.addNameAliasMappings(Ext._aliasMetadata);
Ext._aliasMetadata = null;
}
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/class/Loader.js */
(function(Ext) {
// @tag foundation,core
// @require ClassManager.js
// @define Ext.Loader
Ext.Loader = new function() {
var Loader = this,
Manager = Ext.ClassManager,
Class = Ext.Class,
flexSetter = Ext.Function.flexSetter,
alias = Ext.Function.alias,
pass = Ext.Function.pass,
defer = Ext.Function.defer,
arrayErase = Ext.Array.erase,
//<if nonBrowser>
isNonBrowser = typeof window == 'undefined',
isNodeJS = isNonBrowser && (typeof require == 'function'),
isJsdb = isNonBrowser && typeof system != 'undefined' && system.program.search(/jsdb/) !== -1,
isPhantomJS = (typeof phantom != 'undefined' && phantom.fs),
//</if>
dependencyProperties = ['extend', 'mixins', 'requires'],
isInHistory = {},
history = [],
slashDotSlashRe = /\/\.\//g,
dotRe = /\./g,
setPathCount = 0;
Ext.apply(Loader, {

isInHistory: isInHistory,

history: history,

config: {

enabled: false,

scriptChainDelay : false,

disableCaching: true,

disableCachingParam: '_dc',

garbageCollect : false,

paths: {
'Ext': '.'
},

preserveScripts : true,

scriptCharset : undefined
},

setConfig: function(name, value) {
if (Ext.isObject(name) && arguments.length === 1) {
Ext.merge(Loader.config, name);
if ('paths' in name) {
Ext.app.collectNamespaces(name.paths);
}
}
else {
Loader.config[name] = (Ext.isObject(value)) ? Ext.merge(Loader.config[name], value) : value;
if (name === 'paths') {
Ext.app.collectNamespaces(value);
}
}
return Loader;
},

getConfig: function(name) {
if (name) {
return Loader.config[name];
}
return Loader.config;
},

setPath: flexSetter(function(name, path) {
Loader.config.paths[name] = path;
Ext.app.namespaces[name] = true;
setPathCount++;
return Loader;
}),

addClassPathMappings: function(paths) {
var name;
if(setPathCount == 0){
Loader.config.paths = paths;
} else {
for(name in paths){
Loader.config.paths[name] = paths[name];
}
}
setPathCount++;
return Loader;
},

getPath: function(className) {
var path = '',
paths = Loader.config.paths,
prefix = Loader.getPrefix(className);
if (prefix.length > 0) {
if (prefix === className) {
return paths[prefix];
}
path = paths[prefix];
className = className.substring(prefix.length + 1);
}
if (path.length > 0) {
path += '/';
}
return path.replace(slashDotSlashRe, '/') + className.replace(dotRe, "/") + '.js';
},

getPrefix: function(className) {
var paths = Loader.config.paths,
prefix, deepestPrefix = '';
if (paths.hasOwnProperty(className)) {
return className;
}
for (prefix in paths) {
if (paths.hasOwnProperty(prefix) && prefix + '.' === className.substring(0, prefix.length + 1)) {
if (prefix.length > deepestPrefix.length) {
deepestPrefix = prefix;
}
}
}
return deepestPrefix;
},

isAClassNameWithAKnownPrefix: function(className) {
var prefix = Loader.getPrefix(className);
// we can only say it's really a class if className is not equal to any known namespace
return prefix !== '' && prefix !== className;
},

require: function(expressions, fn, scope, excludes) {
if (fn) {
fn.call(scope);
}
},

syncRequire: function() {},

exclude: function(excludes) {
return {
require: function(expressions, fn, scope) {
return Loader.require(expressions, fn, scope, excludes);
},
syncRequire: function(expressions, fn, scope) {
return Loader.syncRequire(expressions, fn, scope, excludes);
}
};
},

onReady: function(fn, scope, withDomReady, options) {
var oldFn;
if (withDomReady !== false && Ext.onDocumentReady) {
oldFn = fn;
fn = function() {
Ext.onDocumentReady(oldFn, scope, options);
};
}
fn.call(scope);
}
});
//<feature classSystem.loader>
var queue = [],
isClassFileLoaded = {},
isFileLoaded = {},
classNameToFilePathMap = {},
scriptElements = {},
readyListeners = [],
usedClasses = [],
requiresMap = {},
comparePriority = function(listenerA, listenerB) {
return listenerB.priority - listenerA.priority;
};
Ext.apply(Loader, {

documentHead: typeof document != 'undefined' && (document.head || document.getElementsByTagName('head')[0]),

isLoading: false,

queue: queue,

isClassFileLoaded: isClassFileLoaded,

isFileLoaded: isFileLoaded,

readyListeners: readyListeners,

optionalRequires: usedClasses,

requiresMap: requiresMap,

numPendingFiles: 0,

numLoadedFiles: 0,

hasFileLoadError: false,

classNameToFilePathMap: classNameToFilePathMap,

scriptsLoading: 0,

syncModeEnabled: false,
scriptElements: scriptElements,

refreshQueue: function() {
var ln = queue.length,
i, item, j, requires;
// When the queue of loading classes reaches zero, trigger readiness
if (!ln && !Loader.scriptsLoading) {
return Loader.triggerReady();
}
for (i = 0; i < ln; i++) {
item = queue[i];
if (item) {
requires = item.requires;
// Don't bother checking when the number of files loaded
// is still less than the array length
if (requires.length > Loader.numLoadedFiles) {
continue;
}
// Remove any required classes that are loaded
for (j = 0; j < requires.length; ) {
if (Manager.isCreated(requires[j])) {
// Take out from the queue
arrayErase(requires, j, 1);
}
else {
j++;
}
}
// If we've ended up with no required classes, call the callback
if (item.requires.length === 0) {
arrayErase(queue, i, 1);
item.callback.call(item.scope);
Loader.refreshQueue();
break;
}
}
}
return Loader;
},

injectScriptElement: function(url, onLoad, onError, scope, charset) {
var script = document.createElement('script'),
dispatched = false,
config = Loader.config,
onLoadFn = function() {
if(!dispatched) {
dispatched = true;
script.onload = script.onreadystatechange = script.onerror = null;
if (typeof config.scriptChainDelay == 'number') {
//free the stack (and defer the next script)
defer(onLoad, config.scriptChainDelay, scope);
} else {
onLoad.call(scope);
}
Loader.cleanupScriptElement(script, config.preserveScripts === false, config.garbageCollect);
}
},
onErrorFn = function(arg) {
defer(onError, 1, scope); //free the stack
Loader.cleanupScriptElement(script, config.preserveScripts === false, config.garbageCollect);
};
script.type = 'text/javascript';
script.onerror = onErrorFn;
charset = charset || config.scriptCharset;
if (charset) {
script.charset = charset;
}

if ('addEventListener' in script ) {
script.onload = onLoadFn;
} else if ('readyState' in script) { // for <IE9 Compatability
script.onreadystatechange = function() {
if ( this.readyState == 'loaded' || this.readyState == 'complete' ) {
onLoadFn();
}
};
} else {
script.onload = onLoadFn;
}
script.src = url;
(Loader.documentHead || document.getElementsByTagName('head')[0]).appendChild(script);
return script;
},

removeScriptElement: function(url) {
if (scriptElements[url]) {
Loader.cleanupScriptElement(scriptElements[url], true, !!Loader.getConfig('garbageCollect'));
delete scriptElements[url];
}
return Loader;
},

cleanupScriptElement: function(script, remove, collect) {
var prop;
script.onload = script.onreadystatechange = script.onerror = null;
if (remove) {
Ext.removeNode(script); // Remove, since its useless now
if (collect) {
for (prop in script) {
try {
if (prop != 'src') {
// If we set the src property to null IE
// will try and request a script at './null'
script[prop] = null;
}
delete script[prop]; // and prepare for GC
} catch (cleanEx) {
//ignore
}
}
}
}
return Loader;
},

loadScript: function (options) {
var config = Loader.getConfig(),
isString = typeof options == 'string',
url = isString ? options : options.url,
onError = !isString && options.onError,
onLoad = !isString && options.onLoad,
scope = !isString && options.scope,
onScriptError = function() {
Loader.numPendingFiles--;
Loader.scriptsLoading--;
if (onError) {
onError.call(scope, "Failed loading '" + url + "', please verify that the file exists");
}
if (Loader.numPendingFiles + Loader.scriptsLoading === 0) {
Loader.refreshQueue();
}
},
onScriptLoad = function () {
Loader.numPendingFiles--;
Loader.scriptsLoading--;
if (onLoad) {
onLoad.call(scope);
}
if (Loader.numPendingFiles + Loader.scriptsLoading === 0) {
Loader.refreshQueue();
}
},
src;
Loader.isLoading = true;
Loader.numPendingFiles++;
Loader.scriptsLoading++;
src = config.disableCaching ?
(url + '?' + config.disableCachingParam + '=' + Ext.Date.now()) : url;
scriptElements[url] = Loader.injectScriptElement(src, onScriptLoad, onScriptError);
},

loadScriptFile: function(url, onLoad, onError, scope, synchronous) {
if (isFileLoaded[url]) {
return Loader;
}
var config = Loader.getConfig(),
noCacheUrl = url + (config.disableCaching ? ('?' + config.disableCachingParam + '=' + Ext.Date.now()) : ''),
isCrossOriginRestricted = false,
xhr, status, onScriptError,
debugSourceURL = "";
scope = scope || Loader;
Loader.isLoading = true;
if (!synchronous) {
onScriptError = function() {
//<debug error>
onError.call(scope, "Failed loading '" + url + "', please verify that the file exists", synchronous);
//</debug>
};
scriptElements[url] = Loader.injectScriptElement(noCacheUrl, onLoad, onScriptError, scope);
} else {
if (typeof XMLHttpRequest != 'undefined') {
xhr = new XMLHttpRequest();
} else {
xhr = new ActiveXObject('Microsoft.XMLHTTP');
}
try {
xhr.open('GET', noCacheUrl, false);
xhr.send(null);
} catch (e) {
isCrossOriginRestricted = true;
}
status = (xhr.status === 1223) ? 204 :
(xhr.status === 0 && ((self.location || {}).protocol == 'file:' || (self.location || {}).protocol == 'ionp:')) ? 200 : xhr.status;
isCrossOriginRestricted = isCrossOriginRestricted || (status === 0);
if (isCrossOriginRestricted
//<if isNonBrowser>
&& !isPhantomJS
//</if>
) {
//<debug error>
onError.call(Loader, "Failed loading synchronously via XHR: '" + url + "'; It's likely that the file is either " +
"being loaded from a different domain or from the local file system whereby cross origin " +
"requests are not allowed due to security reasons. Use asynchronous loading with " +
"Ext.require instead.", synchronous);
//</debug>
}
else if ((status >= 200 && status < 300) || (status === 304)
//<if isNonBrowser>
|| isPhantomJS
//</if>
) {
// Debugger friendly, file names are still shown even though they're eval'ed code
// Breakpoints work on both Firebug and Chrome's Web Inspector
if (!Ext.isIE) {
debugSourceURL = "\n//@ sourceURL=" + url;
}
Ext.globalEval(xhr.responseText + debugSourceURL);
onLoad.call(scope);
}
else {
//<debug>
onError.call(Loader, "Failed loading synchronously via XHR: '" + url + "'; please " +
"verify that the file exists. " +
"XHR status code: " + status, synchronous);
//</debug>
}
// Prevent potential IE memory leak
xhr = null;
}
},
// documented above
syncRequire: function() {
var syncModeEnabled = Loader.syncModeEnabled;
if (!syncModeEnabled) {
Loader.syncModeEnabled = true;
}
Loader.require.apply(Loader, arguments);
if (!syncModeEnabled) {
Loader.syncModeEnabled = false;
}
Loader.refreshQueue();
},
// documented above
require: function(expressions, fn, scope, excludes) {
var excluded = {},
included = {},
excludedClassNames = [],
possibleClassNames = [],
classNames = [],
references = [],
callback,
syncModeEnabled,
filePath, expression, exclude, className,
possibleClassName, i, j, ln, subLn;
if (excludes) {
// Convert possible single string to an array.
excludes = (typeof excludes === 'string') ? [ excludes ] : excludes;
for (i = 0,ln = excludes.length; i < ln; i++) {
exclude = excludes[i];
if (typeof exclude == 'string' && exclude.length > 0) {
excludedClassNames = Manager.getNamesByExpression(exclude);
for (j = 0,subLn = excludedClassNames.length; j < subLn; j++) {
excluded[excludedClassNames[j]] = true;
}
}
}
}
// Convert possible single string to an array.
expressions = (typeof expressions === 'string') ? [ expressions ] : (expressions ? expressions : []);
if (fn) {
if (fn.length > 0) {
callback = function() {
var classes = [],
i, ln;
for (i = 0,ln = references.length; i < ln; i++) {
classes.push(Manager.get(references[i]));
}
return fn.apply(this, classes);
};
}
else {
callback = fn;
}
}
else {
callback = Ext.emptyFn;
}
scope = scope || Ext.global;
for (i = 0,ln = expressions.length; i < ln; i++) {
expression = expressions[i];
if (typeof expression == 'string' && expression.length > 0) {
possibleClassNames = Manager.getNamesByExpression(expression);
subLn = possibleClassNames.length;
for (j = 0; j < subLn; j++) {
possibleClassName = possibleClassNames[j];
if (excluded[possibleClassName] !== true) {
references.push(possibleClassName);
if (!Manager.isCreated(possibleClassName) && !included[possibleClassName]) {
included[possibleClassName] = true;
classNames.push(possibleClassName);
}
}
}
}
}
// If the dynamic dependency feature is not being used, throw an error
// if the dependencies are not defined
if (classNames.length > 0) {
if (!Loader.config.enabled) {
throw new Error("Ext.Loader is not enabled, so dependencies cannot be resolved dynamically. " +
"Missing required class" + ((classNames.length > 1) ? "es" : "") + ": " + classNames.join(', '));
}
}
else {
callback.call(scope);
return Loader;
}
syncModeEnabled = Loader.syncModeEnabled;
if (!syncModeEnabled) {
queue.push({
requires: classNames.slice(), // this array will be modified as the queue is processed,
// so we need a copy of it
callback: callback,
scope: scope
});
}
ln = classNames.length;
for (i = 0; i < ln; i++) {
className = classNames[i];
filePath = Loader.getPath(className);
// If we are synchronously loading a file that has already been asychronously loaded before
// we need to destroy the script tag and revert the count
// This file will then be forced loaded in synchronous
if (syncModeEnabled && isClassFileLoaded.hasOwnProperty(className)) {
if (!isClassFileLoaded[className]) {
Loader.numPendingFiles--;
Loader.removeScriptElement(filePath);
delete isClassFileLoaded[className];
}
}
if (!isClassFileLoaded.hasOwnProperty(className)) {
isClassFileLoaded[className] = false;
classNameToFilePathMap[className] = filePath;
Loader.numPendingFiles++;
Loader.loadScriptFile(
filePath,
pass(Loader.onFileLoaded, [className, filePath], Loader),
pass(Loader.onFileLoadError, [className, filePath], Loader),
Loader,
syncModeEnabled
);
}
}
if (syncModeEnabled) {
callback.call(scope);
if (ln === 1) {
return Manager.get(className);
}
}
return Loader;
},

onFileLoaded: function(className, filePath) {
var loaded = isClassFileLoaded[className];
Loader.numLoadedFiles++;
isClassFileLoaded[className] = true;
isFileLoaded[filePath] = true;
// In FF, when we sync load something that has had a script tag inserted, the load event may
// sometimes fire even if we clean it up and set it to null, so check if we're already loaded here.
if (!loaded) {
Loader.numPendingFiles--;
}
if (Loader.numPendingFiles === 0) {
Loader.refreshQueue();
}
//<debug>
if (!Loader.syncModeEnabled && Loader.numPendingFiles === 0 && Loader.isLoading && !Loader.hasFileLoadError) {
var missingClasses = [],
missingPaths = [],
requires,
i, ln, j, subLn;
for (i = 0,ln = queue.length; i < ln; i++) {
requires = queue[i].requires;
for (j = 0,subLn = requires.length; j < subLn; j++) {
if (isClassFileLoaded[requires[j]]) {
missingClasses.push(requires[j]);
}
}
}
if (missingClasses.length < 1) {
return;
}
missingClasses = Ext.Array.filter(Ext.Array.unique(missingClasses), function(item) {
return !requiresMap.hasOwnProperty(item);
}, Loader);

if (missingClasses.length < 1) {
return;
}
for (i = 0,ln = missingClasses.length; i < ln; i++) {
missingPaths.push(classNameToFilePathMap[missingClasses[i]]);
}
throw new Error("The following classes are not declared even if their files have been " +
"loaded: '" + missingClasses.join("', '") + "'. Please check the source code of their " +
"corresponding files for possible typos: '" + missingPaths.join("', '"));
}
//</debug>
},

onFileLoadError: function(className, filePath, errorMessage, isSynchronous) {
Loader.numPendingFiles--;
Loader.hasFileLoadError = true;
//<debug error>
throw new Error("[Ext.Loader] " + errorMessage);
//</debug>
},

addUsedClasses: function (classes) {
var cls, i, ln;
if (classes) {
classes = (typeof classes == 'string') ? [classes] : classes;
for (i = 0, ln = classes.length; i < ln; i++) {
cls = classes[i];
if (typeof cls == 'string' && !Ext.Array.contains(usedClasses, cls)) {
usedClasses.push(cls);
}
}
}
return Loader;
},

triggerReady: function() {
var listener,
refClasses = usedClasses;
if (Loader.isLoading) {
Loader.isLoading = false;
if (refClasses.length !== 0) {
// Clone then empty the array to eliminate potential recursive loop issue
refClasses = refClasses.slice();
usedClasses.length = 0;
// this may immediately call us back if all 'uses' classes
// have been loaded
Loader.require(refClasses, Loader.triggerReady, Loader);
return Loader;
}
}
Ext.Array.sort(readyListeners, comparePriority);
// this method can be called with Loader.isLoading either true or false
// (can be called with false when all 'uses' classes are already loaded)
// this may bypass the above if condition
while (readyListeners.length && !Loader.isLoading) {
// calls to refreshQueue may re-enter triggerReady
// so we cannot necessarily iterate the readyListeners array
listener = readyListeners.shift();
listener.fn.call(listener.scope);
}
return Loader;
},
// Documented above already
onReady: function(fn, scope, withDomReady, options) {
var oldFn;
if (withDomReady !== false && Ext.onDocumentReady) {
oldFn = fn;
fn = function() {
Ext.onDocumentReady(oldFn, scope, options);
};
}
if (!Loader.isLoading) {
fn.call(scope);
}
else {
readyListeners.push({
fn: fn,
scope: scope,
priority: (options && options.priority) || 0
});
}
},

historyPush: function(className) {
if (className && isClassFileLoaded.hasOwnProperty(className) && !isInHistory[className]) {
isInHistory[className] = true;
history.push(className);
}
return Loader;
}
});

Ext.disableCacheBuster = function (disable, path) {
var date = new Date();
date.setTime(date.getTime() + (disable ? 10*365 : -1) * 24*60*60*1000);
date = date.toGMTString();
document.cookie = 'ext-cache=1; expires=' + date + '; path='+(path || '/');
};
//<if nonBrowser>
if (isNonBrowser) {
if (isNodeJS) {
Ext.apply(Loader, {
syncModeEnabled: true,
setPath: flexSetter(function(name, path) {
path = require('fs').realpathSync(path);
Loader.config.paths[name] = path;
return Loader;
}),
loadScriptFile: function(filePath, onLoad, onError, scope, synchronous) {
require(filePath);
onLoad.call(scope);
}
});
}
else if (isJsdb) {
Ext.apply(Loader, {
syncModeEnabled: true,
loadScriptFile: function(filePath, onLoad, onError, scope, synchronous) {
load(filePath);
onLoad.call(scope);
}
});
}
}
//</if>
//</feature>

Ext.require = alias(Loader, 'require');

Ext.syncRequire = alias(Loader, 'syncRequire');

Ext.exclude = alias(Loader, 'exclude');

Ext.onReady = function(fn, scope, options) {
Loader.onReady(fn, scope, true, options);
};

Class.registerPreprocessor('loader', function(cls, data, hooks, continueFn) {
//<debug>
Ext.classSystemMonitor && Ext.classSystemMonitor(cls, 'Ext.Loader#loaderPreprocessor', arguments);
//</debug>

var me = this,
dependencies = [],
dependency,
className = Manager.getName(cls),
i, j, ln, subLn, value, propertyName, propertyValue,
requiredMap, requiredDep;

for (i = 0,ln = dependencyProperties.length; i < ln; i++) {
propertyName = dependencyProperties[i];
if (data.hasOwnProperty(propertyName)) {
propertyValue = data[propertyName];
if (typeof propertyValue == 'string') {
dependencies.push(propertyValue);
}
else if (propertyValue instanceof Array) {
for (j = 0, subLn = propertyValue.length; j < subLn; j++) {
value = propertyValue[j];
if (typeof value == 'string') {
dependencies.push(value);
}
}
}
else if (typeof propertyValue != 'function') {
for (j in propertyValue) {
if (propertyValue.hasOwnProperty(j)) {
value = propertyValue[j];
if (typeof value == 'string') {
dependencies.push(value);
}
}
}
}
}
}
if (dependencies.length === 0) {
return;
}
//<feature classSystem.loader>
//<debug error>
var deadlockPath = [],
detectDeadlock;

if (className) {
requiresMap[className] = dependencies;
//<debug>
requiredMap = Loader.requiredByMap || (Loader.requiredByMap = {});
for (i = 0,ln = dependencies.length; i < ln; i++) {
dependency = dependencies[i];
(requiredMap[dependency] || (requiredMap[dependency] = [])).push(className);
}
//</debug>
detectDeadlock = function(cls) {
deadlockPath.push(cls);
if (requiresMap[cls]) {
if (Ext.Array.contains(requiresMap[cls], className)) {
throw new Error("Deadlock detected while loading dependencies! '" + className + "' and '" +
deadlockPath[1] + "' " + "mutually require each other. Path: " +
deadlockPath.join(' -> ') + " -> " + deadlockPath[0]);
}
for (i = 0,ln = requiresMap[cls].length; i < ln; i++) {
detectDeadlock(requiresMap[cls][i]);
}
}
};
detectDeadlock(className);
}
//</debug>
//</feature>
Loader.require(dependencies, function() {
for (i = 0,ln = dependencyProperties.length; i < ln; i++) {
propertyName = dependencyProperties[i];
if (data.hasOwnProperty(propertyName)) {
propertyValue = data[propertyName];
if (typeof propertyValue == 'string') {
data[propertyName] = Manager.get(propertyValue);
}
else if (propertyValue instanceof Array) {
for (j = 0, subLn = propertyValue.length; j < subLn; j++) {
value = propertyValue[j];
if (typeof value == 'string') {
data[propertyName][j] = Manager.get(value);
}
}
}
else if (typeof propertyValue != 'function') {
for (var k in propertyValue) {
if (propertyValue.hasOwnProperty(k)) {
value = propertyValue[k];
if (typeof value == 'string') {
data[propertyName][k] = Manager.get(value);
}
}
}
}
}
}
continueFn.call(me, cls, data, hooks);
});
return false;
}, true, 'after', 'className');
//<feature classSystem.loader>

Manager.registerPostprocessor('uses', function(name, cls, data) {
//<debug>
Ext.classSystemMonitor && Ext.classSystemMonitor(cls, 'Ext.Loader#usesPostprocessor', arguments);
//</debug>

var uses = data.uses;
if (uses) {
Loader.addUsedClasses(uses);
}
});
Manager.onCreated(Loader.historyPush);
//</feature>
};
// simple mechanism for automated means of injecting large amounts of dependency info
// at the appropriate time in the load cycle
if (Ext._classPathMetadata) {
Ext.Loader.addClassPathMappings(Ext._classPathMetadata);
Ext._classPathMetadata = null;
}
// initalize the default path of the framework
(function() {
var scripts = document.getElementsByTagName('script'),
currentScript = scripts[scripts.length - 1],
src = currentScript.src,
path = src.substring(0, src.lastIndexOf('/') + 1),
Loader = Ext.Loader;
//<debug>
if(src.indexOf("/platform/core/src/class/") != -1) {
path = path + "../../../../extjs/";
} else if(src.indexOf("/core/src/class/") != -1) {
path = path + "../../../";
}
//</debug>
Loader.setConfig({
enabled: true,
disableCaching:
//<debug>
(/[?&](?:cache|disableCacheBuster)\b/i.test(location.search) ||
/(^|[ ;])ext-cache=1/.test(document.cookie)) ? false : 
//</debug>
true,
paths: {
'Ext': path + 'src'
}
});
})();
// allows a tools like dynatrace to deterministically detect onReady state by invoking
// a callback (intended for external consumption)
Ext._endTime = new Date().getTime();
if (Ext._beforereadyhandler){
Ext._beforereadyhandler();
}
Ext.Loader.setConfig({
enabled: true,
disableCaching: false,
paths: {
'Ext': '/assets/ext4/src'
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/lang/Error.js */
(function(Ext) {
// @tag foundation,core
// @require ../class/Loader.js
// @define Ext.Error
Ext.Error = Ext.extend(Error, {
statics: {

ignore: false,

//notify: Ext.isIE6 || Ext.isIE7,

raise: function(err){
err = err || {};
if (Ext.isString(err)) {
err = { msg: err };
}
var method = this.raise.caller,
msg;
if (method) {
if (method.$name) {
err.sourceMethod = method.$name;
}
if (method.$owner) {
err.sourceClass = method.$owner.$className;
}
}
if (Ext.Error.handle(err) !== true) {
msg = Ext.Error.prototype.toString.call(err);
Ext.log({
msg: msg,
level: 'error',
dump: err,
stack: true
});
throw new Ext.Error(err);
}
},

handle: function(){
return Ext.Error.ignore;
}
},
// This is the standard property that is the name of the constructor.
name: 'Ext.Error',

constructor: function(config){
if (Ext.isString(config)) {
config = { msg: config };
}
var me = this;
Ext.apply(me, config);
me.message = me.message || me.msg; // 'message' is standard ('msg' is non-standard)
// note: the above does not work in old WebKit (me.message is readonly) (Safari 4)
},

toString: function(){
var me = this,
className = me.sourceClass ? me.sourceClass : '',
methodName = me.sourceMethod ? '.' + me.sourceMethod + '(): ' : '',
msg = me.msg || '(No description provided)';
return className + methodName + msg;
}
});
Ext.deprecated = function (suggestion) {
//<debug>
if (!suggestion) {
suggestion = '';
}
function fail () {
Ext.Error.raise('The method "' + fail.$owner.$className + '.' + fail.$name + 
'" has been removed. ' + suggestion);
}
return fail;
//</debug>
return Ext.emptyFn;
};
//<debug>
(function () {
var timer, errors = 0,
win = Ext.global,
msg;
if (typeof window === 'undefined') {
return; // build system or some such environment...
}
// This method is called to notify the user of the current error status.
function notify () {
var counters = Ext.log.counters,
supports = Ext.supports,
hasOnError = supports && supports.WindowOnError; // TODO - timing
// Put log counters to the status bar (for most browsers):
if (counters && (counters.error + counters.warn + counters.info + counters.log)) {
msg = [ 'Logged Errors:',counters.error, 'Warnings:',counters.warn,
'Info:',counters.info, 'Log:',counters.log].join(' ');
if (errors) {
msg = '*** Errors: ' + errors + ' - ' + msg;
} else if (counters.error) {
msg = '*** ' + msg;
}
win.status = msg;
}
// Display an alert on the first error:
if (!Ext.isDefined(Ext.Error.notify)) {
Ext.Error.notify = Ext.isIE6 || Ext.isIE7; // TODO - timing
}
if (Ext.Error.notify && (hasOnError ? errors : (counters && counters.error))) {
Ext.Error.notify = false;
if (timer) {
win.clearInterval(timer); // ticks can queue up so stop...
timer = null;
}
alert('Unhandled error on page: See console or log');
poll();
}
}
// Sets up polling loop. This is the only way to know about errors in some browsers
// (Opera/Safari) and is the only way to update the status bar for warnings and other
// non-errors.
function poll () {
timer = win.setInterval(notify, 1000);
}
// window.onerror sounds ideal but it prevents the built-in error dialog from doing
// its (better) thing.
poll();
}());
//</debug>
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/misc/JSON.js */
(function(Ext) {
// @tag extras,core
// @require ../lang/Error.js
// @define Ext.JSON
Ext.JSON = (new(function() {
var me = this,
encodingFunction,
decodingFunction,
useNative = null,
useHasOwn = !! {}.hasOwnProperty,
isNative = function() {
if (useNative === null) {
useNative = Ext.USE_NATIVE_JSON && window.JSON && JSON.toString() == '[object JSON]';
}
return useNative;
},
pad = function(n) {
return n < 10 ? "0" + n : n;
},
doDecode = function(json) {
return eval("(" + json + ')');
},
doEncode = function(o, newline) {
// http://jsperf.com/is-undefined
if (o === null || o === undefined) {
return "null";
} else if (Ext.isDate(o)) {
return Ext.JSON.encodeDate(o);
} else if (Ext.isString(o)) {
return Ext.JSON.encodeString(o);
} else if (typeof o == "number") {
//don't use isNumber here, since finite checks happen inside isNumber
return isFinite(o) ? String(o) : "null";
} else if (Ext.isBoolean(o)) {
return String(o);
}
// Allow custom zerialization by adding a toJSON method to any object type.
// Date/String have a toJSON in some environments, so check these first.
else if (o.toJSON) {
return o.toJSON();
} else if (Ext.isArray(o)) {
return encodeArray(o, newline);
} else if (Ext.isObject(o)) {
return encodeObject(o, newline);
} else if (typeof o === "function") {
return "null";
}
return 'undefined';
},
m = {
"\b": '\\b',
"\t": '\\t',
"\n": '\\n',
"\f": '\\f',
"\r": '\\r',
'"': '\\"',
"\\": '\\\\',
'\x0b': '\\u000b' //ie doesn't handle \v
},
charToReplace = /[\\\"\x00-\x1f\x7f-\uffff]/g,
encodeString = function(s) {
return '"' + s.replace(charToReplace, function(a) {
var c = m[a];
return typeof c === 'string' ? c : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
}) + '"';
},
//<debug>
encodeArrayPretty = function(o, newline) {
var len = o.length,
cnewline = newline + ' ',
sep = ',' + cnewline,
a = ["[", cnewline], // Note newline in case there are no members
i;
for (i = 0; i < len; i += 1) {
a.push(Ext.JSON.encodeValue(o[i], cnewline), sep);
}
// Overwrite trailing comma (or empty string)
a[a.length - 1] = newline + ']';
return a.join('');
},
encodeObjectPretty = function(o, newline) {
var cnewline = newline + ' ',
sep = ',' + cnewline,
a = ["{", cnewline], // Note newline in case there are no members
i, val;
for (i in o) {
val = o[i];
if (!useHasOwn || o.hasOwnProperty(i)) {
// To match JSON.stringify, we shouldn't encode functions or undefined
if (typeof val === 'function' || val === undefined) {
continue;
}
a.push(Ext.JSON.encodeValue(i) + ': ' + Ext.JSON.encodeValue(val, cnewline), sep);
}
}
// Overwrite trailing comma (or empty string)
a[a.length - 1] = newline + '}';
return a.join('');
},
//</debug>
encodeArray = function(o, newline) {
//<debug>
if (newline) {
return encodeArrayPretty(o, newline);
}
//</debug>
var a = ["[", ""], // Note empty string in case there are no serializable members.
len = o.length,
i;
for (i = 0; i < len; i += 1) {
a.push(Ext.JSON.encodeValue(o[i]), ',');
}
// Overwrite trailing comma (or empty string)
a[a.length - 1] = ']';
return a.join("");
},
encodeObject = function(o, newline) {
//<debug>
if (newline) {
return encodeObjectPretty(o, newline);
}
//</debug>
var a = ["{", ""], // Note empty string in case there are no serializable members.
i, val;
for (i in o) {
val = o[i];
if (!useHasOwn || o.hasOwnProperty(i)) {
// To match JSON.stringify, we shouldn't encode functions or undefined
if (typeof val === 'function' || val === undefined) {
continue;
}
a.push(Ext.JSON.encodeValue(i), ":", Ext.JSON.encodeValue(val), ',');

}
}
// Overwrite trailing comma (or empty string)
a[a.length - 1] = '}';
return a.join("");
};


me.encodeString = encodeString;

me.encodeValue = doEncode;

me.encodeDate = function(o) {
return '"' + o.getFullYear() + "-"
+ pad(o.getMonth() + 1) + "-"
+ pad(o.getDate()) + "T"
+ pad(o.getHours()) + ":"
+ pad(o.getMinutes()) + ":"
+ pad(o.getSeconds()) + '"';
};

me.encode = function(o) {
if (!encodingFunction) {
// setup encoding function on first access
encodingFunction = isNative() ? JSON.stringify : me.encodeValue;
}
return encodingFunction(o);
};

me.decode = function(json, safe) {
if (!decodingFunction) {
// setup decoding function on first access
decodingFunction = isNative() ? JSON.parse : doDecode;
}
try {
return decodingFunction(json);
} catch (e) {
if (safe === true) {
return null;
}
Ext.Error.raise({
sourceClass: "Ext.JSON",
sourceMethod: "decode",
msg: "You're trying to decode an invalid JSON String: " + json
});
}
};
})());
Ext.encode = Ext.JSON.encode;
Ext.decode = Ext.JSON.decode;
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/Ext-more.js */
(function(Ext) {
// @tag extras,core
// @require misc/JSON.js
// @define Ext
Ext.apply(Ext, {
userAgent: navigator.userAgent.toLowerCase(),
cache: {},
idSeed: 1000,
windowId: 'ext-window',
documentId: 'ext-document',

isReady: false,

enableGarbageCollector: true,

enableListenerCollection: true,

rootHierarchyState: {},
addCacheEntry: function(id, el, dom) {
dom = dom || el.dom;
//<debug>
if (!dom) {
// Without the DOM node we can't GC the entry
Ext.Error.raise('Cannot add an entry to the element cache without the DOM node');
}
//</debug>
var cache = Ext.cache,
key = id || (el && el.id) || dom.id,
entry = cache[key] || (cache[key] = {
data: {},
events: {},
dom: dom,
// Skip garbage collection for special elements (window, document, iframes)
skipGarbageCollection: !!(dom.getElementById || dom.navigator)
});
if (el) {
el.$cache = entry;
// Inject the back link from the cache in case the cache entry
// had already been created by Ext.fly. Ext.fly creates a cache entry with no el link.
entry.el = el;
}
return entry;
},
updateCacheEntry: function(cacheItem, dom){
cacheItem.dom = dom;
if (cacheItem.el) {
cacheItem.el.dom = dom;
}
return cacheItem;
},

id: function(el, prefix) {
var me = this,
sandboxPrefix = '';
el = Ext.getDom(el, true) || {};
if (el === document) {
el.id = me.documentId;
}
else if (el === window) {
el.id = me.windowId;
}
if (!el.id) {
if (me.isSandboxed) {
sandboxPrefix = Ext.sandboxName.toLowerCase() + '-';
}
el.id = sandboxPrefix + (prefix || "ext-gen") + (++Ext.idSeed);
}
return el.id;
},
escapeId: (function(){
var validIdRe = /^[a-zA-Z_][a-zA-Z0-9_\-]*$/i,
escapeRx = /([\W]{1})/g,
leadingNumRx = /^(\d)/g,
escapeFn = function(match, capture){
return "\\" + capture;
},
numEscapeFn = function(match, capture){
return '\\00' + capture.charCodeAt(0).toString(16) + ' ';
};
return function(id) {
return validIdRe.test(id)
? id
// replace the number portion last to keep the trailing ' '
// from being escaped
: id.replace(escapeRx, escapeFn)
.replace(leadingNumRx, numEscapeFn);
};
}()),

getBody: (function() {
var body;
return function() {
return body || (body = Ext.get(document.body));
};
}()),

getHead: (function() {
var head;
return function() {
return head || (head = Ext.get(document.getElementsByTagName("head")[0]));
};
}()),

getDoc: (function() {
var doc;
return function() {
return doc || (doc = Ext.get(document));
};
}()),

getOrientation: function() {
return window.innerHeight > window.innerWidth ? 'portrait' : 'landscape';
},

destroy: function() {
var ln = arguments.length,
i, arg;
for (i = 0; i < ln; i++) {
arg = arguments[i];
if (arg) {
if (Ext.isArray(arg)) {
this.destroy.apply(this, arg);
} else if (arg.isStore) {
arg.destroyStore();
} else if (Ext.isFunction(arg.destroy)) {
arg.destroy();
} else if (arg.dom) {
arg.remove();
}
}
}
},

callback: function (callback, scope, args, delay) {
var fn, ret;
if (Ext.isFunction(callback)){
fn = callback;
} else if (scope && Ext.isString(callback)) {
fn = scope[callback];
//<debug>
if (!fn) {
Ext.Error.raise('No method named "' + callback + '"');
}
//</debug>
}
if (fn) {
args = args || [];
scope = scope || window;
if (delay) {
Ext.defer(fn, delay, scope, args);
} else {
ret = fn.apply(scope, args);
}
}
return ret;
},


resolveMethod: function(fn, scope) {
if (Ext.isFunction(fn)) {
return fn;
}

//<debug>
if (!Ext.isObject(scope) || !Ext.isFunction(scope[fn])) {
Ext.Error.raise('No method named "' + fn + '"');
}
//</debug>

return scope[fn];
},

htmlEncode : function(value) {
return Ext.String.htmlEncode(value);
},

htmlDecode : function(value) {
return Ext.String.htmlDecode(value);
},

urlAppend : function(url, s) {
return Ext.String.urlAppend(url, s);
}
});
Ext.ns = Ext.namespace;
// for old browsers
window.undefined = window.undefined;
(function(){
var check = function(regex){
return regex.test(Ext.userAgent);
},
isStrict = document.compatMode == "CSS1Compat",
version = function (is, regex) {
var m;
return (is && (m = regex.exec(Ext.userAgent))) ? parseFloat(m[1]) : 0;
},
docMode = document.documentMode,
isOpera = check(/opera/),
isOpera10_5 = isOpera && check(/version\/10\.5/),
isChrome = check(/\bchrome\b/),
isWebKit = check(/webkit/),
isSafari = !isChrome && check(/safari/),
isSafari2 = isSafari && check(/applewebkit\/4/), // unique to Safari 2
isSafari3 = isSafari && check(/version\/3/),
isSafari4 = isSafari && check(/version\/4/),
isSafari5_0 = isSafari && check(/version\/5\.0/),
isSafari5 = isSafari && check(/version\/5/),
isIE = !isOpera && check(/msie/),
isIE7 = isIE && ((check(/msie 7/) && docMode != 8 && docMode != 9 && docMode != 10) || docMode == 7),
isIE8 = isIE && ((check(/msie 8/) && docMode != 7 && docMode != 9 && docMode != 10) || docMode == 8),
isIE9 = isIE && ((check(/msie 9/) && docMode != 7 && docMode != 8 && docMode != 10) || docMode == 9),
isIE10 = isIE && ((check(/msie 10/) && docMode != 7 && docMode != 8 && docMode != 9) || docMode == 10),
isIE6 = isIE && check(/msie 6/),
isGecko = !isWebKit && check(/gecko/),
isGecko3 = isGecko && check(/rv:1\.9/),
isGecko4 = isGecko && check(/rv:2\.0/),
isGecko5 = isGecko && check(/rv:5\./),
isGecko10 = isGecko && check(/rv:10\./),
isFF3_0 = isGecko3 && check(/rv:1\.9\.0/),
isFF3_5 = isGecko3 && check(/rv:1\.9\.1/),
isFF3_6 = isGecko3 && check(/rv:1\.9\.2/),
isWindows = check(/windows|win32/),
isMac = check(/macintosh|mac os x/),
isLinux = check(/linux/),
scrollbarSize = null,
chromeVersion = version(true, /\bchrome\/(\d+\.\d+)/),
firefoxVersion = version(true, /\bfirefox\/(\d+\.\d+)/),
ieVersion = version(isIE, /msie (\d+\.\d+)/),
operaVersion = version(isOpera, /version\/(\d+\.\d+)/),
safariVersion = version(isSafari, /version\/(\d+\.\d+)/),
webKitVersion = version(isWebKit, /webkit\/(\d+\.\d+)/),
isSecure = /^https/i.test(window.location.protocol),
nullLog;
// remove css image flicker
try {
document.execCommand("BackgroundImageCache", false, true);
} catch(e) {}
//<debug>
var primitiveRe = /string|number|boolean/;
function dumpObject (object) {
var member, type, value, name,
members = [];
// Cannot use Ext.encode since it can recurse endlessly (if we're lucky)
// ...and the data could be prettier!
for (name in object) {
if (object.hasOwnProperty(name)) {
value = object[name];
type = typeof value;
if (type == "function") {
continue;
}
if (type == 'undefined') {
member = type;
} else if (value === null || primitiveRe.test(type) || Ext.isDate(value)) {
member = Ext.encode(value);
} else if (Ext.isArray(value)) {
member = '[ ]';
} else if (Ext.isObject(value)) {
member = '{ }';
} else {
member = type;
}
members.push(Ext.encode(name) + ': ' + member);
}
}
if (members.length) {
return ' \nData: {\n ' + members.join(',\n ') + '\n}';
}
return '';
}
function log (message) {
var options, dump,
con = Ext.global.console,
level = 'log',
indent = log.indent || 0,
stack,
out,
max;
log.indent = indent;
if (typeof message != 'string') {
options = message;
message = options.msg || '';
level = options.level || level;
dump = options.dump;
stack = options.stack;
if (options.indent) {
++log.indent;
} else if (options.outdent) {
log.indent = indent = Math.max(indent - 1, 0);
}
if (dump && !(con && con.dir)) {
message += dumpObject(dump);
dump = null;
}
}
if (arguments.length > 1) {
message += Array.prototype.slice.call(arguments, 1).join('');
}
message = indent ? Ext.String.repeat(' ', log.indentSize * indent) + message : message;
// w/o console, all messages are equal, so munge the level into the message:
if (level != 'log') {
message = '[' + level.charAt(0).toUpperCase() + '] ' + message;
}
// Not obvious, but 'console' comes and goes when Firebug is turned on/off, so
// an early test may fail either direction if Firebug is toggled.
//
if (con) { // if (Firebug-like console)
if (con[level]) {
con[level](message);
} else {
con.log(message);
}
if (dump) {
con.dir(dump);
}
if (stack && con.trace) {
// Firebug's console.error() includes a trace already...
if (!con.firebug || level != 'error') {
con.trace();
}
}
} else {
if (Ext.isOpera) {
opera.postError(message);
} else {
out = log.out;
max = log.max;
if (out.length >= max) {
// this formula allows out.max to change (via debugger), where the
// more obvious "max/4" would not quite be the same
Ext.Array.erase(out, 0, out.length - 3 * Math.floor(max / 4)); // keep newest 75%
}
out.push(message);
}
}
// Mostly informational, but the Ext.Error notifier uses them:
++log.count;
++log.counters[level];
}
function logx (level, args) {
if (typeof args[0] == 'string') {
args.unshift({});
}
args[0].level = level;
log.apply(this, args);
}
log.error = function () {
logx('error', Array.prototype.slice.call(arguments));
};
log.info = function () {
logx('info', Array.prototype.slice.call(arguments));
};
log.warn = function () {
logx('warn', Array.prototype.slice.call(arguments));
};
log.count = 0;
log.counters = { error: 0, warn: 0, info: 0, log: 0 };
log.indentSize = 2;
log.out = [];
log.max = 750;
log.show = function () {
window.open('','extlog').document.write([
'<html><head><script type="text/javascript">',
'var lastCount = 0;',
'function update () {',
'var ext = window.opener.Ext,',
'extlog = ext && ext.log;',
'if (extlog && extlog.out && lastCount != extlog.count) {',
'lastCount = extlog.count;',
'var s = "<tt>" + extlog.out.join("~~~").replace(/[&]/g, "&amp;").replace(/[<]/g, "&lt;").replace(/[ ]/g, "&#160;").replace(/\\~\\~\\~/g, "<br/>") + "</tt>";',
'document.body.innerHTML = s;',
'}',
'setTimeout(update, 1000);',
'}',
'setTimeout(update, 1000);',
'</script></head><body></body></html>'].join(''));
};
//</debug>
nullLog = function () {};
nullLog.info = nullLog.warn = nullLog.error = Ext.emptyFn;
// also update Version.js
Ext.setVersion('extjs', '4.2.1.883');
Ext.apply(Ext, {

SSL_SECURE_URL : isSecure && isIE ? 'javascript:\'\'' : 'about:blank',

plainTableCls: Ext.buildSettings.baseCSSPrefix + 'table-plain', 
plainListCls: Ext.buildSettings.baseCSSPrefix + 'list-plain', 

enableNestedListenerRemoval : false,

USE_NATIVE_JSON : false,

getDom : function(el, strict) {
if (!el || !document) {
return null;
}
if (el.dom) {
return el.dom;
} else {
if (typeof el == 'string') {
var e = Ext.getElementById(el);
// IE returns elements with the 'name' and 'id' attribute.
// we do a strict check to return the element with only the id attribute
if (e && isIE && strict) {
if (el == e.getAttribute('id')) {
return e;
} else {
return null;
}
}
return e;
} else {
return el;
}
}
},

removeNode : isIE6 || isIE7 || isIE8
? (function() {
var d;
return function(n){
if(n && n.tagName.toUpperCase() != 'BODY'){
(Ext.enableNestedListenerRemoval) ? Ext.EventManager.purgeElement(n) : Ext.EventManager.removeAll(n);
var cache = Ext.cache,
id = n.id;
if (cache[id]) {
delete cache[id].dom;
delete cache[id];
}
if (isIE8 && n.parentNode) {
n.parentNode.removeChild(n);
}
d = d || document.createElement('div');
d.appendChild(n);
d.innerHTML = '';
}
};
}())
: function(n) {
if (n && n.parentNode && n.tagName.toUpperCase() != 'BODY') {
(Ext.enableNestedListenerRemoval) ? Ext.EventManager.purgeElement(n) : Ext.EventManager.removeAll(n);
var cache = Ext.cache,
id = n.id;
if (cache[id]) {
delete cache[id].dom;
delete cache[id];
}
n.parentNode.removeChild(n);
}
},
isStrict: isStrict,
// IE10 quirks behaves like Gecko/WebKit quirks, so don't include it here
isIEQuirks: isIE && (!isStrict && (isIE6 || isIE7 || isIE8 || isIE9)),

isOpera : isOpera,

isOpera10_5 : isOpera10_5,

isWebKit : isWebKit,

isChrome : isChrome,

isSafari : isSafari,

isSafari3 : isSafari3,

isSafari4 : isSafari4,

isSafari5 : isSafari5,

isSafari5_0 : isSafari5_0,

isSafari2 : isSafari2,

isIE : isIE,

isIE6 : isIE6,

isIE7 : isIE7,

isIE7m : isIE6 || isIE7,

isIE7p : isIE && !isIE6,

isIE8 : isIE8,

isIE8m : isIE6 || isIE7 || isIE8,

isIE8p : isIE && !(isIE6 || isIE7),

isIE9 : isIE9,

isIE9m : isIE6 || isIE7 || isIE8 || isIE9,

isIE9p : isIE && !(isIE6 || isIE7 || isIE8),


isIE10 : isIE10, 


isIE10m : isIE6 || isIE7 || isIE8 || isIE9 || isIE10,


isIE10p : isIE && !(isIE6 || isIE7 || isIE8 || isIE9),

isGecko : isGecko,

isGecko3 : isGecko3,

isGecko4 : isGecko4,

isGecko5 : isGecko5,

isGecko10 : isGecko10,

isFF3_0 : isFF3_0,

isFF3_5 : isFF3_5,

isFF3_6 : isFF3_6,

isFF4 : 4 <= firefoxVersion && firefoxVersion < 5,

isFF5 : 5 <= firefoxVersion && firefoxVersion < 6,

isFF10 : 10 <= firefoxVersion && firefoxVersion < 11,

isLinux : isLinux,

isWindows : isWindows,

isMac : isMac,

chromeVersion: chromeVersion,

firefoxVersion: firefoxVersion,

ieVersion: ieVersion,

operaVersion: operaVersion,

safariVersion: safariVersion,

webKitVersion: webKitVersion,

isSecure: isSecure,

BLANK_IMAGE_URL : (isIE6 || isIE7) ? '/' + '/www.sencha.com/s.gif' : 'data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==',

value : function(v, defaultValue, allowBlank){
return Ext.isEmpty(v, allowBlank) ? defaultValue : v;
},

escapeRe : function(s) {
return s.replace(/([-.*+?\^${}()|\[\]\/\\])/g, "\\$1");
},

addBehaviors : function(o){
if(!Ext.isReady){
Ext.onReady(function(){
Ext.addBehaviors(o);
});
} else {
var cache = {}, // simple cache for applying multiple behaviors to same selector does query multiple times
parts,
b,
s;
for (b in o) {
if ((parts = b.split('@'))[1]) { // for Object prototype breakers
s = parts[0];
if(!cache[s]){
cache[s] = Ext.select(s);
}
cache[s].on(parts[1], o[b]);
}
}
cache = null;
}
},

getScrollbarSize: function (force) {
if (!Ext.isReady) {
return {};
}
if (force || !scrollbarSize) {
var db = document.body,
div = document.createElement('div');
div.style.width = div.style.height = '100px';
div.style.overflow = 'scroll';
div.style.position = 'absolute';
db.appendChild(div); // now we can measure the div...
// at least in iE9 the div is not 100px - the scrollbar size is removed!
scrollbarSize = {
width: div.offsetWidth - div.clientWidth,
height: div.offsetHeight - div.clientHeight
};
db.removeChild(div);
}
return scrollbarSize;
},

getScrollBarWidth: function(force){
var size = Ext.getScrollbarSize(force);
return size.width + 2; // legacy fudge factor
},

copyTo : function(dest, source, names, usePrototypeKeys){
if(typeof names == 'string'){
names = names.split(/[,;\s]/);
}
var n,
nLen = names? names.length : 0,
name;
for(n = 0; n < nLen; n++) {
name = names[n];
if(usePrototypeKeys || source.hasOwnProperty(name)){
dest[name] = source[name];
}
}
return dest;
},

destroyMembers : function(o){
for (var i = 1, a = arguments, len = a.length; i < len; i++) {
Ext.destroy(o[a[i]]);
delete o[a[i]];
}
},

log :
//<debug>
log ||
//</debug>
nullLog,

partition : function(arr, truth){
var ret = [[],[]],
a, v,
aLen = arr.length;
for (a = 0; a < aLen; a++) {
v = arr[a];
ret[ (truth && truth(v, a, arr)) || (!truth && v) ? 0 : 1].push(v);
}
return ret;
},

invoke : function(arr, methodName){
var ret = [],
args = Array.prototype.slice.call(arguments, 2),
a, v,
aLen = arr.length;
for (a = 0; a < aLen; a++) {
v = arr[a];
if (v && typeof v[methodName] == 'function') {
ret.push(v[methodName].apply(v, args));
} else {
ret.push(undefined);
}
}
return ret;
},

zip : function(){
var parts = Ext.partition(arguments, function( val ){ return typeof val != 'function'; }),
arrs = parts[0],
fn = parts[1][0],
len = Ext.max(Ext.pluck(arrs, "length")),
ret = [],
i,
j,
aLen;
for (i = 0; i < len; i++) {
ret[i] = [];
if(fn){
ret[i] = fn.apply(fn, Ext.pluck(arrs, i));
}else{
for (j = 0, aLen = arrs.length; j < aLen; j++){
ret[i].push( arrs[j][i] );
}
}
}
return ret;
},

toSentence: function(items, connector) {
var length = items.length,
head,
tail;
if (length <= 1) {
return items[0];
} else {
head = items.slice(0, length - 1);
tail = items[length - 1];
return Ext.util.Format.format("{0} {1} {2}", head.join(", "), connector || 'and', tail);
}
},

setGlyphFontFamily: function(fontFamily) {
Ext._glyphFontFamily = fontFamily;
},

useShims: isIE6
});
}());
Ext.application = function(config) {
var App, paths, ns;

if (typeof config === "string") {
Ext.require(config, function(){
App = Ext.ClassManager.get(config);
});
}
else {
// We have to process `paths` before creating Application class,
// or `requires` won't work.
Ext.Loader.setPath(config.name, config.appFolder || 'app');

if (paths = config.paths) {
for (ns in paths) {
if (paths.hasOwnProperty(ns)) {
Ext.Loader.setPath(ns, paths[ns]);
}
}
}

config['paths processed'] = true;

// Let Ext.define do the hard work but don't assign a class name.
//
Ext.define(config.name + ".$application", Ext.apply({
extend: 'Ext.app.Application' // can be replaced by config!
}, config),
// call here when the App class gets full defined
function () {
App = this;
});
}
Ext.onReady(function() {
// this won't be called until App has been created and its requires have been
// met...
Ext.app.Application.instance = new App();
});
};
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/util/Format.js */
(function(Ext) {
// @tag extras,core
// @require ../Ext-more.js
// @define Ext.util.Format
(function() {
Ext.ns('Ext.util');
var UtilFormat = Ext.util.Format = {},
stripTagsRE = /<\/?[^>]+>/gi,
stripScriptsRe = /(?:<script.*?>)((\n|\r|.)*?)(?:<\/script>)/ig,
nl2brRe = /\r?\n/g,
allHashes = /^#+$/,
// Match a format string characters to be able to detect remaining "literal" characters
formatPattern = /[\d,\.#]+/,
// A RegExp to remove from a number format string, all characters except digits and '.'
formatCleanRe = /[^\d\.#]/g,
// A RegExp to remove from a number format string, all characters except digits and the local decimal separator.
// Created on first use. The local decimal separator character must be initialized for this to be created.
I18NFormatCleanRe,
// Cache ofg number formatting functions keyed by format string
formatFns = {};
Ext.apply(UtilFormat, {
//<locale>

thousandSeparator: ',',
//</locale>
//<locale>

decimalSeparator: '.',
//</locale>
//<locale>

currencyPrecision: 2,
//</locale>
//<locale>

currencySign: '$',
//</locale>
//<locale>

currencyAtEnd: false,
//</locale>

undef : function(value) {
return value !== undefined ? value : "";
},

defaultValue : function(value, defaultValue) {
return value !== undefined && value !== '' ? value : defaultValue;
},

substr : 'ab'.substr(-1) != 'b'
? function (value, start, length) {
var str = String(value);
return (start < 0)
? str.substr(Math.max(str.length + start, 0), length)
: str.substr(start, length);
}
: function(value, start, length) {
return String(value).substr(start, length);
},

lowercase : function(value) {
return String(value).toLowerCase();
},

uppercase : function(value) {
return String(value).toUpperCase();
},

usMoney : function(v) {
return UtilFormat.currency(v, '$', 2);
},

currency: function(v, currencySign, decimals, end) {
var negativeSign = '',
format = ",0",
i = 0;
v = v - 0;
if (v < 0) {
v = -v;
negativeSign = '-';
}
decimals = Ext.isDefined(decimals) ? decimals : UtilFormat.currencyPrecision;
format += (decimals > 0 ? '.' : '');
for (; i < decimals; i++) {
format += '0';
}
v = UtilFormat.number(v, format);
if ((end || UtilFormat.currencyAtEnd) === true) {
return Ext.String.format("{0}{1}{2}", negativeSign, v, currencySign || UtilFormat.currencySign);
} else {
return Ext.String.format("{0}{1}{2}", negativeSign, currencySign || UtilFormat.currencySign, v);
}
},

date: function(v, format) {
if (!v) {
return "";
}
if (!Ext.isDate(v)) {
v = new Date(Date.parse(v));
}
return Ext.Date.dateFormat(v, format || Ext.Date.defaultFormat);
},

dateRenderer : function(format) {
return function(v) {
return UtilFormat.date(v, format);
};
},

stripTags : function(v) {
return !v ? v : String(v).replace(stripTagsRE, "");
},

stripScripts : function(v) {
return !v ? v : String(v).replace(stripScriptsRe, "");
},

fileSize : (function(){
var byteLimit = 1024,
kbLimit = 1048576,
mbLimit = 1073741824;

return function(size) {
var out;
if (size < byteLimit) {
if (size === 1) {
out = '1 byte'; 
} else {
out = size + ' bytes';
}
} else if (size < kbLimit) {
out = (Math.round(((size*10) / byteLimit))/10) + ' KB';
} else if (size < mbLimit) {
out = (Math.round(((size*10) / kbLimit))/10) + ' MB';
} else {
out = (Math.round(((size*10) / mbLimit))/10) + ' GB';
}
return out;
};
})(),

math : (function(){
var fns = {};
return function(v, a){
if (!fns[a]) {
fns[a] = Ext.functionFactory('v', 'return v ' + a + ';');
}
return fns[a](v);
};
}()),

round : function(value, precision) {
var result = Number(value);
if (typeof precision == 'number') {
precision = Math.pow(10, precision);
result = Math.round(value * precision) / precision;
}
return result;
},

number : function(v, formatString) {
if (!formatString) {
return v;
}
var formatFn = formatFns[formatString];
// Generate formatting function to be cached and reused keyed by the format string.
// This results in a 100% performance increase over analyzing the format string each invocation.
if (!formatFn) {
var originalFormatString = formatString,
comma = UtilFormat.thousandSeparator,
decimalSeparator = UtilFormat.decimalSeparator,
hasComma,
splitFormat,
extraChars,
precision = 0,
multiplier,
trimTrailingZeroes,
code;
// The "/i" suffix allows caller to use a locale-specific formatting string.
// Clean the format string by removing all but numerals and the decimal separator.
// Then split the format string into pre and post decimal segments according to *what* the
// decimal separator is. If they are specifying "/i", they are using the local convention in the format string.
if (formatString.substr(formatString.length - 2) == '/i') {
if (!I18NFormatCleanRe) {
I18NFormatCleanRe = new RegExp('[^\\d\\' + UtilFormat.decimalSeparator + ']','g');
}
formatString = formatString.substr(0, formatString.length - 2);
hasComma = formatString.indexOf(comma) != -1;
splitFormat = formatString.replace(I18NFormatCleanRe, '').split(decimalSeparator);
} else {
hasComma = formatString.indexOf(',') != -1;
splitFormat = formatString.replace(formatCleanRe, '').split('.');
}
extraChars = formatString.replace(formatPattern, '');
if (splitFormat.length > 2) {
//<debug>
Ext.Error.raise({
sourceClass: "Ext.util.Format",
sourceMethod: "number",
value: v,
formatString: formatString,
msg: "Invalid number format, should have no more than 1 decimal"
});
//</debug>
} else if (splitFormat.length === 2) {
precision = splitFormat[1].length;
// Formatting ending in .##### means maximum 5 trailing significant digits
trimTrailingZeroes = allHashes.test(splitFormat[1]);
}

// The function we create is called immediately and returns a closure which has access to vars and some fixed values; RegExes and the format string.
code = [
'var utilFormat=Ext.util.Format,extNumber=Ext.Number,neg,fnum,parts' +
(hasComma ? ',thousandSeparator,thousands=[],j,n,i' : '') +
(extraChars ? ',formatString="' + formatString + '",formatPattern=/[\\d,\\.#]+/' : '') +
(trimTrailingZeroes ? ',trailingZeroes=/\\.?0+$/;' : ';') +
'return function(v){' +
'if(typeof v!=="number"&&isNaN(v=extNumber.from(v,NaN)))return"";' +
'neg=v<0;',
'fnum=Ext.Number.toFixed(Math.abs(v), ' + precision + ');'
];
if (hasComma) {
// If we have to insert commas...

// split the string up into whole and decimal parts if there are decimals
if (precision) {
code[code.length] = 'parts=fnum.split(".");';
code[code.length] = 'fnum=parts[0];';
}
code[code.length] =
'if(v>=1000) {';
code[code.length] = 'thousandSeparator=utilFormat.thousandSeparator;' +
'thousands.length=0;' +
'j=fnum.length;' +
'n=fnum.length%3||3;' +
'for(i=0;i<j;i+=n){' +
'if(i!==0){' +
'n=3;' +
'}' +
'thousands[thousands.length]=fnum.substr(i,n);' +
'}' +
'fnum=thousands.join(thousandSeparator);' + 
'}';
if (precision) {
code[code.length] = 'fnum += utilFormat.decimalSeparator+parts[1];';
}

} else if (precision) {
// If they are using a weird decimal separator, split and concat using it
code[code.length] = 'if(utilFormat.decimalSeparator!=="."){' +
'parts=fnum.split(".");' +
'fnum=parts[0]+utilFormat.decimalSeparator+parts[1];' +
'}';
}
if (trimTrailingZeroes) {
code[code.length] = 'fnum=fnum.replace(trailingZeroes,"");';
}

code[code.length] = 'if(neg&&fnum!=="' + (precision ? '0.' + Ext.String.repeat('0', precision) : '0') + '")fnum="-"+fnum;';
code[code.length] = 'return ';
// If there were extra characters around the formatting string, replace the format string part with the formatted number.
if (extraChars) {
code[code.length] = 'formatString.replace(formatPattern, fnum);';
} else {
code[code.length] = 'fnum;';
}
code[code.length] = '};'
formatFn = formatFns[originalFormatString] = Ext.functionFactory('Ext', code.join(''))(Ext);
}
return formatFn(v);
},

numberRenderer : function(format) {
return function(v) {
return UtilFormat.number(v, format);
};
},

attributes: function(attributes) {
if (typeof attributes === 'object') {
var result = [],
name;
for (name in attributes) {
result.push(name, '="', name === 'style' ? Ext.DomHelper.generateStyles(attributes[name]) : Ext.htmlEncode(attributes[name]), '"');
}
attributes = result.join('');
}
return attributes||'';
},

plural : function(v, s, p) {
return v +' ' + (v == 1 ? s : (p ? p : s+'s'));
},

nl2br : function(v) {
return Ext.isEmpty(v) ? '' : v.replace(nl2brRe, '<br/>');
},

capitalize: Ext.String.capitalize,

ellipsis: Ext.String.ellipsis,

format: Ext.String.format,

htmlDecode: Ext.String.htmlDecode,

htmlEncode: Ext.String.htmlEncode,

leftPad: Ext.String.leftPad,

trim : Ext.String.trim,

parseBox : function(box) {
box = box || 0;
if (typeof box === 'number') {
return {
top : box,
right : box,
bottom: box,
left : box
};
}
var parts = box.split(' '),
ln = parts.length;
if (ln == 1) {
parts[1] = parts[2] = parts[3] = parts[0];
}
else if (ln == 2) {
parts[2] = parts[0];
parts[3] = parts[1];
}
else if (ln == 3) {
parts[3] = parts[1];
}
return {
top :parseInt(parts[0], 10) || 0,
right :parseInt(parts[1], 10) || 0,
bottom:parseInt(parts[2], 10) || 0,
left :parseInt(parts[3], 10) || 0
};
},

escapeRegex : function(s) {
return s.replace(/([\-.*+?\^${}()|\[\]\/\\])/g, "\\$1");
}
});
}());
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/util/TaskRunner.js */
(function(Ext) {
// @tag extras,core
// @require Format.js
Ext.define('Ext.util.TaskRunner', {


interval: 10,

timerId: null,
constructor: function (interval) {
var me = this;
if (typeof interval == 'number') {
me.interval = interval;
} else if (interval) {
Ext.apply(me, interval);
}
me.tasks = [];
me.timerFn = Ext.Function.bind(me.onTick, me);
},

newTask: function (config) {
var task = new Ext.util.TaskRunner.Task(config);
task.manager = this;
return task;
},

start: function(task) {
var me = this,
now = Ext.Date.now();
if (!task.pending) {
me.tasks.push(task);
task.pending = true; // don't allow the task to be added to me.tasks again
}
task.stopped = false; // might have been previously stopped...
task.taskStartTime = now;
task.taskRunTime = task.fireOnStart !== false ? 0 : task.taskStartTime;
task.taskRunCount = 0;
if (!me.firing) {
if (task.fireOnStart !== false) {
me.startTimer(0, now);
} else {
me.startTimer(task.interval, now);
}
}
return task;
},

stop: function(task) {
// NOTE: we don't attempt to remove the task from me.tasks at this point because
// this could be called from inside a task which would then corrupt the state of
// the loop in onTick
if (!task.stopped) {
task.stopped = true;
if (task.onStop) {
task.onStop.call(task.scope || task, task);
}
}
return task;
},

stopAll: function() {
// onTick will take care of cleaning up the mess after this point...
Ext.each(this.tasks, this.stop, this);
},
//-------------------------------------------------------------------------
firing: false,
nextExpires: 1e99,
// private
onTick: function () {
var me = this,
tasks = me.tasks,
now = Ext.Date.now(),
nextExpires = 1e99,
len = tasks.length,
expires, newTasks, i, task, rt, remove;
me.timerId = null;
me.firing = true; // ensure we don't startTimer during this loop...
// tasks.length can be > len if start is called during a task.run call... so we
// first check len to avoid tasks.length reference but eventually we need to also
// check tasks.length. we avoid repeating use of tasks.length by setting len at
// that time (to help the next loop)
for (i = 0; i < len || i < (len = tasks.length); ++i) {
task = tasks[i];
if (!(remove = task.stopped)) {
expires = task.taskRunTime + task.interval;
if (expires <= now) {
rt = 1; // otherwise we have a stale "rt"
try {
rt = task.run.apply(task.scope || task, task.args || [++task.taskRunCount]);
} catch (taskError) {
try {
// <debug>
Ext.log({
msg: taskError,
level: 'error'
});
// </debug>
if (task.onError) {
rt = task.onError.call(task.scope || task, task, taskError);
}
} catch (ignore) { }
}
task.taskRunTime = now;
if (rt === false || task.taskRunCount === task.repeat) {
me.stop(task);
remove = true;
} else {
remove = task.stopped; // in case stop was called by run
expires = now + task.interval;
}
}
if (!remove && task.duration && task.duration <= (now - task.taskStartTime)) {
me.stop(task);
remove = true;
}
}
if (remove) {
task.pending = false; // allow the task to be added to me.tasks again
// once we detect that a task needs to be removed, we copy the tasks that
// will carry forward into newTasks... this way we avoid O(N*N) to remove
// each task from the tasks array (and ripple the array down) and also the
// potentially wasted effort of making a new tasks[] even if all tasks are
// going into the next wave.
if (!newTasks) {
newTasks = tasks.slice(0, i);
// we don't set me.tasks here because callbacks can also start tasks,
// which get added to me.tasks... so we will visit them in this loop
// and account for their expirations in nextExpires...
}
} else {
if (newTasks) {
newTasks.push(task); // we've cloned the tasks[], so keep this one...
}
if (nextExpires > expires) {
nextExpires = expires; // track the nearest expiration time
}
}
}
if (newTasks) {
// only now can we copy the newTasks to me.tasks since no user callbacks can
// take place
me.tasks = newTasks;
}
me.firing = false; // we're done, so allow startTimer afterwards
if (me.tasks.length) {
// we create a new Date here because all the callbacks could have taken a long
// time... we want to base the next timeout on the current time (after the
// callback storm):
me.startTimer(nextExpires - now, Ext.Date.now());
}

// After a tick
if (me.fireIdleEvent !== false) {
Ext.EventManager.idleEvent.fire();
}
},
// private
startTimer: function (timeout, now) {
var me = this,
expires = now + timeout,
timerId = me.timerId;
// Check to see if this request is enough in advance of the current timer. If so,
// we reschedule the timer based on this new expiration.
if (timerId && me.nextExpires - expires > me.interval) {
clearTimeout(timerId);
timerId = null;
}
if (!timerId) {
if (timeout < me.interval) {
timeout = me.interval;
}
me.timerId = setTimeout(me.timerFn, timeout);
me.nextExpires = expires;
}
}
},
function () {
var me = this,
proto = me.prototype;

proto.destroy = proto.stopAll;
// Documented in TaskManager.js
Ext.util.TaskManager = Ext.TaskManager = new me();

me.Task = new Ext.Class({
isTask: true,

stopped: true, // this avoids the odd combination of !stopped && !pending

fireOnStart: false,
constructor: function (config) {
Ext.apply(this, config);
},

restart: function (interval) {
if (interval !== undefined) {
this.interval = interval;
}
this.manager.start(this);
},

start: function (interval) {
if (this.stopped) {
this.restart(interval);
}
},

stop: function () {
this.manager.stop(this);
}
});
proto = me.Task.prototype;

proto.destroy = proto.stop;
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/util/TaskManager.js */
(function(Ext) {
// @tag extras,core
Ext.define('Ext.util.TaskManager', {
extend: 'Ext.util.TaskRunner',
alternateClassName: [
'Ext.TaskManager'
],
singleton: true
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/perf/Accumulator.js */
(function(Ext) {
// @tag extras,core
// @require ../util/TaskManager.js
Ext.define('Ext.perf.Accumulator', (function () {
var currentFrame = null,
khrome = Ext.global['chrome'],
formatTpl,
// lazy init on first request for timestamp (avoids infobar in IE until needed)
// Also avoids kicking off Chrome's microsecond timer until first needed
getTimestamp = function () {
getTimestamp = function () {
return new Date().getTime();
};

var interval, toolbox;
// If Chrome is started with the --enable-benchmarking switch
if (Ext.isChrome && khrome && khrome.Interval) {
interval = new khrome.Interval();
interval.start();
getTimestamp = function () {
return interval.microseconds() / 1000;
};
} else if (window.ActiveXObject) {
try {
// the above technique is not very accurate for small intervals...
toolbox = new ActiveXObject('SenchaToolbox.Toolbox');
Ext.senchaToolbox = toolbox; // export for other uses
getTimestamp = function () {
return toolbox.milliseconds;
};
} catch (e) {
// ignore
}
} else if (Date.now) {
getTimestamp = Date.now;
}
Ext.perf.getTimestamp = Ext.perf.Accumulator.getTimestamp = getTimestamp;
return getTimestamp();
};
function adjustSet (set, time) {
set.sum += time;
set.min = Math.min(set.min, time);
set.max = Math.max(set.max, time);
}
function leaveFrame (time) {
var totalTime = time ? time : (getTimestamp() - this.time), // do this first
me = this, // me = frame
accum = me.accum;
++accum.count;
if (! --accum.depth) {
adjustSet(accum.total, totalTime);
}
adjustSet(accum.pure, totalTime - me.childTime);
currentFrame = me.parent;
if (currentFrame) {
++currentFrame.accum.childCount;
currentFrame.childTime += totalTime;
}
}
function makeSet () {
return {
min: Number.MAX_VALUE,
max: 0,
sum: 0
};
}
function makeTap (me, fn) {
return function () {
var frame = me.enter(),
ret = fn.apply(this, arguments);
frame.leave();
return ret;
};
}
function round (x) {
return Math.round(x * 100) / 100;
}
function setToJSON (count, childCount, calibration, set) {
var data = {
avg: 0,
min: set.min,
max: set.max,
sum: 0
};
if (count) {
calibration = calibration || 0;
data.sum = set.sum - childCount * calibration;
data.avg = data.sum / count;
// min and max cannot be easily corrected since we don't know the number of
// child calls for them.
}
return data;
}
return {
constructor: function (name) {
var me = this;
me.count = me.childCount = me.depth = me.maxDepth = 0;
me.pure = makeSet();
me.total = makeSet();
me.name = name;
},
statics: {
getTimestamp: getTimestamp
},
format: function (calibration) {
if (!formatTpl) {
formatTpl = new Ext.XTemplate([
'{name} - {count} call(s)',
'<tpl if="count">',
'<tpl if="childCount">',
' ({childCount} children)',
'</tpl>',
'<tpl if="depth - 1">',
' ({depth} deep)',
'</tpl>',
'<tpl for="times">',
', {type}: {[this.time(values.sum)]} msec (',
//'min={[this.time(values.min)]}, ',
'avg={[this.time(values.sum / parent.count)]}',
//', max={[this.time(values.max)]}',
')',
'</tpl>',
'</tpl>'
].join(''), {
time: function (t) {
return Math.round(t * 100) / 100;
}
});
}
var data = this.getData(calibration);
data.name = this.name;
data.pure.type = 'Pure';
data.total.type = 'Total';
data.times = [data.pure, data.total];
return formatTpl.apply(data);
},
getData: function (calibration) {
var me = this;
return {
count: me.count,
childCount: me.childCount,
depth: me.maxDepth,
pure: setToJSON(me.count, me.childCount, calibration, me.pure),
total: setToJSON(me.count, me.childCount, calibration, me.total)
};
},
enter: function () {
var me = this,
frame = {
accum: me,
leave: leaveFrame,
childTime: 0,
parent: currentFrame
};
++me.depth;
if (me.maxDepth < me.depth) {
me.maxDepth = me.depth;
}
currentFrame = frame;
frame.time = getTimestamp(); // do this last
return frame;
},
monitor: function (fn, scope, args) {
var frame = this.enter();
if (args) {
fn.apply(scope, args);
} else {
fn.call(scope);
}
frame.leave();
},
report: function () {
Ext.log(this.format());
},
tap: function (className, methodName) {
var me = this,
methods = typeof methodName == 'string' ? [methodName] : methodName,
klass, statik, i, parts, length, name, src,
tapFunc;
tapFunc = function(){
if (typeof className == 'string') {
klass = Ext.global;
parts = className.split('.');
for (i = 0, length = parts.length; i < length; ++i) {
klass = klass[parts[i]];
}
} else {
klass = className;
}
for (i = 0, length = methods.length; i < length; ++i) {
name = methods[i];
statik = name.charAt(0) == '!';
if (statik) {
name = name.substring(1);
} else {
statik = !(name in klass.prototype);
}
src = statik ? klass : klass.prototype;
src[name] = makeTap(me, src[name]);
}
};
Ext.ClassManager.onCreated(tapFunc, me, className);
return me;
}
};
}()),
function () {
Ext.perf.getTimestamp = this.getTimestamp;
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/perf/Monitor.js */
(function(Ext) {
// @tag extras,core
// @require Accumulator.js
Ext.define('Ext.perf.Monitor', {
singleton: true,
alternateClassName: 'Ext.Perf',
requires: [
'Ext.perf.Accumulator'
],
constructor: function () {
this.accumulators = [];
this.accumulatorsByName = {};
},
calibrate: function () {
var accum = new Ext.perf.Accumulator('$'),
total = accum.total,
getTimestamp = Ext.perf.Accumulator.getTimestamp,
count = 0,
frame,
endTime,
startTime;
startTime = getTimestamp();
do {
frame = accum.enter();
frame.leave();
++count;
} while (total.sum < 100);
endTime = getTimestamp();
return (endTime - startTime) / count;
},
get: function (name) {
var me = this,
accum = me.accumulatorsByName[name];
if (!accum) {
me.accumulatorsByName[name] = accum = new Ext.perf.Accumulator(name);
me.accumulators.push(accum);
}
return accum;
},
enter: function (name) {
return this.get(name).enter();
},
monitor: function (name, fn, scope) {
this.get(name).monitor(fn, scope);
},
report: function () {
var me = this,
accumulators = me.accumulators,
calibration = me.calibrate();
accumulators.sort(function (a, b) {
return (a.name < b.name) ? -1 : ((b.name < a.name) ? 1 : 0);
});
me.updateGC();
Ext.log('Calibration: ' + Math.round(calibration * 100) / 100 + ' msec/sample');
Ext.each(accumulators, function (accum) {
Ext.log(accum.format(calibration));
});
},
getData: function (all) {
var ret = {},
accumulators = this.accumulators;
Ext.each(accumulators, function (accum) {
if (all || accum.count) {
ret[accum.name] = accum.getData();
}
});
return ret;
},
reset: function(){
Ext.each(this.accumulators, function(accum){
var me = accum;
me.count = me.childCount = me.depth = me.maxDepth = 0;
me.pure = {
min: Number.MAX_VALUE,
max: 0,
sum: 0
};
me.total = {
min: Number.MAX_VALUE,
max: 0,
sum: 0
};
});
},
updateGC: function () {
var accumGC = this.accumulatorsByName.GC,
toolbox = Ext.senchaToolbox,
bucket;
if (accumGC) {
accumGC.count = toolbox.garbageCollectionCounter || 0;
if (accumGC.count) {
bucket = accumGC.pure;
accumGC.total.sum = bucket.sum = toolbox.garbageCollectionMilliseconds;
bucket.min = bucket.max = bucket.sum / accumGC.count;
bucket = accumGC.total;
bucket.min = bucket.max = bucket.sum / accumGC.count;
}
}
},
watchGC: function () {
Ext.perf.getTimestamp(); // initializes SenchaToolbox (if available)
var toolbox = Ext.senchaToolbox;
if (toolbox) {
this.get("GC");
toolbox.watchGarbageCollector(false); // no logging, just totals
}
},
setup: function (config) {
if (!config) {
config = {


// doInsert: {
// 'Ext.Template': 'doInsert'
// },
// applyOut: {
// 'Ext.XTemplate': 'applyOut'
// },
render: {
'Ext.AbstractComponent': 'render'
},
// fnishRender: {
// 'Ext.AbstractComponent': 'finishRender'
// },
// renderSelectors: {
// 'Ext.AbstractComponent': 'applyRenderSelectors'
// },
// compAddCls: {
// 'Ext.AbstractComponent': 'addCls'
// },
// compRemoveCls: {
// 'Ext.AbstractComponent': 'removeCls'
// },
// getStyle: {
// 'Ext.core.Element': 'getStyle'
// },
// setStyle: {
// 'Ext.core.Element': 'setStyle'
// },
// addCls: {
// 'Ext.core.Element': 'addCls'
// },
// removeCls: {
// 'Ext.core.Element': 'removeCls'
// },
// measure: {
// 'Ext.layout.component.Component': 'measureAutoDimensions'
// },
// moveItem: {
// 'Ext.layout.Layout': 'moveItem'
// },
// layoutFlush: {
// 'Ext.layout.Context': 'flush'
// },
layout: {
'Ext.layout.Context': 'run'
}
};
}
this.currentConfig = config;
var key, prop,
accum, className, methods;
for (key in config) {
if (config.hasOwnProperty(key)) {
prop = config[key];
accum = Ext.Perf.get(key);
for (className in prop) {
if (prop.hasOwnProperty(className)) {
methods = prop[className];
accum.tap(className, methods);
}
}
}
}
this.watchGC();
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/Support.js */
(function(Ext) {
// @tag extras,core
// @require perf/Monitor.js
// @define Ext.Supports
Ext.is = {
init : function(navigator) {
var platforms = this.platforms,
ln = platforms.length,
i, platform;
navigator = navigator || window.navigator;
for (i = 0; i < ln; i++) {
platform = platforms[i];
this[platform.identity] = platform.regex.test(navigator[platform.property]);
}

this.Desktop = this.Mac || this.Windows || (this.Linux && !this.Android);

this.Tablet = this.iPad;

this.Phone = !this.Desktop && !this.Tablet;

this.iOS = this.iPhone || this.iPad || this.iPod;


this.Standalone = !!window.navigator.standalone;
},


platforms: [{
property: 'platform',
regex: /iPhone/i,
identity: 'iPhone'
},


{
property: 'platform',
regex: /iPod/i,
identity: 'iPod'
},


{
property: 'userAgent',
regex: /iPad/i,
identity: 'iPad'
},


{
property: 'userAgent',
regex: /Blackberry/i,
identity: 'Blackberry'
},


{
property: 'userAgent',
regex: /Android/i,
identity: 'Android'
},


{
property: 'platform',
regex: /Mac/i,
identity: 'Mac'
},


{
property: 'platform',
regex: /Win/i,
identity: 'Windows'
},


{
property: 'platform',
regex: /Linux/i,
identity: 'Linux'
}]
};
Ext.is.init();
(function(){
// this is a local copy of certain logic from (Abstract)Element.getStyle
// to break a dependancy between the supports mechanism and Element
// use this instead of element references to check for styling info
var getStyle = function(element, styleName){
var view = element.ownerDocument.defaultView,
style = (view ? view.getComputedStyle(element, null) : element.currentStyle) || element.style;
return style[styleName];
},
supportsVectors = {
'IE6-quirks': [0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0,1,0,0,1,0,1,0,0,0],
'IE6-strict': [0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,0],
'IE7-quirks': [0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0,1,0,0,1,0,1,0,0,0],
'IE7-strict': [0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,0,0,0],
'IE8-quirks': [0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,0,0,1,0,0,1,0,1,0,0,0],
'IE8-strict': [0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,0,1],
'IE9-quirks': [0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0,0],
'IE9-strict': [0,1,0,0,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,0,0,0,0,1],
'IE10-quirks': [1,1,0,0,1,1,1,1,0,1,1,1,0,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,0,0,1],
'IE10-strict': [1,1,0,0,1,1,1,1,0,1,1,1,0,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,0,0,1]
};
function getBrowserKey() {
var browser = Ext.isIE6 ? 'IE6' : Ext.isIE7 ? 'IE7' : Ext.isIE8 ? 'IE8' :
Ext.isIE9 ? 'IE9': Ext.isIE10 ? 'IE10' : '';
return browser ? browser + (Ext.isStrict ? '-strict' : '-quirks') : '';
}
Ext.supports = {

init : function() {
var me = this,
doc = document,
toRun = me.toRun || me.tests,
n = toRun.length,
div = n && Ext.isReady && doc.createElement('div'),
notRun = [],
browserKey = getBrowserKey(),
test, vector, value;
if (div) {
div.innerHTML = [
'<div style="height:30px;width:50px;">',
'<div style="height:20px;width:20px;"></div>',
'</div>',
'<div style="width: 200px; height: 200px; position: relative; padding: 5px;">',
'<div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></div>',
'</div>',
'<div style="position: absolute; left: 10%; top: 10%;"></div>',
'<div style="float:left; background-color:transparent;"></div>'
].join('');
doc.body.appendChild(div);
}
vector = supportsVectors[browserKey];
while (n--) {
test = toRun[n];
value = vector && vector[n];
if (value !== undefined) {
me[test.identity] = value;
} else if (div || test.early) {
me[test.identity] = test.fn.call(me, doc, div);
} else {
notRun.push(test);
}
}
if (div) {
doc.body.removeChild(div);
}
me.toRun = notRun;
},
//<debug>

generateVector: function() {
var tests = this.tests,
vector = [],
i = 0,
ln = tests.length,
test;
for (; i < ln; i++) {
test = tests[i];
vector.push(this[test.identity] ? 1 : 0);
}
return vector;
},
//</debug>

PointerEvents: 'pointerEvents' in document.documentElement.style,
// IE10/Win8 throws "Access Denied" accessing window.localStorage, so this test
// needs to have a try/catch

LocalStorage: (function() {
try {
return 'localStorage' in window && window['localStorage'] !== null;
} catch (e) {
return false;
}
})(),

CSS3BoxShadow: 'boxShadow' in document.documentElement.style || 'WebkitBoxShadow' in document.documentElement.style || 'MozBoxShadow' in document.documentElement.style,

ClassList: !!document.documentElement.classList,

OrientationChange: ((typeof window.orientation != 'undefined') && ('onorientationchange' in window)),

DeviceMotion: ('ondevicemotion' in window),

// is.Desktop is needed due to the bug in Chrome 5.0.375, Safari 3.1.2
// and Safari 4.0 (they all have 'ontouchstart' in the window object).
Touch: ('ontouchstart' in window) && (!Ext.is.Desktop),

TimeoutActualLateness: (function(){
setTimeout(function(){
Ext.supports.TimeoutActualLateness = arguments.length !== 0;
}, 0);
}()),
tests: [

{
identity: 'Transitions',
fn: function(doc, div) {
var prefix = [
'webkit',
'Moz',
'o',
'ms',
'khtml'
],
TE = 'TransitionEnd',
transitionEndName = [
prefix[0] + TE,
'transitionend', //Moz bucks the prefixing convention
prefix[2] + TE,
prefix[3] + TE,
prefix[4] + TE
],
ln = prefix.length,
i = 0,
out = false;
for (; i < ln; i++) {
if (getStyle(div, prefix[i] + "TransitionProperty")) {
Ext.supports.CSS3Prefix = prefix[i];
Ext.supports.CSS3TransitionEnd = transitionEndName[i];
out = true;
break;
}
}
return out;
}
},

{
identity: 'RightMargin',
fn: function(doc, div) {
var view = doc.defaultView;
return !(view && view.getComputedStyle(div.firstChild.firstChild, null).marginRight != '0px');
}
},

{
identity: 'DisplayChangeInputSelectionBug',
early: true,
fn: function() {
var webKitVersion = Ext.webKitVersion;
// WebKit but older than Safari 5 or Chrome 6:
return 0 < webKitVersion && webKitVersion < 533;
}
},

{
identity: 'DisplayChangeTextAreaSelectionBug',
early: true,
fn: function() {
var webKitVersion = Ext.webKitVersion;

return 0 < webKitVersion && webKitVersion < 534.24;
}
},

{
identity: 'TransparentColor',
fn: function(doc, div, view) {
view = doc.defaultView;
return !(view && view.getComputedStyle(div.lastChild, null).backgroundColor != 'transparent');
}
},

{
identity: 'ComputedStyle',
fn: function(doc, div, view) {
view = doc.defaultView;
return view && view.getComputedStyle;
}
},

{
identity: 'Svg',
fn: function(doc) {
return !!doc.createElementNS && !!doc.createElementNS( "http:/" + "/www.w3.org/2000/svg", "svg").createSVGRect;
}
},

{
identity: 'Canvas',
fn: function(doc) {
return !!doc.createElement('canvas').getContext;
}
},

{
identity: 'Vml',
fn: function(doc) {
var d = doc.createElement("div");
d.innerHTML = "<!--[if vml]><br/><br/><![endif]-->";
return (d.childNodes.length == 2);
}
},

{
identity: 'Float',
fn: function(doc, div) {
return !!div.lastChild.style.cssFloat;
}
},

{
identity: 'AudioTag',
fn: function(doc) {
return !!doc.createElement('audio').canPlayType;
}
},

{
identity: 'History',
fn: function() {
var history = window.history;
return !!(history && history.pushState);
}
},

{
identity: 'CSS3DTransform',
fn: function() {
return (typeof WebKitCSSMatrix != 'undefined' && new WebKitCSSMatrix().hasOwnProperty('m41'));
}
},

{
identity: 'CSS3LinearGradient',
fn: function(doc, div) {
var property = 'background-image:',
webkit = '-webkit-gradient(linear, left top, right bottom, from(black), to(white))',
w3c = 'linear-gradient(left top, black, white)',
moz = '-moz-' + w3c,
ms = '-ms-' + w3c,
opera = '-o-' + w3c,
options = [property + webkit, property + w3c, property + moz, property + ms, property + opera];
div.style.cssText = options.join(';');
return (("" + div.style.backgroundImage).indexOf('gradient') !== -1) && !Ext.isIE9;
}
},

{
identity: 'CSS3BorderRadius',
fn: function(doc, div) {
var domPrefixes = ['borderRadius', 'BorderRadius', 'MozBorderRadius', 'WebkitBorderRadius', 'OBorderRadius', 'KhtmlBorderRadius'],
pass = false,
i;
for (i = 0; i < domPrefixes.length; i++) {
if (document.body.style[domPrefixes[i]] !== undefined) {
return true;
}
}
return pass;
}
},

{
identity: 'GeoLocation',
fn: function() {
// Use the in check for geolocation, see https://github.com/Modernizr/Modernizr/issues/513
return (typeof navigator != 'undefined' && 'geolocation' in navigator) || (typeof google != 'undefined' && typeof google.gears != 'undefined');
}
},

{
identity: 'MouseEnterLeave',
fn: function(doc, div){
return ('onmouseenter' in div && 'onmouseleave' in div);
}
},

{
identity: 'MouseWheel',
fn: function(doc, div) {
return ('onmousewheel' in div);
}
},

{
identity: 'Opacity',
fn: function(doc, div){
// Not a strict equal comparison in case opacity can be converted to a number.
if (Ext.isIE6 || Ext.isIE7 || Ext.isIE8) {
return false;
}
div.firstChild.style.cssText = 'opacity:0.73';
return div.firstChild.style.opacity == '0.73';
}
},

{
identity: 'Placeholder',
fn: function(doc) {
return 'placeholder' in doc.createElement('input');
}
},

{
identity: 'Direct2DBug',
fn: function() {
return Ext.isString(document.body.style.msTransformOrigin) && Ext.isIE10m;
}
},

{
identity: 'BoundingClientRect',
fn: function(doc, div) {
return Ext.isFunction(div.getBoundingClientRect);
}
},

{
identity: 'RotatedBoundingClientRect',
fn: function() {
var body = document.body,
supports = false,
el = document.createElement('div'),
style = el.style;
if (el.getBoundingClientRect) {
style.WebkitTransform = style.MozTransform =
style.OTransform = style.transform = 'rotate(90deg)';
style.width = '100px';
style.height = '30px';
body.appendChild(el)
supports = el.getBoundingClientRect().height !== 100;
body.removeChild(el);
}

return supports;
}
},
{
identity: 'IncludePaddingInWidthCalculation',
fn: function(doc, div){
return div.childNodes[1].firstChild.offsetWidth == 210;
}
},
{
identity: 'IncludePaddingInHeightCalculation',
fn: function(doc, div){
return div.childNodes[1].firstChild.offsetHeight == 210;
}
},

{
identity: 'ArraySort',
fn: function() {
var a = [1,2,3,4,5].sort(function(){ return 0; });
return a[0] === 1 && a[1] === 2 && a[2] === 3 && a[3] === 4 && a[4] === 5;
}
},

{
identity: 'Range',
fn: function() {
return !!document.createRange;
}
},

{
identity: 'CreateContextualFragment',
fn: function() {
var range = Ext.supports.Range ? document.createRange() : false;
return range && !!range.createContextualFragment;
}
},

{
identity: 'WindowOnError',
fn: function () {
// sadly, we cannot feature detect this...
return Ext.isIE || Ext.isGecko || Ext.webKitVersion >= 534.16; // Chrome 10+
}
},

{
identity: 'TextAreaMaxLength',
fn: function(){
var el = document.createElement('textarea');
return ('maxlength' in el);
}
},

// Related bug: https://bugzilla.mozilla.org/show_bug.cgi?id=707691#c7
{
identity: 'GetPositionPercentage',
fn: function(doc, div){
return getStyle(div.childNodes[2], 'left') == '10%';
}
},

{
identity: 'PercentageHeightOverflowBug',
fn: function(doc) {
var hasBug = false,
style, el;
if (Ext.getScrollbarSize().height) {
// must have space-consuming scrollbars for bug to be possible
el = doc.createElement('div');
style = el.style;
style.height = '50px';
style.width = '50px';
style.overflow = 'auto';
style.position = 'absolute';

el.innerHTML = [
'<div style="display:table;height:100%;">',
// The element that causes the horizontal overflow must be 
// a child of the element with the 100% height, otherwise
// horizontal overflow is not triggered in webkit quirks mode
'<div style="width:51px;"></div>',
'</div>'
].join('');
doc.body.appendChild(el);
if (el.firstChild.offsetHeight === 50) {
hasBug = true;
}
doc.body.removeChild(el);
}

return hasBug;
}
},

{
identity: 'xOriginBug',
fn: function(doc, div) {
div.innerHTML = '<div id="b1" style="height:100px;width:100px;direction:rtl;position:relative;overflow:scroll">' +
'<div id="b2" style="position:relative;width:100%;height:20px;"></div>' +
'<div id="b3" style="position:absolute;width:20px;height:20px;top:0px;right:0px"></div>' +
'</div>';
var outerBox = document.getElementById('b1').getBoundingClientRect(),
b2 = document.getElementById('b2').getBoundingClientRect(),
b3 = document.getElementById('b3').getBoundingClientRect();
return (b2.left !== outerBox.left && b3.right !== outerBox.right);
}
},

{
identity: 'ScrollWidthInlinePaddingBug',
fn: function(doc) {
var hasBug = false,
style, el;
el = doc.createElement('div');
style = el.style;
style.height = '50px';
style.width = '50px';
style.padding = '10px';
style.overflow = 'hidden';
style.position = 'absolute';

el.innerHTML =
'<span style="display:inline-block;zoom:1;height:60px;width:60px;"></span>';
doc.body.appendChild(el);
if (el.scrollWidth === 70) {
hasBug = true;
}
doc.body.removeChild(el);

return hasBug;
}
}
]
};
}());
Ext.supports.init(); // run the "early" detections now
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/util/DelayedTask.js */
(function(Ext) {
// @tag dom,core
// @require ../Support.js
// @define Ext.util.DelayedTask
Ext.util.DelayedTask = function(fn, scope, args, cancelOnDelay) {
var me = this,
delay,
call = function() {
clearInterval(me.id);
me.id = null;
fn.apply(scope, args || []);
Ext.EventManager.idleEvent.fire();
};
cancelOnDelay = typeof cancelOnDelay === 'boolean' ? cancelOnDelay : true;

me.id = null;

me.delay = function(newDelay, newFn, newScope, newArgs) {
if (cancelOnDelay) {
me.cancel();
}
delay = newDelay || delay,
fn = newFn || fn;
scope = newScope || scope;
args = newArgs || args;
if (!me.id) {
me.id = setInterval(call, delay);
}
};

me.cancel = function() {
if (me.id) {
clearInterval(me.id);
me.id = null;
}
};
};
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/util/Event.js */
(function(Ext) {
// @tag dom,core
Ext.define('Ext.util.Event', function() {
var arraySlice = Array.prototype.slice,
arrayInsert = Ext.Array.insert,
toArray = Ext.Array.toArray,
DelayedTask = Ext.util.DelayedTask;
return {
requires: 'Ext.util.DelayedTask',

isEvent: true,

// Private. Event suspend count
suspended: 0,
noOptions: {},
constructor: function(observable, name) {
this.name = name;
this.observable = observable;
this.listeners = [];
},
addListener: function(fn, scope, options) {
var me = this,
listeners, listener, priority, isNegativePriority, highestNegativePriorityIndex,
hasNegativePriorityIndex, length, index, i, listenerPriority;
scope = scope || me.observable;
//<debug error>
if (!fn) {
Ext.Error.raise({
sourceClass: Ext.getClassName(this.observable),
sourceMethod: "addListener",
msg: "The specified callback function is undefined"
});
}
//</debug>
if (!me.isListening(fn, scope)) {
listener = me.createListener(fn, scope, options);
if (me.firing) {
// if we are currently firing this event, don't disturb the listener loop
me.listeners = me.listeners.slice(0);
}
listeners = me.listeners;
index = length = listeners.length;
priority = options && options.priority;
highestNegativePriorityIndex = me._highestNegativePriorityIndex;
hasNegativePriorityIndex = (highestNegativePriorityIndex !== undefined);
if (priority) {
// Find the index at which to insert the listener into the listeners array,
// sorted by priority highest to lowest.
isNegativePriority = (priority < 0);
if (!isNegativePriority || hasNegativePriorityIndex) {
// If the priority is a positive number, or if it is a negative number
// and there are other existing negative priority listenrs, then we
// need to calcuate the listeners priority-order index.
// If the priority is a negative number, begin the search for priority
// order index at the index of the highest existing negative priority
// listener, otherwise begin at 0
for(i = (isNegativePriority ? highestNegativePriorityIndex : 0); i < length; i++) {
// Listeners created without options will have no "o" property
listenerPriority = listeners[i].o ? listeners[i].o.priority||0 : 0;
if (listenerPriority < priority) {
index = i;
break;
}
}
} else {
// if the priority is a negative number, and there are no other negative
// priority listeners, then no calculation is needed - the negative
// priority listener gets appended to the end of the listeners array.
me._highestNegativePriorityIndex = index;
}
} else if (hasNegativePriorityIndex) {
// listeners with a priority of 0 or undefined are appended to the end of
// the listeners array unless there are negative priority listeners in the
// listeners array, then they are inserted before the highest negative
// priority listener.
index = highestNegativePriorityIndex;
}
if (!isNegativePriority && index <= highestNegativePriorityIndex) {
me._highestNegativePriorityIndex ++;
}
if (index === length) {
me.listeners[length] = listener;
} else {
arrayInsert(me.listeners, index, [listener]);
}
}
},
createListener: function(fn, scope, o) {
scope = scope || this.observable;
var me = this,
listener = {
fn: fn,
scope: scope,
ev: me
},
handler = fn;
// The order is important. The 'single' wrapper must be wrapped by the 'buffer' and 'delayed' wrapper
// because the event removal that the single listener does destroys the listener's DelayedTask(s)
if (o) {
listener.o = o;
if (o.single) {
handler = me.createSingle(handler, listener, o, scope);
}
if (o.target) {
handler = me.createTargeted(handler, listener, o, scope);
}
if (o.delay) {
handler = me.createDelayed(handler, listener, o, scope);
}
if (o.buffer) {
handler = me.createBuffered(handler, listener, o, scope);
}
}
listener.fireFn = handler;
return listener;
},
findListener: function(fn, scope) {
var listeners = this.listeners,
i = listeners.length,
listener,
s;
while (i--) {
listener = listeners[i];
if (listener) {
s = listener.scope;
// Compare the listener's scope with *JUST THE PASSED SCOPE* if one is passed, and only fall back to the owning Observable if none is passed.
// We cannot use the test (s == scope || s == this.observable)
// Otherwise, if the Observable itself adds Ext.emptyFn as a listener, and then Ext.emptyFn is added under another scope, there will be a false match.
if (listener.fn == fn && (s == (scope || this.observable))) {
return i;
}
}
}
return - 1;
},
isListening: function(fn, scope) {
return this.findListener(fn, scope) !== -1;
},
removeListener: function(fn, scope) {
var me = this,
index,
listener,
highestNegativePriorityIndex,
k;
index = me.findListener(fn, scope);
if (index != -1) {
listener = me.listeners[index];
highestNegativePriorityIndex = me._highestNegativePriorityIndex;
if (me.firing) {
me.listeners = me.listeners.slice(0);
}
// cancel and remove a buffered handler that hasn't fired yet
if (listener.task) {
listener.task.cancel();
delete listener.task;
}
// cancel and remove all delayed handlers that haven't fired yet
k = listener.tasks && listener.tasks.length;
if (k) {
while (k--) {
listener.tasks[k].cancel();
}
delete listener.tasks;
}
// Remove this listener from the listeners array
// We can use splice directly. The IE8 bug which Ext.Array works around only affects *insertion*
// http://social.msdn.microsoft.com/Forums/en-US/iewebdevelopment/thread/6e946d03-e09f-4b22-a4dd-cd5e276bf05a/
me.listeners.splice(index, 1);
// if the listeners array contains negative priority listeners, adjust the
// internal index if needed.
if (highestNegativePriorityIndex) {
if (index < highestNegativePriorityIndex) {
me._highestNegativePriorityIndex --;
} else if (index === highestNegativePriorityIndex && index === me.listeners.length) {
delete me._highestNegativePriorityIndex;
}
}
return true;
}
return false;
},
// Iterate to stop any buffered/delayed events
clearListeners: function() {
var listeners = this.listeners,
i = listeners.length;
while (i--) {
this.removeListener(listeners[i].fn, listeners[i].scope);
}
},
suspend: function() {
this.suspended += 1;
},
resume: function() {
if (this.suspended) {
this.suspended--;
}
},
fire: function() {
var me = this,
listeners = me.listeners,
count = listeners.length,
i,
args,
listener,
len;
if (!me.suspended && count > 0) {
me.firing = true;
args = arguments.length ? arraySlice.call(arguments, 0) : []
len = args.length;
for (i = 0; i < count; i++) {
listener = listeners[i];
if (listener.o) {
args[len] = listener.o;
}
if (listener && listener.fireFn.apply(listener.scope || me.observable, args) === false) {
return (me.firing = false);
}
}
}
me.firing = false;
return true;
},
createTargeted: function (handler, listener, o, scope) {
return function(){
if (o.target === arguments[0]){
handler.apply(scope, arguments);
}
};
},
createBuffered: function (handler, listener, o, scope) {
listener.task = new DelayedTask();
return function() {
listener.task.delay(o.buffer, handler, scope, toArray(arguments));
};
},
createDelayed: function (handler, listener, o, scope) {
return function() {
var task = new DelayedTask();
if (!listener.tasks) {
listener.tasks = [];
}
listener.tasks.push(task);
task.delay(o.delay || 10, handler, scope, toArray(arguments));
};
},
createSingle: function (handler, listener, o, scope) {
return function() {
var event = listener.ev;
if (event.removeListener(listener.fn, scope) && event.observable) {
// Removing from a regular Observable-owned, named event (not an anonymous
// event such as Ext's readyEvent): Decrement the listeners count
event.observable.hasListeners[event.name]--;
}
return handler.apply(scope, arguments);
};
}
};
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/EventManager.js */
(function(Ext) {
// @tag dom,core
// @require util/Event.js
// @define Ext.EventManager
Ext.EventManager = new function() {
var EventManager = this,
doc = document,
win = window,
escapeRx = /\\/g,
prefix = Ext.baseCSSPrefix,
// IE9strict addEventListener has some issues with using synthetic events
supportsAddEventListener = !Ext.isIE9 && 'addEventListener' in doc,
readyEvent,
initExtCss = function() {
// find the body element
var bd = doc.body || doc.getElementsByTagName('body')[0],
cls = [prefix + 'body'],
htmlCls = [],
supportsLG = Ext.supports.CSS3LinearGradient,
supportsBR = Ext.supports.CSS3BorderRadius,
html;
if (!bd) {
return false;
}
html = bd.parentNode;
function add (c) {
cls.push(prefix + c);
}
//Let's keep this human readable!
if (Ext.isIE && Ext.isIE9m) {
add('ie');
// very often CSS needs to do checks like "IE7+" or "IE6 or 7". To help
// reduce the clutter (since CSS/SCSS cannot do these tests), we add some
// additional classes:
//
// x-ie7p : IE7+ : 7 <= ieVer
// x-ie7m : IE7- : ieVer <= 7
// x-ie8p : IE8+ : 8 <= ieVer
// x-ie8m : IE8- : ieVer <= 8
// x-ie9p : IE9+ : 9 <= ieVer
// x-ie78 : IE7 or 8 : 7 <= ieVer <= 8
//
if (Ext.isIE6) {
add('ie6');
} else { // ignore pre-IE6 :)
add('ie7p');
if (Ext.isIE7) {
add('ie7');
} else {
add('ie8p');
if (Ext.isIE8) {
add('ie8');
} else {
add('ie9p');
if (Ext.isIE9) {
add('ie9');
}
}
}
}
if (Ext.isIE7m) {
add('ie7m');
}
if (Ext.isIE8m) {
add('ie8m');
}
if (Ext.isIE9m) {
add('ie9m');
}
if (Ext.isIE7 || Ext.isIE8) {
add('ie78');
}
}

if (Ext.isIE10) {
add('ie10');
}

if (Ext.isGecko) {
add('gecko');
if (Ext.isGecko3) {
add('gecko3');
}
if (Ext.isGecko4) {
add('gecko4');
}
if (Ext.isGecko5) {
add('gecko5');
}
}
if (Ext.isOpera) {
add('opera');
}
if (Ext.isWebKit) {
add('webkit');
}
if (Ext.isSafari) {
add('safari');
if (Ext.isSafari2) {
add('safari2');
}
if (Ext.isSafari3) {
add('safari3');
}
if (Ext.isSafari4) {
add('safari4');
}
if (Ext.isSafari5) {
add('safari5');
}
if (Ext.isSafari5_0) {
add('safari5_0')
}
}
if (Ext.isChrome) {
add('chrome');
}
if (Ext.isMac) {
add('mac');
}
if (Ext.isLinux) {
add('linux');
}
if (!supportsBR) {
add('nbr');
}
if (!supportsLG) {
add('nlg');
}
// add to the parent to allow for selectors x-strict x-border-box, also set the isBorderBox property correctly
if (html) {
if (Ext.isStrict && (Ext.isIE6 || Ext.isIE7)) {
Ext.isBorderBox = false;
}
else {
Ext.isBorderBox = true;
}
if(!Ext.isBorderBox) {
htmlCls.push(prefix + 'content-box');
}
if (Ext.isStrict) {
htmlCls.push(prefix + 'strict');
} else {
htmlCls.push(prefix + 'quirks');
}
Ext.fly(html, '_internal').addCls(htmlCls);
}
Ext.fly(bd, '_internal').addCls(cls);
return true;
};
Ext.apply(EventManager, {

hasBoundOnReady: false,

hasFiredReady: false,

deferReadyEvent : 1,

onReadyChain : [],

readyEvent:
(function () {
readyEvent = new Ext.util.Event();
readyEvent.fire = function () {
Ext._beforeReadyTime = Ext._beforeReadyTime || new Date().getTime();
readyEvent.self.prototype.fire.apply(readyEvent, arguments);
Ext._afterReadytime = new Date().getTime();
};
return readyEvent;
}()),

idleEvent: new Ext.util.Event(),

isReadyPaused: function(){
return (/[?&]ext-pauseReadyFire\b/i.test(location.search) && !Ext._continueFireReady);
},

bindReadyEvent: function() {
if (EventManager.hasBoundOnReady) {
return;
}
// Test scenario where Core is dynamically loaded AFTER window.load
if ( doc.readyState == 'complete' ) { // Firefox4+ got support for this state, others already do.
EventManager.onReadyEvent({
type: doc.readyState || 'body'
});
} else {
doc.addEventListener('DOMContentLoaded', EventManager.onReadyEvent, false);
win.addEventListener('load', EventManager.onReadyEvent, false);
EventManager.hasBoundOnReady = true;
}
},
onReadyEvent : function(e) {
if (e && e.type) {
EventManager.onReadyChain.push(e.type);
}
if (EventManager.hasBoundOnReady) {
doc.removeEventListener('DOMContentLoaded', EventManager.onReadyEvent, false);
win.removeEventListener('load', EventManager.onReadyEvent, false);
}
if (!Ext.isReady) {
EventManager.fireDocReady();
}
},

fireDocReady: function() {
if (!Ext.isReady) {
Ext._readyTime = new Date().getTime();
Ext.isReady = true;
Ext.supports.init();
EventManager.onWindowUnload();
readyEvent.onReadyChain = EventManager.onReadyChain; //diags report
if (Ext.isNumber(EventManager.deferReadyEvent)) {
Ext.Function.defer(EventManager.fireReadyEvent, EventManager.deferReadyEvent);
EventManager.hasDocReadyTimer = true;
} else {
EventManager.fireReadyEvent();
}
}
},

fireReadyEvent: function() {
// Unset the timer flag here since other onReady events may be
// added during the fire() call and we don't want to block them
EventManager.hasDocReadyTimer = false;
EventManager.isFiring = true;
// Ready events are all single: true, if we get to the end
// & there are more listeners, it means they were added
// inside some other ready event
while (readyEvent.listeners.length && !EventManager.isReadyPaused()) {
readyEvent.fire();
}
EventManager.isFiring = false;
EventManager.hasFiredReady = true;
Ext.EventManager.idleEvent.fire();
},

onDocumentReady: function(fn, scope, options) {
options = options || {};
// force single, only ever fire it once
options.single = true;
readyEvent.addListener(fn, scope, options);
// If we're in the middle of firing, or we have a deferred timer
// pending, drop out since the event will be fired later
if (!(EventManager.isFiring || EventManager.hasDocReadyTimer)) {
if (Ext.isReady) {
EventManager.fireReadyEvent();
} else {
EventManager.bindReadyEvent();
}
}
},
// --------------------- event binding ---------------------

stoppedMouseDownEvent: new Ext.util.Event(),

propRe: /^(?:scope|delay|buffer|single|stopEvent|preventDefault|stopPropagation|normalized|args|delegate|freezeEvent)$/,

getId : function(element) {
var id;
element = Ext.getDom(element);
if (element === doc || element === win) {
id = element === doc ? Ext.documentId : Ext.windowId;
}
else {
id = Ext.id(element);
}
if (!Ext.cache[id]) {
Ext.addCacheEntry(id, null, element);
}
return id;
},

prepareListenerConfig: function(element, config, isRemove) {
var propRe = EventManager.propRe,
key, value, args;
// loop over all the keys in the object
for (key in config) {
if (config.hasOwnProperty(key)) {
// if the key is something else then an event option
if (!propRe.test(key)) {
value = config[key];
// if the value is a function it must be something like click: function() {}, scope: this
// which means that there might be multiple event listeners with shared options
if (typeof value == 'function') {
// shared options
args = [element, key, value, config.scope, config];
} else {
// if its not a function, it must be an object like click: {fn: function() {}, scope: this}
args = [element, key, value.fn, value.scope, value];
}
if (isRemove) {
EventManager.removeListener.apply(EventManager, args);
} else {
EventManager.addListener.apply(EventManager, args);
}
}
}
}
},
mouseEnterLeaveRe: /mouseenter|mouseleave/,

normalizeEvent: function(eventName, fn) {
if (EventManager.mouseEnterLeaveRe.test(eventName) && !Ext.supports.MouseEnterLeave) {
if (fn) {
fn = Ext.Function.createInterceptor(fn, EventManager.contains);
}
eventName = eventName == 'mouseenter' ? 'mouseover' : 'mouseout';
} else if (eventName == 'mousewheel' && !Ext.supports.MouseWheel && !Ext.isOpera) {
eventName = 'DOMMouseScroll';
}
return {
eventName: eventName,
fn: fn
};
},

contains: function(event) {
event = event.browserEvent || event;
var parent = event.currentTarget,
child = EventManager.getRelatedTarget(event);
if (parent && parent.firstChild) {
while (child) {
if (child === parent) {
return false;
}
child = child.parentNode;
if (child && (child.nodeType != 1)) {
child = null;
}
}
}
return true;
},

addListener: function(element, eventName, fn, scope, options) {
// Check if we've been passed a "config style" event.
if (typeof eventName !== 'string') {
EventManager.prepareListenerConfig(element, eventName);
return;
}
var dom = element.dom || Ext.getDom(element),
hasAddEventListener, bind, wrap, cache, id, cacheItem, capture;

if (typeof fn === 'string') {
fn = Ext.resolveMethod(fn, scope || element);
}
//<debug>
if (!fn) {
Ext.Error.raise({
sourceClass: 'Ext.EventManager',
sourceMethod: 'addListener',
targetElement: element,
eventName: eventName,
msg: 'Error adding "' + eventName + '\" listener. The handler function is undefined.'
});
}
//</debug>
// create the wrapper function
options = options || {};
bind = EventManager.normalizeEvent(eventName, fn);
wrap = EventManager.createListenerWrap(dom, eventName, bind.fn, scope, options);

// add all required data into the event cache
cache = EventManager.getEventListenerCache(element.dom ? element : dom, eventName);
eventName = bind.eventName;
// In IE9 we prefer to use attachEvent but it's not available for some Elements (SVG)
hasAddEventListener = supportsAddEventListener || (Ext.isIE9 && !dom.attachEvent);

if (!hasAddEventListener) {
id = EventManager.normalizeId(dom);
// If there's no id we don't have any events bound, so we never
// need to clone at this point.
if (id) {
cacheItem = Ext.cache[id][eventName];
if (cacheItem && cacheItem.firing) {
// If we're in the middle of firing we want to update the class
// cache reference so it is different to the array we referenced
// when we started firing the event. Though this is a more difficult
// way of not mutating the collection while firing, a vast majority of
// the time we won't be adding listeners for the same element/event type
// while firing the same event.
cache = EventManager.cloneEventListenerCache(dom, eventName);
}
}
}
capture = !!options.capture;
cache.push({
fn: fn,
wrap: wrap,
scope: scope,
capture: capture 
});
if (!hasAddEventListener) {
// If cache length is 1, it means we're binding the first event
// for this element for this type
if (cache.length === 1) {
id = EventManager.normalizeId(dom, true);
fn = Ext.Function.bind(EventManager.handleSingleEvent, EventManager, [id, eventName], true);
Ext.cache[id][eventName] = {
firing: false,
fn: fn
};
dom.attachEvent('on' + eventName, fn);
}
} else {
dom.addEventListener(eventName, wrap, capture);
}
if (dom == doc && eventName == 'mousedown') {
EventManager.stoppedMouseDownEvent.addListener(wrap);
}
},

// Handle the case where the window/document already has an id attached.
// In this case we still want to return our custom window/doc id.
normalizeId: function(dom, force) {
var id;
if (dom === document) {
id = Ext.documentId;
} else if (dom === window) {
id = Ext.windowId;
} else {
id = dom.id;
}
if (!id && force) {
id = EventManager.getId(dom);
}
return id;
},

handleSingleEvent: function(e, id, eventName) {
// Don't create a copy here, since we fire lots of events and it's likely
// that we won't add an event during a fire. Instead, we'll handle this during
// the process of adding events 
var listenerCache = EventManager.getEventListenerCache(id, eventName),
attachItem = Ext.cache[id][eventName],
len, i;

// Typically this will never occur, however, the framework allows the creation
// of synthetic events in Ext.EventObject. As such, it makes it possible to fire
// off the same event on the same element during this method.
if (attachItem.firing) {
return;
}

attachItem.firing = true;
for (i = 0, len = listenerCache.length; i < len; ++i) {
listenerCache[i].wrap(e);
}
attachItem.firing = false;

},

removeListener : function(element, eventName, fn, scope) {
// handle our listener config object syntax
if (typeof eventName !== 'string') {
EventManager.prepareListenerConfig(element, eventName, true);
return;
}
var dom = Ext.getDom(element),
id, el = element.dom ? element : Ext.get(dom),
cache = EventManager.getEventListenerCache(el, eventName),
bindName = EventManager.normalizeEvent(eventName).eventName,
i = cache.length, j, cacheItem, hasRemoveEventListener,
listener, wrap;

if (!dom) {
return;
}
// In IE9 we prefer to use detachEvent but it's not available for some Elements (SVG)
hasRemoveEventListener = supportsAddEventListener || (Ext.isIE9 && !dom.detachEvent);

if (typeof fn === 'string') {
fn = Ext.resolveMethod(fn, scope || element);
}
while (i--) {
listener = cache[i];
if (listener && (!fn || listener.fn == fn) && (!scope || listener.scope === scope)) {
wrap = listener.wrap;
// clear buffered calls
if (wrap.task) {
clearTimeout(wrap.task);
delete wrap.task;
}
// clear delayed calls
j = wrap.tasks && wrap.tasks.length;
if (j) {
while (j--) {
clearTimeout(wrap.tasks[j]);
}
delete wrap.tasks;
}
if (!hasRemoveEventListener) {
// if length is 1, we're removing the final event, actually
// unbind it from the element
id = EventManager.normalizeId(dom, true);
cacheItem = Ext.cache[id][bindName];
if (cacheItem && cacheItem.firing) {
// See code in addListener for why we create a copy
cache = EventManager.cloneEventListenerCache(dom, bindName);
}

if (cache.length === 1) {
fn = cacheItem.fn;
delete Ext.cache[id][bindName];
dom.detachEvent('on' + bindName, fn);
}
} else {
dom.removeEventListener(bindName, wrap, listener.capture);
}
if (wrap && dom == doc && eventName == 'mousedown') {
EventManager.stoppedMouseDownEvent.removeListener(wrap);
}
// remove listener from cache
Ext.Array.erase(cache, i, 1);
}
}
},

removeAll : function(element) {
var id = (typeof element === 'string') ? element : element.id,
cache, events, eventName;
// If the element does not have an ID or a cache entry for its ID, then this is a no-op
if (id && (cache = Ext.cache[id])) {
events = cache.events;

for (eventName in events) {
if (events.hasOwnProperty(eventName)) {
EventManager.removeListener(element, eventName);
}
}
cache.events = {};
}
},

purgeElement : function(element, eventName) {
var dom = Ext.getDom(element),
i = 0, len, childNodes;
if (eventName) {
EventManager.removeListener(element, eventName);
} else {
EventManager.removeAll(element);
}
if (dom && dom.childNodes) {
childNodes = dom.childNodes;
for (len = childNodes.length; i < len; i++) {
EventManager.purgeElement(childNodes[i], eventName);
}
}
},

createListenerWrap : function(dom, ename, fn, scope, options) {
options = options || {};
var f, gen, wrap = function(e, args) {
// Compile the implementation upon first firing
if (!gen) {
f = ['if(!' + Ext.name + ') {return;}'];
if (options.buffer || options.delay || options.freezeEvent) {
if (options.freezeEvent) {
// If we're freezing, we still want to update the singleton event object
// as well as returning a frozen copy
f.push('e = X.EventObject.setEvent(e);');
}
f.push('e = new X.EventObjectImpl(e, ' + (options.freezeEvent ? 'true' : 'false' ) + ');');
} else {
f.push('e = X.EventObject.setEvent(e);');
}
if (options.delegate) {
// double up '\' characters so escape sequences survive the
// string-literal translation
f.push('var result, t = e.getTarget("' + (options.delegate + '').replace(escapeRx, '\\\\') + '", this);');
f.push('if(!t) {return;}');
} else {
f.push('var t = e.target, result;');
}
if (options.target) {
f.push('if(e.target !== options.target) {return;}');
}
if (options.stopEvent) {
f.push('e.stopEvent();');
} else {
if(options.preventDefault) {
f.push('e.preventDefault();');
}
if(options.stopPropagation) {
f.push('e.stopPropagation();');
}
}
if (options.normalized === false) {
f.push('e = e.browserEvent;');
}
if (options.buffer) {
f.push('(wrap.task && clearTimeout(wrap.task));');
f.push('wrap.task = setTimeout(function() {');
}
if (options.delay) {
f.push('wrap.tasks = wrap.tasks || [];');
f.push('wrap.tasks.push(setTimeout(function() {');
}
// finally call the actual handler fn
f.push('result = fn.call(scope || dom, e, t, options);');
if (options.single) {
f.push('evtMgr.removeListener(dom, ename, fn, scope);');
}
// Fire the global idle event for all events except mousemove which is too common, and
// fires too frequently and fast to be use in tiggering onIdle processing. Do not fire on page unload.
if (ename !== 'mousemove' && ename !== 'unload') {
f.push('if (evtMgr.idleEvent.listeners.length) {');
f.push('evtMgr.idleEvent.fire();');
f.push('}');
}
if (options.delay) {
f.push('}, ' + options.delay + '));');
}
if (options.buffer) {
f.push('}, ' + options.buffer + ');');
}
f.push('return result;');
gen = Ext.cacheableFunctionFactory('e', 'options', 'fn', 'scope', 'ename', 'dom', 'wrap', 'args', 'X', 'evtMgr', f.join('\n'));
}
return gen.call(dom, e, options, fn, scope, ename, dom, wrap, args, Ext, EventManager);
};
return wrap;
},


getEventCache: function(element) {
var elementCache, eventCache, id;

if (!element) {
return [];
}
if (element.$cache) {
elementCache = element.$cache;
} else {
// getId will populate the cache for this element if it isn't already present
if (typeof element === 'string') {
id = element;
} else {
id = EventManager.getId(element);
}
elementCache = Ext.cache[id];
}
eventCache = elementCache.events || (elementCache.events = {});
return eventCache;
},

getEventListenerCache : function(element, eventName) {
var eventCache = EventManager.getEventCache(element);
return eventCache[eventName] || (eventCache[eventName] = []);
},


cloneEventListenerCache: function(element, eventName){
var eventCache = EventManager.getEventCache(element),
out;

if (eventCache[eventName]) {
out = eventCache[eventName].slice(0);
} else {
out = [];
}
eventCache[eventName] = out;
return out;
},
// --------------------- utility methods ---------------------
mouseLeaveRe: /(mouseout|mouseleave)/,
mouseEnterRe: /(mouseover|mouseenter)/,

stopEvent: function(event) {
EventManager.stopPropagation(event);
EventManager.preventDefault(event);
},

stopPropagation: function(event) {
event = event.browserEvent || event;
if (event.stopPropagation) {
event.stopPropagation();
} else {
event.cancelBubble = true;
}
},

preventDefault: function(event) {
event = event.browserEvent || event;
if (event.preventDefault) {
event.preventDefault();
} else {
event.returnValue = false;
// Some keys events require setting the keyCode to -1 to be prevented
try {
// all ctrl + X and F1 -> F12
if (event.ctrlKey || event.keyCode > 111 && event.keyCode < 124) {
event.keyCode = -1;
}
} catch (e) {
// see this outdated document http://support.microsoft.com/kb/934364/en-us for more info
}
}
},

getRelatedTarget: function(event) {
event = event.browserEvent || event;
var target = event.relatedTarget;
if (!target) {
if (EventManager.mouseLeaveRe.test(event.type)) {
target = event.toElement;
} else if (EventManager.mouseEnterRe.test(event.type)) {
target = event.fromElement;
}
}
return EventManager.resolveTextNode(target);
},

getPageX: function(event) {
return EventManager.getPageXY(event)[0];
},

getPageY: function(event) {
return EventManager.getPageXY(event)[1];
},

getPageXY: function(event) {
event = event.browserEvent || event;
var x = event.pageX,
y = event.pageY,
docEl = doc.documentElement,
body = doc.body;
// pageX/pageY not available (undefined, not null), use clientX/clientY instead
if (!x && x !== 0) {
x = event.clientX + (docEl && docEl.scrollLeft || body && body.scrollLeft || 0) - (docEl && docEl.clientLeft || body && body.clientLeft || 0);
y = event.clientY + (docEl && docEl.scrollTop || body && body.scrollTop || 0) - (docEl && docEl.clientTop || body && body.clientTop || 0);
}
return [x, y];
},

getTarget: function(event) {
event = event.browserEvent || event;
return EventManager.resolveTextNode(event.target || event.srcElement);
},
// technically no need to browser sniff this, however it makes
// no sense to check this every time, for every event, whether
// the string is equal.

resolveTextNode: Ext.isGecko ?
function(node) {
if (node) {
// work around firefox bug, https://bugzilla.mozilla.org/show_bug.cgi?id=101197
var s = HTMLElement.prototype.toString.call(node);
if (s !== '[xpconnect wrapped native prototype]' && s !== '[object XULElement]') {
return node.nodeType == 3 ? node.parentNode: node;
}
}
}
:
function(node) {
return node && node.nodeType == 3 ? node.parentNode: node;
},
// --------------------- custom event binding ---------------------
// Keep track of the current width/height
curWidth: 0,
curHeight: 0,

onWindowResize: function(fn, scope, options) {
var resize = EventManager.resizeEvent;
if (!resize) {
EventManager.resizeEvent = resize = new Ext.util.Event();
EventManager.on(win, 'resize', EventManager.fireResize, null, {buffer: 100});
}
resize.addListener(fn, scope, options);
},

fireResize: function() {
var w = Ext.Element.getViewWidth(),
h = Ext.Element.getViewHeight();
//whacky problem in IE where the resize event will sometimes fire even though the w/h are the same.
if (EventManager.curHeight != h || EventManager.curWidth != w) {
EventManager.curHeight = h;
EventManager.curWidth = w;
EventManager.resizeEvent.fire(w, h);
}
},

removeResizeListener: function(fn, scope) {
var resize = EventManager.resizeEvent;
if (resize) {
resize.removeListener(fn, scope);
}
},

onWindowUnload: function(fn, scope, options) {
var unload = EventManager.unloadEvent;
if (!unload) {
EventManager.unloadEvent = unload = new Ext.util.Event();
EventManager.addListener(win, 'unload', EventManager.fireUnload);
}
if (fn) {
unload.addListener(fn, scope, options);
}
},

fireUnload: function() {
// wrap in a try catch, could have some problems during unload
try {
// relinquish references.
doc = win = undefined;
var gridviews, i, ln,
el, cache;
EventManager.unloadEvent.fire();
// Work around FF3 remembering the last scroll position when refreshing the grid and then losing grid view
if (Ext.isGecko3) {
gridviews = Ext.ComponentQuery.query('gridview');
i = 0;
ln = gridviews.length;
for (; i < ln; i++) {
gridviews[i].scrollToTop();
}
}
// Purge all elements in the cache
cache = Ext.cache;
for (el in cache) {
if (cache.hasOwnProperty(el)) {
EventManager.removeAll(el);
}
}
} catch(e) {
}
},

removeUnloadListener: function(fn, scope) {
var unload = EventManager.unloadEvent;
if (unload) {
unload.removeListener(fn, scope);
}
},

useKeyDown: Ext.isWebKit ?
parseInt(navigator.userAgent.match(/AppleWebKit\/(\d+)/)[1], 10) >= 525 :
!((Ext.isGecko && !Ext.isWindows) || Ext.isOpera),

getKeyEvent: function() {
return EventManager.useKeyDown ? 'keydown' : 'keypress';
}
});
// route "< ie9-Standards" to a legacy IE onReady implementation
if(!supportsAddEventListener && document.attachEvent) {
Ext.apply( EventManager, {


pollScroll : function() {
var scrollable = true;
try {
document.documentElement.doScroll('left');
} catch(e) {
scrollable = false;
}
// on IE8, when running within an iFrame, document.body is not immediately available
if (scrollable && document.body) {
EventManager.onReadyEvent({
type:'doScroll'
});
} else {

EventManager.scrollTimeout = setTimeout(EventManager.pollScroll, 20);
}
return scrollable;
},

scrollTimeout: null,

readyStatesRe : /complete/i,

checkReadyState: function() {
var state = document.readyState;
if (EventManager.readyStatesRe.test(state)) {
EventManager.onReadyEvent({
type: state
});
}
},
bindReadyEvent: function() {
var topContext = true;
if (EventManager.hasBoundOnReady) {
return;
}
//are we in an IFRAME? (doScroll ineffective here)
try {
topContext = window.frameElement === undefined;
} catch(e) {
// If we throw an exception, it means we're probably getting access denied,
// which means we're in an iframe cross domain.
topContext = false;
}
if (!topContext || !doc.documentElement.doScroll) {
EventManager.pollScroll = Ext.emptyFn; //then noop this test altogether
}
// starts doScroll polling if necessary
if (EventManager.pollScroll() === true) {
return;
}
// Core is loaded AFTER initial document write/load ?
if (doc.readyState == 'complete' ) {
EventManager.onReadyEvent({type: 'already ' + (doc.readyState || 'body') });
} else {
doc.attachEvent('onreadystatechange', EventManager.checkReadyState);
window.attachEvent('onload', EventManager.onReadyEvent);
EventManager.hasBoundOnReady = true;
}
},
onReadyEvent : function(e) {
if (e && e.type) {
EventManager.onReadyChain.push(e.type);
}
if (EventManager.hasBoundOnReady) {
document.detachEvent('onreadystatechange', EventManager.checkReadyState);
window.detachEvent('onload', EventManager.onReadyEvent);
}
if (Ext.isNumber(EventManager.scrollTimeout)) {
clearTimeout(EventManager.scrollTimeout);
delete EventManager.scrollTimeout;
}
if (!Ext.isReady) {
EventManager.fireDocReady();
}
},
//diags: a list of event types passed to onReadyEvent (in chron order)
onReadyChain : []
});
}

Ext.onReady = function(fn, scope, options) {
Ext.Loader.onReady(fn, scope, true, options);
};

Ext.onDocumentReady = EventManager.onDocumentReady;

EventManager.on = EventManager.addListener;

EventManager.un = EventManager.removeListener;
Ext.onReady(initExtCss);
};
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/util/Observable.js */
(function(Ext) {
// @tag core
Ext.define('Ext.util.Observable', function(Observable) {
// Private Destroyable class which removes listeners
var emptyArray = [],
arrayProto = Array.prototype,
arraySlice = arrayProto.slice,
ExtEvent = Ext.util.Event,
ListenerRemover = function(observable) {
// Passed a ListenerRemover: return it
if (observable instanceof ListenerRemover) {
return observable;
}
this.observable = observable;
// Called when addManagedListener is used with the event source as the second arg:
// (owner, eventSource, args...)
if (arguments[1].isObservable) {
this.managedListeners = true;
}
this.args = arraySlice.call(arguments, 1);
};
ListenerRemover.prototype.destroy = function() {
this.observable[this.managedListeners ? 'mun' : 'un'].apply(this.observable, this.args);
};
return {

requires: ['Ext.util.Event', 'Ext.EventManager'],
statics: {

releaseCapture: function(o) {
o.fireEventArgs = this.prototype.fireEventArgs;
},

capture: function(o, fn, scope) {
// We're capturing calls to fireEventArgs to avoid duplication of events;
// however fn expects fireEvent's signature so we have to convert it here.
// To avoid unnecessary conversions, observe() below is aware of the changes
// and will capture fireEventArgs instead.
var newFn = function(eventName, args) {
return fn.apply(scope, [eventName].concat(args));
}

this.captureArgs(o, newFn, scope);
},


captureArgs: function(o, fn, scope) {
o.fireEventArgs = Ext.Function.createInterceptor(o.fireEventArgs, fn, scope);
},

observe: function(cls, listeners) {
if (cls) {
if (!cls.isObservable) {
Ext.applyIf(cls, new this());
this.captureArgs(cls.prototype, cls.fireEventArgs, cls);
}
if (Ext.isObject(listeners)) {
cls.on(listeners);
}
}
return cls;
},

prepareClass: function (T, mixin) {
// T.hasListeners is the object to track listeners on class T. This object's
// prototype (__proto__) is the "hasListeners" of T.superclass.
// Instances of T will create "hasListeners" that have T.hasListeners as their
// immediate prototype (__proto__).
if (!T.HasListeners) {
// We create a HasListeners "class" for this class. The "prototype" of the
// HasListeners class is an instance of the HasListeners class associated
// with this class's super class (or with Observable).
var HasListeners = function () {},
SuperHL = T.superclass.HasListeners || (mixin && mixin.HasListeners) ||
Observable.HasListeners;
// Make the HasListener class available on the class and its prototype:
T.prototype.HasListeners = T.HasListeners = HasListeners;
// And connect its "prototype" to the new HasListeners of our super class
// (which is also the class-level "hasListeners" instance).
HasListeners.prototype = T.hasListeners = new SuperHL();
}
}
},



isObservable: true,

eventsSuspended: 0,

constructor: function(config) {
var me = this;
Ext.apply(me, config);
// The subclass may have already initialized it.
if (!me.hasListeners) {
me.hasListeners = new me.HasListeners();
}
me.events = me.events || {};
if (me.listeners) {
me.on(me.listeners);
me.listeners = null; //Set as an instance property to pre-empt the prototype in case any are set there.
}
if (me.bubbleEvents) {
me.enableBubble(me.bubbleEvents);
}
},
onClassExtended: function (T) {
if (!T.HasListeners) {
// Some classes derive from us and some others derive from those classes. All
// of these are passed to this method.
Observable.prepareClass(T);
}
},
// @private
// Matches options property names within a listeners specification object - property names which are never used as event names.
eventOptionsRe : /^(?:scope|delay|buffer|single|stopEvent|preventDefault|stopPropagation|normalized|args|delegate|element|destroyable|vertical|horizontal|freezeEvent|priority)$/,

addManagedListener: function(item, ename, fn, scope, options, noDestroy) {
var me = this,
managedListeners = me.managedListeners = me.managedListeners || [],
config, passedOptions;
if (typeof ename !== 'string') {
// When creating listeners using the object form, allow caller to override the default of
// using the listeners object as options.
// This is used by relayEvents, when adding its relayer so that it does not contibute
// a spurious options param to the end of the arg list.
passedOptions = arguments.length > 4 ? options : ename;
options = ename;
for (ename in options) {
if (options.hasOwnProperty(ename)) {
config = options[ename];
if (!me.eventOptionsRe.test(ename)) {
// recurse, but pass the noDestroy parameter as true so that lots of individual Destroyables are not created.
// We create a single one at the end if necessary.
me.addManagedListener(item, ename, config.fn || config, config.scope || options.scope || scope, config.fn ? config : passedOptions, true);
}
}
}
if (options && options.destroyable) {
return new ListenerRemover(me, item, options);
}
}
else {
if (typeof fn === 'string') {
scope = scope || me;
fn = Ext.resolveMethod(fn, scope);
}

managedListeners.push({
item: item,
ename: ename,
fn: fn,
scope: scope,
options: options
});
item.on(ename, fn, scope, options);
// The 'noDestroy' flag is sent if we're looping through a hash of listeners passing each one to addManagedListener separately
if (!noDestroy && options && options.destroyable) {
return new ListenerRemover(me, item, ename, fn, scope);
}
}
},

removeManagedListener: function(item, ename, fn, scope) {
var me = this,
options,
config,
managedListeners,
length,
i, func;
if (typeof ename !== 'string') {
options = ename;
for (ename in options) {
if (options.hasOwnProperty(ename)) {
config = options[ename];
if (!me.eventOptionsRe.test(ename)) {
me.removeManagedListener(item, ename, config.fn || config, config.scope || options.scope || scope);
}
}
}
} else {
managedListeners = me.managedListeners ? me.managedListeners.slice() : [];

if (typeof fn === 'string') {
scope = scope || me;
fn = Ext.resolveMethod(fn, scope);
}
for (i = 0, length = managedListeners.length; i < length; i++) {
me.removeManagedListenerItem(false, managedListeners[i], item, ename, fn, scope);
}
}
},

fireEvent: function(eventName) {
return this.fireEventArgs(eventName, arraySlice.call(arguments, 1));
},

fireEventArgs: function(eventName, args) {
eventName = eventName.toLowerCase();
var me = this,
events = me.events,
event = events && events[eventName],
ret = true;
// Only continue firing the event if there are listeners to be informed.
// Bubbled events will always have a listener count, so will be fired.
if (event && me.hasListeners[eventName]) {
ret = me.continueFireEvent(eventName, args || emptyArray, event.bubble);
}
return ret;
},

continueFireEvent: function(eventName, args, bubbles) {
var target = this,
queue, event,
ret = true;
do {
if (target.eventsSuspended) {
if ((queue = target.eventQueue)) {
queue.push([eventName, args, bubbles]);
}
return ret;
} else {
event = target.events[eventName];
// Continue bubbling if event exists and it is `true` or the handler didn't returns false and it
// configure to bubble.
if (event && event !== true) {
if ((ret = event.fire.apply(event, args)) === false) {
break;
}
}
}
} while (bubbles && (target = target.getBubbleParent()));
return ret;
},

getBubbleParent: function() {
var me = this, parent = me.getBubbleTarget && me.getBubbleTarget();
if (parent && parent.isObservable) {
return parent;
}
return null;
},

addListener: function(ename, fn, scope, options) {
var me = this,
config, event,
prevListenerCount = 0;
// Object listener hash passed
if (typeof ename !== 'string') {
options = ename;
for (ename in options) {
if (options.hasOwnProperty(ename)) {
config = options[ename];
if (!me.eventOptionsRe.test(ename)) {

me.addListener(ename, config.fn || config, config.scope || options.scope, config.fn ? config : options);
}
}
}
if (options && options.destroyable) {
return new ListenerRemover(me, options);
}
}
// String, function passed
else {
ename = ename.toLowerCase();
event = me.events[ename];
if (event && event.isEvent) {
prevListenerCount = event.listeners.length;
} else {
me.events[ename] = event = new ExtEvent(me, ename);
}
//<debug>
if (!fn) {
Ext.Error.raise('No function passed for event ' + me.$className + '.' + ename);
}
//</debug>
// Allow listeners: { click: 'onClick', scope: myObject }
if (typeof fn === 'string') {
scope = scope || me;
fn = Ext.resolveMethod(fn, scope);
}
event.addListener(fn, scope, options);
// If a new listener has been added (Event.addListener rejects duplicates of the same fn+scope)
// then increment the hasListeners counter
if (event.listeners.length !== prevListenerCount) {
me.hasListeners._incr_(ename);
}
if (options && options.destroyable) {
return new ListenerRemover(me, ename, fn, scope, options);
}
}
},

removeListener: function(ename, fn, scope) {
var me = this,
config,
event,
options;
if (typeof ename !== 'string') {
options = ename;
for (ename in options) {
if (options.hasOwnProperty(ename)) {
config = options[ename];
if (!me.eventOptionsRe.test(ename)) {
me.removeListener(ename, config.fn || config, config.scope || options.scope);
}
}
}
} else {
ename = ename.toLowerCase();
event = me.events[ename];
if (event && event.isEvent) {
if (typeof fn === 'string') {
scope = scope || me;
fn = Ext.resolveMethod(fn, scope);
}

if (event.removeListener(fn, scope)) {
me.hasListeners._decr_(ename);
}
}
}
},

clearListeners: function() {
var events = this.events,
hasListeners = this.hasListeners,
event,
key;
for (key in events) {
if (events.hasOwnProperty(key)) {
event = events[key];
if (event.isEvent) {
delete hasListeners[key];
event.clearListeners();
}
}
}
this.clearManagedListeners();
},
//<debug>
purgeListeners : function() {
if (Ext.global.console) {
Ext.global.console.warn('Observable: purgeListeners has been deprecated. Please use clearListeners.');
}
return this.clearListeners.apply(this, arguments);
},
//</debug>

clearManagedListeners : function() {
var managedListeners = this.managedListeners || [],
i = 0,
len = managedListeners.length;
for (; i < len; i++) {
this.removeManagedListenerItem(true, managedListeners[i]);
}
this.managedListeners = [];
},

removeManagedListenerItem: function(isClear, managedListener, item, ename, fn, scope){
if (isClear || (managedListener.item === item && managedListener.ename === ename && (!fn || managedListener.fn === fn) && (!scope || managedListener.scope === scope))) {
managedListener.item.un(managedListener.ename, managedListener.fn, managedListener.scope);
if (!isClear) {
Ext.Array.remove(this.managedListeners, managedListener);
}
}
},
//<debug>
purgeManagedListeners : function() {
if (Ext.global.console) {
Ext.global.console.warn('Observable: purgeManagedListeners has been deprecated. Please use clearManagedListeners.');
}
return this.clearManagedListeners.apply(this, arguments);
},
//</debug>

addEvents: function(o) {
var me = this,
events = me.events || (me.events = {}),
arg, args, i;
if (typeof o == 'string') {
for (args = arguments, i = args.length; i--; ) {
arg = args[i];
if (!events[arg]) {
events[arg] = true;
}
}
} else {
Ext.applyIf(me.events, o);
}
},

hasListener: function(ename) {
return !!this.hasListeners[ename.toLowerCase()];
},

suspendEvents: function(queueSuspended) {
this.eventsSuspended += 1;
if (queueSuspended && !this.eventQueue) {
this.eventQueue = [];
}
},

suspendEvent: function(eventName) {
var len = arguments.length,
i, event;
for (i = 0; i < len; i++) {
event = this.events[arguments[i]];
// If it exists, and is an Event object (not still a boolean placeholder), suspend it
if (event && event.suspend) {
event.suspend();
}
}
},

resumeEvent: function() {
var len = arguments.length,
i, event;
for (i = 0; i < len; i++) {
// If it exists, and is an Event object (not still a boolean placeholder), resume it
event = this.events[arguments[i]];
if (event && event.resume) {
event.resume();
}
}
},

resumeEvents: function() {
var me = this,
queued = me.eventQueue,
qLen, q;
if (me.eventsSuspended && ! --me.eventsSuspended) {
delete me.eventQueue;
if (queued) {
qLen = queued.length;
for (q = 0; q < qLen; q++) {
me.continueFireEvent.apply(me, queued[q]);
}
}
}
},

relayEvents : function(origin, events, prefix) {
var me = this,
len = events.length,
i = 0,
oldName,
relayers = {};
for (; i < len; i++) {
oldName = events[i];
// Build up the listener hash.
relayers[oldName] = me.createRelayer(prefix ? prefix + oldName : oldName);
}
// Add the relaying listeners as ManagedListeners so that they are removed when this.clearListeners is called (usually when _this_ is destroyed)
// Explicitly pass options as undefined so that the listener does not get an extra options param
// which then has to be sliced off in the relayer.
me.mon(origin, relayers, null, null, undefined);
// relayed events are always destroyable.
return new ListenerRemover(me, origin, relayers);
},

createRelayer: function(newName, beginEnd) {
var me = this;
return function() {
return me.fireEventArgs.call(me, newName, beginEnd ? arraySlice.apply(arguments, beginEnd) : arguments);
};
},

enableBubble: function(eventNames) {
if (eventNames) {
var me = this,
names = (typeof eventNames == 'string') ? arguments : eventNames,
length = names.length,
events = me.events,
ename, event, i;
for (i = 0; i < length; ++i) {
ename = names[i].toLowerCase();
event = events[ename];
if (!event || typeof event == 'boolean') {
events[ename] = event = new ExtEvent(me, ename);
}
// Event must fire if it bubbles (We don't know if anyone up the
// bubble hierarchy has listeners added)
me.hasListeners._incr_(ename);
event.bubble = true;
}
}
}
};
}, function() {
var Observable = this,
proto = Observable.prototype,
HasListeners = function () {},
prepareMixin = function (T) {
if (!T.HasListeners) {
var proto = T.prototype;
// Classes that use us as a mixin (best practice) need to be prepared.
Observable.prepareClass(T, this);
// Now that we are mixed in to class T, we need to watch T for derivations
// and prepare them also.
T.onExtended(function (U) {
//<debug>
Ext.classSystemMonitor && Ext.classSystemMonitor('extend mixin', arguments);
//</debug>

Observable.prepareClass(U);
});
// Also, if a class uses us as a mixin and that class is then used as
// a mixin, we need to be notified of that as well.
if (proto.onClassMixedIn) {
// play nice with other potential overrides...
Ext.override(T, {
onClassMixedIn: function (U) {
prepareMixin.call(this, U);
this.callParent(arguments);
}
});
} else {
// just us chickens, so add the method...
proto.onClassMixedIn = function (U) {
prepareMixin.call(this, U);
};
}
}
},
globalEvents;
HasListeners.prototype = {
//$$: 42 // to make sure we have a proper prototype
_decr_: function (ev) {
if (! --this[ev]) {
// Delete this entry, since 0 does not mean no one is listening, just
// that no one is *directly* listening. This allows the eventBus or
// class observers to "poke" through and expose their presence.
delete this[ev];
}
},
_incr_: function (ev) {
if (this.hasOwnProperty(ev)) {
// if we already have listeners at this level, just increment the count...
++this[ev];
} else {
// otherwise, start the count at 1 (which hides whatever is in our prototype
// chain)...
this[ev] = 1;
}
}
};
proto.HasListeners = Observable.HasListeners = HasListeners;
Observable.createAlias({

on: 'addListener',

un: 'removeListener',

mon: 'addManagedListener',

mun: 'removeManagedListener'
});
//deprecated, will be removed in 5.0
Observable.observeClass = Observable.observe;

Ext.globalEvents = globalEvents = new Observable({
events: {
idle: Ext.EventManager.idleEvent,
ready: Ext.EventManager.readyEvent
}
});

Ext.on = function() {
return globalEvents.addListener.apply(globalEvents, arguments);
};

Ext.un = function() {
return globalEvents.removeListener.apply(globalEvents, arguments);
};
// this is considered experimental (along with beforeMethod, afterMethod, removeMethodListener?)
// allows for easier interceptor and sequences, including cancelling and overwriting the return value of the call
// private
function getMethodEvent(method){
var e = (this.methodEvents = this.methodEvents || {})[method],
returnValue,
v,
cancel,
obj = this,
makeCall;
if (!e) {
this.methodEvents[method] = e = {};
e.originalFn = this[method];
e.methodName = method;
e.before = [];
e.after = [];
makeCall = function(fn, scope, args){
if((v = fn.apply(scope || obj, args)) !== undefined){
if (typeof v == 'object') {
if(v.returnValue !== undefined){
returnValue = v.returnValue;
}else{
returnValue = v;
}
cancel = !!v.cancel;
}
else
if (v === false) {
cancel = true;
}
else {
returnValue = v;
}
}
};
this[method] = function(){
var args = Array.prototype.slice.call(arguments, 0),
b, i, len;
returnValue = v = undefined;
cancel = false;
for(i = 0, len = e.before.length; i < len; i++){
b = e.before[i];
makeCall(b.fn, b.scope, args);
if (cancel) {
return returnValue;
}
}
if((v = e.originalFn.apply(obj, args)) !== undefined){
returnValue = v;
}
for(i = 0, len = e.after.length; i < len; i++){
b = e.after[i];
makeCall(b.fn, b.scope, args);
if (cancel) {
return returnValue;
}
}
return returnValue;
};
}
return e;
}
Ext.apply(proto, {
onClassMixedIn: prepareMixin,
// these are considered experimental
// allows for easier interceptor and sequences, including cancelling and overwriting the return value of the call
// adds an 'interceptor' called before the original method
beforeMethod : function(method, fn, scope){
getMethodEvent.call(this, method).before.push({
fn: fn,
scope: scope
});
},
// adds a 'sequence' called after the original method
afterMethod : function(method, fn, scope){
getMethodEvent.call(this, method).after.push({
fn: fn,
scope: scope
});
},
removeMethodListener: function(method, fn, scope){
var e = this.getMethodEvent(method),
i, len;
for(i = 0, len = e.before.length; i < len; i++){
if(e.before[i].fn == fn && e.before[i].scope == scope){
Ext.Array.erase(e.before, i, 1);
return;
}
}
for(i = 0, len = e.after.length; i < len; i++){
if(e.after[i].fn == fn && e.after[i].scope == scope){
Ext.Array.erase(e.after, i, 1);
return;
}
}
},
toggleEventLogging: function(toggle) {
Ext.util.Observable[toggle ? 'capture' : 'releaseCapture'](this, function(en) {
if (Ext.isDefined(Ext.global.console)) {
Ext.global.console.log(en, arguments);
}
});
}
});
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/util/HashMap.js */
(function(Ext) {
Ext.define('Ext.util.HashMap', {
mixins: {
observable: 'Ext.util.Observable'
},

generation: 0,



constructor: function(config) {
config = config || {};
var me = this,
keyFn = config.keyFn;
me.initialConfig = config;
me.addEvents(

'add',

'clear',

'remove',

'replace'
);
me.mixins.observable.constructor.call(me, config);
me.clear(true);
if (keyFn) {
me.getKey = keyFn;
}
},

getCount: function() {
return this.length;
},

getData: function(key, value) {
// if we have no value, it means we need to get the key from the object
if (value === undefined) {
value = key;
key = this.getKey(value);
}
return [key, value];
},

getKey: function(o) {
return o.id;
},

add: function(key, value) {
var me = this;
// Need to check arguments length here, since we could have called:
// map.add('foo', undefined);
if (arguments.length === 1) {
value = key;
key = me.getKey(value);
}
if (me.containsKey(key)) {
return me.replace(key, value);
}
me.map[key] = value;
++me.length;
me.generation++;
if (me.hasListeners.add) {
me.fireEvent('add', me, key, value);
}
return value;
},

replace: function(key, value) {
var me = this,
map = me.map,
old;
// Need to check arguments length here, since we could have called:
// map.replace('foo', undefined);
if (arguments.length === 1) {
value = key;
key = me.getKey(value);
}
if (!me.containsKey(key)) {
me.add(key, value);
}
old = map[key];
map[key] = value;
me.generation++;
if (me.hasListeners.replace) {
me.fireEvent('replace', me, key, value, old);
}
return value;
},

remove: function(o) {
var key = this.findKey(o);
if (key !== undefined) {
return this.removeAtKey(key);
}
return false;
},

removeAtKey: function(key) {
var me = this,
value;
if (me.containsKey(key)) {
value = me.map[key];
delete me.map[key];
--me.length;
me.generation++;
if (me.hasListeners.remove) {
me.fireEvent('remove', me, key, value);
}
return true;
}
return false;
},

get: function(key) {
var map = this.map;
return map.hasOwnProperty(key) ? map[key] : undefined;
},

clear: function( initial) {
var me = this;
// Only clear if it has ever had any content
if (initial || me.generation) {
me.map = {};
me.length = 0;
me.generation = initial ? 0 : me.generation + 1;
}
if (initial !== true && me.hasListeners.clear) {
me.fireEvent('clear', me);
}
return me;
},

containsKey: function(key) {
var map = this.map;
return map.hasOwnProperty(key) && map[key] !== undefined;
},

contains: function(value) {
return this.containsKey(this.findKey(value));
},

getKeys: function() {
return this.getArray(true);
},

getValues: function() {
return this.getArray(false);
},

getArray: function(isKey) {
var arr = [],
key,
map = this.map;
for (key in map) {
if (map.hasOwnProperty(key)) {
arr.push(isKey ? key: map[key]);
}
}
return arr;
},

each: function(fn, scope) {
// copy items so they may be removed during iteration.
var items = Ext.apply({}, this.map),
key,
length = this.length;
scope = scope || this;
for (key in items) {
if (items.hasOwnProperty(key)) {
if (fn.call(scope, key, items[key], length) === false) {
break;
}
}
}
return this;
},

clone: function() {
var hash = new this.self(this.initialConfig),
map = this.map,
key;
hash.suspendEvents();
for (key in map) {
if (map.hasOwnProperty(key)) {
hash.add(key, map[key]);
}
}
hash.resumeEvents();
return hash;
},

findKey: function(value) {
var key,
map = this.map;
for (key in map) {
if (map.hasOwnProperty(key) && map[key] === value) {
return key;
}
}
return undefined;
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/AbstractManager.js */
(function(Ext) {
Ext.define('Ext.AbstractManager', {

requires: ['Ext.util.HashMap'],

typeName: 'type',
constructor: function(config) {
Ext.apply(this, config || {});

this.all = new Ext.util.HashMap();
this.types = {};
},

get : function(id) {
return this.all.get(id);
},

register: function(item) {
//<debug>
var all = this.all,
key = all.getKey(item);

if (all.containsKey(key)) {
Ext.Error.raise('Registering duplicate id "' + key + '" with this manager');
}
//</debug>
this.all.add(item);
},

unregister: function(item) {
this.all.remove(item);
},

registerType : function(type, cls) {
this.types[type] = cls;
cls[this.typeName] = type;
},

isRegistered : function(type){
return this.types[type] !== undefined;
},

create: function(config, defaultType) {
var type = config[this.typeName] || config.type || defaultType,
Constructor = this.types[type];
//<debug>
if (Constructor === undefined) {
Ext.Error.raise("The '" + type + "' type has not been registered with this manager");
}
//</debug>
return new Constructor(config);
},

onAvailable : function(id, fn, scope){
var all = this.all,
item,
callback;

if (all.containsKey(id)) {
item = all.get(id);
fn.call(scope || item, item);
} else {
callback = function(map, key, item){
if (key == id) {
fn.call(scope || item, item);
all.un('add', callback);
}
}; 
all.on('add', callback);
}
},


each: function(fn, scope){
this.all.each(fn, scope || this); 
},


getCount: function(){
return this.all.getCount();
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/ComponentManager.js */
(function(Ext) {
Ext.define('Ext.ComponentManager', {
extend: 'Ext.AbstractManager',
alternateClassName: 'Ext.ComponentMgr',

singleton: true,

typeName: 'xtype',


create: function(component, defaultType){
if (typeof component == 'string') {
return Ext.widget(component);
}
if (component.isComponent) {
return component;
}
return Ext.widget(component.xtype || defaultType, component);
},
registerType: function(type, cls) {
this.types[type] = cls;
cls[this.typeName] = type;
cls.prototype[this.typeName] = type;
}
},
function () {

Ext.getCmp = function(id) {
return Ext.ComponentManager.get(id);
};
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/util/Offset.js */
(function(Ext) {
// @require Ext.CompositeElement
Ext.define('Ext.util.Offset', {

statics: {
fromObject: function(obj) {
return new this(obj.x, obj.y);
}
},

constructor: function(x, y) {
this.x = (x != null && !isNaN(x)) ? x : 0;
this.y = (y != null && !isNaN(y)) ? y : 0;
return this;
},
copy: function() {
return new Ext.util.Offset(this.x, this.y);
},
copyFrom: function(p) {
this.x = p.x;
this.y = p.y;
},
toString: function() {
return "Offset[" + this.x + "," + this.y + "]";
},
equals: function(offset) {
//<debug>
if(!(offset instanceof this.statics())) {
Ext.Error.raise('Offset must be an instance of Ext.util.Offset');
}
//</debug>
return (this.x == offset.x && this.y == offset.y);
},
round: function(to) {
if (!isNaN(to)) {
var factor = Math.pow(10, to);
this.x = Math.round(this.x * factor) / factor;
this.y = Math.round(this.y * factor) / factor;
} else {
this.x = Math.round(this.x);
this.y = Math.round(this.y);
}
},
isZero: function() {
return this.x == 0 && this.y == 0;
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/util/Region.js */
(function(Ext) {
Ext.define('Ext.util.Region', {

requires: ['Ext.util.Offset'],
statics: {

getRegion: function(el) {
return Ext.fly(el).getRegion();
},

from: function(o) {
return new this(o.top, o.right, o.bottom, o.left);
}
},


constructor : function(t, r, b, l) {
var me = this;
me.y = me.top = me[1] = t;
me.right = r;
me.bottom = b;
me.x = me.left = me[0] = l;
},

contains : function(region) {
var me = this;
return (region.x >= me.x &&
region.right <= me.right &&
region.y >= me.y &&
region.bottom <= me.bottom);
},

intersect : function(region) {
var me = this,
t = Math.max(me.y, region.y),
r = Math.min(me.right, region.right),
b = Math.min(me.bottom, region.bottom),
l = Math.max(me.x, region.x);
if (b > t && r > l) {
return new this.self(t, r, b, l);
}
else {
return false;
}
},

union : function(region) {
var me = this,
t = Math.min(me.y, region.y),
r = Math.max(me.right, region.right),
b = Math.max(me.bottom, region.bottom),
l = Math.min(me.x, region.x);
return new this.self(t, r, b, l);
},

constrainTo : function(r) {
var me = this,
constrain = Ext.Number.constrain;
me.top = me.y = constrain(me.top, r.y, r.bottom);
me.bottom = constrain(me.bottom, r.y, r.bottom);
me.left = me.x = constrain(me.left, r.x, r.right);
me.right = constrain(me.right, r.x, r.right);
return me;
},

adjust : function(t, r, b, l) {
var me = this;
me.top = me.y += t;
me.left = me.x += l;
me.right += r;
me.bottom += b;
return me;
},

getOutOfBoundOffset: function(axis, p) {
if (!Ext.isObject(axis)) {
if (axis == 'x') {
return this.getOutOfBoundOffsetX(p);
} else {
return this.getOutOfBoundOffsetY(p);
}
} else {
p = axis;
var d = new Ext.util.Offset();
d.x = this.getOutOfBoundOffsetX(p.x);
d.y = this.getOutOfBoundOffsetY(p.y);
return d;
}
},

getOutOfBoundOffsetX: function(p) {
if (p <= this.x) {
return this.x - p;
} else if (p >= this.right) {
return this.right - p;
}
return 0;
},

getOutOfBoundOffsetY: function(p) {
if (p <= this.y) {
return this.y - p;
} else if (p >= this.bottom) {
return this.bottom - p;
}
return 0;
},

isOutOfBound: function(axis, p) {
if (!Ext.isObject(axis)) {
if (axis == 'x') {
return this.isOutOfBoundX(p);
} else {
return this.isOutOfBoundY(p);
}
} else {
p = axis;
return (this.isOutOfBoundX(p.x) || this.isOutOfBoundY(p.y));
}
},

isOutOfBoundX: function(p) {
return (p < this.x || p > this.right);
},

isOutOfBoundY: function(p) {
return (p < this.y || p > this.bottom);
},

restrict: function(axis, p, factor) {
if (Ext.isObject(axis)) {
var newP;
factor = p;
p = axis;
if (p.copy) {
newP = p.copy();
}
else {
newP = {
x: p.x,
y: p.y
};
}
newP.x = this.restrictX(p.x, factor);
newP.y = this.restrictY(p.y, factor);
return newP;
} else {
if (axis == 'x') {
return this.restrictX(p, factor);
} else {
return this.restrictY(p, factor);
}
}
},

restrictX : function(p, factor) {
if (!factor) {
factor = 1;
}
if (p <= this.x) {
p -= (p - this.x) * factor;
}
else if (p >= this.right) {
p -= (p - this.right) * factor;
}
return p;
},

restrictY : function(p, factor) {
if (!factor) {
factor = 1;
}
if (p <= this.y) {
p -= (p - this.y) * factor;
}
else if (p >= this.bottom) {
p -= (p - this.bottom) * factor;
}
return p;
},

getSize: function() {
return {
width: this.right - this.x,
height: this.bottom - this.y
};
},

copy: function() {
return new this.self(this.y, this.right, this.bottom, this.x);
},

copyFrom: function(p) {
var me = this;
me.top = me.y = me[1] = p.y;
me.right = p.right;
me.bottom = p.bottom;
me.left = me.x = me[0] = p.x;
return this;
},

toString: function() {
return "Region[" + this.top + "," + this.right + "," + this.bottom + "," + this.left + "]";
},

translateBy: function(x, y) {
if (arguments.length == 1) {
y = x.y;
x = x.x;
}
var me = this;
me.top = me.y += y;
me.right += x;
me.bottom += y;
me.left = me.x += x;
return me;
},

round: function() {
var me = this;
me.top = me.y = Math.round(me.y);
me.right = Math.round(me.right);
me.bottom = Math.round(me.bottom);
me.left = me.x = Math.round(me.x);
return me;
},

equals: function(region) {
return (this.top == region.top && this.right == region.right && this.bottom == region.bottom && this.left == region.left);
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/util/Point.js */
(function(Ext) {
Ext.define('Ext.util.Point', {

extend: 'Ext.util.Region',
statics: {

fromEvent: function(e) {
e = e.browserEvent || e;
e = (e.changedTouches && e.changedTouches.length > 0) ? e.changedTouches[0] : e;
return new this(e.pageX, e.pageY);
}
},


constructor: function(x, y) {
this.callParent([y, x, y, x]);
},

toString: function() {
return "Point[" + this.x + "," + this.y + "]";
},

equals: function(p) {
return (this.x == p.x && this.y == p.y);
},

isWithin: function(p, threshold) {
if (!Ext.isObject(threshold)) {
threshold = {
x: threshold,
y: threshold
};
}
return (this.x <= p.x + threshold.x && this.x >= p.x - threshold.x &&
this.y <= p.y + threshold.y && this.y >= p.y - threshold.y);
},

isContainedBy: function(region) {
if (!(region instanceof Ext.util.Region)) {
region = Ext.get(region.el || region).getRegion();
}
return region.contains(this);
},

roundedEquals: function(p) {
return (Math.round(this.x) == Math.round(p.x) && Math.round(this.y) == Math.round(p.y));
}
}, function() {

this.prototype.translate = Ext.util.Region.prototype.translateBy;
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/EventObject.js */
(function(Ext) {
// @tag dom,core
// @require EventManager.js
// @define Ext.EventObject
Ext.define('Ext.EventObjectImpl', {
uses: ['Ext.util.Point'],

BACKSPACE: 8,

TAB: 9,

NUM_CENTER: 12,

ENTER: 13,

RETURN: 13,

SHIFT: 16,

CTRL: 17,

ALT: 18,

PAUSE: 19,

CAPS_LOCK: 20,

ESC: 27,

SPACE: 32,

PAGE_UP: 33,

PAGE_DOWN: 34,

END: 35,

HOME: 36,

LEFT: 37,

UP: 38,

RIGHT: 39,

DOWN: 40,

PRINT_SCREEN: 44,

INSERT: 45,

DELETE: 46,

ZERO: 48,

ONE: 49,

TWO: 50,

THREE: 51,

FOUR: 52,

FIVE: 53,

SIX: 54,

SEVEN: 55,

EIGHT: 56,

NINE: 57,

A: 65,

B: 66,

C: 67,

D: 68,

E: 69,

F: 70,

G: 71,

H: 72,

I: 73,

J: 74,

K: 75,

L: 76,

M: 77,

N: 78,

O: 79,

P: 80,

Q: 81,

R: 82,

S: 83,

T: 84,

U: 85,

V: 86,

W: 87,

X: 88,

Y: 89,

Z: 90,

CONTEXT_MENU: 93,

NUM_ZERO: 96,

NUM_ONE: 97,

NUM_TWO: 98,

NUM_THREE: 99,

NUM_FOUR: 100,

NUM_FIVE: 101,

NUM_SIX: 102,

NUM_SEVEN: 103,

NUM_EIGHT: 104,

NUM_NINE: 105,

NUM_MULTIPLY: 106,

NUM_PLUS: 107,

NUM_MINUS: 109,

NUM_PERIOD: 110,

NUM_DIVISION: 111,

F1: 112,

F2: 113,

F3: 114,

F4: 115,

F5: 116,

F6: 117,

F7: 118,

F8: 119,

F9: 120,

F10: 121,

F11: 122,

F12: 123,

WHEEL_SCALE: (function () {
var scale;
if (Ext.isGecko) {
// Firefox uses 3 on all platforms
scale = 3;
} else if (Ext.isMac) {
// Continuous scrolling devices have momentum and produce much more scroll than
// discrete devices on the same OS and browser. To make things exciting, Safari
// (and not Chrome) changed from small values to 120 (like IE).
if (Ext.isSafari && Ext.webKitVersion >= 532.0) {
// Safari changed the scrolling factor to match IE (for details see
// https://bugs.webkit.org/show_bug.cgi?id=24368). The WebKit version where this
// change was introduced was 532.0
// Detailed discussion:
// https://bugs.webkit.org/show_bug.cgi?id=29601
// http://trac.webkit.org/browser/trunk/WebKit/chromium/src/mac/WebInputEventFactory.mm#L1063
scale = 120;
} else {
// MS optical wheel mouse produces multiples of 12 which is close enough
// to help tame the speed of the continuous mice...
scale = 12;
}
// Momentum scrolling produces very fast scrolling, so increase the scale factor
// to help produce similar results cross platform. This could be even larger and
// it would help those mice, but other mice would become almost unusable as a
// result (since we cannot tell which device type is in use).
scale *= 3;
} else {
// IE, Opera and other Windows browsers use 120.
scale = 120;
}
return scale;
}()),

clickRe: /(dbl)?click/,
// safari keypress events for special keys return bad keycodes
safariKeys: {
3: 13, // enter
63234: 37, // left
63235: 39, // right
63232: 38, // up
63233: 40, // down
63276: 33, // page up
63277: 34, // page down
63272: 46, // delete
63273: 36, // home
63275: 35 // end
},
// normalize button clicks, don't see any way to feature detect this.
btnMap: Ext.isIE ? {
1: 0,
4: 1,
2: 2
} : {
0: 0,
1: 1,
2: 2
},




constructor: function(event, freezeEvent){
if (event) {
this.setEvent(event.browserEvent || event, freezeEvent);
}
},
setEvent: function(event, freezeEvent){
var me = this, button, options;
if (event === me || (event && event.browserEvent)) { // already wrapped
return event;
}
me.browserEvent = event;
if (event) {
// normalize buttons
button = event.button ? me.btnMap[event.button] : (event.which ? event.which - 1 : -1);
if (me.clickRe.test(event.type) && button == -1) {
button = 0;
}
options = {
type: event.type,
button: button,
shiftKey: event.shiftKey,
// mac metaKey behaves like ctrlKey
ctrlKey: event.ctrlKey || event.metaKey || false,
altKey: event.altKey,
// in getKey these will be normalized for the mac
keyCode: event.keyCode,
charCode: event.charCode,
// cache the targets for the delayed and or buffered events
target: Ext.EventManager.getTarget(event),
relatedTarget: Ext.EventManager.getRelatedTarget(event),
currentTarget: event.currentTarget,
xy: (freezeEvent ? me.getXY() : null)
};
} else {
options = {
button: -1,
shiftKey: false,
ctrlKey: false,
altKey: false,
keyCode: 0,
charCode: 0,
target: null,
xy: [0, 0]
};
}
Ext.apply(me, options);
return me;
},

stopEvent: function(){
this.stopPropagation();
this.preventDefault();
},

preventDefault: function(){
if (this.browserEvent) {
Ext.EventManager.preventDefault(this.browserEvent);
}
},

stopPropagation: function(){
var browserEvent = this.browserEvent;
if (browserEvent) {
if (browserEvent.type == 'mousedown') {
Ext.EventManager.stoppedMouseDownEvent.fire(this);
}
Ext.EventManager.stopPropagation(browserEvent);
}
},

getCharCode: function(){
return this.charCode || this.keyCode;
},

getKey: function(){
return this.normalizeKey(this.keyCode || this.charCode);
},

normalizeKey: function(key){
// can't feature detect this
return Ext.isWebKit ? (this.safariKeys[key] || key) : key;
},

getPageX: function(){
return this.getX();
},

getPageY: function(){
return this.getY();
},

getX: function() {
return this.getXY()[0];
},

getY: function() {
return this.getXY()[1];
},

getXY: function() {
if (!this.xy) {
// same for XY
this.xy = Ext.EventManager.getPageXY(this.browserEvent);
}
return this.xy;
},

getTarget : function(selector, maxDepth, returnEl){
if (selector) {
return Ext.fly(this.target).findParent(selector, maxDepth, returnEl);
}
return returnEl ? Ext.get(this.target) : this.target;
},

getRelatedTarget : function(selector, maxDepth, returnEl){
if (selector && this.relatedTarget) {
return Ext.fly(this.relatedTarget).findParent(selector, maxDepth, returnEl);
}
return returnEl ? Ext.get(this.relatedTarget) : this.relatedTarget;
},

correctWheelDelta : function (delta) {
var scale = this.WHEEL_SCALE,
ret = Math.round(delta / scale);
if (!ret && delta) {
ret = (delta < 0) ? -1 : 1; // don't allow non-zero deltas to go to zero!
}
return ret;
},

getWheelDeltas : function () {
var me = this,
event = me.browserEvent,
dx = 0, dy = 0; // the deltas
if (Ext.isDefined(event.wheelDeltaX)) { // WebKit has both dimensions
dx = event.wheelDeltaX;
dy = event.wheelDeltaY;
} else if (event.wheelDelta) { // old WebKit and IE
dy = event.wheelDelta;
} else if (event.detail) { // Gecko
dy = -event.detail; // gecko is backwards
// Gecko sometimes returns really big values if the user changes settings to
// scroll a whole page per scroll
if (dy > 100) {
dy = 3;
} else if (dy < -100) {
dy = -3;
}
// Firefox 3.1 adds an axis field to the event to indicate direction of
// scroll. See https://developer.mozilla.org/en/Gecko-Specific_DOM_Events
if (Ext.isDefined(event.axis) && event.axis === event.HORIZONTAL_AXIS) {
dx = dy;
dy = 0;
}
}
return {
x: me.correctWheelDelta(dx),
y: me.correctWheelDelta(dy)
};
},

getWheelDelta : function(){
var deltas = this.getWheelDeltas();
return deltas.y;
},

within : function(el, related, allowEl){
if(el){
var t = related ? this.getRelatedTarget() : this.getTarget(),
result;
if (t) {
result = Ext.fly(el, '_internal').contains(t);
if (!result && allowEl) {
result = t == Ext.getDom(el);
}
return result;
}
}
return false;
},

isNavKeyPress : function(){
var me = this,
k = this.normalizeKey(me.keyCode);
return (k >= 33 && k <= 40) || // Page Up/Down, End, Home, Left, Up, Right, Down
k == me.RETURN ||
k == me.TAB ||
k == me.ESC;
},

isSpecialKey : function(){
var k = this.normalizeKey(this.keyCode);
return (this.type == 'keypress' && this.ctrlKey) ||
this.isNavKeyPress() ||
(k == this.BACKSPACE) || // Backspace
(k >= 16 && k <= 20) || // Shift, Ctrl, Alt, Pause, Caps Lock
(k >= 44 && k <= 46); // Print Screen, Insert, Delete
},

getPoint : function(){
var xy = this.getXY();
return new Ext.util.Point(xy[0], xy[1]);
},

hasModifier : function(){
return this.ctrlKey || this.altKey || this.shiftKey || this.metaKey;
},

injectEvent: (function () {
var API,
dispatchers = {}, // keyed by event type (e.g., 'mousedown')
crazyIEButtons;
// Good reference: http://developer.yahoo.com/yui/docs/UserAction.js.html
// IE9 has createEvent, but this code causes major problems with htmleditor (it
// blocks all mouse events and maybe more). TODO
if (!Ext.isIE9m && document.createEvent) { // if (DOM compliant)
API = {
createHtmlEvent: function (doc, type, bubbles, cancelable) {
var event = doc.createEvent('HTMLEvents');
event.initEvent(type, bubbles, cancelable);
return event;
},
createMouseEvent: function (doc, type, bubbles, cancelable, detail,
clientX, clientY, ctrlKey, altKey, shiftKey, metaKey,
button, relatedTarget) {
var event = doc.createEvent('MouseEvents'),
view = doc.defaultView || window;
if (event.initMouseEvent) {
event.initMouseEvent(type, bubbles, cancelable, view, detail,
clientX, clientY, clientX, clientY, ctrlKey, altKey,
shiftKey, metaKey, button, relatedTarget);
} else { // old Safari
event = doc.createEvent('UIEvents');
event.initEvent(type, bubbles, cancelable);
event.view = view;
event.detail = detail;
event.screenX = clientX;
event.screenY = clientY;
event.clientX = clientX;
event.clientY = clientY;
event.ctrlKey = ctrlKey;
event.altKey = altKey;
event.metaKey = metaKey;
event.shiftKey = shiftKey;
event.button = button;
event.relatedTarget = relatedTarget;
}
return event;
},
createUIEvent: function (doc, type, bubbles, cancelable, detail) {
var event = doc.createEvent('UIEvents'),
view = doc.defaultView || window;
event.initUIEvent(type, bubbles, cancelable, view, detail);
return event;
},
fireEvent: function (target, type, event) {
target.dispatchEvent(event);
},
fixTarget: function (target) {
// Safari3 doesn't have window.dispatchEvent()
if (target == window && !target.dispatchEvent) {
return document;
}
return target;
}
};
} else if (document.createEventObject) { // else if (IE)
crazyIEButtons = { 0: 1, 1: 4, 2: 2 };
API = {
createHtmlEvent: function (doc, type, bubbles, cancelable) {
var event = doc.createEventObject();
event.bubbles = bubbles;
event.cancelable = cancelable;
return event;
},
createMouseEvent: function (doc, type, bubbles, cancelable, detail,
clientX, clientY, ctrlKey, altKey, shiftKey, metaKey,
button, relatedTarget) {
var event = doc.createEventObject();
event.bubbles = bubbles;
event.cancelable = cancelable;
event.detail = detail;
event.screenX = clientX;
event.screenY = clientY;
event.clientX = clientX;
event.clientY = clientY;
event.ctrlKey = ctrlKey;
event.altKey = altKey;
event.shiftKey = shiftKey;
event.metaKey = metaKey;
event.button = crazyIEButtons[button] || button;
event.relatedTarget = relatedTarget; // cannot assign to/fromElement
return event;
},
createUIEvent: function (doc, type, bubbles, cancelable, detail) {
var event = doc.createEventObject();
event.bubbles = bubbles;
event.cancelable = cancelable;
return event;
},
fireEvent: function (target, type, event) {
target.fireEvent('on' + type, event);
},
fixTarget: function (target) {
if (target == document) {
// IE6,IE7 thinks window==document and doesn't have window.fireEvent()
// IE6,IE7 cannot properly call document.fireEvent()
return document.documentElement;
}
return target;
}
};
}
//----------------
// HTMLEvents
Ext.Object.each({
load: [false, false],
unload: [false, false],
select: [true, false],
change: [true, false],
submit: [true, true],
reset: [true, false],
resize: [true, false],
scroll: [true, false]
},
function (name, value) {
var bubbles = value[0], cancelable = value[1];
dispatchers[name] = function (targetEl, srcEvent) {
var e = API.createHtmlEvent(name, bubbles, cancelable);
API.fireEvent(targetEl, name, e);
};
});
//----------------
// MouseEvents
function createMouseEventDispatcher (type, detail) {
var cancelable = (type != 'mousemove');
return function (targetEl, srcEvent) {
var xy = srcEvent.getXY(),
e = API.createMouseEvent(targetEl.ownerDocument, type, true, cancelable,
detail, xy[0], xy[1], srcEvent.ctrlKey, srcEvent.altKey,
srcEvent.shiftKey, srcEvent.metaKey, srcEvent.button,
srcEvent.relatedTarget);
API.fireEvent(targetEl, type, e);
};
}
Ext.each(['click', 'dblclick', 'mousedown', 'mouseup', 'mouseover', 'mousemove', 'mouseout'],
function (eventName) {
dispatchers[eventName] = createMouseEventDispatcher(eventName, 1);
});
//----------------
// UIEvents
Ext.Object.each({
focusin: [true, false],
focusout: [true, false],
activate: [true, true],
focus: [false, false],
blur: [false, false]
},
function (name, value) {
var bubbles = value[0], cancelable = value[1];
dispatchers[name] = function (targetEl, srcEvent) {
var e = API.createUIEvent(targetEl.ownerDocument, name, bubbles, cancelable, 1);
API.fireEvent(targetEl, name, e);
};
});
//---------
if (!API) {
// not even sure what ancient browsers fall into this category...
dispatchers = {}; // never mind all those we just built :P
API = {
fixTarget: Ext.identityFn
};
}
function cannotInject (target, srcEvent) {
//<debug>
// TODO log something
//</debug>
}
return function (target) {
var me = this,
dispatcher = dispatchers[me.type] || cannotInject,
t = target ? (target.dom || target) : me.getTarget();
t = API.fixTarget(t);
dispatcher(t, me);
};
}()) // call to produce method
}, function() {
Ext.EventObject = new Ext.EventObjectImpl();
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/dom/AbstractQuery.js */
(function(Ext) {
// @tag dom,core
// @require ../EventObject.js
Ext.define('Ext.dom.AbstractQuery', {

select: function(q, root) {
var results = [],
nodes,
i,
j,
qlen,
nlen;
root = root || document;
if (typeof root == 'string') {
root = document.getElementById(root);
}
q = q.split(",");
for (i = 0,qlen = q.length; i < qlen; i++) {
if (typeof q[i] == 'string') {

//support for node attribute selection
if (typeof q[i][0] == '@') {
nodes = root.getAttributeNode(q[i].substring(1));
results.push(nodes);
} else {
nodes = root.querySelectorAll(q[i]);
for (j = 0,nlen = nodes.length; j < nlen; j++) {
results.push(nodes[j]);
}
}
}
}
return results;
},

selectNode: function(q, root) {
return this.select(q, root)[0];
},

is: function(el, q) {
if (typeof el == "string") {
el = document.getElementById(el);
}
return this.select(q).indexOf(el) !== -1;
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/dom/AbstractHelper.js */
(function(Ext) {
// @tag dom,core
// @require AbstractQuery.js
Ext.define('Ext.dom.AbstractHelper', {
emptyTags : /^(?:br|frame|hr|img|input|link|meta|range|spacer|wbr|area|param|col)$/i,
confRe : /^(?:tag|children|cn|html|tpl|tplData)$/i,
endRe : /end/i,
styleSepRe: /\s*(?::|;)\s*/,
// Since cls & for are reserved words, we need to transform them
attributeTransform: { cls : 'class', htmlFor : 'for' },
closeTags: {},
decamelizeName : (function () {
var camelCaseRe = /([a-z])([A-Z])/g,
cache = {};
function decamel (match, p1, p2) {
return p1 + '-' + p2.toLowerCase();
}
return function (s) {
return cache[s] || (cache[s] = s.replace(camelCaseRe, decamel));
};
}()),
generateMarkup: function(spec, buffer) {
var me = this,
specType = typeof spec,
attr, val, tag, i, closeTags;
if (specType == "string" || specType == "number") {
buffer.push(spec);
} else if (Ext.isArray(spec)) {
for (i = 0; i < spec.length; i++) {
if (spec[i]) {
me.generateMarkup(spec[i], buffer);
}
}
} else {
tag = spec.tag || 'div';
buffer.push('<', tag);
for (attr in spec) {
if (spec.hasOwnProperty(attr)) {
val = spec[attr];
if (!me.confRe.test(attr)) {
if (typeof val == "object") {
buffer.push(' ', attr, '="');
me.generateStyles(val, buffer).push('"');
} else {
buffer.push(' ', me.attributeTransform[attr] || attr, '="', val, '"');
}
}
}
}
// Now either just close the tag or try to add children and close the tag.
if (me.emptyTags.test(tag)) {
buffer.push('/>');
} else {
buffer.push('>');
// Apply the tpl html, and cn specifications
if ((val = spec.tpl)) {
val.applyOut(spec.tplData, buffer);
}
if ((val = spec.html)) {
buffer.push(val);
}
if ((val = spec.cn || spec.children)) {
me.generateMarkup(val, buffer);
}
// we generate a lot of close tags, so cache them rather than push 3 parts
closeTags = me.closeTags;
buffer.push(closeTags[tag] || (closeTags[tag] = '</' + tag + '>'));
}
}
return buffer;
},

generateStyles: function (styles, buffer) {
var a = buffer || [],
name;
for (name in styles) {
if (styles.hasOwnProperty(name)) {
a.push(this.decamelizeName(name), ':', styles[name], ';');
}
}
return buffer || a.join('');
},

markup: function(spec) {
if (typeof spec == "string") {
return spec;
}
var buf = this.generateMarkup(spec, []);
return buf.join('');
},

applyStyles: function(el, styles) {
if (styles) {
var i = 0,
len;
el = Ext.fly(el, '_applyStyles');
if (typeof styles == 'function') {
styles = styles.call();
}
if (typeof styles == 'string') {
styles = Ext.util.Format.trim(styles).split(this.styleSepRe);
for (len = styles.length; i < len;) {
el.setStyle(styles[i++], styles[i++]);
}
} else if (Ext.isObject(styles)) {
el.setStyle(styles);
}
}
},

insertHtml: function(where, el, html) {
var hash = {},
setStart,
range,
frag,
rangeEl;
where = where.toLowerCase();
// add these here because they are used in both branches of the condition.
hash['beforebegin'] = ['BeforeBegin', 'previousSibling'];
hash['afterend'] = ['AfterEnd', 'nextSibling'];
range = el.ownerDocument.createRange();
setStart = 'setStart' + (this.endRe.test(where) ? 'After' : 'Before');
if (hash[where]) {
range[setStart](el);
frag = range.createContextualFragment(html);
el.parentNode.insertBefore(frag, where == 'beforebegin' ? el : el.nextSibling);
return el[(where == 'beforebegin' ? 'previous' : 'next') + 'Sibling'];
}
else {
rangeEl = (where == 'afterbegin' ? 'first' : 'last') + 'Child';
if (el.firstChild) {
range[setStart](el[rangeEl]);
frag = range.createContextualFragment(html);
if (where == 'afterbegin') {
el.insertBefore(frag, el.firstChild);
}
else {
el.appendChild(frag);
}
}
else {
el.innerHTML = html;
}
return el[rangeEl];
}
throw 'Illegal insertion point -> "' + where + '"';
},

insertBefore: function(el, o, returnElement) {
return this.doInsert(el, o, returnElement, 'beforebegin');
},

insertAfter: function(el, o, returnElement) {
return this.doInsert(el, o, returnElement, 'afterend', 'nextSibling');
},

insertFirst: function(el, o, returnElement) {
return this.doInsert(el, o, returnElement, 'afterbegin', 'firstChild');
},

append: function(el, o, returnElement) {
return this.doInsert(el, o, returnElement, 'beforeend', '', true);
},

overwrite: function(el, o, returnElement) {
el = Ext.getDom(el);
el.innerHTML = this.markup(o);
return returnElement ? Ext.get(el.firstChild) : el.firstChild;
},
doInsert: function(el, o, returnElement, pos, sibling, append) {
var newNode = this.insertHtml(pos, Ext.getDom(el), this.markup(o));
return returnElement ? Ext.get(newNode, true) : newNode;
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/dom/AbstractElement_static.js */
(function(Ext) {
// @tag dom,core
Ext.define('Ext.dom.AbstractElement_static', {
override: 'Ext.dom.AbstractElement',
inheritableStatics: {
unitRe: /\d+(px|em|%|en|ex|pt|in|cm|mm|pc)$/i,
camelRe: /(-[a-z])/gi,
msRe: /^-ms-/,
cssRe: /([a-z0-9\-]+)\s*:\s*([^;\s]+(?:\s*[^;\s]+)*)?;?/gi,
opacityRe: /alpha\(opacity=(.*)\)/i,
propertyCache: {},
defaultUnit : "px",
borders: {l: 'border-left-width', r: 'border-right-width', t: 'border-top-width', b: 'border-bottom-width'},
paddings: {l: 'padding-left', r: 'padding-right', t: 'padding-top', b: 'padding-bottom'},
margins: {l: 'margin-left', r: 'margin-right', t: 'margin-top', b: 'margin-bottom'},

addUnits: function(size, units) {
// Most common case first: Size is set to a number
if (typeof size == 'number') {
return size + (units || this.defaultUnit || 'px');
}
// Size set to a value which means "auto"
if (size === "" || size == "auto" || size === undefined || size === null) {
return size || '';
}
// Otherwise, warn if it's not a valid CSS measurement
if (!this.unitRe.test(size)) {
//<debug>
if (Ext.isDefined(Ext.global.console)) {
Ext.global.console.warn("Warning, size detected as NaN on Element.addUnits.");
}
//</debug>
return size || '';
}
return size;
},

isAncestor: function(p, c) {
var ret = false;
p = Ext.getDom(p);
c = Ext.getDom(c);
if (p && c) {
if (p.contains) {
return p.contains(c);
} else if (p.compareDocumentPosition) {
return !!(p.compareDocumentPosition(c) & 16);
} else {
while ((c = c.parentNode)) {
ret = c == p || ret;
}
}
}
return ret;
},

parseBox: function(box) {
box = box || 0;

var type = typeof box,
parts,
ln;
if (type === 'number') {
return {
top : box,
right : box,
bottom: box,
left : box
};
} else if (type !== 'string') {
// If not a number or a string, assume we've been given a box config.
return box;
}
parts = box.split(' ');
ln = parts.length;
if (ln == 1) {
parts[1] = parts[2] = parts[3] = parts[0];
} else if (ln == 2) {
parts[2] = parts[0];
parts[3] = parts[1];
} else if (ln == 3) {
parts[3] = parts[1];
}
return {
top :parseFloat(parts[0]) || 0,
right :parseFloat(parts[1]) || 0,
bottom:parseFloat(parts[2]) || 0,
left :parseFloat(parts[3]) || 0
};
},

unitizeBox: function(box, units) {
var a = this.addUnits,
b = this.parseBox(box);
return a(b.top, units) + ' ' +
a(b.right, units) + ' ' +
a(b.bottom, units) + ' ' +
a(b.left, units);
},
// private
camelReplaceFn: function(m, a) {
return a.charAt(1).toUpperCase();
},

normalize: function(prop) {
// TODO: Mobile optimization?
if (prop == 'float') {
prop = Ext.supports.Float ? 'cssFloat' : 'styleFloat';
}
// For '-ms-foo' we need msFoo
return this.propertyCache[prop] || (this.propertyCache[prop] = prop.replace(this.msRe, 'ms-').replace(this.camelRe, this.camelReplaceFn));
},

getDocumentHeight: function() {
return Math.max(!Ext.isStrict ? document.body.scrollHeight : document.documentElement.scrollHeight, this.getViewportHeight());
},

getDocumentWidth: function() {
return Math.max(!Ext.isStrict ? document.body.scrollWidth : document.documentElement.scrollWidth, this.getViewportWidth());
},

getViewportHeight: function(){
return window.innerHeight;
},

getViewportWidth: function() {
return window.innerWidth;
},

getViewSize: function() {
return {
width: window.innerWidth,
height: window.innerHeight
};
},

getOrientation: function() {
if (Ext.supports.OrientationChange) {
return (window.orientation == 0) ? 'portrait' : 'landscape';
}
return (window.innerHeight > window.innerWidth) ? 'portrait' : 'landscape';
},

fromPoint: function(x, y) {
return Ext.get(document.elementFromPoint(x, y));
},

parseStyles: function(styles){
var out = {},
cssRe = this.cssRe,
matches;
if (styles) {
// Since we're using the g flag on the regex, we need to set the lastIndex.
// This automatically happens on some implementations, but not others, see:
// http://stackoverflow.com/questions/2645273/javascript-regular-expression-literal-persists-between-function-calls
// http://blog.stevenlevithan.com/archives/fixing-javascript-regexp
cssRe.lastIndex = 0;
while ((matches = cssRe.exec(styles))) {
out[matches[1]] = matches[2]||'';
}
}
return out;
}
}
},
function () {
var doc = document,
activeElement = null,
isCSS1 = doc.compatMode == "CSS1Compat";
// If the browser does not support document.activeElement we need some assistance.
// This covers old Safari 3.2 (4.0 added activeElement along with just about all
// other browsers). We need this support to handle issues with old Safari.
if (!('activeElement' in doc) && doc.addEventListener) {
doc.addEventListener('focus',
function (ev) {
if (ev && ev.target) {
activeElement = (ev.target == doc) ? null : ev.target;
}
}, true);
}

function makeSelectionRestoreFn (activeEl, start, end) {
return function () {
activeEl.selectionStart = start;
activeEl.selectionEnd = end;
};
}
this.addInheritableStatics({

getActiveElement: function () {
var active;
// In IE 6/7, calling activeElement can sometimes throw an Unspecified Error,
// so we need to wrap it in a try catch

try {
active = doc.activeElement;
} catch(e) {}

// Default to the body if we can't find anything
// https://developer.mozilla.org/en-US/docs/DOM/document.activeElement
active = active || activeElement;
if (!active) {
active = activeElement = document.body;
}
return active;
},

getRightMarginFixCleaner: function (target) {
var supports = Ext.supports,
hasInputBug = supports.DisplayChangeInputSelectionBug,
hasTextAreaBug = supports.DisplayChangeTextAreaSelectionBug,
activeEl,
tag,
start,
end;
if (hasInputBug || hasTextAreaBug) {
activeEl = doc.activeElement || activeElement; // save a call
tag = activeEl && activeEl.tagName;
if ((hasTextAreaBug && tag == 'TEXTAREA') ||
(hasInputBug && tag == 'INPUT' && activeEl.type == 'text')) {
if (Ext.dom.Element.isAncestor(target, activeEl)) {
start = activeEl.selectionStart;
end = activeEl.selectionEnd;
if (Ext.isNumber(start) && Ext.isNumber(end)) { // to be safe...
// We don't create the raw closure here inline because that
// will be costly even if we don't want to return it (nested
// function decls and exprs are often instantiated on entry
// regardless of whether execution ever reaches them):
return makeSelectionRestoreFn(activeEl, start, end);
}
}
}
}
return Ext.emptyFn; // avoid special cases, just return a nop
},
getViewWidth: function(full) {
return full ? Ext.dom.Element.getDocumentWidth() : Ext.dom.Element.getViewportWidth();
},
getViewHeight: function(full) {
return full ? Ext.dom.Element.getDocumentHeight() : Ext.dom.Element.getViewportHeight();
},
getDocumentHeight: function() {
return Math.max(!isCSS1 ? doc.body.scrollHeight : doc.documentElement.scrollHeight, Ext.dom.Element.getViewportHeight());
},
getDocumentWidth: function() {
return Math.max(!isCSS1 ? doc.body.scrollWidth : doc.documentElement.scrollWidth, Ext.dom.Element.getViewportWidth());
},
getViewportHeight: function(){
return Ext.isIE9m ?
(Ext.isStrict ? doc.documentElement.clientHeight : doc.body.clientHeight) :
self.innerHeight;
},
getViewportWidth: function() {
return (!Ext.isStrict && !Ext.isOpera) ? doc.body.clientWidth :
Ext.isIE9m ? doc.documentElement.clientWidth : self.innerWidth;
},

serializeForm: function(form) {
var fElements = form.elements || (document.forms[form] || Ext.getDom(form)).elements,
hasSubmit = false,
encoder = encodeURIComponent,
data = '',
eLen = fElements.length,
element, name, type, options, hasValue, e,
o, oLen, opt;
for (e = 0; e < eLen; e++) {
element = fElements[e];
name = element.name;
type = element.type;
options = element.options;
if (!element.disabled && name) {
if (/select-(one|multiple)/i.test(type)) {
oLen = options.length;
for (o = 0; o < oLen; o++) {
opt = options[o];
if (opt.selected) {
hasValue = opt.hasAttribute ? opt.hasAttribute('value') : opt.getAttributeNode('value').specified;
data += Ext.String.format("{0}={1}&", encoder(name), encoder(hasValue ? opt.value : opt.text));
}
}
} else if (!(/file|undefined|reset|button/i.test(type))) {
if (!(/radio|checkbox/i.test(type) && !element.checked) && !(type == 'submit' && hasSubmit)) {
data += encoder(name) + '=' + encoder(element.value) + '&';
hasSubmit = /submit/i.test(type);
}
}
}
}
return data.substr(0, data.length - 1);
}
});
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/dom/AbstractElement_insertion.js */
(function(Ext) {
// @tag dom,core
Ext.define('Ext.dom.AbstractElement_insertion', {
override: 'Ext.dom.AbstractElement',

appendChild: function(el, returnDom) {
var me = this,
insertEl,
eLen, e, oldUseDom;
if (el.nodeType || el.dom || typeof el == 'string') { // element
el = Ext.getDom(el);
me.dom.appendChild(el);
return !returnDom ? Ext.get(el) : el;
} else if (el.length) {
// append all elements to a documentFragment
insertEl = Ext.fly(document.createDocumentFragment(), '_internal');
eLen = el.length;
// DocumentFragments cannot accept innerHTML
Ext.DomHelper.useDom = true;
for (e = 0; e < eLen; e++) {
insertEl.appendChild(el[e], returnDom);
}
Ext.DomHelper.useDom = oldUseDom;
me.dom.appendChild(insertEl.dom);
return returnDom ? insertEl.dom : insertEl;
}
else { // dh config
return me.createChild(el, null, returnDom);
}
},

appendTo: function(el) {
Ext.getDom(el).appendChild(this.dom);
return this;
},

insertBefore: function(el) {
el = Ext.getDom(el);
el.parentNode.insertBefore(this.dom, el);
return this;
},

insertAfter: function(el) {
el = Ext.getDom(el);
el.parentNode.insertBefore(this.dom, el.nextSibling);
return this;
},

insertFirst: function(el, returnDom) {
el = el || {};
if (el.nodeType || el.dom || typeof el == 'string') { // element
el = Ext.getDom(el);
this.dom.insertBefore(el, this.dom.firstChild);
return !returnDom ? Ext.get(el) : el;
}
else { // dh config
return this.createChild(el, this.dom.firstChild, returnDom);
}
},

insertSibling: function(el, where, returnDom) {
var me = this,
DomHelper = Ext.core.DomHelper,
oldUseDom = DomHelper.useDom,
isAfter = (where || 'before').toLowerCase() == 'after',
rt, insertEl, eLen, e;
if (Ext.isArray(el)) {
// append all elements to a documentFragment
insertEl = Ext.fly(document.createDocumentFragment(), '_internal');
eLen = el.length;
// DocumentFragments cannot accept innerHTML
DomHelper.useDom = true;
for (e = 0; e < eLen; e++) {
rt = insertEl.appendChild(el[e], returnDom);
}
DomHelper.useDom = oldUseDom;
// Insert fragment into document
me.dom.parentNode.insertBefore(insertEl.dom, isAfter ? me.dom.nextSibling : me.dom);
return rt;
}
el = el || {};
if (el.nodeType || el.dom) {
rt = me.dom.parentNode.insertBefore(Ext.getDom(el), isAfter ? me.dom.nextSibling : me.dom);
if (!returnDom) {
rt = Ext.get(rt);
}
} else {
if (isAfter && !me.dom.nextSibling) {
rt = DomHelper.append(me.dom.parentNode, el, !returnDom);
} else {
rt = DomHelper[isAfter ? 'insertAfter' : 'insertBefore'](me.dom, el, !returnDom);
}
}
return rt;
},

replace: function(el) {
el = Ext.get(el);
this.insertBefore(el);
el.remove();
return this;
},

replaceWith: function(el){
var me = this;
if (el.nodeType || el.dom || typeof el == 'string') {
el = Ext.get(el);
me.dom.parentNode.insertBefore(el.dom, me.dom);
} else {
el = Ext.core.DomHelper.insertBefore(me.dom, el);
}
delete Ext.cache[me.id];
Ext.removeNode(me.dom);
me.id = Ext.id(me.dom = el);
Ext.dom.AbstractElement.addToCache(me.isFlyweight ? new Ext.dom.AbstractElement(me.dom) : me);
return me;
},

createChild: function(config, insertBefore, returnDom) {
config = config || {tag:'div'};
if (insertBefore) {
return Ext.core.DomHelper.insertBefore(insertBefore, config, returnDom !== true);
}
else {
return Ext.core.DomHelper.append(this.dom, config, returnDom !== true);
}
},

wrap: function(config, returnDom, selector) {
var newEl = Ext.core.DomHelper.insertBefore(this.dom, config || {tag: "div"}, true),
target = newEl;

if (selector) {
target = Ext.DomQuery.selectNode(selector, newEl.dom);
}
target.appendChild(this.dom);
return returnDom ? newEl.dom : newEl;
},

insertHtml: function(where, html, returnEl) {
var el = Ext.core.DomHelper.insertHtml(where, this.dom, html);
return returnEl ? Ext.get(el) : el;
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/dom/AbstractElement_style.js */
(function(Ext) {
// @tag dom,core
Ext.define('Ext.dom.AbstractElement_style', {
override: 'Ext.dom.AbstractElement'
}, function() {
// local style camelizing for speed
var Element = this,
wordsRe = /\w/g,
spacesRe = /\s+/,
transparentRe = /^(?:transparent|(?:rgba[(](?:\s*\d+\s*[,]){3}\s*0\s*[)]))$/i,
// In some browsers, currently IE10 and older chrome versions, when ClassList is 
// supported most elements will have the classList attribute, but some svg elements
// will still not have it present, so in a small amount of cases we'll still need
// to check at run time whether we can use it.
hasClassList = Ext.supports.ClassList,
PADDING = 'padding',
MARGIN = 'margin',
BORDER = 'border',
LEFT_SUFFIX = '-left',
RIGHT_SUFFIX = '-right',
TOP_SUFFIX = '-top',
BOTTOM_SUFFIX = '-bottom',
WIDTH = '-width',
// special markup used throughout Ext when box wrapping elements
borders = {l: BORDER + LEFT_SUFFIX + WIDTH, r: BORDER + RIGHT_SUFFIX + WIDTH, t: BORDER + TOP_SUFFIX + WIDTH, b: BORDER + BOTTOM_SUFFIX + WIDTH},
paddings = {l: PADDING + LEFT_SUFFIX, r: PADDING + RIGHT_SUFFIX, t: PADDING + TOP_SUFFIX, b: PADDING + BOTTOM_SUFFIX},
margins = {l: MARGIN + LEFT_SUFFIX, r: MARGIN + RIGHT_SUFFIX, t: MARGIN + TOP_SUFFIX, b: MARGIN + BOTTOM_SUFFIX},
internalFly = new Element.Fly();
Ext.override(Element, {

styleHooks: {},
// private
addStyles : function(sides, styles){
var totalSize = 0,
sidesArr = (sides || '').match(wordsRe),
i,
len = sidesArr.length,
side,
styleSides = [];
if (len == 1) {
totalSize = Math.abs(parseFloat(this.getStyle(styles[sidesArr[0]])) || 0);
} else if (len) {
for (i = 0; i < len; i++) {
side = sidesArr[i];
styleSides.push(styles[side]);
}
//Gather all at once, returning a hash
styleSides = this.getStyle(styleSides);
for (i=0; i < len; i++) {
side = sidesArr[i];
totalSize += Math.abs(parseFloat(styleSides[styles[side]]) || 0);
}
}
return totalSize;
},

addCls: (function(){
var addWithClassList = function(className) {
//<debug warn>
if (String(className).indexOf('undefined') > -1) {
Ext.Logger.warn("called with an undefined className: " + className);
}
//</debug>
var me = this,
dom = me.dom,
trimRe = me.trimRe,
origClassName = className,
classList,
newCls,
i,
len,
cls;
if (typeof(className) == 'string') {
// split string on spaces to make an array of className
className = className.replace(trimRe, '').split(spacesRe);
}
// the gain we have here is that we can skip parsing className and use the
// classList.contains method, so now O(M) not O(M+N)
if (dom && className && !!(len = className.length)) {
if (!dom.className) {
dom.className = className.join(' ');
} else {
classList = dom.classList;
if (classList) {
for (i = 0; i < len; ++i) {
cls = className[i];
if (cls) {
if (!classList.contains(cls)) {
if (newCls) {
newCls.push(cls);
} else {
newCls = dom.className.replace(trimRe, '');
newCls = newCls ? [newCls, cls] : [cls];
}
}
}
}
if (newCls) {
dom.className = newCls.join(' '); // write to DOM once
}
} else {
addWithoutClassList(origClassName);
}
}
}
return me;
}, addWithoutClassList = function(className) {
//<debug warn>
if (String(className).indexOf('undefined') > -1) {
Ext.Logger.warn("called with an undefined className: '" + className + "'");
}
//</debug>
var me = this,
dom = me.dom,
elClasses;
if (dom && className && className.length) {
elClasses = Ext.Element.mergeClsList(dom.className, className);
if (elClasses.changed) {
dom.className = elClasses.join(' '); // write to DOM once
}
}
return me;
};

return hasClassList ? addWithClassList : addWithoutClassList;
})(),

removeCls: function(className) {
var me = this,
dom = me.dom,
classList,
len,
elClasses;
if (typeof(className) == 'string') {
// split string on spaces to make an array of className
className = className.replace(me.trimRe, '').split(spacesRe);
}
if (dom && dom.className && className && !!(len = className.length)) {
classList = dom.classList;
if (len === 1 && classList) {
if (className[0]) {
classList.remove(className[0]); // one DOM write
}
} else {
elClasses = Ext.Element.removeCls(dom.className, className);
if (elClasses.changed) {
dom.className = elClasses.join(' ');
}
}
}
return me;
},

radioCls: function(className) {
var cn = this.dom.parentNode.childNodes,
v,
i, len;
className = Ext.isArray(className) ? className: [className];
for (i = 0, len = cn.length; i < len; i++) {
v = cn[i];
if (v && v.nodeType == 1) {
internalFly.attach(v).removeCls(className);
}
}
return this.addCls(className);
},

toggleCls: (function(){
var toggleWithClassList = function(className){
var me = this,
dom = me.dom,
classList;
if (dom) {
className = className.replace(me.trimRe, '');
if (className) {
classList = dom.classList;
if (classList) {
classList.toggle(className);
} else {
toggleWithoutClassList(className);
}
}
}
return me;
}, toggleWithoutClassList = function(className){
return this.hasCls(className) ? this.removeCls(className) : this.addCls(className);
};

return hasClassList ? toggleWithClassList : toggleWithoutClassList;
})(),

hasCls: (function(){
var hasClsWithClassList = function(className) {
var dom = this.dom,
out = false,
classList;

if (dom && className) {
classList = dom.classList;
if (classList) {
out = classList.contains(className);
} else {
out = hasClsWithoutClassList(className);
}
}
return out;
}, hasClsWithoutClassList = function(className){
var dom = this.dom;
return dom ? className && (' '+dom.className+' ').indexOf(' '+className+' ') !== -1 : false;
};

return hasClassList ? hasClsWithClassList : hasClsWithoutClassList;
})(),

replaceCls: function(oldClassName, newClassName){
return this.removeCls(oldClassName).addCls(newClassName);
},

isStyle: function(style, val) {
return this.getStyle(style) == val;
},

getStyle: function (property, inline) {
var me = this,
dom = me.dom,
multiple = typeof property != 'string',
hooks = me.styleHooks,
prop = property,
props = prop,
len = 1,
domStyle, camel, values, hook, out, style, i;
if (multiple) {
values = {};
prop = props[0];
i = 0;
if (!(len = props.length)) {
return values;
}
}
if (!dom || dom.documentElement) {
return values || '';
}
domStyle = dom.style;
if (inline) {
style = domStyle;
} else {
// Caution: Firefox will not render "presentation" (ie. computed styles) in
// iframes that are display:none or those inheriting display:none. Similar
// issues with legacy Safari.
//
style = dom.ownerDocument.defaultView.getComputedStyle(dom, null);
// fallback to inline style if rendering context not available
if (!style) {
inline = true;
style = domStyle;
}
}
do {
hook = hooks[prop];
if (!hook) {
hooks[prop] = hook = { name: Element.normalize(prop) };
}
if (hook.get) {
out = hook.get(dom, me, inline, style);
} else {
camel = hook.name;
out = style[camel];
}
if (!multiple) {
return out;
}
values[prop] = out;
prop = props[++i];
} while (i < len);
return values;
},
getStyles: function () {
var props = Ext.Array.slice(arguments),
len = props.length,
inline;
if (len && typeof props[len-1] == 'boolean') {
inline = props.pop();
}
return this.getStyle(props, inline);
},

isTransparent: function (prop) {
var value = this.getStyle(prop);
return value ? transparentRe.test(value) : false;
},

setStyle: function(prop, value) {
var me = this,
dom = me.dom,
hooks = me.styleHooks,
style = dom.style,
name = prop,
hook;
// we don't promote the 2-arg form to object-form to avoid the overhead...
if (typeof name == 'string') {
hook = hooks[name];
if (!hook) {
hooks[name] = hook = { name: Element.normalize(name) };
}
value = (value == null) ? '' : value;
if (hook.set) {
hook.set(dom, value, me);
} else {
style[hook.name] = value;
}
if (hook.afterSet) {
hook.afterSet(dom, value, me);
}
} else {
for (name in prop) {
if (prop.hasOwnProperty(name)) {
hook = hooks[name];
if (!hook) {
hooks[name] = hook = { name: Element.normalize(name) };
}
value = prop[name];
value = (value == null) ? '' : value;
if (hook.set) {
hook.set(dom, value, me);
} else {
style[hook.name] = value;
}
if (hook.afterSet) {
hook.afterSet(dom, value, me);
}
}
}
}
return me;
},

getHeight: function(contentHeight) {
var dom = this.dom,
height = contentHeight ? (dom.clientHeight - this.getPadding("tb")) : dom.offsetHeight;
return height > 0 ? height: 0;
},

getWidth: function(contentWidth) {
var dom = this.dom,
width = contentWidth ? (dom.clientWidth - this.getPadding("lr")) : dom.offsetWidth;
return width > 0 ? width: 0;
},

setWidth: function(width) {
var me = this;
me.dom.style.width = Element.addUnits(width);
return me;
},

setHeight: function(height) {
var me = this;
me.dom.style.height = Element.addUnits(height);
return me;
},

getBorderWidth: function(side){
return this.addStyles(side, borders);
},

getPadding: function(side){
return this.addStyles(side, paddings);
},
margins : margins,

applyStyles: function(styles) {
if (styles) {
var i,
len,
dom = this.dom;
if (typeof styles == 'function') {
styles = styles.call();
}
if (typeof styles == 'string') {
styles = Ext.util.Format.trim(styles).split(/\s*(?::|;)\s*/);
for (i = 0, len = styles.length; i < len;) {
dom.style[Element.normalize(styles[i++])] = styles[i++];
}
}
else if (typeof styles == 'object') {
this.setStyle(styles);
}
}
},

setSize: function(width, height) {
var me = this,
style = me.dom.style;
if (Ext.isObject(width)) {
// in case of object from getSize()
height = width.height;
width = width.width;
}
style.width = Element.addUnits(width);
style.height = Element.addUnits(height);
return me;
},

getViewSize: function() {
var doc = document,
dom = this.dom;
if (dom == doc || dom == doc.body) {
return {
width: Element.getViewportWidth(),
height: Element.getViewportHeight()
};
}
else {
return {
width: dom.clientWidth,
height: dom.clientHeight
};
}
},

getSize: function(contentSize) {
var dom = this.dom;
return {
width: Math.max(0, contentSize ? (dom.clientWidth - this.getPadding("lr")) : dom.offsetWidth),
height: Math.max(0, contentSize ? (dom.clientHeight - this.getPadding("tb")) : dom.offsetHeight)
};
},

repaint: function() {
var dom = this.dom;
this.addCls(Ext.baseCSSPrefix + 'repaint');
setTimeout(function(){
internalFly.attach(dom).removeCls(Ext.baseCSSPrefix + 'repaint');
}, 1);
return this;
},

getMargin: function(side){
var me = this,
hash = {t:"top", l:"left", r:"right", b: "bottom"},
key,
o,
margins;
if (!side) {
margins = [];
for (key in me.margins) {
if(me.margins.hasOwnProperty(key)) {
margins.push(me.margins[key]);
}
}
o = me.getStyle(margins);
if(o && typeof o == 'object') {
//now mixin nomalized values (from hash table)
for (key in me.margins) {
if(me.margins.hasOwnProperty(key)) {
o[hash[key]] = parseFloat(o[me.margins[key]]) || 0;
}
}
}
return o;
} else {
return me.addStyles(side, me.margins);
}
},

mask: function(msg, msgCls, transparent) {
var me = this,
dom = me.dom,
data = (me.$cache || me.getCache()).data,
el = data.mask,
mask,
size,
cls = '',
prefix = Ext.baseCSSPrefix;
me.addCls(prefix + 'masked');
if (me.getStyle("position") == "static") {
me.addCls(prefix + 'masked-relative');
}
if (el) {
el.remove();
}
if (msgCls && typeof msgCls == 'string' ) {
cls = ' ' + msgCls;
}
else {
cls = ' ' + prefix + 'mask-gray';
}
mask = me.createChild({
cls: prefix + 'mask' + ((transparent !== false) ? '' : (' ' + prefix + 'mask-gray')),
html: msg ? ('<div class="' + (msgCls || (prefix + 'mask-message')) + '">' + msg + '</div>') : ''
});
size = me.getSize();
data.mask = mask;
if (dom === document.body) {
size.height = window.innerHeight;
if (me.orientationHandler) {
Ext.EventManager.unOrientationChange(me.orientationHandler, me);
}
me.orientationHandler = function() {
size = me.getSize();
size.height = window.innerHeight;
mask.setSize(size);
};
Ext.EventManager.onOrientationChange(me.orientationHandler, me);
}
mask.setSize(size);
if (Ext.is.iPad) {
Ext.repaint();
}
},

unmask: function() {
var me = this,
data = (me.$cache || me.getCache()).data,
mask = data.mask,
prefix = Ext.baseCSSPrefix;
if (mask) {
mask.remove();
delete data.mask;
}
me.removeCls([prefix + 'masked', prefix + 'masked-relative']);
if (me.dom === document.body) {
Ext.EventManager.unOrientationChange(me.orientationHandler, me);
delete me.orientationHandler;
}
}
});
Ext.onReady(function () {
var supports = Ext.supports,
styleHooks,
colorStyles, i, name, camel;
function fixTransparent (dom, el, inline, style) {
var value = style[this.name] || '';
return transparentRe.test(value) ? 'transparent' : value;
}
function fixRightMargin (dom, el, inline, style) {
var result = style.marginRight,
domStyle, display;
// Ignore cases when the margin is correctly reported as 0, the bug only shows
// numbers larger.
if (result != '0px') {
domStyle = dom.style;
display = domStyle.display;
domStyle.display = 'inline-block';
result = (inline ? style : dom.ownerDocument.defaultView.getComputedStyle(dom, null)).marginRight;
domStyle.display = display;
}
return result;
}
function fixRightMarginAndInputFocus (dom, el, inline, style) {
var result = style.marginRight,
domStyle, cleaner, display;
if (result != '0px') {
domStyle = dom.style;
cleaner = Element.getRightMarginFixCleaner(dom);
display = domStyle.display;
domStyle.display = 'inline-block';
result = (inline ? style : dom.ownerDocument.defaultView.getComputedStyle(dom, '')).marginRight;
domStyle.display = display;
cleaner();
}
return result;
}
styleHooks = Element.prototype.styleHooks;
// Ext.supports needs to be initialized (we run very early in the onready sequence),
// but it is OK to call Ext.supports.init() more times than necessary...
if (supports.init) {
supports.init();
}
// Fix bug caused by this: https://bugs.webkit.org/show_bug.cgi?id=13343
if (!supports.RightMargin) {
styleHooks.marginRight = styleHooks['margin-right'] = {
name: 'marginRight',
// TODO - Touch should use conditional compilation here or ensure that the
// underlying Ext.supports flags are set correctly...
get: (supports.DisplayChangeInputSelectionBug || supports.DisplayChangeTextAreaSelectionBug) ?
fixRightMarginAndInputFocus : fixRightMargin
};
}
if (!supports.TransparentColor) {
colorStyles = ['background-color', 'border-color', 'color', 'outline-color'];
for (i = colorStyles.length; i--; ) {
name = colorStyles[i];
camel = Element.normalize(name);
styleHooks[name] = styleHooks[camel] = {
name: camel,
get: fixTransparent
};
}
}
});
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/dom/AbstractElement_traversal.js */
(function(Ext) {
// @tag dom,core
Ext.define('Ext.dom.AbstractElement_traversal', {
override: 'Ext.dom.AbstractElement',

findParent: function(simpleSelector, limit, returnEl) {
var target = this.dom,
topmost = document.documentElement,
depth = 0,
stopEl;
limit = limit || 50;
if (isNaN(limit)) {
stopEl = Ext.getDom(limit);
limit = Number.MAX_VALUE;
}
while (target && target.nodeType == 1 && depth < limit && target != topmost && target != stopEl) {
if (Ext.DomQuery.is(target, simpleSelector)) {
return returnEl ? Ext.get(target) : target;
}
depth++;
target = target.parentNode;
}
return null;
},

findParentNode: function(simpleSelector, limit, returnEl) {
var p = Ext.fly(this.dom.parentNode, '_internal');
return p ? p.findParent(simpleSelector, limit, returnEl) : null;
},

up: function(simpleSelector, limit, returnDom) {
return this.findParentNode(simpleSelector, limit, !returnDom);
},

select: function(selector, composite) {
return Ext.dom.Element.select(selector, this.dom, composite);
},

query: function(selector) {
return Ext.DomQuery.select(selector, this.dom);
},

down: function(selector, returnDom) {
var n = Ext.DomQuery.selectNode(selector, this.dom);
return returnDom ? n : Ext.get(n);
},

child: function(selector, returnDom) {
var node,
me = this,
id;
// Pull the ID from the DOM (Ext.id also ensures that there *is* an ID).
// If this object is a Flyweight, it will not have an ID
id = Ext.id(me.dom);
// Escape "invalid" chars
id = Ext.escapeId(id);
node = Ext.DomQuery.selectNode('#' + id + " > " + selector, me.dom);
return returnDom ? node : Ext.get(node);
},

parent: function(selector, returnDom) {
return this.matchNode('parentNode', 'parentNode', selector, returnDom);
},

next: function(selector, returnDom) {
return this.matchNode('nextSibling', 'nextSibling', selector, returnDom);
},

prev: function(selector, returnDom) {
return this.matchNode('previousSibling', 'previousSibling', selector, returnDom);
},

first: function(selector, returnDom) {
return this.matchNode('nextSibling', 'firstChild', selector, returnDom);
},

last: function(selector, returnDom) {
return this.matchNode('previousSibling', 'lastChild', selector, returnDom);
},
matchNode: function(dir, start, selector, returnDom) {
if (!this.dom) {
return null;
}
var n = this.dom[start];
while (n) {
if (n.nodeType == 1 && (!selector || Ext.DomQuery.is(n, selector))) {
return !returnDom ? Ext.get(n) : n;
}
n = n[dir];
}
return null;
},
isAncestor: function(element) {
return this.self.isAncestor.call(this.self, this.dom, element);
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/dom/AbstractElement.js */
(function(Ext) {
// @tag dom,core
// @require Ext.Supports
Ext.define('Ext.dom.AbstractElement', {
requires: [
'Ext.EventManager',
'Ext.dom.AbstractElement_static',
'Ext.dom.AbstractElement_insertion',
'Ext.dom.AbstractElement_style',
'Ext.dom.AbstractElement_traversal'
],
trimRe: /^\s+|\s+$/g,
whitespaceRe: /\s/,

inheritableStatics: {
trimRe: /^\s+|\s+$/g,
whitespaceRe: /\s/,

get: function(el) {
var me = this,
document = window.document,
El = Ext.dom.Element,
cacheItem,
docEl,
extEl,
dom,
id;
if (!el) {
return null;
}
// Ext.get(flyweight) must return an Element instance, not the flyweight
if (el.isFly) {
el = el.dom;
}
if (typeof el == "string") { // element id
if (el == Ext.windowId) {
return El.get(window);
} else if (el == Ext.documentId) {
return El.get(document);
}

cacheItem = Ext.cache[el];
// This code is here to catch the case where we've got a reference to a document of an iframe
// It getElementById will fail because it's not part of the document, so if we're skipping
// GC it means it's a window/document object that isn't the default window/document, which we have
// already handled above
if (cacheItem && cacheItem.skipGarbageCollection) {
extEl = cacheItem.el;
return extEl;
}

if (!(dom = document.getElementById(el))) {
return null;
}
if (cacheItem && cacheItem.el) {
extEl = Ext.updateCacheEntry(cacheItem, dom).el;
} else {
// Force new element if there's a cache but no el attached
extEl = new El(dom, !!cacheItem);
}
return extEl;
} else if (el.tagName) { // dom element
if (!(id = el.id)) {
id = Ext.id(el);
}
cacheItem = Ext.cache[id];
if (cacheItem && cacheItem.el) {
extEl = Ext.updateCacheEntry(cacheItem, el).el;
} else {
// Force new element if there's a cache but no el attached
extEl = new El(el, !!cacheItem);
}
return extEl;
} else if (el instanceof me) {
if (el != me.docEl && el != me.winEl) {
id = el.id;
// refresh dom element in case no longer valid,
// catch case where it hasn't been appended
cacheItem = Ext.cache[id];
if (cacheItem) {
Ext.updateCacheEntry(cacheItem, document.getElementById(id) || el.dom);
}
}
return el;
} else if (el.isComposite) {
return el;
} else if (Ext.isArray(el)) {
return me.select(el);
} else if (el === document) {
// create a bogus element object representing the document object
if (!me.docEl) {
docEl = me.docEl = Ext.Object.chain(El.prototype);
docEl.dom = document;
// set an "el" property on the element that references itself.
// This allows Ext.util.Positionable methods to operate on
// this.el.dom since it gets mixed into both Element and Component
docEl.el = docEl;
docEl.id = Ext.id(document);
me.addToCache(docEl);
}
return me.docEl;
} else if (el === window) {
if (!me.winEl) {
me.winEl = Ext.Object.chain(El.prototype);
me.winEl.dom = window;
me.winEl.id = Ext.id(window);
me.addToCache(me.winEl);
}
return me.winEl;
}
return null;
},
addToCache: function(el, id) {
if (el) {
Ext.addCacheEntry(id, el);
}
return el;
},
addMethods: function() {
this.override.apply(this, arguments);
},

mergeClsList: function() {
var clsList, clsHash = {},
i, length, j, listLength, clsName, result = [],
changed = false,
trimRe = this.trimRe,
whitespaceRe = this.whitespaceRe;
for (i = 0, length = arguments.length; i < length; i++) {
clsList = arguments[i];
if (Ext.isString(clsList)) {
clsList = clsList.replace(trimRe, '').split(whitespaceRe);
}
if (clsList) {
for (j = 0, listLength = clsList.length; j < listLength; j++) {
clsName = clsList[j];
if (!clsHash[clsName]) {
if (i) {
changed = true;
}
clsHash[clsName] = true;
}
}
}
}
for (clsName in clsHash) {
result.push(clsName);
}
result.changed = changed;
return result;
},

removeCls: function(existingClsList, removeClsList) {
var clsHash = {},
i, length, clsName, result = [],
changed = false,
whitespaceRe = this.whitespaceRe;
if (existingClsList) {
if (Ext.isString(existingClsList)) {
existingClsList = existingClsList.replace(this.trimRe, '').split(whitespaceRe);
}
for (i = 0, length = existingClsList.length; i < length; i++) {
clsHash[existingClsList[i]] = true;
}
}
if (removeClsList) {
if (Ext.isString(removeClsList)) {
removeClsList = removeClsList.split(whitespaceRe);
}
for (i = 0, length = removeClsList.length; i < length; i++) {
clsName = removeClsList[i];
if (clsHash[clsName]) {
changed = true;
delete clsHash[clsName];
}
}
}
for (clsName in clsHash) {
result.push(clsName);
}
result.changed = changed;
return result;
},

VISIBILITY: 1,

DISPLAY: 2,

OFFSETS: 3,

ASCLASS: 4
},
constructor: function(element, forceNew) {
var me = this,
dom = typeof element == 'string'
? document.getElementById(element)
: element,
id;
// set an "el" property that references "this". This allows
// Ext.util.Positionable methods to operate on this.el.dom since it
// gets mixed into both Element and Component
me.el = me;
if (!dom) {
return null;
}
id = dom.id;
if (!forceNew && id && Ext.cache[id]) {
// element object already exists
return Ext.cache[id].el;
}

me.dom = dom;

me.id = id || Ext.id(dom);
me.self.addToCache(me);
},

set: function(o, useSet) {
var el = this.dom,
attr,
value;
for (attr in o) {
if (o.hasOwnProperty(attr)) {
value = o[attr];
if (attr == 'style') {
this.applyStyles(value);
}
else if (attr == 'cls') {
el.className = value;
}
else if (useSet !== false) {
if (value === undefined) {
el.removeAttribute(attr);
} else {
el.setAttribute(attr, value);
}
}
else {
el[attr] = value;
}
}
}
return this;
},

defaultUnit: "px",

is: function(simpleSelector) {
return Ext.DomQuery.is(this.dom, simpleSelector);
},

getValue: function(asNumber) {
var val = this.dom.value;
return asNumber ? parseInt(val, 10) : val;
},

remove: function() {
var me = this,
dom = me.dom;

if (me.isAnimate) {
me.stopAnimation();
}
if (dom) {
Ext.removeNode(dom);
delete me.dom;
}
},

contains: function(el) {
if (!el) {
return false;
}
var me = this,
dom = el.dom || el;
// we need el-contains-itself logic here because isAncestor does not do that:
return (dom === me.dom) || Ext.dom.AbstractElement.isAncestor(me.dom, dom);
},

getAttribute: function(name, ns) {
var dom = this.dom;
return dom.getAttributeNS(ns, name) || dom.getAttribute(ns + ":" + name) || dom.getAttribute(name) || dom[name];
},

update: function(html) {
if (this.dom) {
this.dom.innerHTML = html;
}
return this;
},

setHTML: function(html) {
if(this.dom) {
this.dom.innerHTML = html;
}
return this;
},

getHTML: function() {
return this.dom ? this.dom.innerHTML : '';
},

hide: function() {
this.setVisible(false);
return this;
},

show: function() {
this.setVisible(true);
return this;
},

setVisible: function(visible, animate) {
var me = this,
statics = me.self,
mode = me.getVisibilityMode(),
prefix = Ext.baseCSSPrefix;
switch (mode) {
case statics.VISIBILITY:
me.removeCls([prefix + 'hidden-display', prefix + 'hidden-offsets']);
me[visible ? 'removeCls' : 'addCls'](prefix + 'hidden-visibility');
break;
case statics.DISPLAY:
me.removeCls([prefix + 'hidden-visibility', prefix + 'hidden-offsets']);
me[visible ? 'removeCls' : 'addCls'](prefix + 'hidden-display');
break;
case statics.OFFSETS:
me.removeCls([prefix + 'hidden-visibility', prefix + 'hidden-display']);
me[visible ? 'removeCls' : 'addCls'](prefix + 'hidden-offsets');
break;
}
return me;
},
getVisibilityMode: function() {
// Only flyweights won't have a $cache object, by calling getCache the cache
// will be created for future accesses. As such, we're eliminating the method
// call since it's mostly redundant
var data = (this.$cache || this.getCache()).data,
visMode = data.visibilityMode;
if (visMode === undefined) {
data.visibilityMode = visMode = this.self.DISPLAY;
}

return visMode;
},

setVisibilityMode: function(mode) {
(this.$cache || this.getCache()).data.visibilityMode = mode;
return this;
},

getCache: function() {
var me = this,
id = me.dom.id || Ext.id(me.dom);
// Note that we do not assign an ID to the calling object here.
// An Ext.dom.Element will have one assigned at construction, and an Ext.dom.Element.Fly must not have one.
// We assign an ID to the DOM element if it does not have one.
me.$cache = Ext.cache[id] || Ext.addCacheEntry(id, null, me.dom);

return me.$cache;
}
},
function() {
var AbstractElement = this;

Ext.getDetachedBody = function () {
var detachedEl = AbstractElement.detachedBodyEl;
if (!detachedEl) {
detachedEl = document.createElement('div');
AbstractElement.detachedBodyEl = detachedEl = new AbstractElement.Fly(detachedEl);
detachedEl.isDetachedBody = true;
}
return detachedEl;
};

Ext.getElementById = function (id) {
var el = document.getElementById(id),
detachedBodyEl;
if (!el && (detachedBodyEl = AbstractElement.detachedBodyEl)) {
el = detachedBodyEl.dom.querySelector('#' + Ext.escapeId(id));
}
return el;
};

Ext.get = function(el) {
return Ext.dom.Element.get(el);
};
this.addStatics({

Fly: new Ext.Class({
// Although here the class is extending from AbstractElement,
// the class will be overwritten by Element definition with
// a class extending from Element instead.
// Therefore above we document it as extending Ext.Element.
extend: AbstractElement,

isFly: true,
constructor: function(dom) {
this.dom = dom;
// set an "el" property that references "this". This allows
// Ext.util.Positionable methods to operate on this.el.dom since it
// gets mixed into both Element and Component
this.el = this;
},

attach: function (dom) {
// Attach to the passed DOM element. The same code as in Ext.Fly
this.dom = dom;
// Use cached data if there is existing cached data for the referenced DOM element,
// otherwise it will be created when needed by getCache.
this.$cache = dom.id ? Ext.cache[dom.id] : null;
return this;
}
}),
_flyweights: {},

fly: function(dom, named) {
var fly = null,
_flyweights = AbstractElement._flyweights;
named = named || '_global';
dom = Ext.getDom(dom);
if (dom) {
fly = _flyweights[named] || (_flyweights[named] = new AbstractElement.Fly());
// Attach to the passed DOM element.
// This code performs the same function as Fly.attach, but inline it for efficiency
fly.dom = dom;
// Use cached data if there is existing cached data for the referenced DOM element,
// otherwise it will be created when needed by getCache.
fly.$cache = dom.id ? Ext.cache[dom.id] : null;
}
return fly;
}
});

Ext.fly = function() {
return AbstractElement.fly.apply(AbstractElement, arguments);
};
(function (proto) {

proto.destroy = proto.remove;

if (document.querySelector) {
proto.getById = function (id, asDom) {
// for normal elements getElementById is the best solution, but if the el is
// not part of the document.body, we have to resort to querySelector
var dom = document.getElementById(id) ||
this.dom.querySelector('#'+Ext.escapeId(id));
return asDom ? dom : (dom ? Ext.get(dom) : null);
};
} else {
proto.getById = function (id, asDom) {
var dom = document.getElementById(id);
return asDom ? dom : (dom ? Ext.get(dom) : null);
};
}
}(this.prototype));
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/dom/Helper.js */
(function(Ext) {
// @tag dom,core
// @define Ext.DomHelper
// @define Ext.core.DomHelper
Ext.define('Ext.dom.Helper', (function() {
// kill repeat to save bytes
var afterbegin = 'afterbegin',
afterend = 'afterend',
beforebegin = 'beforebegin',
beforeend = 'beforeend',
ts = '<table>',
te = '</table>',
tbs = ts+'<tbody>',
tbe = '</tbody>'+te,
trs = tbs + '<tr>',
tre = '</tr>'+tbe,
detachedDiv = document.createElement('div'),
bbValues = ['BeforeBegin', 'previousSibling'],
aeValues = ['AfterEnd', 'nextSibling'],
bb_ae_PositionHash = {
beforebegin: bbValues,
afterend: aeValues
},
fullPositionHash = {
beforebegin: bbValues,
afterend: aeValues,
afterbegin: ['AfterBegin', 'firstChild'],
beforeend: ['BeforeEnd', 'lastChild']
};
return {
extend: 'Ext.dom.AbstractHelper',
requires:['Ext.dom.AbstractElement'],
tableRe: /^(?:table|thead|tbody|tr|td)$/i,
tableElRe: /td|tr|tbody|thead/i,

useDom : false,

createDom: function(o, parentNode){
var el,
doc = document,
useSet,
attr,
val,
cn,
i, l;
if (Ext.isArray(o)) { // Allow Arrays of siblings to be inserted
el = doc.createDocumentFragment(); // in one shot using a DocumentFragment
for (i = 0, l = o.length; i < l; i++) {
this.createDom(o[i], el);
}
} else if (typeof o == 'string') { // Allow a string as a child spec.
el = doc.createTextNode(o);
} else {
el = doc.createElement(o.tag || 'div');
useSet = !!el.setAttribute; // In IE some elements don't have setAttribute
for (attr in o) {
if (!this.confRe.test(attr)) {
val = o[attr];
if (attr == 'cls') {
el.className = val;
} else {
if (useSet) {
el.setAttribute(attr, val);
} else {
el[attr] = val;
}
}
}
}
Ext.DomHelper.applyStyles(el, o.style);
if ((cn = o.children || o.cn)) {
this.createDom(cn, el);
} else if (o.html) {
el.innerHTML = o.html;
}
}
if (parentNode) {
parentNode.appendChild(el);
}
return el;
},
ieTable: function(depth, openingTags, htmlContent, closingTags){
detachedDiv.innerHTML = [openingTags, htmlContent, closingTags].join('');
var i = -1,
el = detachedDiv,
ns;
while (++i < depth) {
el = el.firstChild;
}
// If the result is multiple siblings, then encapsulate them into one fragment.
ns = el.nextSibling;
if (ns) {
ns = el;
el = document.createDocumentFragment();

while (ns) {
nx = ns.nextSibling;
el.appendChild(ns);
ns = nx;
}
}
return el;
},

insertIntoTable: function(tag, where, destinationEl, html) {
var node,
before,
bb = where == beforebegin,
ab = where == afterbegin,
be = where == beforeend,
ae = where == afterend;
if (tag == 'td' && (ab || be) || !this.tableElRe.test(tag) && (bb || ae)) {
return null;
}
before = bb ? destinationEl :
ae ? destinationEl.nextSibling :
ab ? destinationEl.firstChild : null;
if (bb || ae) {
destinationEl = destinationEl.parentNode;
}
if (tag == 'td' || (tag == 'tr' && (be || ab))) {
node = this.ieTable(4, trs, html, tre);
} else if (((tag == 'tbody' || tag == 'thead') && (be || ab)) ||
(tag == 'tr' && (bb || ae))) {
node = this.ieTable(3, tbs, html, tbe);
} else {
node = this.ieTable(2, ts, html, te);
}
destinationEl.insertBefore(node, before);
return node;
},

createContextualFragment: function(html) {
var fragment = document.createDocumentFragment(),
length, childNodes;
detachedDiv.innerHTML = html;
childNodes = detachedDiv.childNodes;
length = childNodes.length;
// Move nodes into fragment, don't clone: http://jsperf.com/create-fragment
while (length--) {
fragment.appendChild(childNodes[0]);
}
return fragment;
},
applyStyles: function(el, styles) {
if (styles) {
if (typeof styles == "function") {
styles = styles.call();
}
if (typeof styles == "string") {
styles = Ext.dom.Element.parseStyles(styles);
}
if (typeof styles == "object") {
Ext.fly(el, '_applyStyles').setStyle(styles);
}
}
},

createHtml: function(spec) {
return this.markup(spec);
},
doInsert: function(el, o, returnElement, pos, sibling, append) {

el = el.dom || Ext.getDom(el);
var newNode;
if (this.useDom) {
newNode = this.createDom(o, null);
if (append) {
el.appendChild(newNode);
}
else {
(sibling == 'firstChild' ? el : el.parentNode).insertBefore(newNode, el[sibling] || el);
}
} else {
newNode = this.insertHtml(pos, el, this.markup(o));
}
return returnElement ? Ext.get(newNode, true) : newNode;
},

overwrite: function(el, html, returnElement) {
var newNode;
el = Ext.getDom(el);
html = this.markup(html);
// IE Inserting HTML into a table/tbody/tr requires extra processing: http://www.ericvasilik.com/2006/07/code-karma.html
if (Ext.isIE && this.tableRe.test(el.tagName)) {
// Clearing table elements requires removal of all elements.
while (el.firstChild) {
el.removeChild(el.firstChild);
}
if (html) {
newNode = this.insertHtml('afterbegin', el, html);
return returnElement ? Ext.get(newNode) : newNode;
}
return null;
}
el.innerHTML = html;
return returnElement ? Ext.get(el.firstChild) : el.firstChild;
},
insertHtml: function(where, el, html) {
var hashVal,
range,
rangeEl,
setStart,
frag;
where = where.toLowerCase();
// Has fast HTML insertion into existing DOM: http://www.w3.org/TR/html5/apis-in-html-documents.html#insertadjacenthtml
if (el.insertAdjacentHTML) {
// IE's incomplete table implementation: http://www.ericvasilik.com/2006/07/code-karma.html
if (Ext.isIE && this.tableRe.test(el.tagName) && (frag = this.insertIntoTable(el.tagName.toLowerCase(), where, el, html))) {
return frag;
}
if ((hashVal = fullPositionHash[where])) {
if (Ext.global.MSApp && Ext.global.MSApp.execUnsafeLocalFunction) {
//ALLOW MS TO EXECUTE THIS CODE FOR NATIVE WINDOWS 8 DESKTOP APPS
MSApp.execUnsafeLocalFunction(function () {
el.insertAdjacentHTML(hashVal[0], html);
});
} else {
el.insertAdjacentHTML(hashVal[0], html);
}
return el[hashVal[1]];
}
// if (not IE and context element is an HTMLElement) or TextNode
} else {
// we cannot insert anything inside a textnode so...
if (el.nodeType === 3) {
where = where === 'afterbegin' ? 'beforebegin' : where;
where = where === 'beforeend' ? 'afterend' : where;
}
range = Ext.supports.CreateContextualFragment ? el.ownerDocument.createRange() : undefined;
setStart = 'setStart' + (this.endRe.test(where) ? 'After' : 'Before');
if (bb_ae_PositionHash[where]) {
if (range) {
range[setStart](el);
frag = range.createContextualFragment(html);
} else {
frag = this.createContextualFragment(html);
}
el.parentNode.insertBefore(frag, where == beforebegin ? el : el.nextSibling);
return el[(where == beforebegin ? 'previous' : 'next') + 'Sibling'];
} else {
rangeEl = (where == afterbegin ? 'first' : 'last') + 'Child';
if (el.firstChild) {
if (range) {
range[setStart](el[rangeEl]);
frag = range.createContextualFragment(html);
} else {
frag = this.createContextualFragment(html);
}
if (where == afterbegin) {
el.insertBefore(frag, el.firstChild);
} else {
el.appendChild(frag);
}
} else {
el.innerHTML = html;
}
return el[rangeEl];
}
}
//<debug>
Ext.Error.raise({
sourceClass: 'Ext.DomHelper',
sourceMethod: 'insertHtml',
htmlToInsert: html,
targetElement: el,
msg: 'Illegal insertion point reached: "' + where + '"'
});
//</debug>
},

createTemplate: function(o) {
var html = this.markup(o);
return new Ext.Template(html);
}
};
})(), function() {
Ext.ns('Ext.core');
Ext.DomHelper = Ext.core.DomHelper = new this;
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/dom/Query.js */
(function(Ext) {
// @tag dom,core
// @require Helper.js
// @define Ext.dom.Query
// @define Ext.core.DomQuery
// @define Ext.DomQuery
Ext.ns('Ext.core');
Ext.dom.Query = Ext.core.DomQuery = Ext.DomQuery = (function() {
var DQ,
doc = document,
cache = {},
simpleCache = {},
valueCache = {},
useClassList = !!doc.documentElement.classList,
useElementPointer = !!doc.documentElement.firstElementChild,
useChildrenCollection = (function() {
var d = doc.createElement('div');
d.innerHTML = '<!-- -->text<!-- -->';
return d.children && (d.children.length === 0);
})(),
nonSpace = /\S/,
trimRe = /^\s+|\s+$/g,
tplRe = /\{(\d+)\}/g,
modeRe = /^(\s?[\/>+~]\s?|\s|$)/,
tagTokenRe = /^(#)?([\w\-\*\|\\]+)/,
nthRe = /(\d*)n\+?(\d*)/,
nthRe2 = /\D/,
startIdRe = /^\s*#/,
// This is for IE MSXML which does not support expandos.
// IE runs the same speed using setAttribute, however FF slows way down
// and Safari completely fails so they need to continue to use expandos.
isIE = window.ActiveXObject ? true : false,
key = 30803,
longHex = /\\([0-9a-fA-F]{6})/g,
shortHex = /\\([0-9a-fA-F]{1,6})\s{0,1}/g,
nonHex = /\\([^0-9a-fA-F]{1})/g,
escapes = /\\/g,
num, hasEscapes,
// True if the browser supports the following syntax:
// document.getElementsByTagName('namespacePrefix:tagName')
supportsColonNsSeparator = (function () {
var xmlDoc,
xmlString = '<r><a:b xmlns:a="n"></a:b></r>';
if (window.DOMParser) {
xmlDoc = (new DOMParser()).parseFromString(xmlString, "application/xml");
} else {
xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
xmlDoc.loadXML(xmlString);
}
return !!xmlDoc.getElementsByTagName('a:b').length;
})(),
// replaces a long hex regex match group with the appropriate ascii value
// $args indicate regex match pos
longHexToChar = function($0, $1) {
return String.fromCharCode(parseInt($1, 16));
},
// converts a shortHex regex match to the long form
shortToLongHex = function($0, $1) {
while ($1.length < 6) {
$1 = '0' + $1;
}
return '\\' + $1;
},
// converts a single char escape to long escape form
charToLongHex = function($0, $1) {
num = $1.charCodeAt(0).toString(16);
if (num.length === 1) {
num = '0' + num;
}
return '\\0000' + num;
},
// Un-escapes an input selector string. Assumes all escape sequences have been
// normalized to the css '\\0000##' 6-hex-digit style escape sequence :
// will not handle any other escape formats
unescapeCssSelector = function(selector) {
return (hasEscapes) ? selector.replace(longHex, longHexToChar) : selector;
},
// checks if the path has escaping & does any appropriate replacements
setupEscapes = function(path) {
hasEscapes = (path.indexOf('\\') > -1);
if (hasEscapes) {
path = path
.replace(shortHex, shortToLongHex)
.replace(nonHex, charToLongHex)
.replace(escapes, '\\\\'); // double the '\' for js compilation
}
return path;
};
// this eval is stop the compressor from
// renaming the variable to something shorter
eval("var batch = 30803, child, next, prev, byClassName;");
// Retrieve the child node from a particular
// parent at the specified index.
child = useChildrenCollection ?
function child(parent, index) {
return parent.children[index];
} :
function child(parent, index) {
var i = 0,
n = parent.firstChild;
while (n) {
if (n.nodeType == 1) {
if (++i == index) {
return n;
}
}
n = n.nextSibling;
}
return null;
};
// retrieve the next element node
next = useElementPointer ?
function(n) {
return n.nextElementSibling;
} :
function(n) {
while ((n = n.nextSibling) && n.nodeType != 1);
return n;
};
// retrieve the previous element node
prev = useElementPointer ?
function(n) {
return n.previousElementSibling;
} :
function(n) {
while ((n = n.previousSibling) && n.nodeType != 1);
return n;
};
// Mark each child node with a nodeIndex skipping and
// removing empty text nodes.
function children(parent) {
var n = parent.firstChild,
nodeIndex = -1,
nextNode;
while (n) {
nextNode = n.nextSibling;
// clean worthless empty nodes.
if (n.nodeType == 3 && !nonSpace.test(n.nodeValue)) {
parent.removeChild(n);
} else {
// add an expando nodeIndex
n.nodeIndex = ++nodeIndex;
}
n = nextNode;
}
return this;
}
// nodeSet - array of nodes
// cls - CSS Class
byClassName = useClassList ? // Use classList API where available: http://jsperf.com/classlist-vs-old-school-check/
function (nodeSet, cls) {
cls = unescapeCssSelector(cls);
if (!cls) {
return nodeSet;
}
var result = [], ri = -1,
i, ci, classList;
for (i = 0; ci = nodeSet[i]; i++) {
classList = ci.classList;
if (classList) {
if (classList.contains(cls)) {
result[++ri] = ci;
}
} else if ((' ' + ci.className + ' ').indexOf(cls) !== -1) {
// Some elements types (SVG) may not always have a classList
// in some browsers, so fallback to the old style here
result[++ri] = ci;
}
}
return result;
} :
function (nodeSet, cls) {
cls = unescapeCssSelector(cls);
if (!cls) {
return nodeSet;
}
var result = [], ri = -1,
i, ci;
for (i = 0; ci = nodeSet[i]; i++) {
if ((' ' + ci.className + ' ').indexOf(cls) !== -1) {
result[++ri] = ci;
}
}
return result;
};
function attrValue(n, attr) {
// if its an array, use the first node.
if (!n.tagName && typeof n.length != "undefined") {
n = n[0];
}
if (!n) {
return null;
}
if (attr == "for") {
return n.htmlFor;
}
if (attr == "class" || attr == "className") {
return n.className;
}
return n.getAttribute(attr) || n[attr];
}
// ns - nodes
// mode - false, /, >, +, ~
// tagName - defaults to "*"
function getNodes(ns, mode, tagName) {
var result = [], ri = -1, cs,
i, ni, j, ci, cn, utag, n, cj;
if (!ns) {
return result;
}
tagName = tagName.replace('|', ':') || "*";
// convert to array
if (typeof ns.getElementsByTagName != "undefined") {
ns = [ns];
}
// no mode specified, grab all elements by tagName
// at any depth
if (!mode) {
tagName = unescapeCssSelector(tagName);
if (!supportsColonNsSeparator && DQ.isXml(ns[0]) &&
tagName.indexOf(':') !== -1) {
// Some browsers (e.g. WebKit and Opera do not support the following syntax
// in xml documents: getElementsByTagName('ns:tagName'). To work around
// this, we remove the namespace prefix from the tagName, get the elements
// by tag name only, and then compare each element's tagName property to
// the tagName with namespace prefix attached to ensure that the tag is in
// the proper namespace.
for (i = 0; ni = ns[i]; i++) {
cs = ni.getElementsByTagName(tagName.split(':').pop());
for (j = 0; ci = cs[j]; j++) {
if (ci.tagName === tagName) {
result[++ri] = ci;
}
}
}
} else {
for (i = 0; ni = ns[i]; i++) {
cs = ni.getElementsByTagName(tagName);
for (j = 0; ci = cs[j]; j++) {
result[++ri] = ci;
}
}
}
// Direct Child mode (/ or >)
// E > F or E/F all direct children elements of E that have the tag
} else if (mode == "/" || mode == ">") {
utag = tagName.toUpperCase();
for (i = 0; ni = ns[i]; i++) {
cn = ni.childNodes;
for (j = 0; cj = cn[j]; j++) {
if (cj.nodeName == utag || cj.nodeName == tagName || tagName == '*') {
result[++ri] = cj;
}
}
}
// Immediately Preceding mode (+)
// E + F all elements with the tag F that are immediately preceded by an element with the tag E
} else if (mode == "+") {
utag = tagName.toUpperCase();
for (i = 0; n = ns[i]; i++) {
while ((n = n.nextSibling) && n.nodeType != 1);
if (n && (n.nodeName == utag || n.nodeName == tagName || tagName == '*')) {
result[++ri] = n;
}
}
// Sibling mode (~)
// E ~ F all elements with the tag F that are preceded by a sibling element with the tag E
} else if (mode == "~") {
utag = tagName.toUpperCase();
for (i = 0; n = ns[i]; i++) {
while ((n = n.nextSibling)) {
if (n.nodeName == utag || n.nodeName == tagName || tagName == '*') {
result[++ri] = n;
}
}
}
}
return result;
}
function concat(a, b) {
a.push.apply(a, b);
return a;
}
function byTag(cs, tagName) {
if (cs.tagName || cs === doc) {
cs = [cs];
}
if (!tagName) {
return cs;
}
var result = [], ri = -1,
i, ci;
tagName = tagName.toLowerCase();
for (i = 0; ci = cs[i]; i++) {
if (ci.nodeType == 1 && ci.tagName.toLowerCase() == tagName) {
result[++ri] = ci;
}
}
return result;
}
function byId(cs, id) {
id = unescapeCssSelector(id);
if (cs.tagName || cs === doc) {
cs = [cs];
}
if (!id) {
return cs;
}
var result = [], ri = -1,
i, ci;
for (i = 0; ci = cs[i]; i++) {
if (ci && ci.id == id) {
result[++ri] = ci;
return result;
}
}
return result;
}
// operators are =, !=, ^=, $=, *=, %=, |= and ~=
// custom can be "{"
function byAttribute(cs, attr, value, op, custom) {
var result = [],
ri = -1,
useGetStyle = custom == "{",
fn = DQ.operators[op],
a,
xml,
hasXml,
i, ci;
value = unescapeCssSelector(value);
for (i = 0; ci = cs[i]; i++) {
// skip non-element nodes.
if (ci.nodeType === 1) {
// only need to do this for the first node
if (!hasXml) {
xml = DQ.isXml(ci);
hasXml = true;
}
// we only need to change the property names if we're dealing with html nodes, not XML
if (!xml) {
if (useGetStyle) {
a = DQ.getStyle(ci, attr);
} else if (attr == "class" || attr == "className") {
a = ci.className;
} else if (attr == "for") {
a = ci.htmlFor;
} else if (attr == "href") {
// getAttribute href bug
// http://www.glennjones.net/Post/809/getAttributehrefbug.htm
a = ci.getAttribute("href", 2);
} else {
a = ci.getAttribute(attr);
}
} else {
a = ci.getAttribute(attr);
}
if ((fn && fn(a, value)) || (!fn && a)) {
result[++ri] = ci;
}
}
}
return result;
}
function byPseudo(cs, name, value) {
value = unescapeCssSelector(value);
return DQ.pseudos[name](cs, value);
}
function nodupIEXml(cs) {
var d = ++key,
r,
i, len, c;
cs[0].setAttribute("_nodup", d);
r = [cs[0]];
for (i = 1, len = cs.length; i < len; i++) {
c = cs[i];
if (!c.getAttribute("_nodup") != d) {
c.setAttribute("_nodup", d);
r[r.length] = c;
}
}
for (i = 0, len = cs.length; i < len; i++) {
cs[i].removeAttribute("_nodup");
}
return r;
}
function nodup(cs) {
if (!cs) {
return [];
}
var len = cs.length, c, i, r = cs, cj, ri = -1, d, j;
if (!len || typeof cs.nodeType != "undefined" || len == 1) {
return cs;
}
if (isIE && typeof cs[0].selectSingleNode != "undefined") {
return nodupIEXml(cs);
}
d = ++key;
cs[0]._nodup = d;
for (i = 1; c = cs[i]; i++) {
if (c._nodup != d) {
c._nodup = d;
} else {
r = [];
for (j = 0; j < i; j++) {
r[++ri] = cs[j];
}
for (j = i + 1; cj = cs[j]; j++) {
if (cj._nodup != d) {
cj._nodup = d;
r[++ri] = cj;
}
}
return r;
}
}
return r;
}
function quickDiffIEXml(c1, c2) {
var d = ++key,
r = [],
i, len;
for (i = 0, len = c1.length; i < len; i++) {
c1[i].setAttribute("_qdiff", d);
}
for (i = 0, len = c2.length; i < len; i++) {
if (c2[i].getAttribute("_qdiff") != d) {
r[r.length] = c2[i];
}
}
for (i = 0, len = c1.length; i < len; i++) {
c1[i].removeAttribute("_qdiff");
}
return r;
}
function quickDiff(c1, c2) {
var len1 = c1.length,
d = ++key,
r = [],
i, len;
if (!len1) {
return c2;
}
if (isIE && typeof c1[0].selectSingleNode != "undefined") {
return quickDiffIEXml(c1, c2);
}
for (i = 0; i < len1; i++) {
c1[i]._qdiff = d;
}
for (i = 0, len = c2.length; i < len; i++) {
if (c2[i]._qdiff != d) {
r[r.length] = c2[i];
}
}
return r;
}
function quickId(ns, mode, root, id) {
if (ns == root) {
id = unescapeCssSelector(id);
var d = root.ownerDocument || root;
return d.getElementById(id);
}
ns = getNodes(ns, mode, "*");
return byId(ns, id);
}
return DQ = {
getStyle: function(el, name) {
return Ext.fly(el, '_DomQuery').getStyle(name);
},

compile: function(path, type) {
type = type || "select";
// setup fn preamble
var fn = ["var f = function(root) {\n var mode; ++batch; var n = root || document;\n"],
lastPath,
matchers = DQ.matchers,
matchersLn = matchers.length,
modeMatch,
// accept leading mode switch
lmode = path.match(modeRe),
tokenMatch, matched, j, t, m;
path = setupEscapes(path);
if (lmode && lmode[1]) {
fn[fn.length] = 'mode="' + lmode[1].replace(trimRe, "") + '";';
path = path.replace(lmode[1], "");
}
// strip leading slashes
while (path.substr(0, 1) == "/") {
path = path.substr(1);
}
while (path && lastPath != path) {
lastPath = path;
tokenMatch = path.match(tagTokenRe);
if (type == "select") {
if (tokenMatch) {
// ID Selector
if (tokenMatch[1] == "#") {
fn[fn.length] = 'n = quickId(n, mode, root, "' + tokenMatch[2] + '");';
} else {
fn[fn.length] = 'n = getNodes(n, mode, "' + tokenMatch[2] + '");';
}
path = path.replace(tokenMatch[0], "");
} else if (path.substr(0, 1) != '@') {
fn[fn.length] = 'n = getNodes(n, mode, "*");';
}
// type of "simple"
} else {
if (tokenMatch) {
if (tokenMatch[1] == "#") {
fn[fn.length] = 'n = byId(n, "' + tokenMatch[2] + '");';
} else {
fn[fn.length] = 'n = byTag(n, "' + tokenMatch[2] + '");';
}
path = path.replace(tokenMatch[0], "");
}
}
while (!(modeMatch = path.match(modeRe))) {
matched = false;
for (j = 0; j < matchersLn; j++) {
t = matchers[j];
m = path.match(t.re);
if (m) {
fn[fn.length] = t.select.replace(tplRe, function(x, i) {
return m[i];
});
path = path.replace(m[0], "");
matched = true;
break;
}
}
// prevent infinite loop on bad selector
if (!matched) {
Ext.Error.raise({
sourceClass:'Ext.DomQuery',
sourceMethod:'compile',
msg:'Error parsing selector. Parsing failed at "' + path + '"'
});
}
}
if (modeMatch[1]) {
fn[fn.length] = 'mode="' + modeMatch[1].replace(trimRe, "") + '";';
path = path.replace(modeMatch[1], "");
}
}
// close fn out
fn[fn.length] = "return nodup(n);\n}";
// eval fn and return it
eval(fn.join(""));
return f;
},

jsSelect: function(path, root, type) {
// set root to doc if not specified.
root = root || doc;
if (typeof root == "string") {
root = doc.getElementById(root);
}
var paths = path.split(","),
results = [],
i, len, subPath, result;
// loop over each selector
for (i = 0, len = paths.length; i < len; i++) {
subPath = paths[i].replace(trimRe, "");
// compile and place in cache
if (!cache[subPath]) {
// When we compile, escaping is handled inside the compile method
cache[subPath] = DQ.compile(subPath, type);
if (!cache[subPath]) {
Ext.Error.raise({
sourceClass:'Ext.DomQuery',
sourceMethod:'jsSelect',
msg:subPath + ' is not a valid selector'
});
}
} else {
// If we've already compiled, we still need to check if the
// selector has escaping and setup the appropriate flags
setupEscapes(subPath);
}
result = cache[subPath](root);
if (result && result !== doc) {
results = results.concat(result);
}
}
// if there were multiple selectors, make sure dups
// are eliminated
if (paths.length > 1) {
return nodup(results);
}
return results;
},
isXml: function(el) {
var docEl = (el ? el.ownerDocument || el : 0).documentElement;
return docEl ? docEl.nodeName !== "HTML" : false;
},

select : doc.querySelectorAll ? function(path, root, type, single) {
root = root || doc;
if (!DQ.isXml(root)) {
try {

if (root.parentNode && (root.nodeType !== 9) && path.indexOf(',') === -1 && !startIdRe.test(path)) {
path = '#' + Ext.escapeId(Ext.id(root)) + ' ' + path;
root = root.parentNode;
}
return single ? [ root.querySelector(path) ]
: Ext.Array.toArray(root.querySelectorAll(path));
}
catch (e) {
}
}
return DQ.jsSelect.call(this, path, root, type);
} : function(path, root, type) {
return DQ.jsSelect.call(this, path, root, type);
},

selectNode : function(path, root){
return Ext.DomQuery.select(path, root, null, true)[0];
},

selectValue: function(path, root, defaultValue) {
path = path.replace(trimRe, "");
if (!valueCache[path]) {
valueCache[path] = DQ.compile(path, "select");
} else {
setupEscapes(path);
}
var n = valueCache[path](root),
v;
n = n[0] ? n[0] : n;
// overcome a limitation of maximum textnode size
// Rumored to potentially crash IE6 but has not been confirmed.
// http://reference.sitepoint.com/javascript/Node/normalize
// https://developer.mozilla.org/En/DOM/Node.normalize
if (typeof n.normalize == 'function') {
n.normalize();
}
v = (n && n.firstChild ? n.firstChild.nodeValue : null);
return ((v === null || v === undefined || v === '') ? defaultValue : v);
},

selectNumber: function(path, root, defaultValue) {
var v = DQ.selectValue(path, root, defaultValue || 0);
return parseFloat(v);
},

is: function(el, ss) {
if (typeof el == "string") {
el = doc.getElementById(el);
}
var isArray = Ext.isArray(el),
result = DQ.filter(isArray ? el : [el], ss);
return isArray ? (result.length == el.length) : (result.length > 0);
},

filter: function(els, ss, nonMatches) {
ss = ss.replace(trimRe, "");
if (!simpleCache[ss]) {
simpleCache[ss] = DQ.compile(ss, "simple");
} else {
setupEscapes(ss);
}
var result = simpleCache[ss](els);
return nonMatches ? quickDiff(result, els) : result;
},

matchers: [{
re: /^\.([\w\-\\]+)/,
select: useClassList ? 'n = byClassName(n, "{1}");' : 'n = byClassName(n, " {1} ");'
}, {
re: /^\:([\w\-]+)(?:\(((?:[^\s>\/]*|.*?))\))?/,
select: 'n = byPseudo(n, "{1}", "{2}");'
}, {
re: /^(?:([\[\{])(?:@)?([\w\-]+)\s?(?:(=|.=)\s?['"]?(.*?)["']?)?[\]\}])/,
select: 'n = byAttribute(n, "{2}", "{4}", "{3}", "{1}");'
}, {
re: /^#([\w\-\\]+)/,
select: 'n = byId(n, "{1}");'
}, {
re: /^@([\w\-\.]+)/,
select: 'return {firstChild:{nodeValue:attrValue(n, "{1}")}};'
}],

operators: {
"=": function(a, v) {
return a == v;
},
"!=": function(a, v) {
return a != v;
},
"^=": function(a, v) {
return a && a.substr(0, v.length) == v;
},
"$=": function(a, v) {
return a && a.substr(a.length - v.length) == v;
},
"*=": function(a, v) {
return a && a.indexOf(v) !== -1;
},
"%=": function(a, v) {
return (a % v) === 0;
},
"|=": function(a, v) {
return a && (a == v || a.substr(0, v.length + 1) == v + '-');
},
"~=": function(a, v) {
return a && (' ' + a + ' ').indexOf(' ' + v + ' ') != -1;
}
},

pseudos: {
"first-child": function(c) {
var r = [], ri = -1, n,
i, ci;
for (i = 0; (ci = n = c[i]); i++) {
while ((n = n.previousSibling) && n.nodeType != 1);
if (!n) {
r[++ri] = ci;
}
}
return r;
},
"last-child": function(c) {
var r = [], ri = -1, n,
i, ci;
for (i = 0; (ci = n = c[i]); i++) {
while ((n = n.nextSibling) && n.nodeType != 1);
if (!n) {
r[++ri] = ci;
}
}
return r;
},
"nth-child": function(c, a) {
var r = [], ri = -1,
m = nthRe.exec(a == "even" && "2n" || a == "odd" && "2n+1" || !nthRe2.test(a) && "n+" + a || a),
f = (m[1] || 1) - 0, l = m[2] - 0,
i, n, j, cn, pn;
for (i = 0; n = c[i]; i++) {
pn = n.parentNode;
if (batch != pn._batch) {
j = 0;
for (cn = pn.firstChild; cn; cn = cn.nextSibling) {
if (cn.nodeType == 1) {
cn.nodeIndex = ++j;
}
}
pn._batch = batch;
}
if (f == 1) {
if (l === 0 || n.nodeIndex == l) {
r[++ri] = n;
}
} else if ((n.nodeIndex + l) % f === 0) {
r[++ri] = n;
}
}
return r;
},
"only-child": function(c) {
var r = [], ri = -1,
i, ci;
for (i = 0; ci = c[i]; i++) {
if (!prev(ci) && !next(ci)) {
r[++ri] = ci;
}
}
return r;
},
"empty": function(c) {
var r = [], ri = -1,
i, ci, cns, j, cn, empty;
for (i = 0; ci = c[i]; i++) {
cns = ci.childNodes;
j = 0;
empty = true;
while (cn = cns[j]) {
++j;
if (cn.nodeType == 1 || cn.nodeType == 3) {
empty = false;
break;
}
}
if (empty) {
r[++ri] = ci;
}
}
return r;
},
"contains": function(c, v) {
var r = [], ri = -1,
i, ci;
for (i = 0; ci = c[i]; i++) {
if ((ci.textContent || ci.innerText || ci.text || '').indexOf(v) != -1) {
r[++ri] = ci;
}
}
return r;
},
"nodeValue": function(c, v) {
var r = [], ri = -1,
i, ci;
for (i = 0; ci = c[i]; i++) {
if (ci.firstChild && ci.firstChild.nodeValue == v) {
r[++ri] = ci;
}
}
return r;
},
"checked": function(c) {
var r = [], ri = -1,
i, ci;
for (i = 0; ci = c[i]; i++) {
if (ci.checked === true) {
r[++ri] = ci;
}
}
return r;
},
"not": function(c, ss) {
return DQ.filter(c, ss, true);
},
"any": function(c, selectors) {
var ss = selectors.split('|'),
r = [], ri = -1, s,
i, ci, j;
for (i = 0; ci = c[i]; i++) {
for (j = 0; s = ss[j]; j++) {
if (DQ.is(ci, s)) {
r[++ri] = ci;
break;
}
}
}
return r;
},
"odd": function(c) {
return this["nth-child"](c, "odd");
},
"even": function(c) {
return this["nth-child"](c, "even");
},
"nth": function(c, a) {
return c[a - 1] || [];
},
"first": function(c) {
return c[0] || [];
},
"last": function(c) {
return c[c.length - 1] || [];
},
"has": function(c, ss) {
var s = DQ.select,
r = [], ri = -1,
i, ci;
for (i = 0; ci = c[i]; i++) {
if (s(ss, ci).length > 0) {
r[++ri] = ci;
}
}
return r;
},
"next": function(c, ss) {
var is = DQ.is,
r = [], ri = -1,
i, ci, n;
for (i = 0; ci = c[i]; i++) {
n = next(ci);
if (n && is(n, ss)) {
r[++ri] = ci;
}
}
return r;
},
"prev": function(c, ss) {
var is = DQ.is,
r = [], ri = -1,
i, ci, n;
for (i = 0; ci = c[i]; i++) {
n = prev(ci);
if (n && is(n, ss)) {
r[++ri] = ci;
}
}
return r;
},
focusable: function(candidates) {
var len = candidates.length,
results = [],
i = 0,
c;
for (; i < len; i++) {
c = candidates[i];
if (Ext.fly(c, '_DomQuery').isFocusable()) {
results.push(c);
}
}
return results;
},

visible: function(candidates, deep) {
var len = candidates.length,
results = [],
i = 0,
c;
for (; i < len; i++) {
c = candidates[i];
if (Ext.fly(c, '_DomQuery').isVisible(deep)) {
results.push(c);
}
}
return results;
}
}
};
}());
Ext.query = Ext.DomQuery.select;
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/ComponentQuery.js */
(function(Ext) {
Ext.define('Ext.ComponentQuery', {
singleton: true,
requires: [
'Ext.ComponentManager',
'Ext.dom.Query'
]
}, function() {
var cq = this,
domQueryOperators = Ext.dom.Query.operators,
nthRe = /(\d*)n\+?(\d*)/,
nthRe2 = /\D/,
// A function source code pattern with a placeholder which accepts an expression which yields a truth value when applied
// as a member on each item in the passed array.
filterFnPattern = [
'var r = [],',
'i = 0,',
'it = items,',
'l = it.length,',
'c;',
'for (; i < l; i++) {',
'c = it[i];',
'if (c.{0}) {',
'r.push(c);',
'}',
'}',
'return r;'
].join(''),
filterItems = function(items, operation) {
// Argument list for the operation is [ itemsArray, operationArg1, operationArg2...]
// The operation's method loops over each item in the candidate array and
// returns an array of items which match its criteria
return operation.method.apply(this, [ items ].concat(operation.args));
},
getItems = function(items, mode) {
var result = [],
i = 0,
length = items.length,
candidate,
deep = mode !== '>';

for (; i < length; i++) {
candidate = items[i];
if (candidate.getRefItems) {
result = result.concat(candidate.getRefItems(deep));
}
}
return result;
},
getAncestors = function(items) {
var result = [],
i = 0,
length = items.length,
candidate;
for (; i < length; i++) {
candidate = items[i];
while (!!(candidate = candidate.getRefOwner())) {
result.push(candidate);
}
}
return result;
},
// Filters the passed candidate array and returns only items which match the passed xtype
filterByXType = function(items, xtype, shallow) {
if (xtype === '*') {
return items.slice();
}
else {
var result = [],
i = 0,
length = items.length,
candidate;
for (; i < length; i++) {
candidate = items[i];
if (candidate.isXType(xtype, shallow)) {
result.push(candidate);
}
}
return result;
}
},
// Filters the passed candidate array and returns only items which have the passed className
filterByClassName = function(items, className) {
var result = [],
i = 0,
length = items.length,
candidate;
for (; i < length; i++) {
candidate = items[i];
if (candidate.hasCls(className)) {
result.push(candidate);
}
}
return result;
},
// Filters the passed candidate array and returns only items which have the specified property match
filterByAttribute = function(items, property, operator, compareTo) {
var result = [],
i = 0,
length = items.length,
mustBeOwnProperty,
presenceOnly,
candidate, propValue,
j, propLen;
// Prefixing property name with an @ means that the property must be in the candidate, not in its prototype
if (property.charAt(0) === '@') {
mustBeOwnProperty = true;
property = property.substr(1);
}
if (property.charAt(0) === '?') {
mustBeOwnProperty = true;
presenceOnly = true;
property = property.substr(1);
}
for (; i < length; i++) {
candidate = items[i];
// Check candidate hasOwnProperty is propName prefixed with a bang.
if (!mustBeOwnProperty || candidate.hasOwnProperty(property)) {
// pull out property value to test
propValue = candidate[property];
if (presenceOnly) {
result.push(candidate);
}
// implies property is an array, and we must compare value against each element.
else if (operator === '~=') {
if (propValue) {
//We need an array
if (!Ext.isArray(propValue)) {
propValue = propValue.split(' ');
}
for (j = 0, propLen = propValue.length; j < propLen; j++) {
if (domQueryOperators[operator](Ext.coerce(propValue[j], compareTo), compareTo)) {
result.push(candidate);
break;
}
}
}
} else if (!compareTo ? !!candidate[property] : domQueryOperators[operator](Ext.coerce(propValue, compareTo), compareTo)) {
result.push(candidate);
}
}
}
return result;
},
// Filters the passed candidate array and returns only items which have the specified itemId or id
filterById = function(items, id) {
var result = [],
i = 0,
length = items.length,
candidate;
for (; i < length; i++) {
candidate = items[i];
if (candidate.getItemId() === id) {
result.push(candidate);
}
}
return result;
},
// Filters the passed candidate array and returns only items which the named pseudo class matcher filters in
filterByPseudo = function(items, name, value) {
return cq.pseudos[name](items, value);
},
// Determines leading mode
// > for direct child, and ^ to switch to ownerCt axis
modeRe = /^(\s?([>\^])\s?|\s|$)/,
// Matches a token with possibly (true|false) appended for the "shallow" parameter
tokenRe = /^(#)?([\w\-]+|\*)(?:\((true|false)\))?/,
matchers = [{
// Checks for .xtype with possibly (true|false) appended for the "shallow" parameter
re: /^\.([\w\-]+)(?:\((true|false)\))?/,
method: filterByXType
}, {
// checks for [attribute=value], [attribute^=value], [attribute$=value], [attribute*=value], [attribute~=value], [attribute%=value], [attribute!=value]
// Allow [@attribute] to check truthy ownProperty
// Allow [?attribute] to check for presence of ownProperty
re: /^(?:\[((?:@|\?)?[\w\-\$]*[^\^\$\*~%!])\s?(?:(=|.=)\s?['"]?(.*?)["']?)?\])/,
method: filterByAttribute
}, {
// checks for #cmpItemId
re: /^#([\w\-]+)/,
method: filterById
}, {
// checks for :<pseudo_class>(<selector>)
re: /^\:([\w\-]+)(?:\(((?:\{[^\}]+\})|(?:(?!\{)[^\s>\/]*?(?!\})))\))?/,
method: filterByPseudo
}, {
// checks for {<member_expression>}
re: /^(?:\{([^\}]+)\})/,
method: filterFnPattern
}];
// Internal class Ext.ComponentQuery.Query
cq.Query = Ext.extend(Object, {
constructor: function(cfg) {
cfg = cfg || {};
Ext.apply(this, cfg);
},
// Executes this Query upon the selected root.
// The root provides the initial source of candidate Component matches which are progressively
// filtered by iterating through this Query's operations cache.
// If no root is provided, all registered Components are searched via the ComponentManager.
// root may be a Container who's descendant Components are filtered
// root may be a Component with an implementation of getRefItems which provides some nested Components such as the
// docked items within a Panel.
// root may be an array of candidate Components to filter using this Query.
execute : function(root) {
var operations = this.operations,
i = 0,
length = operations.length,
operation,
workingItems;
// no root, use all Components in the document
if (!root) {
workingItems = Ext.ComponentManager.all.getArray();
}
// Root is an iterable object like an Array, or system Collection, eg HtmlCollection
else if (Ext.isIterable(root)) {
workingItems = root;
}
// Root is a MixedCollection
else if (root.isMixedCollection) {
workingItems = root.items;
}
// We are going to loop over our operations and take care of them
// one by one.
for (; i < length; i++) {
operation = operations[i];
// The mode operation requires some custom handling.
// All other operations essentially filter down our current
// working items, while mode replaces our current working
// items by getting children from each one of our current
// working items. The type of mode determines the type of
// children we get. (e.g. > only gets direct children)
if (operation.mode === '^') {
workingItems = getAncestors(workingItems || [root]);
}
else if (operation.mode) {
workingItems = getItems(workingItems || [root], operation.mode);
}
else {
workingItems = filterItems(workingItems || getItems([root]), operation);
}
// If this is the last operation, it means our current working
// items are the final matched items. Thus return them!
if (i === length -1) {
return workingItems;
}
}
return [];
},
is: function(component) {
var operations = this.operations,
components = Ext.isArray(component) ? component : [component],
originalLength = components.length,
lastOperation = operations[operations.length-1],
ln, i;
components = filterItems(components, lastOperation);
if (components.length === originalLength) {
if (operations.length > 1) {
for (i = 0, ln = components.length; i < ln; i++) {
if (Ext.Array.indexOf(this.execute(), components[i]) === -1) {
return false;
}
}
}
return true;
}
return false;
}
});
Ext.apply(this, {
// private cache of selectors and matching ComponentQuery.Query objects
cache: {},
// private cache of pseudo class filter functions
pseudos: {
not: function(components, selector){
var CQ = Ext.ComponentQuery,
i = 0,
length = components.length,
results = [],
index = -1,
component;

for(; i < length; ++i) {
component = components[i];
if (!CQ.is(component, selector)) {
results[++index] = component;
}
}
return results;
},
first: function(components) {
var ret = [];

if (components.length > 0) {
ret.push(components[0]);
}
return ret; 
},
last: function(components) {
var len = components.length,
ret = [];

if (len > 0) {
ret.push(components[len - 1]);
}
return ret;
},
focusable: function(cmps) {
var len = cmps.length,
results = [],
i = 0,
c;
for (; i < len; i++) {
c = cmps[i];
// If this is a generally focusable Component (has a focusEl, is rendered, enabled and visible)
// then it is currently focusable if focus management is enabled or if it is an input field, a button or a menu item
if (c.isFocusable()) {
results.push(c);
}
}
return results;
},
"nth-child" : function(c, a) {
var result = [],
m = nthRe.exec(a == "even" && "2n" || a == "odd" && "2n+1" || !nthRe2.test(a) && "n+" + a || a),
f = (m[1] || 1) - 0, l = m[2] - 0,
i, n, nodeIndex;
for (i = 0; n = c[i]; i++) {
nodeIndex = i + 1;
if (f == 1) {
if (l == 0 || nodeIndex == l) {
result.push(n);
}
} else if ((nodeIndex + l) % f == 0){
result.push(n);
}
}
return result;
}
},

query: function(selector, root) {
var selectors = selector.split(','),
length = selectors.length,
i = 0,
results = [],
noDupResults = [], 
dupMatcher = {}, 
query, resultsLn, cmp;
for (; i < length; i++) {
selector = Ext.String.trim(selectors[i]);
query = this.cache[selector] || (this.cache[selector] = this.parse(selector));
results = results.concat(query.execute(root));
}
// multiple selectors, potential to find duplicates
// lets filter them out.
if (length > 1) {
resultsLn = results.length;
for (i = 0; i < resultsLn; i++) {
cmp = results[i];
if (!dupMatcher[cmp.id]) {
noDupResults.push(cmp);
dupMatcher[cmp.id] = true;
}
}
results = noDupResults;
}
return results;
},

is: function(component, selector) {
if (!selector) {
return true;
}
var selectors = selector.split(','),
length = selectors.length,
i = 0,
query;
for (; i < length; i++) {
selector = Ext.String.trim(selectors[i]);
query = this.cache[selector] || (this.cache[selector] = this.parse(selector));
if (query.is(component)) {
return true;
}
}
return false;
},
parse: function(selector) {
var operations = [],
length = matchers.length,
lastSelector,
tokenMatch,
matchedChar,
modeMatch,
selectorMatch,
i, matcher, method;
// We are going to parse the beginning of the selector over and
// over again, slicing off the selector any portions we converted into an
// operation, until it is an empty string.
while (selector && lastSelector !== selector) {
lastSelector = selector;
// First we check if we are dealing with a token like #, * or an xtype
tokenMatch = selector.match(tokenRe);
if (tokenMatch) {
matchedChar = tokenMatch[1];
// If the token is prefixed with a # we push a filterById operation to our stack
if (matchedChar === '#') {
operations.push({
method: filterById,
args: [Ext.String.trim(tokenMatch[2])]
});
}
// If the token is prefixed with a . we push a filterByClassName operation to our stack
// FIXME: Not enabled yet. just needs \. adding to the tokenRe prefix
else if (matchedChar === '.') {
operations.push({
method: filterByClassName,
args: [Ext.String.trim(tokenMatch[2])]
});
}
// If the token is a * or an xtype string, we push a filterByXType
// operation to the stack.
else {
operations.push({
method: filterByXType,
args: [Ext.String.trim(tokenMatch[2]), Boolean(tokenMatch[3])]
});
}
// Now we slice of the part we just converted into an operation
selector = selector.replace(tokenMatch[0], '');
}
// If the next part of the query is not a space or > or ^, it means we
// are going to check for more things that our current selection
// has to comply to.
while (!(modeMatch = selector.match(modeRe))) {
// Lets loop over each type of matcher and execute it
// on our current selector.
for (i = 0; selector && i < length; i++) {
matcher = matchers[i];
selectorMatch = selector.match(matcher.re);
method = matcher.method;
// If we have a match, add an operation with the method
// associated with this matcher, and pass the regular
// expression matches are arguments to the operation.
if (selectorMatch) {
operations.push({
method: Ext.isString(matcher.method)
// Turn a string method into a function by formatting the string with our selector matche expression
// A new method is created for different match expressions, eg {id=='textfield-1024'}
// Every expression may be different in different selectors.
? Ext.functionFactory('items', Ext.String.format.apply(Ext.String, [method].concat(selectorMatch.slice(1))))
: matcher.method,
args: selectorMatch.slice(1)
});
selector = selector.replace(selectorMatch[0], '');
break; // Break on match
}
// Exhausted all matches: It's an error
if (i === (length - 1)) {
Ext.Error.raise('Invalid ComponentQuery selector: "' + arguments[0] + '"');
}
}
}
// Now we are going to check for a mode change. This means a space
// or a > to determine if we are going to select all the children
// of the currently matched items, or a ^ if we are going to use the
// ownerCt axis as the candidate source.
if (modeMatch[1]) { // Assignment, and test for truthiness!
operations.push({
mode: modeMatch[2]||modeMatch[1]
});
selector = selector.replace(modeMatch[0], '');
}
}
// Now that we have all our operations in an array, we are going
// to create a new Query using these operations.
return new cq.Query({
operations: operations
});
}
});
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/util/ProtoElement.js */
(function(Ext) {
Ext.define('Ext.util.ProtoElement', (function () {
var splitWords = Ext.String.splitWords,
toMap = Ext.Array.toMap;
return {

isProtoEl: true,


clsProp: 'cls',

styleProp: 'style',


removedProp: 'removed',

styleIsText: false,
constructor: function (config) {
var me = this;
Ext.apply(me, config);
me.classList = splitWords(me.cls);
me.classMap = toMap(me.classList);
delete me.cls;
if (Ext.isFunction(me.style)) {
me.styleFn = me.style;
delete me.style;
} else if (typeof me.style == 'string') {
me.style = Ext.Element.parseStyles(me.style);
} else if (me.style) {
me.style = Ext.apply({}, me.style); // don't edit the given object
}
},


flush: function(){
this.flushClassList = [];
this.removedClasses = {};
// clear the style, it will be recreated if we add anything new
delete this.style;
delete this.unselectableAttr;
},

addCls: function (cls) {
var me = this,
add = (typeof cls === 'string') ? splitWords(cls) : cls,
length = add.length,
list = me.classList,
map = me.classMap,
flushList = me.flushClassList,
i = 0,
c;
for (; i < length; ++i) {
c = add[i];
if (!map[c]) {
map[c] = true;
list.push(c);
if (flushList) {
flushList.push(c);
delete me.removedClasses[c];
}
}
}
return me;
},

hasCls: function (cls) {
return cls in this.classMap;
},

removeCls: function (cls) {
var me = this,
list = me.classList,
newList = (me.classList = []),
remove = toMap(splitWords(cls)),
length = list.length,
map = me.classMap,
removedClasses = me.removedClasses,
i, c;
for (i = 0; i < length; ++i) {
c = list[i];
if (remove[c]) {
if (removedClasses) {
if (map[c]) {
removedClasses[c] = true;
Ext.Array.remove(me.flushClassList, c);
}
}
delete map[c];
} else {
newList.push(c);
}
}
return me;
},

setStyle: function (prop, value) {
var me = this,
style = me.style || (me.style = {});
if (typeof prop == 'string') {
if (arguments.length === 1) {
me.setStyle(Ext.Element.parseStyles(prop));
} else {
style[prop] = value;
}
} else {
Ext.apply(style, prop);
}
return me;
},
unselectable: function() {
// See Ext.dom.Element.unselectable for an explanation of what is required to make an element unselectable
this.addCls(Ext.dom.Element.unselectableCls);
if (Ext.isOpera) {
this.unselectableAttr = true;
}
},

writeTo: function (to) {
var me = this,
classList = me.flushClassList || me.classList,
removedClasses = me.removedClasses,
style;
if (me.styleFn) {
style = Ext.apply({}, me.styleFn());
Ext.apply(style, me.style);
} else {
style = me.style;
}
to[me.clsProp] = classList.join(' ');
if (style) {
to[me.styleProp] = me.styleIsText ? Ext.DomHelper.generateStyles(style) : style;
}

if (removedClasses) {
removedClasses = Ext.Object.getKeys(removedClasses);
if (removedClasses.length) {
to[me.removedProp] = removedClasses.join(' ');
}
}
if (me.unselectableAttr) {
to.unselectable = 'on';
}
return to;
}
};
}()));
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/dom/Element_anim.js */
(function(Ext) {
// @tag dom,core
Ext.define('Ext.dom.Element_anim', {
override: 'Ext.dom.Element',

animate: function(config) {
var me = this,
listeners,
anim,
animId = me.dom.id || Ext.id(me.dom);
if (!Ext.fx.Manager.hasFxBlock(animId)) {
// Bit of gymnastics here to ensure our internal listeners get bound first
if (config.listeners) {
listeners = config.listeners;
delete config.listeners;
}
if (config.internalListeners) {
config.listeners = config.internalListeners;
delete config.internalListeners;
}
anim = new Ext.fx.Anim(me.anim(config));
if (listeners) {
anim.on(listeners);
}
Ext.fx.Manager.queueFx(anim);
}
return me;
},
// @private - process the passed fx configuration.
anim: function(config) {
if (!Ext.isObject(config)) {
return (config) ? {} : false;
}
var me = this,
duration = config.duration || Ext.fx.Anim.prototype.duration,
easing = config.easing || 'ease',
animConfig;
if (config.stopAnimation) {
me.stopAnimation();
}
Ext.applyIf(config, Ext.fx.Manager.getFxDefaults(me.id));
// Clear any 'paused' defaults.
Ext.fx.Manager.setFxDefaults(me.id, {
delay: 0
});
animConfig = {
// Pass the DOM reference. That's tested first so will be converted to an Ext.fx.Target fastest.
target: me.dom,
remove: config.remove,
alternate: config.alternate || false,
duration: duration,
easing: easing,
callback: config.callback,
listeners: config.listeners,
iterations: config.iterations || 1,
scope: config.scope,
block: config.block,
concurrent: config.concurrent,
delay: config.delay || 0,
paused: true,
keyframes: config.keyframes,
from: config.from || {},
to: Ext.apply({}, config)
};
Ext.apply(animConfig.to, config.to);
// Anim API properties - backward compat
delete animConfig.to.to;
delete animConfig.to.from;
delete animConfig.to.remove;
delete animConfig.to.alternate;
delete animConfig.to.keyframes;
delete animConfig.to.iterations;
delete animConfig.to.listeners;
delete animConfig.to.target;
delete animConfig.to.paused;
delete animConfig.to.callback;
delete animConfig.to.scope;
delete animConfig.to.duration;
delete animConfig.to.easing;
delete animConfig.to.concurrent;
delete animConfig.to.block;
delete animConfig.to.stopAnimation;
delete animConfig.to.delay;
return animConfig;
},

slideIn: function(anchor, obj, slideOut) {
var me = this,
dom = me.dom,
elStyle = dom.style,
beforeAnim,
wrapAnim,
restoreScroll,
wrapDomParentNode;
anchor = anchor || "t";
obj = obj || {};
beforeAnim = function() {
var animScope = this,
listeners = obj.listeners,
el = Ext.fly(dom, '_anim'),
box, originalStyles, anim, wrap;
if (!slideOut) {
el.fixDisplay();
}
box = el.getBox();
if ((anchor == 't' || anchor == 'b') && box.height === 0) {
box.height = dom.scrollHeight;
}
else if ((anchor == 'l' || anchor == 'r') && box.width === 0) {
box.width = dom.scrollWidth;
}
originalStyles = el.getStyles('width', 'height', 'left', 'right', 'top', 'bottom', 'position', 'z-index', true);
el.setSize(box.width, box.height);
// Cache all descendants' scrollTop & scrollLeft values if configured to preserve scroll.
if (obj.preserveScroll) {
restoreScroll = el.cacheScrollValues();
}
wrap = el.wrap({
id: Ext.id() + '-anim-wrap-for-' + el.dom.id,
style: {
visibility: slideOut ? 'visible' : 'hidden'
}
});
wrapDomParentNode = wrap.dom.parentNode;
wrap.setPositioning(el.getPositioning(true));
if (wrap.isStyle('position', 'static')) {
wrap.position('relative');
}
el.clearPositioning('auto');
wrap.clip();
// The wrap will have reset all descendant scrollTops. Restore them if we cached them.
if (restoreScroll) {
restoreScroll();
}
// This element is temporarily positioned absolute within its wrapper.
// Restore to its default, CSS-inherited visibility setting.
// We cannot explicitly poke visibility:visible into its style because that overrides the visibility of the wrap.
el.setStyle({
visibility: '',
position: 'absolute'
});
if (slideOut) {
wrap.setSize(box.width, box.height);
}
switch (anchor) {
case 't':
anim = {
from: {
width: box.width + 'px',
height: '0px'
},
to: {
width: box.width + 'px',
height: box.height + 'px'
}
};
elStyle.bottom = '0px';
break;
case 'l':
anim = {
from: {
width: '0px',
height: box.height + 'px'
},
to: {
width: box.width + 'px',
height: box.height + 'px'
}
};
me.anchorAnimX(anchor);
break;
case 'r':
anim = {
from: {
x: box.x + box.width,
width: '0px',
height: box.height + 'px'
},
to: {
x: box.x,
width: box.width + 'px',
height: box.height + 'px'
}
};
me.anchorAnimX(anchor);
break;
case 'b':
anim = {
from: {
y: box.y + box.height,
width: box.width + 'px',
height: '0px'
},
to: {
y: box.y,
width: box.width + 'px',
height: box.height + 'px'
}
};
break;
case 'tl':
anim = {
from: {
x: box.x,
y: box.y,
width: '0px',
height: '0px'
},
to: {
width: box.width + 'px',
height: box.height + 'px'
}
};
elStyle.bottom = '0px';
me.anchorAnimX('l');
break;
case 'bl':
anim = {
from: {
y: box.y + box.height,
width: '0px',
height: '0px'
},
to: {
y: box.y,
width: box.width + 'px',
height: box.height + 'px'
}
};
me.anchorAnimX('l');
break;
case 'br':
anim = {
from: {
x: box.x + box.width,
y: box.y + box.height,
width: '0px',
height: '0px'
},
to: {
x: box.x,
y: box.y,
width: box.width + 'px',
height: box.height + 'px'
}
};
me.anchorAnimX('r');
break;
case 'tr':
anim = {
from: {
x: box.x + box.width,
width: '0px',
height: '0px'
},
to: {
x: box.x,
width: box.width + 'px',
height: box.height + 'px'
}
};
elStyle.bottom = '0px';
me.anchorAnimX('r');
break;
}
wrap.show();
wrapAnim = Ext.apply({}, obj);
delete wrapAnim.listeners;
wrapAnim = new Ext.fx.Anim(Ext.applyIf(wrapAnim, {
target: wrap,
duration: 500,
easing: 'ease-out',
from: slideOut ? anim.to : anim.from,
to: slideOut ? anim.from : anim.to
}));
// In the absence of a callback, this listener MUST be added first
wrapAnim.on('afteranimate', function() {
var el = Ext.fly(dom, '_anim');

el.setStyle(originalStyles);
if (slideOut) {
if (obj.useDisplay) {
el.setDisplayed(false);
} else {
el.hide();
}
}
if (wrap.dom) {
if (wrap.dom.parentNode) {
wrap.dom.parentNode.insertBefore(el.dom, wrap.dom);
} else {
wrapDomParentNode.appendChild(el.dom);
}
wrap.remove();
}
// The unwrap will have reset all descendant scrollTops. Restore them if we cached them.
if (restoreScroll) {
restoreScroll();
}
// kill the no-op element animation created below
animScope.end();
});
// Add configured listeners after
if (listeners) {
wrapAnim.on(listeners);
}
};
me.animate({
// See "A Note About Wrapped Animations" at the top of this class:
duration: obj.duration ? Math.max(obj.duration, 500) * 2 : 1000,
listeners: {
beforeanimate: beforeAnim // kick off the wrap animation
}
});
return me;
},

slideOut: function(anchor, o) {
return this.slideIn(anchor, o, true);
},

puff: function(obj) {
var me = this,
dom = me.dom,
beforeAnim,
box = me.getBox(),
originalStyles = me.getStyles('width', 'height', 'left', 'right', 'top', 'bottom', 'position', 'z-index', 'font-size', 'opacity', true);
obj = Ext.applyIf(obj || {}, {
easing: 'ease-out',
duration: 500,
useDisplay: false
});
beforeAnim = function() {
var el = Ext.fly(dom, '_anim');

el.clearOpacity();
el.show();
this.to = {
width: box.width * 2,
height: box.height * 2,
x: box.x - (box.width / 2),
y: box.y - (box.height /2),
opacity: 0,
fontSize: '200%'
};
this.on('afteranimate',function() {
var el = Ext.fly(dom, '_anim');
if (el) {
if (obj.useDisplay) {
el.setDisplayed(false);
} else {
el.hide();
}
el.setStyle(originalStyles);
Ext.callback(obj.callback, obj.scope);
}
});
};
me.animate({
duration: obj.duration,
easing: obj.easing,
listeners: {
beforeanimate: {
fn: beforeAnim
}
}
});
return me;
},

switchOff: function(obj) {
var me = this,
dom = me.dom,
beforeAnim;
obj = Ext.applyIf(obj || {}, {
easing: 'ease-in',
duration: 500,
remove: false,
useDisplay: false
});
beforeAnim = function() {
var el = Ext.fly(dom, '_anim'),
animScope = this,
size = el.getSize(),
xy = el.getXY(),
keyframe, position;

el.clearOpacity();
el.clip();
position = el.getPositioning();
keyframe = new Ext.fx.Animator({
target: dom,
duration: obj.duration,
easing: obj.easing,
keyframes: {
33: {
opacity: 0.3
},
66: {
height: 1,
y: xy[1] + size.height / 2
},
100: {
width: 1,
x: xy[0] + size.width / 2
}
}
});
keyframe.on('afteranimate', function() {
var el = Ext.fly(dom, '_anim');
if (obj.useDisplay) {
el.setDisplayed(false);
} else {
el.hide();
}
el.clearOpacity();
el.setPositioning(position);
el.setSize(size);
// kill the no-op element animation created below
animScope.end();
});
};

me.animate({
// See "A Note About Wrapped Animations" at the top of this class:
duration: (Math.max(obj.duration, 500) * 2),
listeners: {
beforeanimate: {
fn: beforeAnim
}
},
callback: obj.callback,
scope: obj.scope
});
return me;
},

frame : function(color, count, obj){
var me = this,
dom = me.dom,
beforeAnim;
color = color || '#C3DAF9';
count = count || 1;
obj = obj || {};
beforeAnim = function() {
var el = Ext.fly(dom, '_anim'),
animScope = this,
box,
proxy, proxyAnim;

el.show();
box = el.getBox();
proxy = Ext.getBody().createChild({
id: el.dom.id + '-anim-proxy',
style: {
position : 'absolute',
'pointer-events': 'none',
'z-index': 35000,
border : '0px solid ' + color
}
});

proxyAnim = new Ext.fx.Anim({
target: proxy,
duration: obj.duration || 1000,
iterations: count,
from: {
top: box.y,
left: box.x,
borderWidth: 0,
opacity: 1,
height: box.height,
width: box.width
},
to: {
top: box.y - 20,
left: box.x - 20,
borderWidth: 10,
opacity: 0,
height: box.height + 40,
width: box.width + 40
}
});
proxyAnim.on('afteranimate', function() {
proxy.remove();
// kill the no-op element animation created below
animScope.end();
});
};
me.animate({
// See "A Note About Wrapped Animations" at the top of this class:
duration: (Math.max(obj.duration, 500) * 2) || 2000,
listeners: {
beforeanimate: {
fn: beforeAnim
}
},
callback: obj.callback,
scope: obj.scope
});
return me;
},

ghost: function(anchor, obj) {
var me = this,
dom = me.dom,
beforeAnim;
anchor = anchor || "b";
beforeAnim = function() {
var el = Ext.fly(dom, '_anim'),
width = el.getWidth(),
height = el.getHeight(),
xy = el.getXY(),
position = el.getPositioning(),
to = {
opacity: 0
};
switch (anchor) {
case 't':
to.y = xy[1] - height;
break;
case 'l':
to.x = xy[0] - width;
break;
case 'r':
to.x = xy[0] + width;
break;
case 'b':
to.y = xy[1] + height;
break;
case 'tl':
to.x = xy[0] - width;
to.y = xy[1] - height;
break;
case 'bl':
to.x = xy[0] - width;
to.y = xy[1] + height;
break;
case 'br':
to.x = xy[0] + width;
to.y = xy[1] + height;
break;
case 'tr':
to.x = xy[0] + width;
to.y = xy[1] - height;
break;
}
this.to = to;
this.on('afteranimate', function () {
var el = Ext.fly(dom, '_anim');
if (el) {
el.hide();
el.clearOpacity();
el.setPositioning(position);
}
});
};
me.animate(Ext.applyIf(obj || {}, {
duration: 500,
easing: 'ease-out',
listeners: {
beforeanimate: beforeAnim
}
}));
return me;
},

highlight: function(color, o) {
var me = this,
dom = me.dom,
from = {},
restore, to, attr, lns, event, fn;
// Cannot set bckground-color on table elements. Find div elements to highlight.
if (dom.tagName.match(me.tableTagRe)) {
return me.select('div').highlight(color, o);
}
o = o || {};
lns = o.listeners || {};
attr = o.attr || 'backgroundColor';
from[attr] = color || 'ffff9c';
if (!o.to) {
to = {};
to[attr] = o.endColor || me.getColor(attr, 'ffffff', '');
}
else {
to = o.to;
}
// Don't apply directly on lns, since we reference it in our own callbacks below
o.listeners = Ext.apply(Ext.apply({}, lns), {
beforeanimate: function() {
restore = dom.style[attr];
var el = Ext.fly(dom, '_anim');
el.clearOpacity();
el.show();
event = lns.beforeanimate;
if (event) {
fn = event.fn || event;
return fn.apply(event.scope || lns.scope || window, arguments);
}
},
afteranimate: function() {
if (dom) {
dom.style[attr] = restore;
}
event = lns.afteranimate;
if (event) {
fn = event.fn || event;
fn.apply(event.scope || lns.scope || window, arguments);
}
}
});
me.animate(Ext.apply({}, o, {
duration: 1000,
easing: 'ease-in',
from: from,
to: to
}));
return me;
},

pause: function(ms) {
var me = this;
Ext.fx.Manager.setFxDefaults(me.id, {
delay: ms
});
return me;
},

fadeIn: function(o) {
var me = this,
dom = me.dom;

me.animate(Ext.apply({}, o, {
opacity: 1,
internalListeners: {
beforeanimate: function(anim){
// restore any visibility/display that may have 
// been applied by a fadeout animation
var el = Ext.fly(dom, '_anim');
if (el.isStyle('display', 'none')) {
el.setDisplayed('');
} else {
el.show();
} 
}
}
}));
return this;
},

fadeOut: function(o) {
var me = this,
dom = me.dom;

o = Ext.apply({
opacity: 0,
internalListeners: {
afteranimate: function(anim){
if (dom && anim.to.opacity === 0) {
var el = Ext.fly(dom, '_anim');
if (o.useDisplay) {
el.setDisplayed(false);
} else {
el.hide();
}
} 
}
}
}, o);
me.animate(o);
return me;
},

scale: function(w, h, o) {
this.animate(Ext.apply({}, o, {
width: w,
height: h
}));
return this;
},

shift: function(config) {
this.animate(config);
return this;
},

anchorAnimX: function(anchor) {
var xName = (anchor === 'l') ? 'right' : 'left';
this.dom.style[xName] = '0px';
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/dom/Element_dd.js */
(function(Ext) {
// @tag dom,core
Ext.define('Ext.dom.Element_dd', {
override: 'Ext.dom.Element',

initDD : function(group, config, overrides){
var dd = new Ext.dd.DD(Ext.id(this.dom), group, config);
return Ext.apply(dd, overrides);
},

initDDProxy : function(group, config, overrides){
var dd = new Ext.dd.DDProxy(Ext.id(this.dom), group, config);
return Ext.apply(dd, overrides);
},

initDDTarget : function(group, config, overrides){
var dd = new Ext.dd.DDTarget(Ext.id(this.dom), group, config);
return Ext.apply(dd, overrides);
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/dom/Element_fx.js */
(function(Ext) {
// @tag dom,core
Ext.define('Ext.dom.Element_fx', {
override: 'Ext.dom.Element'
},
function() {
var Element = Ext.dom.Element,
VISIBILITY = "visibility",
DISPLAY = "display",
NONE = "none",
HIDDEN = 'hidden',
VISIBLE = 'visible',
OFFSETS = "offsets",
ASCLASS = "asclass",
NOSIZE = 'nosize',
ORIGINALDISPLAY = 'originalDisplay',
VISMODE = 'visibilityMode',
ISVISIBLE = 'isVisible',
OFFSETCLASS = Ext.baseCSSPrefix + 'hide-offsets',
getDisplay = function(el) {
var data = (el.$cache || el.getCache()).data,
display = data[ORIGINALDISPLAY];

if (display === undefined) {
data[ORIGINALDISPLAY] = display = '';
}
return display;
},
getVisMode = function(el){
var data = (el.$cache || el.getCache()).data,
visMode = data[VISMODE];

if (visMode === undefined) {
data[VISMODE] = visMode = Element.VISIBILITY;
}
return visMode;
};
Element.override({

originalDisplay : "",
visibilityMode : 1,

setVisible : function(visible, animate) {
var me = this,
dom = me.dom,
visMode = getVisMode(me);
// hideMode string override
if (typeof animate == 'string') {
switch (animate) {
case DISPLAY:
visMode = Element.DISPLAY;
break;
case VISIBILITY:
visMode = Element.VISIBILITY;
break;
case OFFSETS:
visMode = Element.OFFSETS;
break;
case NOSIZE:
case ASCLASS:
visMode = Element.ASCLASS;
break;
}
me.setVisibilityMode(visMode);
animate = false;
}
if (!animate || !me.anim) {
if (visMode == Element.DISPLAY) {
return me.setDisplayed(visible);
} else if (visMode == Element.OFFSETS) {
me[visible?'removeCls':'addCls'](OFFSETCLASS);
} else if (visMode == Element.VISIBILITY) {
me.fixDisplay();
// Show by clearing visibility style. Explicitly setting to "visible" overrides parent visibility setting
dom.style.visibility = visible ? '' : HIDDEN;
} else if (visMode == Element.ASCLASS) {
me[visible?'removeCls':'addCls'](me.visibilityCls || Element.visibilityCls);
}
} else {
// closure for composites
if (visible) {
me.setOpacity(0.01);
me.setVisible(true);
}
if (!Ext.isObject(animate)) {
animate = {
duration: 350,
easing: 'ease-in'
};
}
me.animate(Ext.applyIf({
callback: function() {
if (!visible) {

// Grab the dom again, since the reference may have changed if we use fly
Ext.fly(dom, '_internal').setVisible(false).setOpacity(1);
}
},
to: {
opacity: (visible) ? 1 : 0
}
}, animate));
}
(me.$cache || me.getCache()).data[ISVISIBLE] = visible;
return me;
},

hasMetrics : function(){
var visMode = getVisMode(this);
return this.isVisible() || (visMode == Element.OFFSETS) || (visMode == Element.VISIBILITY);
},

toggle : function(animate){
var me = this;
me.setVisible(!me.isVisible(), me.anim(animate));
return me;
},

setDisplayed : function(value) {
if(typeof value == "boolean"){
value = value ? getDisplay(this) : NONE;
}
this.setStyle(DISPLAY, value);
return this;
},
// private
fixDisplay : function(){
var me = this;
if (me.isStyle(DISPLAY, NONE)) {
me.setStyle(VISIBILITY, HIDDEN);
me.setStyle(DISPLAY, getDisplay(me)); // first try reverting to default
if (me.isStyle(DISPLAY, NONE)) { // if that fails, default to block
me.setStyle(DISPLAY, "block");
}
}
},

hide : function(animate){
// hideMode override
if (typeof animate == 'string'){
this.setVisible(false, animate);
return this;
}
this.setVisible(false, this.anim(animate));
return this;
},

show : function(animate){
// hideMode override
if (typeof animate == 'string'){
this.setVisible(true, animate);
return this;
}
this.setVisible(true, this.anim(animate));
return this;
}
});
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/dom/Element_position.js */
(function(Ext) {
// @tag dom,core
Ext.define('Ext.dom.Element_position', {
override: 'Ext.dom.Element'
},
function() {
var flyInstance,
Element = this,
LEFT = "left",
RIGHT = "right",
TOP = "top",
BOTTOM = "bottom",
POSITION = "position",
STATIC = "static",
RELATIVE = "relative",
ZINDEX = "z-index",
BODY = 'BODY',
PADDING = 'padding',
BORDER = 'border',
SLEFT = '-left',
SRIGHT = '-right',
STOP = '-top',
SBOTTOM = '-bottom',
SWIDTH = '-width',
// special markup used throughout Ext when box wrapping elements
borders = {l: BORDER + SLEFT + SWIDTH, r: BORDER + SRIGHT + SWIDTH, t: BORDER + STOP + SWIDTH, b: BORDER + SBOTTOM + SWIDTH},
paddings = {l: PADDING + SLEFT, r: PADDING + SRIGHT, t: PADDING + STOP, b: PADDING + SBOTTOM},
paddingsTLRB = [paddings.l, paddings.r, paddings.t, paddings.b],
bordersTLRB = [borders.l, borders.r, borders.t, borders.b],
round = Math.round,
doc = document,
fly = function (el) {
if (!flyInstance) {
flyInstance = new Ext.Element.Fly();
}
flyInstance.attach(el);
return flyInstance;
};
Element.override({
pxRe: /^\d+(?:\.\d*)?px$/i,
inheritableStatics: {
getX: function(el) {
return Element.getXY(el)[0];
},
getXY: function(el) {
var bd = doc.body,
docEl = doc.documentElement,
leftBorder = 0,
topBorder = 0,
ret = [0,0],
box,
scroll;
el = Ext.getDom(el);
if(el != doc && el != bd){
// IE has the potential to throw when getBoundingClientRect
// is called on an element not attached to dom
if (Ext.isIE) {
try {
box = el.getBoundingClientRect();
// In some versions of IE, the documentElement (HTML element)
// will have a 2px border that gets included, so subtract it off
topBorder = docEl.clientTop || bd.clientTop;
leftBorder = docEl.clientLeft || bd.clientLeft;
} catch (ex) {
box = { left: 0, top: 0 };
}
} else {
box = el.getBoundingClientRect();
}
scroll = fly(doc).getScroll();
ret = [
round(box.left + scroll.left - leftBorder),
round(box.top + scroll.top - topBorder)
];
}
return ret;
},
getY: function(el) {
return Element.getXY(el)[1];
},
setX: function(el, x) {
Element.setXY(el, [x, false]);
},
setXY: function(el, xy) {
(el = Ext.fly(el, '_setXY')).position();
var pts = el.translatePoints(xy),
style = el.dom.style,
pos;
// right position may have been previously set by rtlSetXY or
// rtlSetLocalXY so clear it here just in case.
style.right = 'auto';
for (pos in pts) {
if (!isNaN(pts[pos])) {
style[pos] = pts[pos] + "px";
}
}
},
setY: function(el, y) {
Element.setXY(el, [false, y]);
}
},

center: function(centerIn){
return this.alignTo(centerIn || doc, 'c-c');
},

clearPositioning: function(value) {
value = value || '';
return this.setStyle({
left : value,
right : value,
top : value,
bottom : value,
'z-index' : '',
position : STATIC
});
},
getAnchorToXY: function(el, anchor, local, mySize) {
return el.getAnchorXY(anchor, local, mySize);
},

getBottom: function(local) {
return (local ? this.getLocalY() : this.getY()) + this.getHeight();
},
getBorderPadding: function() {
var paddingWidth = this.getStyle(paddingsTLRB),
bordersWidth = this.getStyle(bordersTLRB);
return {
beforeX: (parseFloat(bordersWidth[borders.l]) || 0) + (parseFloat(paddingWidth[paddings.l]) || 0),
afterX: (parseFloat(bordersWidth[borders.r]) || 0) + (parseFloat(paddingWidth[paddings.r]) || 0),
beforeY: (parseFloat(bordersWidth[borders.t]) || 0) + (parseFloat(paddingWidth[paddings.t]) || 0),
afterY: (parseFloat(bordersWidth[borders.b]) || 0) + (parseFloat(paddingWidth[paddings.b]) || 0)
};
},

getCenterXY: function(){
return this.getAlignToXY(doc, 'c-c');
},

getLeft: function(local) {
return local ? this.getLocalX() : this.getX();
},

getLocalX: function() {
var me = this,
offsetParent = me.dom.offsetParent,
x = me.getStyle('left');
if (!x || x === 'auto') {
x = 0;
} else if (me.pxRe.test(x)) {
x = parseFloat(x);
} else {
x = me.getX();
if (offsetParent) {
x -= Element.getX(offsetParent);
}
}
return x;
},

getLocalXY: function() {
var me = this,
offsetParent = me.dom.offsetParent,
style = me.getStyle(['left', 'top']),
x = style.left,
y = style.top;
if (!x || x === 'auto') {
x = 0;
} else if (me.pxRe.test(x)) {
x = parseFloat(x);
} else {
x = me.getX();
if (offsetParent) {
x -= Element.getX(offsetParent);
}
}
if (!y || y === 'auto') {
y = 0;
} else if (me.pxRe.test(y)) {
y = parseFloat(y);
} else {
y = me.getY();
if (offsetParent) {
y -= Element.getY(offsetParent);
}
}
return [x, y];
},

getLocalY: function() {
var me = this,
offsetParent = me.dom.offsetParent,
y = me.getStyle('top');
if (!y || y === 'auto') {
y = 0;
} else if (me.pxRe.test(y)) {
y = parseFloat(y);
} else {
y = me.getY();
if (offsetParent) {
y -= Element.getY(offsetParent);
}
}
return y;
},

getPageBox: function(getRegion) {
var me = this,
dom = me.dom,
isDoc = dom.nodeName == BODY,
w = isDoc ? Ext.Element.getViewWidth() : dom.offsetWidth,
h = isDoc ? Ext.Element.getViewHeight() : dom.offsetHeight,
xy = me.getXY(),
t = xy[1],
r = xy[0] + w,
b = xy[1] + h,
l = xy[0];
if (getRegion) {
return new Ext.util.Region(t, r, b, l);
}
else {
return {
left: l,
top: t,
width: w,
height: h,
right: r,
bottom: b
};
}
},

getPositioning: function(autoPx){
var styles = this.getStyle(['left', 'top', 'position', 'z-index']),
dom = this.dom;
if(autoPx) {
if(styles.left === 'auto') {
styles.left = dom.offsetLeft + 'px';
}
if(styles.top === 'auto') {
styles.top = dom.offsetTop + 'px';
}
}
return styles;
},

getRight: function(local) {
return (local ? this.getLocalX() : this.getX()) + this.getWidth();
},

getTop: function(local) {
return local ? this.getLocalY() : this.getY();
},

getX: function() {
return Element.getX(this.dom);
},

getXY: function() {
return Element.getXY(this.dom);
},

getY: function() {
return Element.getY(this.dom);
},

moveTo: function(x, y, animate) {
return this.setXY([x, y], animate);
},

position: function(pos, zIndex, x, y) {
var me = this;
if (!pos && me.isStyle(POSITION, STATIC)) {
me.setStyle(POSITION, RELATIVE);
} else if (pos) {
me.setStyle(POSITION, pos);
}
if (zIndex) {
me.setStyle(ZINDEX, zIndex);
}
if (x || y) {
me.setXY([x || false, y || false]);
}
},

setBottom: function(bottom) {
this.dom.style[BOTTOM] = this.addUnits(bottom);
return this;
},

setBounds: function(x, y, width, height, animate) {
return this.setBox({
x: x,
y: y,
width: width,
height: height
}, animate);
},

setLeft: function(left) {
this.dom.style[LEFT] = this.addUnits(left); 
return this;
},

setLeftTop: function(left, top) {
var me = this,
style = me.dom.style;
style.left = me.addUnits(left);
style.top = me.addUnits(top);
return me;
},
setLocalX: function(x) {
var style = this.dom.style;
// clear right style just in case it was previously set by rtlSetXY/rtlSetLocalXY
style.right = 'auto';
style.left = (x === null) ? 'auto' : x + 'px';
},
setLocalXY: function(x, y) {
var style = this.dom.style;
// clear right style just in case it was previously set by rtlSetXY/rtlSetLocalXY
style.right = 'auto';
if (x && x.length) {
y = x[1];
x = x[0];
}
if (x === null) {
style.left = 'auto';
} else if (x !== undefined) {
style.left = x + 'px';
}
if (y === null) {
style.top = 'auto';
} else if (y !== undefined) {
style.top = y + 'px';
}
},
setLocalY: function(y) {
this.dom.style.top = (y === null) ? 'auto' : y + 'px';
},

setLocation: function(x, y, animate) {
return this.setXY([x, y], animate);
},

setPositioning: function(pc) {
return this.setStyle(pc);
},

setRight: function(right) {
this.dom.style[RIGHT] = this.addUnits(right);
return this;
},

setTop: function(top) {
this.dom.style[TOP] = this.addUnits(top);
return this;
},
setX: function(x, animate) {
return this.setXY([x, this.getY()], animate);
},
setXY: function(xy, animate) {
var me = this;
if (!animate || !me.anim) {
Element.setXY(me.dom, xy);
} else {
if (!Ext.isObject(animate)) {
animate = {};
}
me.animate(Ext.applyIf({ to: { x: xy[0], y: xy[1] } }, animate));
}
return this;
},
setY: function(y, animate) {
return this.setXY([this.getX(), y], animate);
}
});

Element.getTrueXY = Element.getXY;
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/dom/Element_scroll.js */
(function(Ext) {
// @tag dom,core
Ext.define('Ext.dom.Element_scroll', {
override: 'Ext.dom.Element',

isScrollable: function() {
var dom = this.dom;
return dom.scrollHeight > dom.clientHeight || dom.scrollWidth > dom.clientWidth;
},

getScroll: function() {
var me = this,
dom = me.dom,
doc = document,
body = doc.body,
docElement = doc.documentElement,
left, top;
if (dom === doc || dom === body) {
// the scrollLeft/scrollTop may be either on the body or documentElement,
// depending on browser. It is possible to use window.pageXOffset/pageYOffset
// in most modern browsers but this complicates things when in rtl mode because
// pageXOffset does not always behave the same as scrollLeft when direction is
// rtl. (e.g. pageXOffset can be an offset from the right, while scrollLeft
// is offset from the left, one can be positive and the other negative, etc.)
// To avoid adding an extra layer of feature detection in rtl mode to deal with
// these differences, it's best just to always use scrollLeft/scrollTop
left = docElement.scrollLeft || (body ? body.scrollLeft : 0);
top = docElement.scrollTop || (body ? body.scrollTop : 0);
} else {
left = dom.scrollLeft;
top = dom.scrollTop;
}
return {
left: left,
top: top
};
},


getScrollLeft: function() {
var dom = this.dom,
doc = document;

if (dom === doc || dom === doc.body) {
return this.getScroll().left;
} else {
return dom.scrollLeft;
}
},


getScrollTop: function(){
var dom = this.dom,
doc = document;

if (dom === doc || dom === doc.body) {
return this.getScroll().top;
} else {
return dom.scrollTop;
}
},


setScrollLeft: function(left){
this.dom.scrollLeft = left;
return this;
},


setScrollTop: function(top) {
this.dom.scrollTop = top;
return this;
},

scrollBy: function(deltaX, deltaY, animate) {
var me = this,
dom = me.dom;
// Extract args if deltas were passed as an Array.
if (deltaX.length) {
animate = deltaY;
deltaY = deltaX[1];
deltaX = deltaX[0];
} else if (typeof deltaX != 'number') { // or an object
animate = deltaY;
deltaY = deltaX.y;
deltaX = deltaX.x;
}
if (deltaX) {
me.scrollTo('left', me.constrainScrollLeft(dom.scrollLeft + deltaX), animate);
}
if (deltaY) {
me.scrollTo('top', me.constrainScrollTop(dom.scrollTop + deltaY), animate);
}
return me;
},

scrollTo: function(side, value, animate) {
//check if we're scrolling top or left
var top = /top/i.test(side),
me = this,
prop = top ? 'scrollTop' : 'scrollLeft',
dom = me.dom,
animCfg;
if (!animate || !me.anim) {
// just setting the value, so grab the direction
dom[prop] = value;
// corrects IE, other browsers will ignore
dom[prop] = value;
}
else {
animCfg = {
to: {}
};
animCfg.to[prop] = value;
if (Ext.isObject(animate)) {
Ext.applyIf(animCfg, animate);
}
me.animate(animCfg);
}
return me;
},

scrollIntoView: function(container, hscroll, animate, highlight) {
var me = this,
dom = me.dom,
offsets = me.getOffsetsTo(container = Ext.getDom(container) || Ext.getBody().dom),
// el's box
left = offsets[0] + container.scrollLeft,
top = offsets[1] + container.scrollTop,
bottom = top + dom.offsetHeight,
right = left + dom.offsetWidth,
// ct's box
ctClientHeight = container.clientHeight,
ctScrollTop = parseInt(container.scrollTop, 10),
ctScrollLeft = parseInt(container.scrollLeft, 10),
ctBottom = ctScrollTop + ctClientHeight,
ctRight = ctScrollLeft + container.clientWidth,
newPos;
// Highlight upon end of scroll
if (highlight) {
if (animate) {
animate = Ext.apply({
listeners: {
afteranimate: function() {
me.scrollChildFly.attach(dom).highlight();
}
}
}, animate);
} else {
me.scrollChildFly.attach(dom).highlight();
}
}
if (dom.offsetHeight > ctClientHeight || top < ctScrollTop) {
newPos = top;
} else if (bottom > ctBottom) {
newPos = bottom - ctClientHeight;
}
if (newPos != null) {
me.scrollChildFly.attach(container).scrollTo('top', newPos, animate);
}
if (hscroll !== false) {
newPos = null;
if (dom.offsetWidth > container.clientWidth || left < ctScrollLeft) {
newPos = left;
} else if (right > ctRight) {
newPos = right - container.clientWidth;
}
if (newPos != null) {
me.scrollChildFly.attach(container).scrollTo('left', newPos, animate);
}
}
return me;
},
// @private
scrollChildIntoView: function(child, hscroll) {
this.scrollChildFly.attach(Ext.getDom(child)).scrollIntoView(this, hscroll);
},

scroll: function(direction, distance, animate) {
if (!this.isScrollable()) {
return false;
}
var me = this,
dom = me.dom,
side = direction === 'r' || direction === 'l' ? 'left' : 'top',
scrolled = false,
currentScroll, constrainedScroll;
if (direction === 'r') {
distance = -distance;
}
if (side === 'left') {
currentScroll = dom.scrollLeft;
constrainedScroll = me.constrainScrollLeft(currentScroll + distance);
} else {
currentScroll = dom.scrollTop;
constrainedScroll = me.constrainScrollTop(currentScroll + distance);
}
if (constrainedScroll !== currentScroll) {
this.scrollTo(side, constrainedScroll, animate);
scrolled = true;
}
return scrolled;
},
constrainScrollLeft: function(left) {
var dom = this.dom;
return Math.max(Math.min(left, dom.scrollWidth - dom.clientWidth), 0);
},
constrainScrollTop: function(top) {
var dom = this.dom;
return Math.max(Math.min(top, dom.scrollHeight - dom.clientHeight), 0);
}
}, function() {
this.prototype.scrollChildFly = new this.Fly();
this.prototype.scrolltoFly = new this.Fly();
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/dom/Element_style.js */
(function(Ext) {
// @tag dom,core
Ext.define('Ext.dom.Element_style', {
override: 'Ext.dom.Element'
},
function() {
var Element = this,
view = document.defaultView,
adjustDirect2DTableRe = /table-row|table-.*-group/,
INTERNAL = '_internal',
HIDDEN = 'hidden',
HEIGHT = 'height',
WIDTH = 'width',
ISCLIPPED = 'isClipped',
OVERFLOW = 'overflow',
OVERFLOWX = 'overflow-x',
OVERFLOWY = 'overflow-y',
ORIGINALCLIP = 'originalClip',
DOCORBODYRE = /#document|body/i,
// This reduces the lookup of 'me.styleHooks' by one hop in the prototype chain. It is
// the same object.
styleHooks, verticalStyleHooks90, verticalStyleHooks270,
edges, k, edge, borderWidth;
if (!view || !view.getComputedStyle) {
Element.prototype.getStyle = function (property, inline) {
var me = this,
dom = me.dom,
multiple = typeof property != 'string',
hooks = me.styleHooks,
prop = property,
props = prop,
len = 1,
isInline = inline,
camel, domStyle, values, hook, out, style, i;
if (multiple) {
values = {};
prop = props[0];
i = 0;
if (!(len = props.length)) {
return values;
}
}
if (!dom || dom.documentElement) {
return values || '';
}
domStyle = dom.style;
if (inline) {
style = domStyle;
} else {
style = dom.currentStyle;
// fallback to inline style if rendering context not available
if (!style) {
isInline = true;
style = domStyle;
}
}
do {
hook = hooks[prop];
if (!hook) {
hooks[prop] = hook = { name: Element.normalize(prop) };
}
if (hook.get) {
out = hook.get(dom, me, isInline, style);
} else {
camel = hook.name;
// In some cases, IE6 will throw Invalid Argument exceptions for properties
// like fontSize (/examples/tabs/tabs.html in 4.0 used to exhibit this but
// no longer does due to font style changes). There is a real cost to a try
// block, so we avoid it where possible...
if (hook.canThrow) {
try {
out = style[camel];
} catch (e) {
out = '';
}
} else {
// EXTJSIV-5657 - In IE9 quirks mode there is a chance that VML root element 
// has neither `currentStyle` nor `style`. Return '' this case.
out = style ? style[camel] : '';
}
}
if (!multiple) {
return out;
}
values[prop] = out;
prop = props[++i];
} while (i < len);
return values;
};
}
Element.override({
getHeight: function(contentHeight, preciseHeight) {
var me = this,
hidden = me.isStyle('display', 'none'),
height,
floating;
if (hidden) {
return 0;
}
height = me.dom.offsetHeight;
// IE9/10 Direct2D dimension rounding bug
if (Ext.supports.Direct2DBug) {
floating = me.adjustDirect2DDimension(HEIGHT);
if (preciseHeight) {
height += floating;
}
else if (floating > 0 && floating < 0.5) {
height++;
}
}
if (contentHeight) {
height -= me.getBorderWidth("tb") + me.getPadding("tb");
}
return (height < 0) ? 0 : height;
},
getWidth: function(contentWidth, preciseWidth) {
var me = this,
dom = me.dom,
hidden = me.isStyle('display', 'none'),
rect, width, floating;
if (hidden) {
return 0;
}
// Gecko will in some cases report an offsetWidth that is actually less than the width of the
// text contents, because it measures fonts with sub-pixel precision but rounds the calculated
// value down. Using getBoundingClientRect instead of offsetWidth allows us to get the precise
// subpixel measurements so we can force them to always be rounded up. See
// https://bugzilla.mozilla.org/show_bug.cgi?id=458617
// Rounding up ensures that the width includes the full width of the text contents.
if (preciseWidth && Ext.supports.BoundingClientRect) {
rect = dom.getBoundingClientRect();
// IE9 is the only browser that supports getBoundingClientRect() and
// uses a filter to rotate the element vertically. When a filter
// is used to rotate the element, the getHeight/getWidth functions
// are not inverted (see setVertical).
width = (me.vertical && !Ext.isIE9 && !Ext.supports.RotatedBoundingClientRect) ?
(rect.bottom - rect.top) : (rect.right - rect.left);
} else {
width = dom.offsetWidth;
}
// IE9/10 Direct2D dimension rounding bug: https://sencha.jira.com/browse/EXTJSIV-603
// there is no need make adjustments for this bug when the element is vertically
// rotated because the width of a vertical element is its rotated height
if (Ext.supports.Direct2DBug && !me.vertical) {
// get the fractional portion of the sub-pixel precision width of the element's text contents
floating = me.adjustDirect2DDimension(WIDTH);
if (preciseWidth) {
width += floating;
}
// IE9 also measures fonts with sub-pixel precision, but unlike Gecko, instead of rounding the offsetWidth down,
// it rounds to the nearest integer. This means that in order to ensure that the width includes the full
// width of the text contents we need to increment the width by 1 only if the fractional portion is less than 0.5
else if (floating > 0 && floating < 0.5) {
width++;
}
}
if (contentWidth) {
width -= me.getBorderWidth("lr") + me.getPadding("lr");
}
return (width < 0) ? 0 : width;
},
setWidth: function(width, animate) {
var me = this;
width = me.adjustWidth(width);
if (!animate || !me.anim) {
me.dom.style.width = me.addUnits(width);
}
else {
if (!Ext.isObject(animate)) {
animate = {};
}
me.animate(Ext.applyIf({
to: {
width: width
}
}, animate));
}
return me;
},
setHeight : function(height, animate) {
var me = this;
height = me.adjustHeight(height);
if (!animate || !me.anim) {
me.dom.style.height = me.addUnits(height);
}
else {
if (!Ext.isObject(animate)) {
animate = {};
}
me.animate(Ext.applyIf({
to: {
height: height
}
}, animate));
}
return me;
},
applyStyles: function(style) {
Ext.DomHelper.applyStyles(this.dom, style);
return this;
},
setSize: function(width, height, animate) {
var me = this;
if (Ext.isObject(width)) { // in case of object from getSize()
animate = height;
height = width.height;
width = width.width;
}
width = me.adjustWidth(width);
height = me.adjustHeight(height);
if (!animate || !me.anim) {
me.dom.style.width = me.addUnits(width);
me.dom.style.height = me.addUnits(height);
}
else {
if (animate === true) {
animate = {};
}
me.animate(Ext.applyIf({
to: {
width: width,
height: height
}
}, animate));
}
return me;
},
getViewSize : function() {
var me = this,
dom = me.dom,
isDoc = DOCORBODYRE.test(dom.nodeName),
ret;
// If the body, use static methods
if (isDoc) {
ret = {
width : Element.getViewWidth(),
height : Element.getViewHeight()
};
} else {
ret = {
width : dom.clientWidth,
height : dom.clientHeight
};
}
return ret;
},
getSize: function(contentSize) {
return {width: this.getWidth(contentSize), height: this.getHeight(contentSize)};
},
// TODO: Look at this
// private ==> used by Fx
adjustWidth : function(width) {
var me = this,
isNum = (typeof width == 'number');
if (isNum && me.autoBoxAdjust && !me.isBorderBox()) {
width -= (me.getBorderWidth("lr") + me.getPadding("lr"));
}
return (isNum && width < 0) ? 0 : width;
},
// private ==> used by Fx
adjustHeight : function(height) {
var me = this,
isNum = (typeof height == "number");
if (isNum && me.autoBoxAdjust && !me.isBorderBox()) {
height -= (me.getBorderWidth("tb") + me.getPadding("tb"));
}
return (isNum && height < 0) ? 0 : height;
},

getColor : function(attr, defaultValue, prefix) {
var v = this.getStyle(attr),
color = prefix || prefix === '' ? prefix : '#',
h, len, i=0;
if (!v || (/transparent|inherit/.test(v))) {
return defaultValue;
}
if (/^r/.test(v)) {
v = v.slice(4, v.length - 1).split(',');
len = v.length;
for (; i<len; i++) {
h = parseInt(v[i], 10);
color += (h < 16 ? '0' : '') + h.toString(16);
}
} else {
v = v.replace('#', '');
color += v.length == 3 ? v.replace(/^(\w)(\w)(\w)$/, '$1$1$2$2$3$3') : v;
}
return(color.length > 5 ? color.toLowerCase() : defaultValue);
},

setOpacity: function(opacity, animate) {
var me = this;
if (!me.dom) {
return me;
}
if (!animate || !me.anim) {
me.setStyle('opacity', opacity);
}
else {
if (typeof animate != 'object') {
animate = {
duration: 350,
easing: 'ease-in'
};
}
me.animate(Ext.applyIf({
to: {
opacity: opacity
}
}, animate));
}
return me;
},

clearOpacity : function() {
return this.setOpacity('');
},

adjustDirect2DDimension: function(dimension) {
var me = this,
dom = me.dom,
display = me.getStyle('display'),
inlineDisplay = dom.style.display,
inlinePosition = dom.style.position,
originIndex = dimension === WIDTH ? 0 : 1,
currentStyle = dom.currentStyle,
floating;
if (display === 'inline') {
dom.style.display = 'inline-block';
}
dom.style.position = display.match(adjustDirect2DTableRe) ? 'absolute' : 'static';
// floating will contain digits that appears after the decimal point
// if height or width are set to auto we fallback to msTransformOrigin calculation

// Use currentStyle here instead of getStyle. In some difficult to reproduce 
// instances it resets the scrollWidth of the element
floating = (parseFloat(currentStyle[dimension]) || parseFloat(currentStyle.msTransformOrigin.split(' ')[originIndex]) * 2) % 1;
dom.style.position = inlinePosition;
if (display === 'inline') {
dom.style.display = inlineDisplay;
}
return floating;
},

clip : function() {
var me = this,
data = (me.$cache || me.getCache()).data,
style;
if (!data[ISCLIPPED]) {
data[ISCLIPPED] = true;
style = me.getStyle([OVERFLOW, OVERFLOWX, OVERFLOWY]);
data[ORIGINALCLIP] = {
o: style[OVERFLOW],
x: style[OVERFLOWX],
y: style[OVERFLOWY]
};
me.setStyle(OVERFLOW, HIDDEN);
me.setStyle(OVERFLOWX, HIDDEN);
me.setStyle(OVERFLOWY, HIDDEN);
}
return me;
},

unclip : function() {
var me = this,
data = (me.$cache || me.getCache()).data,
clip;
if (data[ISCLIPPED]) {
data[ISCLIPPED] = false;
clip = data[ORIGINALCLIP];
if (clip.o) {
me.setStyle(OVERFLOW, clip.o);
}
if (clip.x) {
me.setStyle(OVERFLOWX, clip.x);
}
if (clip.y) {
me.setStyle(OVERFLOWY, clip.y);
}
}
return me;
},

boxWrap : function(cls) {
cls = cls || Ext.baseCSSPrefix + 'box';
var el = Ext.get(this.insertHtml("beforeBegin", "<div class='" + cls + "'>" + Ext.String.format(Element.boxMarkup, cls) + "</div>"));
Ext.DomQuery.selectNode('.' + cls + '-mc', el.dom).appendChild(this.dom);
return el;
},

getComputedHeight : function() {
var me = this,
h = Math.max(me.dom.offsetHeight, me.dom.clientHeight);
if (!h) {
h = parseFloat(me.getStyle(HEIGHT)) || 0;
if (!me.isBorderBox()) {
h += me.getFrameWidth('tb');
}
}
return h;
},

getComputedWidth : function() {
var me = this,
w = Math.max(me.dom.offsetWidth, me.dom.clientWidth);
if (!w) {
w = parseFloat(me.getStyle(WIDTH)) || 0;
if (!me.isBorderBox()) {
w += me.getFrameWidth('lr');
}
}
return w;
},

getFrameWidth : function(sides, onlyContentBox) {
return (onlyContentBox && this.isBorderBox()) ? 0 : (this.getPadding(sides) + this.getBorderWidth(sides));
},

addClsOnOver : function(className, testFn, scope) {
var me = this,
dom = me.dom,
hasTest = Ext.isFunction(testFn);

me.hover(
function() {
if (hasTest && testFn.call(scope || me, me) === false) {
return;
}
Ext.fly(dom, INTERNAL).addCls(className);
},
function() {
Ext.fly(dom, INTERNAL).removeCls(className);
}
);
return me;
},

addClsOnFocus : function(className, testFn, scope) {
var me = this,
dom = me.dom,
hasTest = Ext.isFunction(testFn);

me.on("focus", function() {
if (hasTest && testFn.call(scope || me, me) === false) {
return false;
}
Ext.fly(dom, INTERNAL).addCls(className);
});
me.on("blur", function() {
Ext.fly(dom, INTERNAL).removeCls(className);
});
return me;
},

addClsOnClick : function(className, testFn, scope) {
var me = this,
dom = me.dom,
hasTest = Ext.isFunction(testFn);

me.on("mousedown", function() {
if (hasTest && testFn.call(scope || me, me) === false) {
return false;
}
Ext.fly(dom, INTERNAL).addCls(className);
var d = Ext.getDoc(),
fn = function() {
Ext.fly(dom, INTERNAL).removeCls(className);
d.removeListener("mouseup", fn);
};
d.on("mouseup", fn);
});
return me;
},

getStyleSize : function() {
var me = this,
d = this.dom,
isDoc = DOCORBODYRE.test(d.nodeName),
s ,
w, h;
// If the body, use static methods
if (isDoc) {
return {
width : Element.getViewWidth(),
height : Element.getViewHeight()
};
}
s = me.getStyle([HEIGHT, WIDTH], true); //seek inline
// Use Styles if they are set
if (s.width && s.width != 'auto') {
w = parseFloat(s.width);
if (me.isBorderBox()) {
w -= me.getFrameWidth('lr');
}
}
// Use Styles if they are set
if (s.height && s.height != 'auto') {
h = parseFloat(s.height);
if (me.isBorderBox()) {
h -= me.getFrameWidth('tb');
}
}
// Use getWidth/getHeight if style not set.
return {width: w || me.getWidth(true), height: h || me.getHeight(true)};
},
statics: {
selectableCls: Ext.baseCSSPrefix + 'selectable',
unselectableCls: Ext.baseCSSPrefix + 'unselectable'
},

selectable : function() {
var me = this;
// We clear this property for all browsers, not just Opera. This is so that rendering templates don't need to
// condition on Opera when making elements unselectable.
me.dom.unselectable = '';
me.removeCls(Element.unselectableCls);
me.addCls(Element.selectableCls);
return me;
},

unselectable : function() {
// The approach used to disable text selection combines CSS, HTML attributes and DOM events. Importantly the
// strategy is designed to be expressible in markup, so that elements can be rendered unselectable without
// needing modifications post-render. e.g.:
//
// <div class="x-unselectable" unselectable="on"></div>
//
// Changes to this method may need to be reflected elsewhere, e.g. ProtoElement.
var me = this;
// The unselectable property (or similar) is supported by various browsers but Opera is the only browser that
// doesn't support any of the other techniques. The problem with it is that it isn't inherited by child
// elements. Theoretically we could add it to all children but the performance would be terrible. In certain
// key locations (e.g. panel headers) we add unselectable="on" to extra elements during rendering just for
// Opera's benefit.
if (Ext.isOpera) {
me.dom.unselectable = 'on';
}
// In Mozilla and WebKit the CSS properties -moz-user-select and -webkit-user-select prevent a selection
// originating in an element. These are inherited, which is what we want.
//
// In IE we rely on a listener for the selectstart event instead. We don't need to register a listener on the
// individual element, instead we use a single listener and rely on event propagation to listen for the event at
// the document level. That listener will walk up the DOM looking for nodes that have either of the classes
// x-selectable or x-unselectable. This simulates the CSS inheritance approach.
//
// IE 10 is expected to support -ms-user-select so the listener may not be required.
me.removeCls(Element.selectableCls);
me.addCls(Element.unselectableCls);
return me;
},

setVertical: function(angle, cls) {
var me = this,
proto = Element.prototype,
hooks;
me.vertical = true;
if (cls) {
me.addCls(me.verticalCls = cls);
}
me.setWidth = proto.setHeight;
me.setHeight = proto.setWidth;
if (!Ext.isIE9m) {
// In browsers that use CSS3 transforms we must invert getHeight and
// get Width. In IE9 and below no adjustment is needed because we use
// a BasicImage filter to rotate the element and the element's
// offsetWidth and offsetHeight are automatically inverted.
me.getWidth = proto.getHeight;
me.getHeight = proto.getWidth;
}
// Switch to using the appropriate vertical style hooks
me.styleHooks = (angle === 270) ?
Element.prototype.verticalStyleHooks270 : Element.prototype.verticalStyleHooks90;
},

setHorizontal: function() {
var me = this,
cls = me.verticalCls;
delete me.vertical;
if (cls) {
delete me.verticalCls;
me.removeCls(cls);
}
// delete the inverted methods and revert to inheriting from the prototype 
delete me.setWidth;
delete me.setHeight;
if (!Ext.isIE9m) {
delete me.getWidth;
delete me.getHeight;
}
// revert to inheriting styleHooks from the prototype
delete me.styleHooks;
}
});
Element.prototype.styleHooks = styleHooks = Ext.dom.AbstractElement.prototype.styleHooks;
// When elements are rotated 80 or 270 degrees, their border, margin and padding hooks
// need to be rotated as well.
Element.prototype.verticalStyleHooks90 = verticalStyleHooks90 = Ext.Object.chain(Element.prototype.styleHooks);
Element.prototype.verticalStyleHooks270 = verticalStyleHooks270 = Ext.Object.chain(Element.prototype.styleHooks);
verticalStyleHooks90.width = { name: 'height' };
verticalStyleHooks90.height = { name: 'width' };
verticalStyleHooks90['margin-top'] = { name: 'marginLeft' };
verticalStyleHooks90['margin-right'] = { name: 'marginTop' };
verticalStyleHooks90['margin-bottom'] = { name: 'marginRight' };
verticalStyleHooks90['margin-left'] = { name: 'marginBottom' };
verticalStyleHooks90['padding-top'] = { name: 'paddingLeft' };
verticalStyleHooks90['padding-right'] = { name: 'paddingTop' };
verticalStyleHooks90['padding-bottom'] = { name: 'paddingRight' };
verticalStyleHooks90['padding-left'] = { name: 'paddingBottom' };
verticalStyleHooks90['border-top'] = { name: 'borderLeft' };
verticalStyleHooks90['border-right'] = { name: 'borderTop' };
verticalStyleHooks90['border-bottom'] = { name: 'borderRight' };
verticalStyleHooks90['border-left'] = { name: 'borderBottom' };
verticalStyleHooks270.width = { name: 'height' };
verticalStyleHooks270.height = { name: 'width' };
verticalStyleHooks270['margin-top'] = { name: 'marginRight' };
verticalStyleHooks270['margin-right'] = { name: 'marginBottom' };
verticalStyleHooks270['margin-bottom'] = { name: 'marginLeft' };
verticalStyleHooks270['margin-left'] = { name: 'marginTop' };
verticalStyleHooks270['padding-top'] = { name: 'paddingRight' };
verticalStyleHooks270['padding-right'] = { name: 'paddingBottom' };
verticalStyleHooks270['padding-bottom'] = { name: 'paddingLeft' };
verticalStyleHooks270['padding-left'] = { name: 'paddingTop' };
verticalStyleHooks270['border-top'] = { name: 'borderRight' };
verticalStyleHooks270['border-right'] = { name: 'borderBottom' };
verticalStyleHooks270['border-bottom'] = { name: 'borderLeft' };
verticalStyleHooks270['border-left'] = { name: 'borderTop' };
if (Ext.isIE7m) {
styleHooks.fontSize = styleHooks['font-size'] = {
name: 'fontSize',
canThrow: true
};

styleHooks.fontStyle = styleHooks['font-style'] = {
name: 'fontStyle',
canThrow: true
};

styleHooks.fontFamily = styleHooks['font-family'] = {
name: 'fontFamily',
canThrow: true
};
}
// override getStyle for border-*-width
if (Ext.isIEQuirks || Ext.isIE && Ext.ieVersion <= 8) {
function getBorderWidth (dom, el, inline, style) {
if (style[this.styleName] == 'none') {
return '0px';
}
return style[this.name];
}
edges = ['Top','Right','Bottom','Left'];
k = edges.length;
while (k--) {
edge = edges[k];
borderWidth = 'border' + edge + 'Width';
styleHooks['border-'+edge.toLowerCase()+'-width'] = styleHooks[borderWidth] = {
name: borderWidth,
styleName: 'border' + edge + 'Style',
get: getBorderWidth
};
}
}
// The following hack is needed to support padding on dom elements with display:table.
// It was added because at one point auto layout's "outerCt" element had padding applied
// to it. The padding is now appplied to the innerCt which is display:table-cell, so this
// hack is not currently needed.
//if (Ext.isIE9 && Ext.isStrict) {
// // In IE9, getComputedStyle always returns 0px for padding if the element has
// // "display:table", so we use currentStyle instead.
// var names = {
// padding: 'padding',
// paddingTop: 'padding-top',
// paddingRight: 'padding-right',
// paddingBottom: 'padding-bottom',
// paddingLeft: 'padding-left'
// },
// createHook = function(name, camelCaseName) {
// styleHooks[name] = styleHooks[camelCaseName] = {
// name: name,
// get: function(dom) {
// return dom.currentStyle[name];
// }
// }
// },
// camelCaseName;
//
// for (camelCaseName in names) {
// createHook(names[camelCaseName], camelCaseName);
// }
//}
// Element.unselectable relies on this listener to prevent selection in IE. Some other browsers support the event too
// but it is only strictly required for IE. In WebKit this listener causes subtle differences to how the browser handles
// the non-selection, e.g. whether or not the mouse cursor changes when attempting to select text.
Ext.getDoc().on('selectstart', function(ev, dom) {
var doc = document.documentElement,
selectableCls = Element.selectableCls,
unselectableCls = Element.unselectableCls,
tagName = dom && dom.tagName;
tagName = tagName && tagName.toLowerCase();
// Element.unselectable is not really intended to handle selection within text fields and it is important that
// fields inside menus or panel headers don't inherit the unselectability. In most browsers this is automatic but in
// IE 9 the selectstart event can bubble up from text fields so we have to explicitly handle that case.
if (tagName === 'input' || tagName === 'textarea') {
return;
}
// Walk up the DOM checking the nodes. This may be 'slow' but selectstart events don't fire very often
while (dom && dom.nodeType === 1 && dom !== doc) {
var el = Ext.fly(dom);
// If the node has the class x-selectable then stop looking, the text selection is allowed
if (el.hasCls(selectableCls)) {
return;
}
// If the node has class x-unselectable then the text selection needs to be stopped
if (el.hasCls(unselectableCls)) {
ev.stopEvent();
return;
}
dom = dom.parentNode;
}
});
});
Ext.onReady(function () {
var opacityRe = /alpha\(opacity=(.*)\)/i,
trimRe = /^\s+|\s+$/g,
hooks = Ext.dom.Element.prototype.styleHooks;
// Ext.supports flags are not populated until onReady...
hooks.opacity = {
name: 'opacity',
afterSet: function(dom, value, el) {
if (el.isLayer) {
el.onOpacitySet(value);
}
}
};
if (!Ext.supports.Opacity && Ext.isIE) {
Ext.apply(hooks.opacity, {
get: function (dom) {
var filter = dom.style.filter,
match, opacity;
if (filter.match) {
match = filter.match(opacityRe);
if (match) {
opacity = parseFloat(match[1]);
if (!isNaN(opacity)) {
return opacity ? opacity / 100 : 0;
}
}
}
return 1;
},
set: function (dom, value) {
var style = dom.style,
val = style.filter.replace(opacityRe, '').replace(trimRe, '');
style.zoom = 1; // ensure dom.hasLayout
// value can be a number or '' or null... so treat falsey as no opacity
if (typeof(value) == 'number' && value >= 0 && value < 1) {
value *= 100;
style.filter = val + (val.length ? ' ' : '') + 'alpha(opacity='+value+')';
} else {
style.filter = val;
}
} 
});
}
// else there is no work around for the lack of opacity support. Should not be a
// problem given that this has been supported for a long time now...
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/util/Positionable.js */
(function(Ext) {
// @tag core
Ext.define('Ext.util.Positionable', {
_positionTopLeft: ['position', 'top', 'left'],
_alignRe: /^([a-z]+)-([a-z]+)(\?)?$/,
// Stub implementation called after positioning.
// May be implemented in subclasses. AbstractComponent has an implementation.
afterSetPosition: Ext.emptyFn,
//<debug>
// ***********************
// Begin Abstract Methods
// ***********************

getAnchorToXY: function() {
Ext.Error.raise("getAnchorToXY is not implemented in " + this.$className);
},

getBorderPadding: function() {
Ext.Error.raise("getBorderPadding is not implemented in " + this.$className);
},

getLocalX: function() {
Ext.Error.raise("getLocalX is not implemented in " + this.$className);
},

getLocalXY: function() {
Ext.Error.raise("getLocalXY is not implemented in " + this.$className);
},

getLocalY: function() {
Ext.Error.raise("getLocalY is not implemented in " + this.$className);
},

getX: function() {
Ext.Error.raise("getX is not implemented in " + this.$className);
},

getXY: function() {
Ext.Error.raise("getXY is not implemented in " + this.$className);
},

getY: function() {
Ext.Error.raise("getY is not implemented in " + this.$className);
},

setLocalX: function() {
Ext.Error.raise("setLocalX is not implemented in " + this.$className);
},

setLocalXY: function() {
Ext.Error.raise("setLocalXY is not implemented in " + this.$className);
},

setLocalY: function() {
Ext.Error.raise("setLocalY is not implemented in " + this.$className);
},

setX: function() {
Ext.Error.raise("setX is not implemented in " + this.$className);
},

setXY: function() {
Ext.Error.raise("setXY is not implemented in " + this.$className);
},

setY: function() {
Ext.Error.raise("setY is not implemented in " + this.$className);
},
// ***********************
// End Abstract Methods
// ***********************
//</debug>
// private ==> used outside of core
// TODO: currently only used by ToolTip. does this method belong here?
adjustForConstraints: function(xy, parent) {
var vector = this.getConstrainVector(parent, xy);
if (vector) {
xy[0] += vector[0];
xy[1] += vector[1];
}
return xy;
},

alignTo: function(element, position, offsets, animate) {
var me = this,
el = me.el;
return me.setXY(me.getAlignToXY(element, position, offsets),
el.anim && !!animate ? el.anim(animate) : false);
},

anchorTo: function(anchorToEl, alignment, offsets, animate, monitorScroll, callback) {
var me = this,
scroll = !Ext.isEmpty(monitorScroll),
action = function() {
me.alignTo(anchorToEl, alignment, offsets, animate);
Ext.callback(callback, me);
},
anchor = me.getAnchor();
// previous listener anchor, remove it
me.removeAnchor();
Ext.apply(anchor, {
fn: action,
scroll: scroll
});
Ext.EventManager.onWindowResize(action, null);
if (scroll) {
Ext.EventManager.on(window, 'scroll', action, null,
{buffer: !isNaN(monitorScroll) ? monitorScroll : 50});
}
action(); // align immediately
return me;
},

calculateAnchorXY: function(anchor, extraX, extraY, mySize) {
//Passing a different size is useful for pre-calculating anchors,
//especially for anchored animations that change the el size.
var me = this,
el = me.el,
doc = document,
isViewport = el.dom == doc.body || el.dom == doc,
round = Math.round,
xy, myWidth, myHeight;
anchor = (anchor || "tl").toLowerCase();
mySize = mySize || {};
myWidth = mySize.width || isViewport ? Ext.Element.getViewWidth() : me.getWidth();
myHeight = mySize.height || isViewport ? Ext.Element.getViewHeight() : me.getHeight();
// Calculate anchor position.
// Test most common cases for picker alignment first.
switch (anchor) {
case 'tl' : xy = [0, 0];
break;
case 'bl' : xy = [0, myHeight];
break;
case 'tr' : xy = [myWidth, 0];
break;
case 'c' : xy = [round(myWidth * 0.5), round(myHeight * 0.5)];
break;
case 't' : xy = [round(myWidth * 0.5), 0];
break;
case 'l' : xy = [0, round(myHeight * 0.5)];
break;
case 'r' : xy = [myWidth, round(myHeight * 0.5)];
break;
case 'b' : xy = [round(myWidth * 0.5), myHeight];
break;
case 'tc' : xy = [round(myWidth * 0.5), 0];
break;
case 'bc' : xy = [round(myWidth * 0.5), myHeight];
break;
case 'br' : xy = [myWidth, myHeight];
}
return [xy[0] + extraX, xy[1] + extraY];
},

convertPositionSpec: Ext.identityFn,

getAlignToXY: function(alignToEl, posSpec, offset) {
var me = this,
viewportWidth = Ext.Element.getViewWidth() - 10, // 10px of margin for ie
viewportHeight = Ext.Element.getViewHeight() - 10, // 10px of margin for ie
doc = document,
docElement = doc.documentElement,
docBody = doc.body,
scrollX = (docElement.scrollLeft || docBody.scrollLeft || 0),
scrollY = (docElement.scrollTop || docBody.scrollTop || 0),
alignMatch, myPosition, alignToElPosition, myWidth, myHeight,
alignToElRegion, swapY, swapX, constrain, align1, align2,
p1y, p1x, p2y, p2x, x, y;
alignToEl = Ext.get(alignToEl.el || alignToEl);
if (!alignToEl || !alignToEl.dom) {
//<debug>
Ext.Error.raise({
sourceClass: 'Ext.util.Positionable',
sourceMethod: 'getAlignToXY',
msg: 'Attempted to align an element that doesn\'t exist'
});
//</debug>
}
offset = offset || [0,0];
posSpec = (!posSpec || posSpec == "?" ? "tl-bl?" :
(!(/-/).test(posSpec) && posSpec !== "" ? "tl-" + posSpec : posSpec || "tl-bl")).toLowerCase();
posSpec = me.convertPositionSpec(posSpec);
alignMatch = posSpec.match(me._alignRe);
//<debug>
if (!alignMatch) {
Ext.Error.raise({
sourceClass: 'Ext.util.Positionable',
sourceMethod: 'getAlignToXY',
el: alignToEl,
position: posSpec,
offset: offset,
msg: 'Attemmpted to align an element with an invalid position: "' + posSpec + '"'
});
}
//</debug>
align1 = alignMatch[1];
align2 = alignMatch[2];
constrain = !!alignMatch[3];
//Subtract the aligned el's internal xy from the target's offset xy
//plus custom offset to get this Element's new offset xy
myPosition = me.getAnchorXY(align1, true);
alignToElPosition = me.getAnchorToXY(alignToEl, align2, false);
x = alignToElPosition[0] - myPosition[0] + offset[0];
y = alignToElPosition[1] - myPosition[1] + offset[1];
// If position spec ended with a "?", then constrain to viewport is necessary
if (constrain) {
myWidth = me.getWidth();
myHeight = me.getHeight();
alignToElRegion = alignToEl.getRegion();
// If we are at a viewport boundary and the aligned el is anchored
// on a target border that is perpendicular to the vp border,
// allow the aligned el to slide on that border, otherwise swap
// the aligned el to the opposite border of the target.
p1y = align1.charAt(0);
p1x = align1.charAt(align1.length - 1);
p2y = align2.charAt(0);
p2x = align2.charAt(align2.length - 1);
swapY = ((p1y == "t" && p2y == "b") || (p1y == "b" && p2y == "t"));
swapX = ((p1x == "r" && p2x == "l") || (p1x == "l" && p2x == "r"));
if (x + myWidth > viewportWidth + scrollX) {
x = swapX ? alignToElRegion.left - myWidth : viewportWidth + scrollX - myWidth;
}
if (x < scrollX) {
x = swapX ? alignToElRegion.right : scrollX;
}
if (y + myHeight > viewportHeight + scrollY) {
y = swapY ? alignToElRegion.top - myHeight : viewportHeight + scrollY - myHeight;
}
if (y < scrollY) {
y = swapY ? alignToElRegion.bottom : scrollY;
}
}
return [x,y];
},
// private
getAnchor: function(){
var el = this.el,
data = (el.$cache || el.getCache()).data,
anchor;

if (!el.dom) {
return;
}
anchor = data._anchor;
if(!anchor){
anchor = data._anchor = {};
}
return anchor;
},

getAnchorXY: function(anchor, local, mySize) {
var me = this,
myPos = me.getXY(),
el = me.el,
doc = document,
isViewport = el.dom == doc.body || el.dom == doc,
scroll = el.getScroll(),
extraX = isViewport ? scroll.left : local ? 0 : myPos[0],
extraY = isViewport ? scroll.top : local ? 0 : myPos[1];
return me.calculateAnchorXY(anchor, extraX, extraY, mySize);
},

getBox: function(contentBox, local) {
var me = this,
xy = local ? me.getLocalXY() : me.getXY(),
x = xy[0],
y = xy[1],
w = me.getWidth(),
h = me.getHeight(),
borderPadding, beforeX, beforeY;
if (contentBox) {
borderPadding = me.getBorderPadding();
beforeX = borderPadding.beforeX;
beforeY = borderPadding.beforeY;
x += beforeX;
y += beforeY;
w -= (beforeX + borderPadding.afterX);
h -= (beforeY + borderPadding.afterY);
}
return {
x: x,
left: x,
0: x,
y: y,
top: y,
1: y,
width: w,
height: h,
right: x + w,
bottom: y + h
};
},

calculateConstrainedPosition: function(constrainTo, proposedPosition, local, proposedSize) {
var me = this,
vector,
fp = me.floatParent,
parentNode = fp ? fp.getTargetEl() : null,
parentOffset,
borderPadding,
proposedConstrainPosition,
xy = false;
if (local && fp) {
parentOffset = parentNode.getXY();
borderPadding = parentNode.getBorderPadding();
parentOffset[0] += borderPadding.beforeX;
parentOffset[1] += borderPadding.beforeY;
if (proposedPosition) {
proposedConstrainPosition = [proposedPosition[0] + parentOffset[0], proposedPosition[1] + parentOffset[1]];
}
} else {
proposedConstrainPosition = proposedPosition;
}
// Calculate the constrain vector to coerce our position to within our
// constrainTo setting. getConstrainVector will provide a default constraint
// region if there is no explicit constrainTo, *and* there is no floatParent owner Component.
constrainTo = constrainTo || me.constrainTo || parentNode || me.container || me.el.parent();
vector = (me.constrainHeader ? me.header : me).getConstrainVector(constrainTo, proposedConstrainPosition, proposedSize);
// false is returned if no movement is needed
if (vector) {
xy = proposedPosition || me.getPosition(local);
xy[0] += vector[0];
xy[1] += vector[1];
}
return xy;
},

getConstrainVector: function(constrainTo, proposedPosition, proposedSize) {
var thisRegion = this.getRegion(),
vector = [0, 0],
shadowSize = (this.shadow && this.constrainShadow && !this.shadowDisabled) ? this.shadow.getShadowSize() : undefined,
overflowed = false,
constraintInsets = this.constraintInsets;
if (!(constrainTo instanceof Ext.util.Region)) {
constrainTo = Ext.get(constrainTo.el || constrainTo).getViewRegion();
}
// Apply constraintInsets
if (constraintInsets) {
constraintInsets = Ext.isObject(constraintInsets) ? constraintInsets : Ext.Element.parseBox(constraintInsets);
constrainTo.adjust(constraintInsets.top, constraintInsets.right, constraintInsets.bottom, constraintInsets.length);
}
// Shift this region to occupy the proposed position
if (proposedPosition) {
thisRegion.translateBy(proposedPosition[0] - thisRegion.x, proposedPosition[1] - thisRegion.y);
}
// Set the size of this region to the proposed size
if (proposedSize) {
thisRegion.right = thisRegion.left + proposedSize[0];
thisRegion.bottom = thisRegion.top + proposedSize[1];
}
// Reduce the constrain region to allow for shadow
if (shadowSize) {
constrainTo.adjust(shadowSize[0], -shadowSize[1], -shadowSize[2], shadowSize[3]);
}
// Constrain the X coordinate by however much this Element overflows
if (thisRegion.right > constrainTo.right) {
overflowed = true;
vector[0] = (constrainTo.right - thisRegion.right); // overflowed the right
}
if (thisRegion.left + vector[0] < constrainTo.left) {
overflowed = true;
vector[0] = (constrainTo.left - thisRegion.left); // overflowed the left
}
// Constrain the Y coordinate by however much this Element overflows
if (thisRegion.bottom > constrainTo.bottom) {
overflowed = true;
vector[1] = (constrainTo.bottom - thisRegion.bottom); // overflowed the bottom
}
if (thisRegion.top + vector[1] < constrainTo.top) {
overflowed = true;
vector[1] = (constrainTo.top - thisRegion.top); // overflowed the top
}
return overflowed ? vector : false;
},

getOffsetsTo: function(offsetsTo) {
var o = this.getXY(),
e = Ext.fly(offsetsTo.el || offsetsTo, '_internal').getXY();
return [o[0] - e[0],o[1] - e[1]];
},

getRegion: function() {
var box = this.getBox();
return new Ext.util.Region(box.top, box.right, box.bottom, box.left);
},

getViewRegion: function() {
var me = this,
el = me.el,
isBody = el.dom.nodeName === 'BODY',
borderPadding, scroll, pos, top, left, width, height;
// For the body we want to do some special logic
if (isBody) {
scroll = el.getScroll();
left = scroll.left;
top = scroll.top;
width = Ext.dom.AbstractElement.getViewportWidth();
height = Ext.dom.AbstractElement.getViewportHeight();
}
else {
borderPadding = me.getBorderPadding();
pos = me.getXY();
left = pos[0] + borderPadding.beforeX;
top = pos[1] + borderPadding.beforeY;
width = me.getWidth(true);
height = me.getHeight(true);
}
return new Ext.util.Region(top, left + width, top + height, left);
},

move: function(direction, distance, animate) {
var me = this,
xy = me.getXY(),
x = xy[0],
y = xy[1],
left = [x - distance, y],
right = [x + distance, y],
top = [x, y - distance],
bottom = [x, y + distance],
hash = {
l: left,
left: left,
r: right,
right: right,
t: top,
top: top,
up: top,
b: bottom,
bottom: bottom,
down: bottom
};
direction = direction.toLowerCase();
me.setXY([hash[direction][0], hash[direction][1]], animate);
},

removeAnchor: function() {
var anchor = this.getAnchor();
if (anchor && anchor.fn) {
Ext.EventManager.removeResizeListener(anchor.fn);
if (anchor.scroll) {
Ext.EventManager.un(window, 'scroll', anchor.fn);
}
delete anchor.fn;
}
return this;
},

setBox: function(box, animate) {
var me = this,
el = me.el,
x = box.x,
y = box.y,
xy = [x, y],
w = box.width,
h = box.height,
doConstrain = (me.constrain || me.constrainHeader),
constrainedPos = doConstrain && me.calculateConstrainedPosition(null, [x, y], false, [w, h]);
// Position to the contrained
if (constrainedPos) {
x = constrainedPos[0];
y = constrainedPos[1];
}
if (!animate || !el.anim) {
me.setSize(w, h);
me.setXY([x, y]);
me.afterSetPosition(x, y);
} else {
me.animate(Ext.applyIf({
to: {
x: x,
y: y,
width: el.adjustWidth(w),
height: el.adjustHeight(h)
},
listeners: {
afteranimate: Ext.Function.bind(me.afterSetPosition, me, [x, y])
}
}, animate));
}
return me;
},

setRegion: function(region, animate) {
return this.setBox({
x: region.left,
y: region.top,
width: region.right - region.left,
height: region.bottom - region.top
}, animate);
},

translatePoints: function(x, y) {
var pos = this.translateXY(x, y);
return {
left: pos.x,
top: pos.y
};
},

translateXY: function(x, y) {
var me = this,
el = me.el,
styles = el.getStyle(me._positionTopLeft),
relative = styles.position == 'relative',
left = parseFloat(styles.left),
top = parseFloat(styles.top),
xy = me.getXY();
if (Ext.isArray(x)) {
y = x[1];
x = x[0];
}
if (isNaN(left)) {
left = relative ? 0 : el.dom.offsetLeft;
}
if (isNaN(top)) {
top = relative ? 0 : el.dom.offsetTop;
}
left = (typeof x == 'number') ? x - xy[0] + left : undefined;
top = (typeof y == 'number') ? y - xy[1] + top : undefined;
return {
x: left,
y: top
};
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/dom/Element.js */
(function(Ext) {
// @tag dom,core
Ext.define('Ext.dom.Element', function(Element) {
var HIDDEN = 'hidden',
DOC = document,
VISIBILITY = "visibility",
DISPLAY = "display",
NONE = "none",
XMASKED = Ext.baseCSSPrefix + "masked",
XMASKEDRELATIVE = Ext.baseCSSPrefix + "masked-relative",
EXTELMASKMSG = Ext.baseCSSPrefix + "mask-msg",
bodyRe = /^body/i,
visFly,
// speedy lookup for elements never to box adjust
noBoxAdjust = Ext.isStrict ? {
select: 1
}: {
input: 1,
select: 1,
textarea: 1
},
// Pseudo for use by cacheScrollValues
isScrolled = function(c) {
var r = [], ri = -1,
i, ci;
for (i = 0; ci = c[i]; i++) {
if (ci.scrollTop > 0 || ci.scrollLeft > 0) {
r[++ri] = ci;
}
}
return r;
};
return {
extend: 'Ext.dom.AbstractElement',
alternateClassName: ['Ext.Element', 'Ext.core.Element'],
requires: [
'Ext.dom.Query',
'Ext.dom.Element_anim',
'Ext.dom.Element_dd',
'Ext.dom.Element_fx',
'Ext.dom.Element_position',
'Ext.dom.Element_scroll',
'Ext.dom.Element_style'
],

tableTagRe: /^(?:tr|td|table|tbody)$/i,
mixins: [
'Ext.util.Positionable'
],
addUnits: function() {
return Element.addUnits.apply(Element, arguments);
},

focus: function(defer, dom) {
var me = this;
dom = dom || me.dom;
try {
if (Number(defer)) {
Ext.defer(me.focus, defer, me, [null, dom]);
} else {
dom.focus();
}
} catch(e) {
}
return me;
},

blur: function() {
var me = this,
dom = me.dom;
// In IE, blurring the body can cause the browser window to hide.
// Blurring the body is redundant, so instead we just focus it
if (dom !== document.body) {
try {
dom.blur();
} catch(e) {
}
return me;
} else {
return me.focus(undefined, dom);
}
},

isBorderBox: function() {
var box = Ext.isBorderBox;

// IE6/7 force input elements to content-box even if border-box is set explicitly
if (box && Ext.isIE7m) {
box = !((this.dom.tagName || "").toLowerCase() in noBoxAdjust);
}
return box;
},

hover: function(overFn, outFn, scope, options) {
var me = this;
me.on('mouseenter', overFn, scope || me.dom, options);
me.on('mouseleave', outFn, scope || me.dom, options);
return me;
},

getAttributeNS: function(ns, name) {
return this.getAttribute(name, ns);
},
getAttribute: (Ext.isIE && !(Ext.isIE9p && DOC.documentMode >= 9)) ?
// Essentially all web browsers (Firefox, Internet Explorer, recent versions of Opera, Safari, Konqueror, and iCab,
// as a non-exhaustive list) return null when the specified attribute does not exist on the specified element.
// The DOM specification says that the correct return value in this case is actually the empty string, and some
// DOM implementations implement this behavior. The implementation of getAttribute in XUL (Gecko) actually follows
// the specification and returns an empty string. Consequently, you should use hasAttribute to check for an attribute's
// existence prior to calling getAttribute() if it is possible that the requested attribute does not exist on the specified element.
//
// https://developer.mozilla.org/en-US/docs/DOM/element.getAttribute
// http://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-745549614
function(name, ns) {
var d = this.dom,
type;
if (ns) {
type = typeof d[ns + ":" + name];
if (type != 'undefined' && type != 'unknown') {
return d[ns + ":" + name] || null;
}
return null;
}
if (name === "for") {
name = "htmlFor";
}
return d[name] || null;
} : function(name, ns) {
var d = this.dom;
if (ns) {
return d.getAttributeNS(ns, name) || d.getAttribute(ns + ":" + name);
}
return d.getAttribute(name) || d[name] || null;
},

cacheScrollValues: function() {
var me = this,
scrolledDescendants,
el, i,
scrollValues = [],
result = function() {
for (i = 0; i < scrolledDescendants.length; i++) {
el = scrolledDescendants[i];
el.scrollLeft = scrollValues[i][0];
el.scrollTop = scrollValues[i][1];
}
};
if (!Ext.DomQuery.pseudos.isScrolled) {
Ext.DomQuery.pseudos.isScrolled = isScrolled;
}
scrolledDescendants = me.query(':isScrolled');
for (i = 0; i < scrolledDescendants.length; i++) {
el = scrolledDescendants[i];
scrollValues[i] = [el.scrollLeft, el.scrollTop];
}
return result;
},

autoBoxAdjust: true,

isVisible : function(deep) {
var me = this,
dom = me.dom,
stopNode = dom.ownerDocument.documentElement;
if (!visFly) {
visFly = new Element.Fly();
}
while (dom !== stopNode) {
// We're invisible if we hit a nonexistent parentNode or a document
// fragment or computed style visibility:hidden or display:none
if (!dom || dom.nodeType === 11 || (visFly.attach(dom)).isStyle(VISIBILITY, HIDDEN) || visFly.isStyle(DISPLAY, NONE)) {
return false;
}
// Quit now unless we are being asked to check parent nodes.
if (!deep) {
break;
}
dom = dom.parentNode;
}
return true;
},

isDisplayed : function() {
return !this.isStyle(DISPLAY, NONE);
},

enableDisplayMode : function(display) {
var me = this;
me.setVisibilityMode(Element.DISPLAY);
if (!Ext.isEmpty(display)) {
(me.$cache || me.getCache()).data.originalDisplay = display;
}
return me;
},

mask : function(msg, msgCls , elHeight) {
var me = this,
dom = me.dom,
// In some cases, setExpression will exist but not be of a function type,
// so we check it explicitly here to stop IE throwing errors
setExpression = dom.style.setExpression,
data = (me.$cache || me.getCache()).data,
maskShimEl = data.maskShimEl,
maskEl = data.maskEl,
maskMsg = data.maskMsg,
widthExpression, heightExpression;
if (!(bodyRe.test(dom.tagName) && me.getStyle('position') == 'static')) {
me.addCls(XMASKEDRELATIVE);
}
// We always needs to recreate the mask since the DOM element may have been re-created
if (maskEl) {
maskEl.remove();
}
if (maskMsg) {
maskMsg.remove();
}
if (maskShimEl) {
maskShimEl.remove();
}
if (Ext.isIE6) {
maskShimEl = Ext.DomHelper.append(dom, {
tag: 'iframe',
cls : Ext.baseCSSPrefix + 'shim ' + Ext.baseCSSPrefix + 'mask-shim'
}, true);
data.maskShimEl = maskShimEl;
maskShimEl.setDisplayed(true);
}
Ext.DomHelper.append(dom, [{
cls : Ext.baseCSSPrefix + "mask",
style: 'top:0;left:0;'
}, {
cls : msgCls ? EXTELMASKMSG + " " + msgCls : EXTELMASKMSG,
cn : {
tag: 'div',
cls: Ext.baseCSSPrefix + 'mask-msg-inner',
cn: {
tag: 'div',
cls: Ext.baseCSSPrefix + 'mask-msg-text',
html: msg || ''
}
}
}]);
maskMsg = Ext.get(dom.lastChild);
maskEl = Ext.get(maskMsg.dom.previousSibling);
data.maskMsg = maskMsg;
data.maskEl = maskEl;
me.addCls(XMASKED);
maskEl.setDisplayed(true);
if (typeof msg == 'string') {
maskMsg.setDisplayed(true);
maskMsg.center(me);
} else {
maskMsg.setDisplayed(false);
}
// NOTE: CSS expressions are resource intensive and to be used only as a last resort
// These expressions are removed as soon as they are no longer necessary - in the unmask method.
// In normal use cases an element will be masked for a limited period of time.
// Fix for https://sencha.jira.com/browse/EXTJSIV-19.
// IE6 strict mode and IE6-9 quirks mode takes off left+right padding when calculating width!
if (!Ext.supports.IncludePaddingInWidthCalculation && setExpression) {
// In an occasional case setExpression will throw an exception
try {
maskEl.dom.style.setExpression('width', 'this.parentNode.clientWidth + "px"');
widthExpression = 'this.parentNode.clientWidth + "px"';
if (maskShimEl) {
maskShimEl.dom.style.setExpression('width', widthExpression);
}
maskEl.dom.style.setExpression('width', widthExpression);
} catch (e) {}
}
// Some versions and modes of IE subtract top+bottom padding when calculating height.
// Different versions from those which make the same error for width!
if (!Ext.supports.IncludePaddingInHeightCalculation && setExpression) {
// In an occasional case setExpression will throw an exception
try {
heightExpression = 'this.parentNode.' + (dom == DOC.body ? 'scrollHeight' : 'offsetHeight') + ' + "px"';
if (maskShimEl) {
maskShimEl.dom.style.setExpression('height', heightExpression);
}
maskEl.dom.style.setExpression('height', heightExpression);
} catch (e) {}
}
// ie will not expand full height automatically
else if (Ext.isIE9m && !(Ext.isIE7 && Ext.isStrict) && me.getStyle('height') == 'auto') {
if (maskShimEl) {
maskShimEl.setSize(undefined, elHeight || me.getHeight());
}
maskEl.setSize(undefined, elHeight || me.getHeight());
}
return maskEl;
},

unmask : function() {
var me = this,
data = (me.$cache || me.getCache()).data,
maskEl = data.maskEl,
maskShimEl = data.maskShimEl,
maskMsg = data.maskMsg,
style;
if (maskEl) {
style = maskEl.dom.style;
// Remove resource-intensive CSS expressions as soon as they are not required.
if (style.clearExpression) {
style.clearExpression('width');
style.clearExpression('height');
}
if (maskEl) {
maskEl.remove();
delete data.maskEl;
}
if (maskMsg) {
maskMsg.remove();
delete data.maskMsg;
}
me.removeCls([XMASKED, XMASKEDRELATIVE]);
if (maskShimEl) {
style = maskShimEl.dom.style;
// Remove resource-intensive CSS expressions as soon as they are not required.
if (style.clearExpression) {
style.clearExpression('width');
style.clearExpression('height');
}
maskShimEl.remove();
delete data.maskShimEl;
}
}
},

isMasked : function() {
var me = this,
data = (me.$cache || me.getCache()).data,
maskEl = data.maskEl,
maskMsg = data.maskMsg,
hasMask = false; 
if (maskEl && maskEl.isVisible()) {
if (maskMsg) {
maskMsg.center(me);
}
hasMask = true;
}
return hasMask;
},

createShim : function() {
var el = DOC.createElement('iframe'),
shim;
el.frameBorder = '0';
el.className = Ext.baseCSSPrefix + 'shim';
el.src = Ext.SSL_SECURE_URL;
shim = Ext.get(this.dom.parentNode.insertBefore(el, this.dom));
shim.autoBoxAdjust = false;
return shim;
},

addKeyListener : function(key, fn, scope){
var config;
if(typeof key != 'object' || Ext.isArray(key)){
config = {
target: this,
key: key,
fn: fn,
scope: scope
};
}else{
config = {
target: this,
key : key.key,
shift : key.shift,
ctrl : key.ctrl,
alt : key.alt,
fn: fn,
scope: scope
};
}
return new Ext.util.KeyMap(config);
},

addKeyMap : function(config) {
return new Ext.util.KeyMap(Ext.apply({
target: this
}, config));
},
// Mouse events










// Keyboard events



// HTML frame/object events






// Form events






// User Interface events



// DOM Mutation events








on: function(eventName, fn, scope, options) {
Ext.EventManager.on(this, eventName, fn, scope || this, options);
return this;
},

un: function(eventName, fn, scope) {
Ext.EventManager.un(this, eventName, fn, scope || this);
return this;
},

removeAllListeners: function() {
Ext.EventManager.removeAll(this);
return this;
},

purgeAllListeners: function() {
Ext.EventManager.purgeElement(this);
return this;
},
select: function(selector) {
return Element.select(selector, false, this.dom);
}
};
}, function() {
var DOC = document,
EC = Ext.cache,
Element = this,
AbstractElement = Ext.dom.AbstractElement,
focusRe = /^a|button|embed|iframe|input|object|select|textarea$/i,
nonSpaceRe = /\S/,
scriptTagRe = /(?:<script([^>]*)?>)((\n|\r|.)*?)(?:<\/script>)/ig,
replaceScriptTagRe = /(?:<script.*?>)((\n|\r|.)*?)(?:<\/script>)/ig,
srcRe = /\ssrc=([\'\"])(.*?)\1/i,
typeRe = /\stype=([\'\"])(.*?)\1/i,
useDocForId = !Ext.isIE8m,
internalFly;
Element.boxMarkup = '<div class="{0}-tl"><div class="{0}-tr"><div class="{0}-tc"></div></div></div><div class="{0}-ml"><div class="{0}-mr"><div class="{0}-mc"></div></div></div><div class="{0}-bl"><div class="{0}-br"><div class="{0}-bc"></div></div></div>';
//</!if>
// private
// Garbage collection - uncache elements/purge listeners on orphaned elements
// so we don't hold a reference and cause the browser to retain them
function garbageCollect() {
if (!Ext.enableGarbageCollector) {
clearInterval(Element.collectorThreadId);
} else {
var eid,
d,
o,
t;
for (eid in EC) {
if (!EC.hasOwnProperty(eid)) {
continue;
}
o = EC[eid];
// Skip document and window elements
if (o.skipGarbageCollection) {
continue;
}
d = o.dom;
//<debug>
// Should always have a DOM node
if (!d) {
Ext.Error.raise('Missing DOM node in element garbage collection: ' + eid);
}
// Check that document and window elements haven't got through
if (d && (d.getElementById || d.navigator)) {
Ext.Error.raise('Unexpected document or window element in element garbage collection');
}
//</debug>
// -------------------------------------------------------
// Determining what is garbage:
// -------------------------------------------------------
// !d.parentNode
// no parentNode == direct orphan, definitely garbage
// -------------------------------------------------------
// !d.offsetParent && !document.getElementById(eid)
// display none elements have no offsetParent so we will
// also try to look it up by it's id. However, check
// offsetParent first so we don't do unneeded lookups.
// This enables collection of elements that are not orphans
// directly, but somewhere up the line they have an orphan
// parent.
// -------------------------------------------------------
if (d && (!d.parentNode || (!d.offsetParent && !Ext.getElementById(eid)))) {
if (Ext.enableListenerCollection) {
Ext.EventManager.removeAll(d);
}
delete EC[eid];
}
}
// Cleanup IE Object leaks
if (Ext.isIE) {
t = {};
for (eid in EC) {
if (!EC.hasOwnProperty(eid)) {
continue;
}
t[eid] = EC[eid];
}
EC = Ext.cache = t;
}
}
}
Element.collectorThreadId = setInterval(garbageCollect, 30000);
//Stuff from Element-more.js
Element.addMethods({

monitorMouseLeave: function(delay, handler, scope) {
var me = this,
timer,
listeners = {
mouseleave: function(e) {
timer = setTimeout(Ext.Function.bind(handler, scope||me, [e]), delay);
},
mouseenter: function() {
clearTimeout(timer);
},
freezeEvent: true
};
me.on(listeners);
return listeners;
},

swallowEvent : function(eventName, preventDefault) {
var me = this,
e, eLen,
fn = function(e) {
e.stopPropagation();
if (preventDefault) {
e.preventDefault();
}
};
if (Ext.isArray(eventName)) {
eLen = eventName.length;
for (e = 0; e < eLen; e++) {
me.on(eventName[e], fn);
}
return me;
}
me.on(eventName, fn);
return me;
},

relayEvent : function(eventName, observable) {
this.on(eventName, function(e) {
observable.fireEvent(eventName, e);
});
},

clean : function(forceReclean) {
var me = this,
dom = me.dom,
data = (me.$cache || me.getCache()).data,
n = dom.firstChild,
ni = -1,
nx;
if (data.isCleaned && forceReclean !== true) {
return me;
}
while (n) {
nx = n.nextSibling;
if (n.nodeType == 3) {
// Remove empty/whitespace text nodes
if (!(nonSpaceRe.test(n.nodeValue))) {
dom.removeChild(n);
// Combine adjacent text nodes
} else if (nx && nx.nodeType == 3) {
n.appendData(Ext.String.trim(nx.data));
dom.removeChild(nx);
nx = n.nextSibling;
n.nodeIndex = ++ni;
}
} else {
// Recursively clean
internalFly.attach(n).clean();
n.nodeIndex = ++ni;
}
n = nx;
}
data.isCleaned = true;
return me;
},

load : function(options) {
this.getLoader().load(options);
return this;
},

getLoader : function() {
var me = this,
data = (me.$cache || me.getCache()).data,
loader = data.loader;
if (!loader) {
data.loader = loader = new Ext.ElementLoader({
target: me
});
}
return loader;
},

syncContent: function(source) {
source = Ext.getDom(source);
var sourceNodes = source.childNodes,
sourceLen = sourceNodes.length,
dest = this.dom,
destNodes = dest.childNodes,
destLen = destNodes.length,
i, destNode, sourceNode,
nodeType, newAttrs, attLen, attName;
// Copy top node's attributes across. Use IE-specific method if possible.
// In IE10, there is a problem where the className will not get updated
// in the view, even though the className on the dom element is correct.
// See EXTJSIV-9462
if (Ext.isIE9m && dest.mergeAttributes) {
dest.mergeAttributes(source, true);
// EXTJSIV-6803. IE's mergeAttributes appears not to make the source's "src" value available until after the image is ready.
// So programatically copy any src attribute.
dest.src = source.src;
} else {
newAttrs = source.attributes;
attLen = newAttrs.length;
for (i = 0; i < attLen; i++) {
attName = newAttrs[i].name;
if (attName !== 'id') {
dest.setAttribute(attName, newAttrs[i].value);
}
}
}
// If the number of child nodes does not match, fall back to replacing innerHTML
if (sourceLen !== destLen) {
dest.innerHTML = source.innerHTML;
return;
}
// Loop through source nodes.
// If there are fewer, we must remove excess
for (i = 0; i < sourceLen; i++) {
sourceNode = sourceNodes[i];
destNode = destNodes[i];
nodeType = sourceNode.nodeType;
// If node structure is out of sync, just drop innerHTML in and return
if (nodeType !== destNode.nodeType || (nodeType === 1 && sourceNode.tagName !== destNode.tagName)) {
dest.innerHTML = source.innerHTML;
return;
}
// Update text node
if (nodeType === 3) {
destNode.data = sourceNode.data;
}
// Sync element content
else {
if (sourceNode.id && destNode.id !== sourceNode.id) {
destNode.id = sourceNode.id;
}
destNode.style.cssText = sourceNode.style.cssText;
destNode.className = sourceNode.className;
internalFly.attach(destNode).syncContent(sourceNode);
}
}
},

update : function(html, loadScripts, callback) {
var me = this,
id,
dom,
interval;
if (!me.dom) {
return me;
}
html = html || '';
dom = me.dom;
if (loadScripts !== true) {
dom.innerHTML = html;
Ext.callback(callback, me);
return me;
}
id = Ext.id();
html += '<span id="' + id + '"></span>';
interval = setInterval(function() {
var hd,
match,
attrs,
srcMatch,
typeMatch,
el,
s;
if (!(el = DOC.getElementById(id))) {
return false;
}
clearInterval(interval);
Ext.removeNode(el);
hd = Ext.getHead().dom;
while ((match = scriptTagRe.exec(html))) {
attrs = match[1];
srcMatch = attrs ? attrs.match(srcRe) : false;
if (srcMatch && srcMatch[2]) {
s = DOC.createElement("script");
s.src = srcMatch[2];
typeMatch = attrs.match(typeRe);
if (typeMatch && typeMatch[2]) {
s.type = typeMatch[2];
}
hd.appendChild(s);
} else if (match[2] && match[2].length > 0) {
if (window.execScript) {
window.execScript(match[2]);
} else {
window.eval(match[2]);
}
}
}
Ext.callback(callback, me);
}, 20);
dom.innerHTML = html.replace(replaceScriptTagRe, '');
return me;
},
// inherit docs, overridden so we can add removeAnchor
removeAllListeners : function() {
this.removeAnchor();
Ext.EventManager.removeAll(this.dom);
return this;
},

createProxy : function(config, renderTo, matchBox) {
config = (typeof config == 'object') ? config : {tag : "div", cls: config};
var me = this,
proxy = renderTo ? Ext.DomHelper.append(renderTo, config, true) :
Ext.DomHelper.insertBefore(me.dom, config, true);
proxy.setVisibilityMode(Element.DISPLAY);
proxy.hide();
if (matchBox && me.setBox && me.getBox) { // check to make sure Element.position.js is loaded
proxy.setBox(me.getBox());
}
return proxy;
},


needsTabIndex: function() {
if (this.dom) {
if ((this.dom.nodeName === 'a') && (!this.dom.href)) {
return true;
}
return !focusRe.test(this.dom.nodeName);
}
},

isFocusable: function ( asFocusEl) {
var dom = this.dom,
tabIndexAttr = dom.getAttributeNode('tabIndex'),
tabIndex,
nodeName = dom.nodeName,
canFocus = false;
// Certain browsers always report zero in the absence of the tabIndex attribute.
// Testing the specified property (Standards: http://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-862529273)
// Should filter out these cases.
// The exceptions are IE6 to IE8. In these browsers all elements will yield a tabIndex
// and therefore all elements will appear to be focusable.
// This adversely affects modal Floating components.
// These listen for the TAB key, and then test whether the event target === last focusable
// or first focusable element, and forcibly to a circular navigation.
// We cannot know the true first or last focusable element, so this problem still exists for IE6,7,8
// See Ext.util.Floating
if (tabIndexAttr && tabIndexAttr.specified) {
tabIndex = tabIndexAttr.value;
}
if (dom && !dom.disabled) {
// A tabIndex of -1 means it has to be programatically focused, so that needs FocusManager,
// and it has to be the focus holding el of a Component within the Component tree.
if (tabIndex == -1) { // note that the value is a string
canFocus = Ext.FocusManager && Ext.FocusManager.enabled && asFocusEl;
}
else {
// See if it's a naturally focusable element
if (focusRe.test(nodeName)) {
if ((nodeName !== 'a') || dom.href) {
canFocus = true;
}
}
// A non naturally focusable element is in the navigation flow if it has a positive numeric tab index.
else {
canFocus = tabIndex != null && tabIndex >= 0;
}
}
canFocus = canFocus && this.isVisible(true);
}
return canFocus;
}
});
if (Ext.isIE) {
Element.prototype.getById = function (id, asDom) {
var dom = this.dom,
cacheItem, el, ret;
if (dom) {
// for normal elements getElementById is the best solution, but if the el is
// not part of the document.body, we need to use all[]
el = (useDocForId && DOC.getElementById(id)) || dom.all[id];
if (el) {
if (asDom) {
ret = el;
} else {
// calling Element.get here is a real hit (2x slower) because it has to
// redetermine that we are giving it a dom el.
cacheItem = EC[id];
if (cacheItem && cacheItem.el) {
ret = Ext.updateCacheEntry(cacheItem, el).el;
} else {
ret = new Element(el);
}
}
return ret;
}
}
return asDom ? Ext.getDom(id) : Element.get(id);
};
}
Element.createAlias({

addListener: 'on',

removeListener: 'un',

clearListeners: 'removeAllListeners',

focusable: 'isFocusable'
});
Element.Fly = AbstractElement.Fly = new Ext.Class({
extend: Element,
isFly: true,
constructor: function(dom) {
this.dom = dom;
// set an "el" property that references "this". This allows
// Ext.util.Positionable methods to operate on this.el.dom since it
// gets mixed into both Element and Component
this.el = this;
},

attach: AbstractElement.Fly.prototype.attach
});

internalFly = new Element.Fly();
if (Ext.isIE) {
Ext.getElementById = function (id) {
var el = DOC.getElementById(id),
detachedBodyEl;
if (!el && (detachedBodyEl = AbstractElement.detachedBodyEl)) {
el = detachedBodyEl.dom.all[id];
}
return el;
};
} else if (!DOC.querySelector) {
Ext.getDetachedBody = Ext.getBody;
Ext.getElementById = function (id) {
return DOC.getElementById(id);
};
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/dom/CompositeElementLite.js */
(function(Ext) {
// @tag dom,core
Ext.define('Ext.dom.CompositeElementLite', {
alternateClassName: 'Ext.CompositeElementLite',
requires: ['Ext.dom.Element', 'Ext.dom.Query'],
statics: {

importElementMethods: function() {
var name,
elementPrototype = Ext.dom.Element.prototype,
prototype = this.prototype;
for (name in elementPrototype) {
if (typeof elementPrototype[name] == 'function'){
(function(key) {
prototype[key] = prototype[key] || function() {
return this.invoke(key, arguments);
};
}).call(prototype, name);
}
}
}
},
constructor: function(elements, root) {

this.elements = [];
this.add(elements, root);
this.el = new Ext.dom.AbstractElement.Fly();
},

isComposite: true,
// private
getElement: function(el) {
// Set the shared flyweight dom property to the current element
return this.el.attach(el);
},
// private
transformElement: function(el) {
return Ext.getDom(el);
},

getCount: function() {
return this.elements.length;
},

add: function(els, root) {
var elements = this.elements,
i, ln;
if (!els) {
return this;
}
if (typeof els == "string") {
els = Ext.dom.Element.selectorFunction(els, root);
}
else if (els.isComposite) {
els = els.elements;
}
else if (!Ext.isIterable(els)) {
els = [els];
}
for (i = 0, ln = els.length; i < ln; ++i) {
elements.push(this.transformElement(els[i]));
}
return this;
},
invoke: function(fn, args) {
var elements = this.elements,
ln = elements.length,
element,
i;
fn = Ext.dom.Element.prototype[fn];
for (i = 0; i < ln; i++) {
element = elements[i];
if (element) {
fn.apply(this.getElement(element), args);
}
}
return this;
},

item: function(index) {
var el = this.elements[index],
out = null;
if (el) {
out = this.getElement(el);
}
return out;
},

slice: function() {
return this.elements.slice.apply(this.elements, arguments);
},
// fixes scope with flyweight
addListener: function(eventName, handler, scope, opt) {
var els = this.elements,
len = els.length,
i, e;
for (i = 0; i < len; i++) {
e = els[i];
if (e) {
Ext.EventManager.on(e, eventName, handler, scope || e, opt);
}
}
return this;
},

each: function(fn, scope) {
var me = this,
els = me.elements,
len = els.length,
i, e;
for (i = 0; i < len; i++) {
e = els[i];
if (e) {
e = this.getElement(e);
if (fn.call(scope || e, e, me, i) === false) {
break;
}
}
}
return me;
},

fill: function(els) {
var me = this;
me.elements = [];
me.add(els);
return me;
},
insert: function(index, nodes) {
Ext.Array.insert(this.elements, index, nodes);
},

filter: function(selector) {
var me = this,
els = me.elements,
len = els.length,
out = [],
i = 0,
isFunc = typeof selector == 'function',
add,
el;
for (; i < len; i++) {
el = els[i];
add = false;
if (el) {
el = me.getElement(el);
if (isFunc) {
add = selector.call(el, el, me, i) !== false;
} else {
add = el.is(selector);
}

if (add) {
out.push(me.transformElement(el));
}
}
}
me.elements = out;
return me;
},

indexOf: function(el) {
return Ext.Array.indexOf(this.elements, this.transformElement(el));
},

replaceElement: function(el, replacement, domReplace) {
var index = !isNaN(el) ? el : this.indexOf(el),
d;
if (index > -1) {
replacement = Ext.getDom(replacement);
if (domReplace) {
d = this.elements[index];
d.parentNode.insertBefore(replacement, d);
Ext.removeNode(d);
}
Ext.Array.splice(this.elements, index, 1, replacement);
}
return this;
},

clear: function(removeDom) {
var me = this,
els = me.elements,
i = els.length - 1;

if (removeDom) {
for (; i >= 0; i--) {
Ext.removeNode(els[i]);
}
}
this.elements = [];
},
addElements: function(els, root) {
if (!els) {
return this;
}
if (typeof els == "string") {
els = Ext.dom.Element.selectorFunction(els, root);
}
var yels = this.elements,
eLen = els.length,
e;
for (e = 0; e < eLen; e++) {
yels.push(Ext.get(els[e]));
}
return this;
},

first: function() {
return this.item(0);
},

last: function() {
return this.item(this.getCount() - 1);
},

contains: function(el) {
return this.indexOf(el) != -1;
},

removeElement: function(keys, removeDom) {
keys = [].concat(keys);
var me = this,
elements = me.elements,
kLen = keys.length,
val, el, k;
for (k = 0; k < kLen; k++) {
val = keys[k];
if ((el = (elements[val] || elements[val = me.indexOf(val)]))) {
if (removeDom) {
if (el.dom) {
el.remove();
} else {
Ext.removeNode(el);
}
}
Ext.Array.erase(elements, val, 1);
}
}
return me;
}
}, function() {
this.importElementMethods();
this.prototype.on = this.prototype.addListener;
if (Ext.DomQuery){
Ext.dom.Element.selectorFunction = Ext.DomQuery.select;
}

Ext.dom.Element.select = function(selector, root) {
var elements;
if (typeof selector == "string") {
elements = Ext.dom.Element.selectorFunction(selector, root);
}
else if (selector.length !== undefined) {
elements = selector;
}
else {
//<debug>
throw new Error("[Ext.select] Invalid selector specified: " + selector);
//</debug>
}
return new Ext.CompositeElementLite(elements);
};

Ext.select = function() {
return Ext.dom.Element.select.apply(Ext.dom.Element, arguments);
};
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/dom/CompositeElement.js */
(function(Ext) {
// @tag dom,core
Ext.define('Ext.dom.CompositeElement', {
alternateClassName: 'Ext.CompositeElement',
extend: 'Ext.dom.CompositeElementLite',
// private
getElement: function(el) {
// In this case just return it, since we already have a reference to it
return el;
},
// private
transformElement: function(el) {
return Ext.get(el);
}
}, function() {

Ext.dom.Element.select = function(selector, unique, root) {
var elements;
if (typeof selector == "string") {
elements = Ext.dom.Element.selectorFunction(selector, root);
}
else if (selector.length !== undefined) {
elements = selector;
}
else {
//<debug>
throw new Error("[Ext.select] Invalid selector specified: " + selector);
//</debug>
}
return (unique === true) ? new Ext.CompositeElement(elements) : new Ext.CompositeElementLite(elements);
};
});
Ext.select = Ext.Element.select;
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/PluginManager.js */
(function(Ext) {
Ext.define('Ext.PluginManager', {
extend: 'Ext.AbstractManager',
alternateClassName: 'Ext.PluginMgr',
singleton: true,
typeName: 'ptype',

create : function(config, defaultType, host) {
var result;
if (config.init) {
result = config;
} else {
// Inject the host into the config is we know the host
if (host) {
config = Ext.apply({}, config); // copy since we are going to modify
config.cmp = host;
}
// Grab the host ref if it was configured in
else {
host = config.cmp;
}
if (config.xclass) {
result = Ext.create(config);
} else {
// Lookup the class from the ptype and instantiate unless its a singleton
result = Ext.ClassManager.getByAlias(('plugin.' + (config.ptype || defaultType)));
if (typeof result === 'function') {
result = new result(config);
}
}
}
// If we come out with a non-null plugin, ensure that any setCmp is called once.
if (result && host && result.setCmp && !result.setCmpCalled) {
result.setCmp(host);
result.setCmpCalled = true;
}
return result;
},

findByType: function(type, defaultsOnly) {
var matches = [],
types = this.types,
name,
item;
for (name in types) {
if (!types.hasOwnProperty(name)) {
continue;
}
item = types[name];
if (item.type == type && (!defaultsOnly || (defaultsOnly === true && item.isDefault))) {
matches.push(item);
}
}
return matches;
}
}, function() {

Ext.preg = function() {
return Ext.PluginManager.registerType.apply(Ext.PluginManager, arguments);
};
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/util/Filter.js */
(function(Ext) {
Ext.define('Ext.util.Filter', {




id: null,

anyMatch: false,

exactMatch: false,

caseSensitive: false,

disabled: false,

operator: null,

statics: {

createFilterFn: function(filters) {
return filters && filters.length ? function(candidate) {
var isMatch = true,
length = filters.length,
i, filter;
for (i = 0; isMatch && i < length; i++) {
filter = filters[i];
// Disabling a filter stops it from contributing to the overall filter function.
if (!filter.disabled) {
isMatch = isMatch && filter.filterFn.call(filter.scope || filter, candidate);
}
}
return isMatch;
} : function() {
return true;
};
}
},
operatorFns: {
"<": function(candidate) {
return Ext.coerce(this.getRoot(candidate)[this.property], this.value) < this.value;
},
"<=": function(candidate) {
return Ext.coerce(this.getRoot(candidate)[this.property], this.value) <= this.value;
},
"=": function(candidate) {
return Ext.coerce(this.getRoot(candidate)[this.property], this.value) == this.value;
},
">=": function(candidate) {
return Ext.coerce(this.getRoot(candidate)[this.property], this.value) >= this.value;
},
">": function(candidate) {
return Ext.coerce(this.getRoot(candidate)[this.property], this.value) > this.value;
},
"!=": function(candidate) {
return Ext.coerce(this.getRoot(candidate)[this.property], this.value) != this.value;
}
},

constructor: function(config) {
var me = this;
me.initialConfig = config;
Ext.apply(me, config);
//we're aliasing filter to filterFn mostly for API cleanliness reasons, despite the fact it dirties the code here.
//Ext.util.Sorter takes a sorterFn property but allows .sort to be called - we do the same here
me.filter = me.filter || me.filterFn;
if (me.filter === undefined) {
me.setValue(config.value);
}
},

setValue: function(value) {
var me = this;
me.value = value;
if (me.property === undefined || me.value === undefined) {
// Commented this out temporarily because it stops us using string ids in models. TODO: Remove this once
// Model has been updated to allow string ids
// Ext.Error.raise("A Filter requires either a property or a filterFn to be set");
} else {
me.filter = me.createFilterFn();
}
me.filterFn = me.filter;
},

setFilterFn: function(filterFn) {
this.filterFn = this.filter = filterFn;
},

createFilterFn: function() {
var me = this,
matcher = me.createValueMatcher(),
property = me.property;
if (me.operator) {
return me.operatorFns[me.operator];
} else {
return function(item) {
var value = me.getRoot(item)[property];
return matcher === null ? value === null : matcher.test(value);
};
}
},

getRoot: function(item) {
var root = this.root;
return root === undefined ? item : item[root];
},

createValueMatcher : function() {
var me = this,
value = me.value,
anyMatch = me.anyMatch,
exactMatch = me.exactMatch,
caseSensitive = me.caseSensitive,
escapeRe = Ext.String.escapeRegex;
if (value === null) {
return value;
}
if (!value.exec) { // not a regex
value = String(value);
if (anyMatch === true) {
value = escapeRe(value);
} else {
value = '^' + escapeRe(value);
if (exactMatch === true) {
value += '$';
}
}
value = new RegExp(value, caseSensitive ? '' : 'i');
}
return value;
},
serialize: function() {
var me = this,
result = Ext.apply({}, me.initialConfig);
result.value = me.value;
return result;
}
}, function() {
// Operator type '==' is the same as operator type '='
this.prototype.operatorFns['=='] = this.prototype.operatorFns['='];
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/util/AbstractMixedCollection.js */
(function(Ext) {
Ext.define('Ext.util.AbstractMixedCollection', {
requires: ['Ext.util.Filter'],
mixins: {
observable: 'Ext.util.Observable'
},

isMixedCollection: true,

generation: 0,


indexGeneration: 0,

constructor: function(allowFunctions, keyFn) {
var me = this;
// Modern constructor signature using a config object
if (arguments.length === 1 && Ext.isObject(allowFunctions)) {
me.initialConfig = allowFunctions;
Ext.apply(me, allowFunctions);
}
// Old constructor signature
else {
me.allowFunctions = allowFunctions === true;
if (keyFn) {
me.getKey = keyFn;
}
me.initialConfig = {
allowFunctions: me.allowFunctions,
getKey: me.getKey
};
}
me.items = [];
me.map = {};
me.keys = [];
me.indexMap = {};
me.length = 0;





me.mixins.observable.constructor.call(me);
},

allowFunctions : false,

add : function(key, obj) {
var len = this.length,
out;

if (arguments.length === 1) {
out = this.insert(len, key);
} else {
out = this.insert(len, key, obj);
}
return out;
},

getKey : function(o) {
return o.id;
},

replace : function(key, o) {
var me = this,
old,
index;
if (arguments.length == 1) {
o = arguments[0];
key = me.getKey(o);
}
old = me.map[key];
if (typeof key == 'undefined' || key === null || typeof old == 'undefined') {
return me.add(key, o);
}
me.generation++;
index = me.indexOfKey(key);
me.items[index] = o;
me.map[key] = o;
if (me.hasListeners.replace) {
me.fireEvent('replace', key, old, o);
}
return o;
},


updateKey: function(oldKey, newKey) {
var me = this,
map = me.map,
indexMap = me.indexMap,
index = me.indexOfKey(oldKey),
item;

if (index > -1) {
item = map[oldKey];
delete map[oldKey];
delete indexMap[oldKey];
map[newKey] = item;
indexMap[newKey] = index;
me.keys[index] = newKey;
me.generation++;

}
},

addAll : function(objs) {
var me = this,
key;
if (arguments.length > 1 || Ext.isArray(objs)) {
me.insert(me.length, arguments.length > 1 ? arguments : objs);
} else {
for (key in objs) {
if (objs.hasOwnProperty(key)) {
if (me.allowFunctions || typeof objs[key] != 'function') {
me.add(key, objs[key]);
}
}
}
}
},

each : function(fn, scope){
var items = Ext.Array.push([], this.items), // each safe for removal
i = 0,
len = items.length,
item;
for (; i < len; i++) {
item = items[i];
if (fn.call(scope || item, item, i, len) === false) {
break;
}
}
},

eachKey : function(fn, scope){
var keys = this.keys,
items = this.items,
i = 0,
len = keys.length;
for (; i < len; i++) {
fn.call(scope || window, keys[i], items[i], i, len);
}
},

findBy : function(fn, scope) {
var keys = this.keys,
items = this.items,
i = 0,
len = items.length;
for (; i < len; i++) {
if (fn.call(scope || window, items[i], keys[i])) {
return items[i];
}
}
return null;
},
//<deprecated since="0.99">

find : function() {
if (Ext.isDefined(Ext.global.console)) {
Ext.global.console.warn('Ext.util.MixedCollection: find has been deprecated. Use findBy instead.');
}
return this.findBy.apply(this, arguments);
},
//</deprecated>

insert : function(index, key, obj) {
var out;
if (Ext.isIterable(key)) {
out = this.doInsert(index, key, obj);
} else {
if (arguments.length > 2) {
out = this.doInsert(index, [key], [obj]);
} else {
out = this.doInsert(index, [key]);
}
out = out[0];
}
return out;
},

// Private multi insert implementation.
doInsert : function(index, keys, objects) {
var me = this,
itemKey,
removeIndex,
i, len = keys.length,
deDupedLen = len,
fireAdd = me.hasListeners.add,
syncIndices,
newKeys = {},
passedDuplicates,
oldKeys, oldObjects;
// External key(s) passed. We cannot reliably find an object's index using the key extraction fn.
// Set a flag for use by contains, indexOf and remove
if (objects != null) {
me.useLinearSearch = true;
}
// No external keys: calculate keys array if not passed
else {
objects = keys;
keys = new Array(len);
for (i = 0; i < len; i++) {
keys[i] = this.getKey(objects[i]);
}
}
// First, remove duplicates of the keys. If a removal point is less than insertion index, decr insertion index
me.suspendEvents();
for (i = 0; i < len; i++) {
itemKey = keys[i];
// Must use indexOf - map might be out of sync
removeIndex = me.indexOfKey(itemKey);
if (removeIndex !== -1) {
if (removeIndex < index) {
index--;
}
me.removeAt(removeIndex);
}
if (itemKey != null) {
// If a previous new item used this key, we will have to rebuild the input arrays from the newKeys map.
if (newKeys[itemKey] != null) {
passedDuplicates = true;
deDupedLen--;
}
newKeys[itemKey] = i;
}
}
me.resumeEvents();
// Duplicate keys were detected - rebuild the objects and keys arrays from the last values associated with each unique key
if (passedDuplicates) {
oldKeys = keys;
oldObjects = objects;
keys = new Array(deDupedLen);
objects = new Array(deDupedLen);
i = 0;
// Loop through unique key hash, properties of which point to last encountered index for that key.
// Rebuild deduped objects and keys arrays.
for (itemKey in newKeys) {
keys[i] = oldKeys[newKeys[itemKey]];
objects[i] = oldObjects[newKeys[itemKey]];
i++;
}
len = deDupedLen;
}
// If we are appending and the indices are in sync, its cheap to kep them that way
syncIndices = index === me.length && me.indexGeneration === me.generation;
// Insert the new items and new keys in at the insertion point
Ext.Array.insert(me.items, index, objects);
Ext.Array.insert(me.keys, index, keys);
me.length += len;
me.generation++;
if (syncIndices) {
me.indexGeneration = me.generation;
}
for (i = 0; i < len; i++, index++) {
itemKey = keys[i];
if (itemKey != null) {
me.map[itemKey] = objects[i];
// If the index is still in sync, keep it that way
if (syncIndices) {
me.indexMap[itemKey] = index;
}
}
if (fireAdd) {
me.fireEvent('add', index, objects[i], itemKey);
}
}
return objects;
},

remove : function(o) {
var me = this,
removeKey,
index;
// If
// We have not been forced into using linear lookup by a usage of the 2 arg form of add
// and
// The key extraction function yields a key
// Then use indexOfKey. This will use the indexMap - rebuilding it if necessary.
if (!me.useLinearSearch && (removeKey = me.getKey(o))) {
index = me.indexOfKey(removeKey);
}
// Otherwise we have to do it the slow way with a linear search.
else {
index = Ext.Array.indexOf(me.items, o);
}
return (index === -1) ? false : me.removeAt(index);
},

removeAll : function(items) {
var me = this, 
i;
if (items || me.hasListeners.remove) {
// Only perform expensive item-by-item removal if there's a listener or specific items
if (items) {
for (i = items.length - 1; i >= 0; --i) {
me.remove(items[i]);
}
} else {
while (me.length) {
me.removeAt(0);
}
}
} else {
me.length = me.items.length = me.keys.length = 0;
me.map = {};
me.indexMap = {};
me.generation++;
me.indexGeneration = me.generation;
}
},


removeAt : function(index) {
var me = this,
o,
key;
if (index < me.length && index >= 0) {
me.length--;
o = me.items[index];
Ext.Array.erase(me.items, index, 1);
key = me.keys[index];
if (typeof key != 'undefined') {
delete me.map[key];
}
Ext.Array.erase(me.keys, index, 1);
if (me.hasListeners.remove) {
me.fireEvent('remove', o, key);
}
me.generation++;
return o;
}
return false;
},

removeRange : function(index, removeCount) {
var me = this,
o,
key,
i,
limit,
syncIndices,
trimming;
if (index < me.length && index >= 0) {
if (!removeCount) {
removeCount = 1;
}
limit = Math.min(index + removeCount, me.length);
removeCount = limit - index;
// If we are removing from end and the indices are in sync, its cheap to kep them that way
trimming = limit === me.length;
syncIndices = trimming && me.indexGeneration === me.generation;
// Loop through the to remove indices deleting from the key hashes
for (i = index; i < limit; i++) {
key = me.keys[i];
if (key != null) {
delete me.map[key];
if (syncIndices) {
delete me.indexMap[key];
}
}
}
// Last item encountered
o = me.items[i - 1];

me.length -= removeCount;
me.generation++;
if (syncIndices) {
me.indexGeneration = me.generation;
}
// Chop items and keys arrays.
// If trimming the trailing end, we can just truncate the array.
// We can use splice directly. The IE8 bug which Ext.Array works around only affects *insertion*
// http://social.msdn.microsoft.com/Forums/en-US/iewebdevelopment/thread/6e946d03-e09f-4b22-a4dd-cd5e276bf05a/
if (trimming) {
me.items.length = me.keys.length = me.length;
} else {
me.items.splice(index, removeCount);
me.keys.splice(index, removeCount);
}
// Return last object removed
return o;
}
return false;
},

removeAtKey : function(key) {
var me = this,
keys = me.keys,
i;
// Remove objects which yielded no key from our configured getKey function
if (key == null) {
for (i = keys.length - 1; i >=0; i--) {
if (keys[i] == null) {
me.removeAt(i);
}
}
}
// Remove object at the passed key
else {
return me.removeAt(me.indexOfKey(key));
}
},

getCount : function() {
return this.length;
},

indexOf : function(o) {
var me = this,
key;
if (o != null) {
// If
// We have not been forced into using linear lookup by a usage of the 2 arg form of add
// and
// The key extraction function yields a key
// Then use indexOfKey. This will use the indexMap - rebuilding it if necessary.
if (!me.useLinearSearch && (key = me.getKey(o))) {
return this.indexOfKey(key);
}
// Fallback: Use linear search
return Ext.Array.indexOf(me.items, o);
}
// No object passed
return -1;
},

indexOfKey : function(key) {
if (!this.map.hasOwnProperty(key)) {
return -1;
}
if (this.indexGeneration !== this.generation) {
this.rebuildIndexMap();
}
return this.indexMap[key];
},

rebuildIndexMap: function() {
var me = this,
indexMap = me.indexMap = {},
keys = me.keys,
len = keys.length,
i;
for (i = 0; i < len; i++) {
indexMap[keys[i]] = i;
}
me.indexGeneration = me.generation;
},

get : function(key) {
var me = this,
mk = me.map[key],
item = mk !== undefined ? mk : (typeof key == 'number') ? me.items[key] : undefined;
return typeof item != 'function' || me.allowFunctions ? item : null; // for prototype!
},

getAt : function(index) {
return this.items[index];
},

getByKey : function(key) {
return this.map[key];
},

contains : function(o) {
var me = this,
key;
if (o != null) {
// If
// We have not been forced into using linear lookup by a usage of the 2 arg form of add
// and
// The key extraction function yields a key
// Then use the map to determine object presence.
if (!me.useLinearSearch && (key = me.getKey(o))) {
return this.map[key] != null;
}
// Fallback: Use linear search
return Ext.Array.indexOf(this.items, o) !== -1;
}

return false;
},

containsKey : function(key) {
return this.map.hasOwnProperty(key);
},

clear : function() {
var me = this;
// Only clear if it has ever had any content
if (me.generation) {
me.length = 0;
me.items = [];
me.keys = [];
me.map = {};
me.indexMap = {};
me.generation++;
me.indexGeneration = me.generation;
}
if (me.hasListeners.clear) {
me.fireEvent('clear');
}
},

first : function() {
return this.items[0];
},

last : function() {
return this.items[this.length - 1];
},

sum: function(property, root, start, end) {
var values = this.extractValues(property, root),
length = values.length,
sum = 0,
i;
start = start || 0;
end = (end || end === 0) ? end : length - 1;
for (i = start; i <= end; i++) {
sum += values[i];
}
return sum;
},

collect: function(property, root, allowNull) {
var values = this.extractValues(property, root),
length = values.length,
hits = {},
unique = [],
value, strValue, i;
for (i = 0; i < length; i++) {
value = values[i];
strValue = String(value);
if ((allowNull || !Ext.isEmpty(value)) && !hits[strValue]) {
hits[strValue] = true;
unique.push(value);
}
}
return unique;
},

extractValues: function(property, root) {
var values = this.items;
if (root) {
values = Ext.Array.pluck(values, root);
}
return Ext.Array.pluck(values, property);
},

hasRange: function(start, end) {
return (end < this.length);
},

getRange : function(start, end){
var me = this,
items = me.items,
range = [],
len = items.length,
tmp, reverse;
if (len < 1) {
return range;
}

if (start > end) {
reverse = true;
tmp = start;
start = end;
end = tmp;
}
if (start < 0) {
start = 0;
}

if (end == null || end >= len) {
end = len - 1; 
}

range = items.slice(start, end + 1);
if (reverse && range.length) {
range.reverse();
}
return range;
},

filter : function(property, value, anyMatch, caseSensitive) {
var filters = [];
//support for the simple case of filtering by property/value
if (Ext.isString(property)) {
filters.push(new Ext.util.Filter({
property : property,
value : value,
anyMatch : anyMatch,
caseSensitive: caseSensitive
}));
} else if (Ext.isArray(property) || property instanceof Ext.util.Filter) {
filters = filters.concat(property);
}
// At this point we have an array of zero or more Ext.util.Filter objects to filter with,
// so here we construct a function that combines these filters by ANDing them together
// and filter by that.
return this.filterBy(Ext.util.Filter.createFilterFn(filters));
},

filterBy : function(fn, scope) {
var me = this,
newMC = new me.self(me.initialConfig),
keys = me.keys,
items = me.items,
length = items.length,
i;
newMC.getKey = me.getKey;
for (i = 0; i < length; i++) {
if (fn.call(scope || me, items[i], keys[i])) {
newMC.add(keys[i], items[i]);
}
}
return newMC;
},

findIndex : function(property, value, start, anyMatch, caseSensitive){
if(Ext.isEmpty(value, false)){
return -1;
}
value = this.createValueMatcher(value, anyMatch, caseSensitive);
return this.findIndexBy(function(o){
return o && value.test(o[property]);
}, null, start);
},

findIndexBy : function(fn, scope, start){
var me = this,
keys = me.keys,
items = me.items,
i = start || 0,
len = items.length;
for (; i < len; i++) {
if (fn.call(scope || me, items[i], keys[i])) {
return i;
}
}
return -1;
},

createValueMatcher : function(value, anyMatch, caseSensitive, exactMatch) {
if (!value.exec) { // not a regex
var er = Ext.String.escapeRegex;
value = String(value);
if (anyMatch === true) {
value = er(value);
} else {
value = '^' + er(value);
if (exactMatch === true) {
value += '$';
}
}
value = new RegExp(value, caseSensitive ? '' : 'i');
}
return value;
},

clone : function() {
var me = this,
copy = new this.self(me.initialConfig);
copy.add(me.keys, me.items);
return copy;
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/util/Sorter.js */
(function(Ext) {
Ext.define('Ext.util.Sorter', {





direction: "ASC",
constructor: function(config) {
var me = this;
Ext.apply(me, config);
//<debug>
if (me.property === undefined && me.sorterFn === undefined) {
Ext.Error.raise("A Sorter requires either a property or a sorter function");
}
//</debug>
me.updateSortFunction();
},

createSortFunction: function(sorterFn) {
var me = this,
direction = me.direction || "ASC",
modifier = direction.toUpperCase() == "DESC" ? -1 : 1;
//create a comparison function. Takes 2 objects, returns 1 if object 1 is greater,
//-1 if object 2 is greater or 0 if they are equal
return function(o1, o2) {
return modifier * sorterFn.call(me, o1, o2);
};
},

defaultSorterFn: function(o1, o2) {
var me = this,
transform = me.transform,
v1 = me.getRoot(o1)[me.property],
v2 = me.getRoot(o2)[me.property];
if (transform) {
v1 = transform(v1);
v2 = transform(v2);
}
return v1 > v2 ? 1 : (v1 < v2 ? -1 : 0);
},

getRoot: function(item) {
return this.root === undefined ? item : item[this.root];
},

setDirection: function(direction) {
var me = this;
me.direction = direction ? direction.toUpperCase() : direction;
me.updateSortFunction();
},

toggle: function() {
var me = this;
me.direction = Ext.String.toggle(me.direction, "ASC", "DESC");
me.updateSortFunction();
},

updateSortFunction: function(fn) {
var me = this;
fn = fn || me.sorterFn || me.defaultSorterFn;
me.sort = me.createSortFunction(fn);
},
serialize: function() {
return {
root: this.root,
property: this.property,
direction: this.direction
};
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/util/Sortable.js */
(function(Ext) {
Ext.define("Ext.util.Sortable", {

isSortable: true,

defaultSortDirection: "ASC",
requires: [
'Ext.util.Sorter'
],
statics: {

createComparator: function(sorters) {
return sorters && sorters.length ? function(r1, r2) {
var result = sorters[0].sort(r1, r2),
length = sorters.length,
i = 1;
// if we have more than one sorter, OR any additional sorter functions together
for (; i < length; i++) {
result = result || sorters[i].sort.call(this, r1, r2);
}
return result;
}: function() {
return 0;
};
}
},



initSortable: function() {
var me = this,
sorters = me.sorters;

me.sorters = new Ext.util.AbstractMixedCollection(false, function(item) {
return item.id || item.property;
});
if (sorters) {
me.sorters.addAll(me.decodeSorters(sorters));
}
},

sort: function(sorters, direction, where, doSort) {
var me = this,
sorter,
newSorters;
if (Ext.isArray(sorters)) {
doSort = where;
where = direction;
newSorters = sorters;
}
else if (Ext.isObject(sorters)) {
doSort = where;
where = direction;
newSorters = [sorters];
}
else if (Ext.isString(sorters)) {
sorter = me.sorters.get(sorters);
if (!sorter) {
sorter = {
property : sorters,
direction: direction
};
newSorters = [sorter];
}
else if (direction === undefined) {
sorter.toggle();
}
else {
sorter.setDirection(direction);
}
}
if (newSorters && newSorters.length) {
newSorters = me.decodeSorters(newSorters);
if (Ext.isString(where)) {
if (where === 'prepend') {
me.sorters.insert(0, newSorters);
}
else {
me.sorters.addAll(newSorters);
}
}
else {
me.sorters.clear();
me.sorters.addAll(newSorters);
}
}
if (doSort !== false) {
me.fireEvent('beforesort', me, newSorters);
me.onBeforeSort(newSorters);

sorters = me.sorters.items;
if (sorters.length) {
// Sort using a generated sorter function which combines all of the Sorters passed
me.doSort(me.generateComparator());
}
}
return sorters;
},

generateComparator: function() {
var sorters = this.sorters.getRange();
return sorters.length ? this.createComparator(sorters) : this.emptyComparator;
},
emptyComparator: function(){
return 0;
},
onBeforeSort: Ext.emptyFn,

decodeSorters: function(sorters) {
if (!Ext.isArray(sorters)) {
if (sorters === undefined) {
sorters = [];
} else {
sorters = [sorters];
}
}
var length = sorters.length,
Sorter = Ext.util.Sorter,
fields = this.model ? this.model.prototype.fields : null,
field,
config, i;
for (i = 0; i < length; i++) {
config = sorters[i];
if (!(config instanceof Sorter)) {
if (Ext.isString(config)) {
config = {
property: config
};
}
Ext.applyIf(config, {
root : this.sortRoot,
direction: "ASC"
});
//support for 3.x style sorters where a function can be defined as 'fn'
if (config.fn) {
config.sorterFn = config.fn;
}
//support a function to be passed as a sorter definition
if (typeof config == 'function') {
config = {
sorterFn: config
};
}
// ensure sortType gets pushed on if necessary
if (fields && !config.transform) {
field = fields.get(config.property);
config.transform = field && field.sortType !== Ext.identityFn ? field.sortType : undefined;
}
sorters[i] = new Ext.util.Sorter(config);
}
}
return sorters;
},
getSorters: function() {
return this.sorters.items;
},


getFirstSorter: function(){
var sorters = this.sorters.items,
len = sorters.length,
i = 0,
sorter;

for (; i < len; ++i) {
sorter = sorters[i];
if (!sorter.isGrouper) {
return sorter; 
}
}
return null;
}
}, function() {
// Reference the static implementation in prototype
this.prototype.createComparator = this.createComparator;
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/util/MixedCollection.js */
(function(Ext) {
Ext.define('Ext.util.MixedCollection', {
extend: 'Ext.util.AbstractMixedCollection',
mixins: {
sortable: 'Ext.util.Sortable'
},


constructor: function() {
var me = this;
me.callParent(arguments);
me.addEvents('sort');
me.mixins.sortable.initSortable.call(me);
},
doSort: function(sorterFn) {
this.sortBy(sorterFn);
},

_sort : function(property, dir, fn) {
var me = this,
i, len,
dsc = String(dir).toUpperCase() == 'DESC' ? -1 : 1,
//this is a temporary array used to apply the sorting function
c = [],
keys = me.keys,
items = me.items,
o;
//default to a simple sorter function if one is not provided
fn = fn || function(a, b) {
return a - b;
};
//copy all the items into a temporary array, which we will sort
for (i = 0, len = items.length; i < len; i++) {
c[c.length] = {
key : keys[i],
value: items[i],
index: i
};
}
//sort the temporary array
Ext.Array.sort(c, function(a, b) {
return fn(a[property], b[property]) * dsc ||
// In case of equality, ensure stable sort by comparing collection index
(a.index < b.index ? -1 : 1);
});
// Copy the temporary array back into the main this.items and this.keys objects
// Repopulate the indexMap hash if configured to do so.
for (i = 0, len = c.length; i < len; i++) {
o = c[i];
items[i] = o.value;
keys[i] = o.key;
me.indexMap[o.key] = i;
}
me.generation++;
me.indexGeneration = me.generation;
me.fireEvent('sort', me);
},

sortBy: function(sorterFn) {
var me = this,
items = me.items,
item,
keys = me.keys,
key,
length = items.length,
i;
// Stamp the collection index into each item so that we can implement stable sort
for (i = 0; i < length; i++) {
items[i].$extCollectionIndex = i;
}
Ext.Array.sort(items, function(a, b) {
return sorterFn(a, b) ||
// In case of equality, ensure stable sort by comparing collection index
(a.$extCollectionIndex < b.$extCollectionIndex ? -1 : 1);
});
// Update the keys array, and remove the index
for (i = 0; i < length; i++) {
item = items[i];
key = me.getKey(item);
keys[i] = key;
me.indexMap[key] = i;
delete items.$extCollectionIndex;
}
me.generation++;
me.indexGeneration = me.generation;
me.fireEvent('sort', me, items, keys);
},

findInsertionIndex: function(newItem, sorterFn) {
var me = this,
items = me.items,
start = 0,
end = items.length - 1,
middle,
comparison;
if (!sorterFn) {
sorterFn = me.generateComparator();
}
while (start <= end) {
middle = (start + end) >> 1;
comparison = sorterFn(newItem, items[middle]);
if (comparison >= 0) {
start = middle + 1;
} else if (comparison < 0) {
end = middle - 1;
}
}
return start;
},

reorder: function(mapping) {
var me = this,
items = me.items,
index = 0,
length = items.length,
order = [],
remaining = [],
oldIndex;
me.suspendEvents();
//object of {oldPosition: newPosition} reversed to {newPosition: oldPosition}
for (oldIndex in mapping) {
order[mapping[oldIndex]] = items[oldIndex];
}
for (index = 0; index < length; index++) {
if (mapping[index] == undefined) {
remaining.push(items[index]);
}
}
for (index = 0; index < length; index++) {
if (order[index] == undefined) {
order[index] = remaining.shift();
}
}
me.clear();
me.addAll(order);
me.resumeEvents();
me.fireEvent('sort', me);
},

sortByKey : function(dir, fn){
this._sort('key', dir, fn || function(a, b){
var v1 = String(a).toUpperCase(), v2 = String(b).toUpperCase();
return v1 > v2 ? 1 : (v1 < v2 ? -1 : 0);
});
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/fx/target/Target.js */
(function(Ext) {
Ext.define('Ext.fx.target.Target', {
isAnimTarget: true,

constructor: function(target) {
this.target = target;
this.id = this.getId();
},

getId: function() {
return this.target.id;
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/fx/target/Element.js */
(function(Ext) {
Ext.define('Ext.fx.target.Element', {


extend: 'Ext.fx.target.Target',


type: 'element',
getElVal: function(el, attr, val) {
if (val == undefined) {
if (attr === 'x') {
val = el.getX();
} else if (attr === 'y') {
val = el.getY();
} else if (attr === 'scrollTop') {
val = el.getScroll().top;
} else if (attr === 'scrollLeft') {
val = el.getScroll().left;
} else if (attr === 'height') {
val = el.getHeight();
} else if (attr === 'width') {
val = el.getWidth();
} else {
val = el.getStyle(attr);
}
}
return val;
},
getAttr: function(attr, val) {
var el = this.target;
return [[ el, this.getElVal(el, attr, val)]];
},
setAttr: function(targetData) {
var target = this.target,
ln = targetData.length,
attrs, attr, o, i, j, ln2;

for (i = 0; i < ln; i++) {
attrs = targetData[i].attrs;
for (attr in attrs) {
if (attrs.hasOwnProperty(attr)) {
ln2 = attrs[attr].length;
for (j = 0; j < ln2; j++) {
o = attrs[attr][j];
this.setElVal(o[0], attr, o[1]);
}
}
}
}
},

setElVal: function(element, attr, value){
if (attr === 'x') {
element.setX(value);
} else if (attr === 'y') {
element.setY(value);
} else if (attr === 'scrollTop') {
element.scrollTo('top', value);
} else if (attr === 'scrollLeft') {
element.scrollTo('left',value);
} else if (attr === 'width') {
element.setWidth(value);
} else if (attr === 'height') {
element.setHeight(value);
} else {
element.setStyle(attr, value);
}
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/fx/target/ElementCSS.js */
(function(Ext) {
Ext.define('Ext.fx.target.ElementCSS', {

extend: 'Ext.fx.target.Element',

setAttr: function(targetData, isFirstFrame) {
var cssArr = {
attrs: [],
duration: [],
easing: []
},
ln = targetData.length,
attributes,
attrs,
attr,
easing,
duration,
o,
i,
j,
ln2;
for (i = 0; i < ln; i++) {
attrs = targetData[i];
duration = attrs.duration;
easing = attrs.easing;
attrs = attrs.attrs;
for (attr in attrs) {
if (Ext.Array.indexOf(cssArr.attrs, attr) == -1) {
cssArr.attrs.push(attr.replace(/[A-Z]/g, function(v) {
return '-' + v.toLowerCase();
}));
cssArr.duration.push(duration + 'ms');
cssArr.easing.push(easing);
}
}
}
attributes = cssArr.attrs.join(',');
duration = cssArr.duration.join(',');
easing = cssArr.easing.join(', ');
for (i = 0; i < ln; i++) {
attrs = targetData[i].attrs;
for (attr in attrs) {
ln2 = attrs[attr].length;
for (j = 0; j < ln2; j++) {
o = attrs[attr][j];
o[0].setStyle(Ext.supports.CSS3Prefix + 'TransitionProperty', isFirstFrame ? '' : attributes);
o[0].setStyle(Ext.supports.CSS3Prefix + 'TransitionDuration', isFirstFrame ? '' : duration);
o[0].setStyle(Ext.supports.CSS3Prefix + 'TransitionTimingFunction', isFirstFrame ? '' : easing);
o[0].setStyle(attr, o[1]);
// Must trigger reflow to make this get used as the start point for the transition that follows
if (isFirstFrame) {
o = o[0].dom.offsetWidth;
}
else {
// Remove transition properties when completed.
o[0].on(Ext.supports.CSS3TransitionEnd, function() {
this.setStyle(Ext.supports.CSS3Prefix + 'TransitionProperty', null);
this.setStyle(Ext.supports.CSS3Prefix + 'TransitionDuration', null);
this.setStyle(Ext.supports.CSS3Prefix + 'TransitionTimingFunction', null);
}, o[0], { single: true });
}
}
}
}
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/fx/target/CompositeElement.js */
(function(Ext) {
Ext.define('Ext.fx.target.CompositeElement', {

extend: 'Ext.fx.target.Element',


isComposite: true,

constructor: function(target) {
target.id = target.id || Ext.id(null, 'ext-composite-');
this.callParent([target]);
},
getAttr: function(attr, val) {
var out = [],
target = this.target,
elements = target.elements,
length = elements.length,
i,
el;
for (i = 0; i < length; i++) {
el = elements[i];
if (el) {
el = target.getElement(el);
out.push([el, this.getElVal(el, attr, val)]);
}
}
return out;
},

setAttr: function(targetData){
var target = this.target,
ln = targetData.length,
elements = target.elements,
ln3 = elements.length,
value, k,
attrs, attr, o, i, j, ln2;

for (i = 0; i < ln; i++) {
attrs = targetData[i].attrs;
for (attr in attrs) {
if (attrs.hasOwnProperty(attr)) {
ln2 = attrs[attr].length;
for (j = 0; j < ln2; j++) {
value = attrs[attr][j][1];
for (k = 0; k < ln3; ++k) {
el = elements[k];
if (el) {
el = target.getElement(el);
this.setElVal(el, attr, value);
}
}
}
}
}
}
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/fx/target/CompositeElementCSS.js */
(function(Ext) {
Ext.define('Ext.fx.target.CompositeElementCSS', {

extend: 'Ext.fx.target.CompositeElement',
requires: ['Ext.fx.target.ElementCSS'],

setAttr: function() {
return Ext.fx.target.ElementCSS.prototype.setAttr.apply(this, arguments);
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/fx/target/Sprite.js */
(function(Ext) {
Ext.define('Ext.fx.target.Sprite', {

extend: 'Ext.fx.target.Target',

type: 'draw',
getFromPrim: function (sprite, attr) {
var obj;
switch (attr) {
case 'rotate':
case 'rotation':
obj = sprite.attr.rotation;
return {
x: obj.x || 0,
y: obj.y || 0,
degrees: obj.degrees || 0
};
case 'scale':
case 'scaling':
obj = sprite.attr.scaling;
return {
x: obj.x || 1,
y: obj.y || 1,
cx: obj.cx || 0,
cy: obj.cy || 0
};
case 'translate':
case 'translation':
obj = sprite.attr.translation;
return {
x: obj.x || 0,
y: obj.y || 0
};
default:
return sprite.attr[attr];
}
},
getAttr: function (attr, val) {
return [
[this.target, val != undefined ? val : this.getFromPrim(this.target, attr)]
];
},
setAttr: function (targetData) {
var ln = targetData.length,
spriteArr = [],
attrsConf, attr, attrArr, attrs, sprite, idx, value, i, j, x, y, ln2;
for (i = 0; i < ln; i++) {
attrsConf = targetData[i].attrs;
for (attr in attrsConf) {
attrArr = attrsConf[attr];
ln2 = attrArr.length;
for (j = 0; j < ln2; j++) {
sprite = attrArr[j][0];
attrs = attrArr[j][1];
if (attr === 'translate' || attr === 'translation') {
value = {
x: attrs.x,
y: attrs.y
};
}
else if (attr === 'rotate' || attr === 'rotation') {
x = attrs.x;
if (isNaN(x)) {
x = null;
}
y = attrs.y;
if (isNaN(y)) {
y = null;
}
value = {
degrees: attrs.degrees,
x: x,
y: y
};
} else if (attr === 'scale' || attr === 'scaling') {
x = attrs.x;
if (isNaN(x)) {
x = null;
}
y = attrs.y;
if (isNaN(y)) {
y = null;
}
value = {
x: x,
y: y,
cx: attrs.cx,
cy: attrs.cy
};
}
else if (attr === 'width' || attr === 'height' || attr === 'x' || attr === 'y') {
value = parseFloat(attrs);
}
else {
value = attrs;
}
idx = Ext.Array.indexOf(spriteArr, sprite);
if (idx == -1) {
spriteArr.push([sprite, {}]);
idx = spriteArr.length - 1;
}
spriteArr[idx][1][attr] = value;
}
}
}
ln = spriteArr.length;
for (i = 0; i < ln; i++) {
spriteArr[i][0].setAttributes(spriteArr[i][1]);
}
this.target.redraw();
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/fx/target/CompositeSprite.js */
(function(Ext) {
Ext.define('Ext.fx.target.CompositeSprite', {

extend: 'Ext.fx.target.Sprite',

getAttr: function(attr, val) {
var out = [],
sprites = [].concat(this.target.items),
length = sprites.length,
i,
sprite;
for (i = 0; i < length; i++) {
sprite = sprites[i];
out.push([sprite, val != undefined ? val : this.getFromPrim(sprite, attr)]);
}
return out;
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/fx/target/Component.js */
(function(Ext) {
Ext.define('Ext.fx.target.Component', {


extend: 'Ext.fx.target.Target',


type: 'component',
// Methods to call to retrieve unspecified "from" values from a target Component
getPropMethod: {
top: function() {
return this.getPosition(true)[1];
},
left: function() {
return this.getPosition(true)[0];
},
x: function() {
return this.getPosition()[0];
},
y: function() {
return this.getPosition()[1];
},
height: function() {
return this.getHeight();
},
width: function() {
return this.getWidth();
},
opacity: function() {
return this.el.getStyle('opacity');
}
},
setMethods: {
top: 'setPosition',
left: 'setPosition',
x: 'setPagePosition',
y: 'setPagePosition',
height: 'setSize',
width: 'setSize',
opacity: 'setOpacity'
},
// Read the named attribute from the target Component. Use the defined getter for the attribute
getAttr: function(attr, val) {
return [[this.target, val !== undefined ? val : this.getPropMethod[attr].call(this.target)]];
},
setAttr: function(targetData, isFirstFrame, isLastFrame) {
var me = this,
ln = targetData.length,
attrs, attr, o, i, j, targets, left, top, w, h,
methodsToCall = {},
methodProps;
for (i = 0; i < ln; i++) {
attrs = targetData[i].attrs;
for (attr in attrs) {
targets = attrs[attr].length;
for (j = 0; j < targets; j++) {
o = attrs[attr][j];
methodProps = methodsToCall[me.setMethods[attr]] || (methodsToCall[me.setMethods[attr]] = {});
methodProps.target = o[0];
methodProps[attr] = o[1];
// debugging code: Ext.log('Setting ' + o[0].id + "'s " + attr + ' to ' + o[1]);
}
}
if (methodsToCall.setPosition) {
o = methodsToCall.setPosition;
left = (o.left === undefined) ? undefined : parseFloat(o.left);
top = (o.top === undefined) ? undefined : parseFloat(o.top);
o.target.setPosition(left, top);
}
if (methodsToCall.setPagePosition) {
o = methodsToCall.setPagePosition;
o.target.setPagePosition(o.x, o.y);
}
if (methodsToCall.setSize) {
o = methodsToCall.setSize;
// Dimensions not being animated MUST NOT be autosized. They must remain at current value.
w = (o.width === undefined) ? o.target.getWidth() : parseFloat(o.width);
h = (o.height === undefined) ? o.target.getHeight() : parseFloat(o.height);
// Only set the size of the Component on the last frame, or if the animation was
// configured with dynamic: true.
// In other cases, we just set the target element size.
// This will result in either clipping if animating a reduction in size, or the revealing of
// the inner elements of the Component if animating an increase in size.
// Component's animate function initially resizes to the larger size before resizing the
// outer element to clip the contents.
o.target.el.setSize(w, h);
if (isLastFrame || me.dynamic) {
// Defer the final sizing & layout until we are outside of this frame.
// In case anything in the resulting layout calls animation.
// If it does, *this* frame will fire again... recursively
Ext.globalEvents.on({
idle: Ext.Function.bind(o.target.setSize, o.target, [w, h]),
single: true
});
}
}
if (methodsToCall.setOpacity) {
o = methodsToCall.setOpacity;
o.target.el.setStyle('opacity', o.opacity);
}
}
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/fx/Queue.js */
(function(Ext) {
Ext.define('Ext.fx.Queue', {
requires: ['Ext.util.HashMap'],
constructor: function() {
this.targets = new Ext.util.HashMap();
this.fxQueue = {};
},
// @private
getFxDefaults: function(targetId) {
var target = this.targets.get(targetId);
if (target) {
return target.fxDefaults;
}
return {};
},
// @private
setFxDefaults: function(targetId, obj) {
var target = this.targets.get(targetId);
if (target) {
target.fxDefaults = Ext.apply(target.fxDefaults || {}, obj);
}
},
// @private
stopAnimation: function(targetId) {
var me = this,
queue = me.getFxQueue(targetId),
ln = queue.length;
while (ln) {
queue[ln - 1].end();
ln--;
}
},

getActiveAnimation: function(targetId) {
var queue = this.getFxQueue(targetId);
return (queue && !!queue.length) ? queue[0] : false;
},
// @private
hasFxBlock: function(targetId) {
var queue = this.getFxQueue(targetId);
return queue && queue[0] && queue[0].block;
},
// @private get fx queue for passed target, create if needed.
getFxQueue: function(targetId) {
if (!targetId) {
return false;
}
var me = this,
queue = me.fxQueue[targetId],
target = me.targets.get(targetId);
if (!target) {
return false;
}
if (!queue) {
me.fxQueue[targetId] = [];
// GarbageCollector will need to clean up Elements since they aren't currently observable
if (target.type != 'element') {
target.target.on('destroy', function() {
me.fxQueue[targetId] = [];
});
}
}
return me.fxQueue[targetId];
},
// @private
queueFx: function(anim) {
var me = this,
target = anim.target,
queue, ln;
if (!target) {
return;
}
queue = me.getFxQueue(target.getId());
ln = queue.length;
if (ln) {
if (anim.concurrent) {
anim.paused = false;
}
else {
queue[ln - 1].on('afteranimate', function() {
anim.paused = false;
});
}
}
else {
anim.paused = false;
}
anim.on('afteranimate', function() {
Ext.Array.remove(queue, anim);
if (queue.length === 0) {
me.targets.remove(anim.target);
}
if (anim.remove) {
if (target.type == 'element') {
var el = Ext.get(target.id);
if (el) {
el.remove();
}
}
}
}, me, {
single: true
});
queue.push(anim);
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/fx/Manager.js */
(function(Ext) {
Ext.define('Ext.fx.Manager', {

singleton: true,
requires: ['Ext.util.MixedCollection',
'Ext.fx.target.Element',
'Ext.fx.target.ElementCSS',
'Ext.fx.target.CompositeElement',
'Ext.fx.target.CompositeElementCSS',
'Ext.fx.target.Sprite',
'Ext.fx.target.CompositeSprite',
'Ext.fx.target.Component'],
mixins: {
queue: 'Ext.fx.Queue'
},

constructor: function() {
var me = this;
me.items = new Ext.util.MixedCollection();
me.mixins.queue.constructor.call(me);

// Do not use fireIdleEvent: false. Each tick of the TaskRunner needs to fire the idleEvent
// in case an animation callback/listener adds a listener.
me.taskRunner = new Ext.util.TaskRunner();
// this.requestAnimFrame = (function() {
// var raf = window.requestAnimationFrame ||
// window.webkitRequestAnimationFrame ||
// window.mozRequestAnimationFrame ||
// window.oRequestAnimationFrame ||
// window.msRequestAnimationFrame;
// if (raf) {
// return function(callback, element) {
// raf(callback);
// };
// }
// else {
// return function(callback, element) {
// window.setTimeout(callback, Ext.fx.Manager.interval);
// };
// }
// })();
},

interval: 16,

forceJS: true,
// @private Target factory
createTarget: function(target) {
var me = this,
useCSS3 = !me.forceJS && Ext.supports.Transitions,
targetObj;
me.useCSS3 = useCSS3;
if (target) {
// dom element, string or fly
if (target.tagName || Ext.isString(target) || target.isFly) {
target = Ext.get(target);
targetObj = new Ext.fx.target['Element' + (useCSS3 ? 'CSS' : '')](target);
}
// Element
else if (target.dom) {
targetObj = new Ext.fx.target['Element' + (useCSS3 ? 'CSS' : '')](target);
}
// Element Composite
else if (target.isComposite) {
targetObj = new Ext.fx.target['CompositeElement' + (useCSS3 ? 'CSS' : '')](target);
}
// Draw Sprite
else if (target.isSprite) {
targetObj = new Ext.fx.target.Sprite(target);
}
// Draw Sprite Composite
else if (target.isCompositeSprite) {
targetObj = new Ext.fx.target.CompositeSprite(target);
}
// Component
else if (target.isComponent) {
targetObj = new Ext.fx.target.Component(target);
}
else if (target.isAnimTarget) {
return target;
}
else {
return null;
}
me.targets.add(targetObj);
return targetObj;
}
else {
return null;
}
},

addAnim: function(anim) {
var me = this,
items = me.items,
task = me.task;
// Make sure we use the anim's id, not the anim target's id here. The anim id will be unique on
// each call to addAnim. `anim.target` is the DOM element being targeted, and since multiple animations
// can target a single DOM node concurrently, the target id cannot be assumned to be unique.
items.add(anim.id, anim);
//Ext.log('+ added anim ', anim.id, ', target: ', anim.target.getId(), ', duration: ', anim.duration);
// Start the timer if not already running
if (!task && items.length) {
task = me.task = {
run: me.runner,
interval: me.interval,
scope: me
};
//Ext.log('--->> Starting task');
me.taskRunner.start(task);
}
},

removeAnim: function(anim) {
var me = this,
items = me.items,
task = me.task;

items.removeAtKey(anim.id);
//Ext.log(' X removed anim ', anim.id, ', target: ', anim.target.getId(), ', frames: ', anim.frameCount, ', item count: ', items.length);

// Stop the timer if there are no more managed Anims
if (task && !items.length) {
//Ext.log('[]--- Stopping task');
me.taskRunner.stop(task);
delete me.task;
}
},

runner: function() {
var me = this,
items = me.items.getRange(),
i = 0,
len = items.length,
anim;
//Ext.log(' executing anim runner task with ', len, ' items');
me.targetArr = {};
// Single timestamp for all animations this interval
me.timestamp = new Date();

// Loop to start any new animations first before looping to
// execute running animations (which will also include all animations
// started in this loop). This is a subtle difference from simply
// iterating in one loop and starting then running each animation,
// but separating the loops is necessary to ensure that all new animations
// actually kick off prior to existing ones regardless of array order.
// Otherwise in edge cases when there is excess latency in overall
// performance, allowing existing animations to run before new ones can
// lead to dropped frames and subtle race conditions when they are
// interdependent, which is often the case with certain Element fx.
for (; i < len; i++) {
anim = items[i];

if (anim.isReady()) {
//Ext.log(' starting anim ', anim.id, ', target: ', anim.target.id);
me.startAnim(anim);
}
}

for (i = 0; i < len; i++) {
anim = items[i];

if (anim.isRunning()) {
//Ext.log(' running anim ', anim.target.id);
me.runAnim(anim);
//<debug>
} else if (!me.useCSS3) {
// When using CSS3 transitions the animations get paused since they are not
// needed once the transition is handed over to the browser, so we can
// ignore this case. However if we are doing JS animations and something is
// paused here it's possibly unintentional.
//Ext.log(' (i) anim ', anim.id, ' is active but not running...');
//</debug>
}
}
// Apply all the pending changes to their targets
me.applyPendingAttrs();
},

startAnim: function(anim) {
anim.start(this.timestamp);
},

runAnim: function(anim) {
if (!anim) {
return;
}
var me = this,
useCSS3 = me.useCSS3 && anim.target.type == 'element',
elapsedTime = me.timestamp - anim.startTime,
lastFrame = (elapsedTime >= anim.duration),
target, o;
target = this.collectTargetData(anim, elapsedTime, useCSS3, lastFrame);

// For CSS3 animation, we need to immediately set the first frame's attributes without any transition
// to get a good initial state, then add the transition properties and set the final attributes.
if (useCSS3) {
//Ext.log(' (i) using CSS3 transitions');

// Flush the collected attributes, without transition
anim.target.setAttr(target.anims[anim.id].attributes, true);
// Add the end frame data
me.collectTargetData(anim, anim.duration, useCSS3, lastFrame);
// Pause the animation so runAnim doesn't keep getting called
anim.paused = true;
target = anim.target.target;
// We only want to attach an event on the last element in a composite
if (anim.target.isComposite) {
target = anim.target.target.last();
}
// Listen for the transitionend event
o = {};
o[Ext.supports.CSS3TransitionEnd] = anim.lastFrame;
o.scope = anim;
o.single = true;
target.on(o);
}
},

collectTargetData: function(anim, elapsedTime, useCSS3, isLastFrame) {
var targetId = anim.target.getId(),
target = this.targetArr[targetId];

if (!target) {
// Create a thin wrapper around the target so that we can create a link between the
// target element and its associated animations. This is important later when applying
// attributes to the target so that each animation can be independently run with its own
// duration and stopped at any point without affecting other animations for the same target.
target = this.targetArr[targetId] = {
id: targetId,
el: anim.target,
anims: {}
};
}
// This is a wrapper for the animation so that we can also save state along with it,
// including the current elapsed time and lastFrame status. Even though this method only
// adds a single anim object per call, each target element could have multiple animations
// associated with it, which is why the anim is added to the target's `anims` hash by id.
target.anims[anim.id] = {
id: anim.id,
anim: anim,
elapsed: elapsedTime,
isLastFrame: isLastFrame,
// This is the object that gets applied to the target element below in applyPendingAttrs():
attributes: [{
duration: anim.duration,
easing: (useCSS3 && anim.reverse) ? anim.easingFn.reverse().toCSS3() : anim.easing,
// This is where the magic happens. The anim calculates what its new attributes should
// be based on the current frame and returns those as a hash of values.
attrs: anim.runAnim(elapsedTime)
}]
};

return target;
},


applyPendingAttrs: function() {
var targetArr = this.targetArr,
target, targetId, animWrap, anim, animId;

// Loop through each target
for (targetId in targetArr) {
if (targetArr.hasOwnProperty(targetId)) {
target = targetArr[targetId];

// Each target could have multiple associated animations, so iterate those
for (animId in target.anims) {
if (target.anims.hasOwnProperty(animId)) {
animWrap = target.anims[animId];
anim = animWrap.anim;

// If the animation has valid attributes, set them on the target
if (animWrap.attributes && anim.isRunning()) {
//Ext.log(' > applying attributes for anim ', animWrap.id, ', target: ', target.id, ', elapsed: ', animWrap.elapsed);
target.el.setAttr(animWrap.attributes, false, animWrap.isLastFrame);

// If this particular anim is at the last frame end it
if (animWrap.isLastFrame) {
//Ext.log(' running last frame for ', animWrap.id, ', target: ', targetId);
anim.lastFrame();
}
}
}
}
}
}
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/fx/Animator.js */
(function(Ext) {
Ext.define('Ext.fx.Animator', {

mixins: {
observable: 'Ext.util.Observable'
},
requires: ['Ext.fx.Manager'],


isAnimator: true,

duration: 250,

delay: 0,

delayStart: 0,

dynamic: false,

easing: 'ease',

running: false,

paused: false,

damper: 1,

iterations: 1,

currentIteration: 0,

keyframeStep: 0,

animKeyFramesRE: /^(from|to|\d+%?)$/,


constructor: function(config) {
var me = this;
config = Ext.apply(me, config || {});
me.config = config;
me.id = Ext.id(null, 'ext-animator-');
me.addEvents(

'beforeanimate',

'keyframe',

'afteranimate'
);
me.mixins.observable.constructor.call(me, config);
me.timeline = [];
me.createTimeline(me.keyframes);
if (me.target) {
me.applyAnimator(me.target);
Ext.fx.Manager.addAnim(me);
}
},

sorter: function (a, b) {
return a.pct - b.pct;
},

createTimeline: function(keyframes) {
var me = this,
attrs = [],
to = me.to || {},
duration = me.duration,
prevMs, ms, i, ln, pct, attr;
for (pct in keyframes) {
if (keyframes.hasOwnProperty(pct) && me.animKeyFramesRE.test(pct)) {
attr = {attrs: Ext.apply(keyframes[pct], to)};
// CSS3 spec allow for from/to to be specified.
if (pct == "from") {
pct = 0;
}
else if (pct == "to") {
pct = 100;
}
// convert % values into integers
attr.pct = parseInt(pct, 10);
attrs.push(attr);
}
}
// Sort by pct property
Ext.Array.sort(attrs, me.sorter);
// Only an end
//if (attrs[0].pct) {
// attrs.unshift({pct: 0, attrs: element.attrs});
//}
ln = attrs.length;
for (i = 0; i < ln; i++) {
prevMs = (attrs[i - 1]) ? duration * (attrs[i - 1].pct / 100) : 0;
ms = duration * (attrs[i].pct / 100);
me.timeline.push({
duration: ms - prevMs,
attrs: attrs[i].attrs
});
}
},

applyAnimator: function(target) {
var me = this,
anims = [],
timeline = me.timeline,
ln = timeline.length,
anim, easing, damper, attrs, i;
if (me.fireEvent('beforeanimate', me) !== false) {
for (i = 0; i < ln; i++) {
anim = timeline[i];
attrs = anim.attrs;
easing = attrs.easing || me.easing;
damper = attrs.damper || me.damper;
delete attrs.easing;
delete attrs.damper;
anim = new Ext.fx.Anim({
target: target,
easing: easing,
damper: damper,
duration: anim.duration,
paused: true,
to: attrs
});
anims.push(anim);
}
me.animations = anims;
me.target = anim.target;
for (i = 0; i < ln - 1; i++) {
anim = anims[i];
anim.nextAnim = anims[i + 1];
anim.on('afteranimate', function() {
this.nextAnim.paused = false;
});
anim.on('afteranimate', function() {
this.fireEvent('keyframe', this, ++this.keyframeStep);
}, me);
}
anims[ln - 1].on('afteranimate', function() {
this.lastFrame();
}, me);
}
},

start: function(startTime) {
var me = this,
delay = me.delay,
delayStart = me.delayStart,
delayDelta;
if (delay) {
if (!delayStart) {
me.delayStart = startTime;
return;
}
else {
delayDelta = startTime - delayStart;
if (delayDelta < delay) {
return;
}
else {
// Compensate for frame delay;
startTime = new Date(delayStart.getTime() + delay);
}
}
}
if (me.fireEvent('beforeanimate', me) !== false) {
me.startTime = startTime;
me.running = true;
me.animations[me.keyframeStep].paused = false;
}
},

lastFrame: function() {
var me = this,
iter = me.iterations,
iterCount = me.currentIteration;
iterCount++;
if (iterCount < iter) {
me.startTime = new Date();
me.currentIteration = iterCount;
me.keyframeStep = 0;
me.applyAnimator(me.target);
me.animations[me.keyframeStep].paused = false;
}
else {
me.currentIteration = 0;
me.end();
}
},

end: function() {
var me = this;
me.fireEvent('afteranimate', me, me.startTime, new Date() - me.startTime);
},

isReady: function() {
return this.paused === false && this.running === false && this.iterations > 0;
},

isRunning: function() {
// Explicitly return false, we don't want to be run continuously by the manager
return false;
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/fx/CubicBezier.js */
(function(Ext) {
Ext.define('Ext.fx.CubicBezier', {

singleton: true,

cubicBezierAtTime: function(t, p1x, p1y, p2x, p2y, duration) {
var cx = 3 * p1x,
bx = 3 * (p2x - p1x) - cx,
ax = 1 - cx - bx,
cy = 3 * p1y,
by = 3 * (p2y - p1y) - cy,
ay = 1 - cy - by;
function sampleCurveX(t) {
return ((ax * t + bx) * t + cx) * t;
}
function solve(x, epsilon) {
var t = solveCurveX(x, epsilon);
return ((ay * t + by) * t + cy) * t;
}
function solveCurveX(x, epsilon) {
var t0, t1, t2, x2, d2, i;
for (t2 = x, i = 0; i < 8; i++) {
x2 = sampleCurveX(t2) - x;
if (Math.abs(x2) < epsilon) {
return t2;
}
d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;
if (Math.abs(d2) < 1e-6) {
break;
}
t2 = t2 - x2 / d2;
}
t0 = 0;
t1 = 1;
t2 = x;
if (t2 < t0) {
return t0;
}
if (t2 > t1) {
return t1;
}
while (t0 < t1) {
x2 = sampleCurveX(t2);
if (Math.abs(x2 - x) < epsilon) {
return t2;
}
if (x > x2) {
t0 = t2;
} else {
t1 = t2;
}
t2 = (t1 - t0) / 2 + t0;
}
return t2;
}
return solve(t, 1 / (200 * duration));
},
cubicBezier: function(x1, y1, x2, y2) {
var fn = function(pos) {
return Ext.fx.CubicBezier.cubicBezierAtTime(pos, x1, y1, x2, y2, 1);
};
fn.toCSS3 = function() {
return 'cubic-bezier(' + [x1, y1, x2, y2].join(',') + ')';
};
fn.reverse = function() {
return Ext.fx.CubicBezier.cubicBezier(1 - x2, 1 - y2, 1 - x1, 1 - y1);
};
return fn;
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/fx/Easing.js */
(function(Ext) {
// @define Ext.fx.Easing
Ext.require('Ext.fx.CubicBezier', function() {
var math = Math,
pi = math.PI,
pow = math.pow,
sin = math.sin,
sqrt = math.sqrt,
abs = math.abs,
backInSeed = 1.70158;

Ext.define('Ext.fx.Easing', {
singleton: true,

linear: Ext.identityFn,
ease: function(n) {
var q = 0.07813 - n / 2,
alpha = -0.25,
Q = sqrt(0.0066 + q * q),
x = Q - q,
X = pow(abs(x), 1/3) * (x < 0 ? -1 : 1),
y = -Q - q,
Y = pow(abs(y), 1/3) * (y < 0 ? -1 : 1),
t = X + Y + 0.25;
return pow(1 - t, 2) * 3 * t * 0.1 + (1 - t) * 3 * t * t + t * t * t;
},
easeIn: function (n) {
return pow(n, 1.7);
},
easeOut: function (n) {
return pow(n, 0.48);
},
easeInOut: function(n) {
var q = 0.48 - n / 1.04,
Q = sqrt(0.1734 + q * q),
x = Q - q,
X = pow(abs(x), 1/3) * (x < 0 ? -1 : 1),
y = -Q - q,
Y = pow(abs(y), 1/3) * (y < 0 ? -1 : 1),
t = X + Y + 0.5;
return (1 - t) * 3 * t * t + t * t * t;
},
backIn: function (n) {
return n * n * ((backInSeed + 1) * n - backInSeed);
},
backOut: function (n) {
n = n - 1;
return n * n * ((backInSeed + 1) * n + backInSeed) + 1;
},
elasticIn: function (n) {
if (n === 0 || n === 1) {
return n;
}
var p = 0.3,
s = p / 4;
return pow(2, -10 * n) * sin((n - s) * (2 * pi) / p) + 1;
},
elasticOut: function (n) {
return 1 - Ext.fx.Easing.elasticIn(1 - n);
},
bounceIn: function (n) {
return 1 - Ext.fx.Easing.bounceOut(1 - n);
},
bounceOut: function (n) {
var s = 7.5625,
p = 2.75,
l;
if (n < (1 / p)) {
l = s * n * n;
} else {
if (n < (2 / p)) {
n -= (1.5 / p);
l = s * n * n + 0.75;
} else {
if (n < (2.5 / p)) {
n -= (2.25 / p);
l = s * n * n + 0.9375;
} else {
n -= (2.625 / p);
l = s * n * n + 0.984375;
}
}
}
return l;
}
}, function(){
var easing = Ext.fx.Easing.self,
proto = easing.prototype;

easing.implement({
'back-in': proto.backIn,
'back-out': proto.backOut,
'ease-in': proto.easeIn,
'ease-out': proto.easeOut,
'elastic-in': proto.elasticIn,
'elastic-out': proto.elasticOut,
'bounce-in': proto.bounceIn,
'bounce-out': proto.bounceOut,
'ease-in-out': proto.easeInOut
}); 
});
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/draw/Color.js */
(function(Ext) {
Ext.define('Ext.draw.Color', {


colorToHexRe: /(.*?)rgb\((\d+),\s*(\d+),\s*(\d+)\)/,
rgbRe: /\s*rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)\s*/,
hexRe: /\s*#([0-9a-fA-F][0-9a-fA-F]?)([0-9a-fA-F][0-9a-fA-F]?)([0-9a-fA-F][0-9a-fA-F]?)\s*/,

lightnessFactor: 0.2,

constructor : function(red, green, blue) {
var me = this,
clamp = Ext.Number.constrain;
me.r = clamp(red, 0, 255);
me.g = clamp(green, 0, 255);
me.b = clamp(blue, 0, 255);
},

getRed: function() {
return this.r;
},

getGreen: function() {
return this.g;
},

getBlue: function() {
return this.b;
},

getRGB: function() {
var me = this;
return [me.r, me.g, me.b];
},

getHSL: function() {
var me = this,
r = me.r / 255,
g = me.g / 255,
b = me.b / 255,
max = Math.max(r, g, b),
min = Math.min(r, g, b),
delta = max - min,
h,
s = 0,
l = 0.5 * (max + min);
// min==max means achromatic (hue is undefined)
if (min != max) {
s = (l < 0.5) ? delta / (max + min) : delta / (2 - max - min);
if (r == max) {
h = 60 * (g - b) / delta;
} else if (g == max) {
h = 120 + 60 * (b - r) / delta;
} else {
h = 240 + 60 * (r - g) / delta;
}
if (h < 0) {
h += 360;
}
if (h >= 360) {
h -= 360;
}
}
return [h, s, l];
},

getLighter: function(factor) {
var hsl = this.getHSL();
factor = factor || this.lightnessFactor;
hsl[2] = Ext.Number.constrain(hsl[2] + factor, 0, 1);
return this.fromHSL(hsl[0], hsl[1], hsl[2]);
},

getDarker: function(factor) {
factor = factor || this.lightnessFactor;
return this.getLighter(-factor);
},

toString: function() {
var me = this,
round = Math.round,
r = round(me.r).toString(16),
g = round(me.g).toString(16),
b = round(me.b).toString(16);
r = (r.length == 1) ? '0' + r : r;
g = (g.length == 1) ? '0' + g : g;
b = (b.length == 1) ? '0' + b : b;
return ['#', r, g, b].join('');
},

toHex: function(color) {
if (Ext.isArray(color)) {
color = color[0];
}
if (!Ext.isString(color)) {
return '';
}
if (color.substr(0, 1) === '#') {
return color;
}
var digits = this.colorToHexRe.exec(color),
red,
green,
blue,
rgb;
if (Ext.isArray(digits)) {
red = parseInt(digits[2], 10);
green = parseInt(digits[3], 10);
blue = parseInt(digits[4], 10);
rgb = blue | (green << 8) | (red << 16);
return digits[1] + '#' + ("000000" + rgb.toString(16)).slice(-6);
}
else {
return color;
}
},

fromString: function(str) {
var values, r, g, b,
parse = parseInt;
if ((str.length == 4 || str.length == 7) && str.substr(0, 1) === '#') {
values = str.match(this.hexRe);
if (values) {
r = parse(values[1], 16) >> 0;
g = parse(values[2], 16) >> 0;
b = parse(values[3], 16) >> 0;
if (str.length == 4) {
r += (r * 16);
g += (g * 16);
b += (b * 16);
}
}
}
else {
values = str.match(this.rgbRe);
if (values) {
r = values[1];
g = values[2];
b = values[3];
}
}
return (typeof r == 'undefined') ? undefined : new Ext.draw.Color(r, g, b);
},

getGrayscale: function() {
// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
return this.r * 0.3 + this.g * 0.59 + this.b * 0.11;
},

fromHSL: function(h, s, l) {
var C, X, m, i, rgb = [],
abs = Math.abs,
floor = Math.floor;
if (s == 0 || h == null) {
// achromatic
rgb = [l, l, l];
}
else {
// http://en.wikipedia.org/wiki/HSL_and_HSV#From_HSL
// C is the chroma
// X is the second largest component
// m is the lightness adjustment
h /= 60;
C = s * (1 - abs(2 * l - 1));
X = C * (1 - abs(h - 2 * floor(h / 2) - 1));
m = l - C / 2;
switch (floor(h)) {
case 0:
rgb = [C, X, 0];
break;
case 1:
rgb = [X, C, 0];
break;
case 2:
rgb = [0, C, X];
break;
case 3:
rgb = [0, X, C];
break;
case 4:
rgb = [X, 0, C];
break;
case 5:
rgb = [C, 0, X];
break;
}
rgb = [rgb[0] + m, rgb[1] + m, rgb[2] + m];
}
return new Ext.draw.Color(rgb[0] * 255, rgb[1] * 255, rgb[2] * 255);
}
}, function() {
var prototype = this.prototype;
//These functions are both static and instance. TODO: find a more elegant way of copying them
this.addStatics({
fromHSL: function() {
return prototype.fromHSL.apply(prototype, arguments);
},
fromString: function() {
return prototype.fromString.apply(prototype, arguments);
},
toHex: function() {
return prototype.toHex.apply(prototype, arguments);
}
});
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/draw/Draw.js */
(function(Ext) {
Ext.define('Ext.draw.Draw', {

singleton: true,
requires: ['Ext.draw.Color'],

pathToStringRE: /,?([achlmqrstvxz]),?/gi,
pathCommandRE: /([achlmqstvz])[\s,]*((-?\d*\.?\d*(?:e[-+]?\d+)?\s*,?\s*)+)/ig,
pathValuesRE: /(-?\d*\.?\d*(?:e[-+]?\d+)?)\s*,?\s*/ig,
stopsRE: /^(\d+%?)$/,
radian: Math.PI / 180,
availableAnimAttrs: {
along: "along",
blur: null,
"clip-rect": "csv",
cx: null,
cy: null,
fill: "color",
"fill-opacity": null,
"font-size": null,
height: null,
opacity: null,
path: "path",
r: null,
rotation: "csv",
rx: null,
ry: null,
scale: "csv",
stroke: "color",
"stroke-opacity": null,
"stroke-width": null,
translation: "csv",
width: null,
x: null,
y: null
},
is: function(o, type) {
type = String(type).toLowerCase();
return (type == "object" && o === Object(o)) ||
(type == "undefined" && typeof o == type) ||
(type == "null" && o === null) ||
(type == "array" && Array.isArray && Array.isArray(o)) ||
(Object.prototype.toString.call(o).toLowerCase().slice(8, -1)) == type;
},
ellipsePath: function(sprite) {
var attr = sprite.attr;
return Ext.String.format("M{0},{1}A{2},{3},0,1,1,{0},{4}A{2},{3},0,1,1,{0},{1}z", attr.x, attr.y - attr.ry, attr.rx, attr.ry, attr.y + attr.ry);
},
rectPath: function(sprite) {
var attr = sprite.attr;
if (attr.radius) {
return Ext.String.format("M{0},{1}l{2},0a{3},{3},0,0,1,{3},{3}l0,{5}a{3},{3},0,0,1,{4},{3}l{6},0a{3},{3},0,0,1,{4},{4}l0,{7}a{3},{3},0,0,1,{3},{4}z", attr.x + attr.radius, attr.y, attr.width - attr.radius * 2, attr.radius, -attr.radius, attr.height - attr.radius * 2, attr.radius * 2 - attr.width, attr.radius * 2 - attr.height);
}
else {
return Ext.String.format("M{0},{1}L{2},{1},{2},{3},{0},{3}z", attr.x, attr.y, attr.width + attr.x, attr.height + attr.y);
}
},
// To be deprecated, converts itself (an arrayPath) to a proper SVG path string
path2string: function () {
return this.join(",").replace(Ext.draw.Draw.pathToStringRE, "$1");
},
// Convert the passed arrayPath to a proper SVG path string (d attribute)
pathToString: function(arrayPath) {
return arrayPath.join(",").replace(Ext.draw.Draw.pathToStringRE, "$1");
},
parsePathString: function (pathString) {
if (!pathString) {
return null;
}
var paramCounts = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0},
data = [],
me = this;
if (me.is(pathString, "array") && me.is(pathString[0], "array")) { // rough assumption
data = me.pathClone(pathString);
}
if (!data.length) {
String(pathString).replace(me.pathCommandRE, function (a, b, c) {
var params = [],
name = b.toLowerCase();
c.replace(me.pathValuesRE, function (a, b) {
b && params.push(+b);
});
if (name == "m" && params.length > 2) {
data.push([b].concat(Ext.Array.splice(params, 0, 2)));
name = "l";
b = (b == "m") ? "l" : "L";
}
while (params.length >= paramCounts[name]) {
data.push([b].concat(Ext.Array.splice(params, 0, paramCounts[name])));
if (!paramCounts[name]) {
break;
}
}
});
}
data.toString = me.path2string;
return data;
},
mapPath: function (path, matrix) {
if (!matrix) {
return path;
}
var x, y, i, ii, j, jj, pathi;
path = this.path2curve(path);
for (i = 0, ii = path.length; i < ii; i++) {
pathi = path[i];
for (j = 1, jj = pathi.length; j < jj-1; j += 2) {
x = matrix.x(pathi[j], pathi[j + 1]);
y = matrix.y(pathi[j], pathi[j + 1]);
pathi[j] = x;
pathi[j + 1] = y;
}
}
return path;
},
pathClone: function(pathArray) {
var res = [],
j, jj, i, ii;
if (!this.is(pathArray, "array") || !this.is(pathArray && pathArray[0], "array")) { // rough assumption
pathArray = this.parsePathString(pathArray);
}
for (i = 0, ii = pathArray.length; i < ii; i++) {
res[i] = [];
for (j = 0, jj = pathArray[i].length; j < jj; j++) {
res[i][j] = pathArray[i][j];
}
}
res.toString = this.path2string;
return res;
},
pathToAbsolute: function (pathArray) {
if (!this.is(pathArray, "array") || !this.is(pathArray && pathArray[0], "array")) { // rough assumption
pathArray = this.parsePathString(pathArray);
}
var res = [],
x = 0,
y = 0,
mx = 0,
my = 0,
i = 0,
ln = pathArray.length,
r, pathSegment, j, ln2;
// MoveTo initial x/y position
if (ln && pathArray[0][0] == "M") {
x = +pathArray[0][1];
y = +pathArray[0][2];
mx = x;
my = y;
i++;
res[0] = ["M", x, y];
}
for (; i < ln; i++) {
r = res[i] = [];
pathSegment = pathArray[i];
if (pathSegment[0] != pathSegment[0].toUpperCase()) {
r[0] = pathSegment[0].toUpperCase();
switch (r[0]) {
// Elliptical Arc
case "A":
r[1] = pathSegment[1];
r[2] = pathSegment[2];
r[3] = pathSegment[3];
r[4] = pathSegment[4];
r[5] = pathSegment[5];
r[6] = +(pathSegment[6] + x);
r[7] = +(pathSegment[7] + y);
break;
// Vertical LineTo
case "V":
r[1] = +pathSegment[1] + y;
break;
// Horizontal LineTo
case "H":
r[1] = +pathSegment[1] + x;
break;
case "M":
// MoveTo
mx = +pathSegment[1] + x;
my = +pathSegment[2] + y;
default:
j = 1;
ln2 = pathSegment.length;
for (; j < ln2; j++) {
r[j] = +pathSegment[j] + ((j % 2) ? x : y);
}
}
}
else {
j = 0;
ln2 = pathSegment.length;
for (; j < ln2; j++) {
res[i][j] = pathSegment[j];
}
}
switch (r[0]) {
// ClosePath
case "Z":
x = mx;
y = my;
break;
// Horizontal LineTo
case "H":
x = r[1];
break;
// Vertical LineTo
case "V":
y = r[1];
break;
// MoveTo
case "M":
pathSegment = res[i];
ln2 = pathSegment.length;
mx = pathSegment[ln2 - 2];
my = pathSegment[ln2 - 1];
default:
pathSegment = res[i];
ln2 = pathSegment.length;
x = pathSegment[ln2 - 2];
y = pathSegment[ln2 - 1];
}
}
res.toString = this.path2string;
return res;
},
// TO BE DEPRECATED
pathToRelative: function (pathArray) {
if (!this.is(pathArray, "array") || !this.is(pathArray && pathArray[0], "array")) {
pathArray = this.parsePathString(pathArray);
}
var res = [],
x = 0,
y = 0,
mx = 0,
my = 0,
start = 0,
r,
pa,
i,
j,
k,
len,
ii,
jj,
kk;

if (pathArray[0][0] == "M") {
x = pathArray[0][1];
y = pathArray[0][2];
mx = x;
my = y;
start++;
res.push(["M", x, y]);
}
for (i = start, ii = pathArray.length; i < ii; i++) {
r = res[i] = [];
pa = pathArray[i];
if (pa[0] != pa[0].toLowerCase()) {
r[0] = pa[0].toLowerCase();
switch (r[0]) {
case "a":
r[1] = pa[1];
r[2] = pa[2];
r[3] = pa[3];
r[4] = pa[4];
r[5] = pa[5];
r[6] = +(pa[6] - x).toFixed(3);
r[7] = +(pa[7] - y).toFixed(3);
break;
case "v":
r[1] = +(pa[1] - y).toFixed(3);
break;
case "m":
mx = pa[1];
my = pa[2];
default:
for (j = 1, jj = pa.length; j < jj; j++) {
r[j] = +(pa[j] - ((j % 2) ? x : y)).toFixed(3);
}
}
} else {
r = res[i] = [];
if (pa[0] == "m") {
mx = pa[1] + x;
my = pa[2] + y;
}
for (k = 0, kk = pa.length; k < kk; k++) {
res[i][k] = pa[k];
}
}
len = res[i].length;
switch (res[i][0]) {
case "z":
x = mx;
y = my;
break;
case "h":
x += +res[i][len - 1];
break;
case "v":
y += +res[i][len - 1];
break;
default:
x += +res[i][len - 2];
y += +res[i][len - 1];
}
}
res.toString = this.path2string;
return res;
},
// Returns a path converted to a set of curveto commands
path2curve: function (path) {
var me = this,
points = me.pathToAbsolute(path),
ln = points.length,
attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
i, seg, segLn, point;

for (i = 0; i < ln; i++) {
points[i] = me.command2curve(points[i], attrs);
if (points[i].length > 7) {
points[i].shift();
point = points[i];
while (point.length) {
Ext.Array.splice(points, i++, 0, ["C"].concat(Ext.Array.splice(point, 0, 6)));
}
Ext.Array.erase(points, i, 1);
ln = points.length;
i--;
}
seg = points[i];
segLn = seg.length;
attrs.x = seg[segLn - 2];
attrs.y = seg[segLn - 1];
attrs.bx = parseFloat(seg[segLn - 4]) || attrs.x;
attrs.by = parseFloat(seg[segLn - 3]) || attrs.y;
}
return points;
},

interpolatePaths: function (path, path2) {
var me = this,
p = me.pathToAbsolute(path),
p2 = me.pathToAbsolute(path2),
attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
fixArc = function (pp, i) {
if (pp[i].length > 7) {
pp[i].shift();
var pi = pp[i];
while (pi.length) {
Ext.Array.splice(pp, i++, 0, ["C"].concat(Ext.Array.splice(pi, 0, 6)));
}
Ext.Array.erase(pp, i, 1);
ii = Math.max(p.length, p2.length || 0);
}
},
fixM = function (path1, path2, a1, a2, i) {
if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
Ext.Array.splice(path2, i, 0, ["M", a2.x, a2.y]);
a1.bx = 0;
a1.by = 0;
a1.x = path1[i][1];
a1.y = path1[i][2];
ii = Math.max(p.length, p2.length || 0);
}
},
i, ii,
seg, seg2, seglen, seg2len;
for (i = 0, ii = Math.max(p.length, p2.length || 0); i < ii; i++) {
p[i] = me.command2curve(p[i], attrs);
fixArc(p, i);
(p2[i] = me.command2curve(p2[i], attrs2));
fixArc(p2, i);
fixM(p, p2, attrs, attrs2, i);
fixM(p2, p, attrs2, attrs, i);
seg = p[i];
seg2 = p2[i];
seglen = seg.length;
seg2len = seg2.length;
attrs.x = seg[seglen - 2];
attrs.y = seg[seglen - 1];
attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
attrs2.bx = (parseFloat(seg2[seg2len - 4]) || attrs2.x);
attrs2.by = (parseFloat(seg2[seg2len - 3]) || attrs2.y);
attrs2.x = seg2[seg2len - 2];
attrs2.y = seg2[seg2len - 1];
}
return [p, p2];
},

//Returns any path command as a curveto command based on the attrs passed
command2curve: function (pathCommand, d) {
var me = this;
if (!pathCommand) {
return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
}
if (pathCommand[0] != "T" && pathCommand[0] != "Q") {
d.qx = d.qy = null;
}
switch (pathCommand[0]) {
case "M":
d.X = pathCommand[1];
d.Y = pathCommand[2];
break;
case "A":
pathCommand = ["C"].concat(me.arc2curve.apply(me, [d.x, d.y].concat(pathCommand.slice(1))));
break;
case "S":
pathCommand = ["C", d.x + (d.x - (d.bx || d.x)), d.y + (d.y - (d.by || d.y))].concat(pathCommand.slice(1));
break;
case "T":
d.qx = d.x + (d.x - (d.qx || d.x));
d.qy = d.y + (d.y - (d.qy || d.y));
pathCommand = ["C"].concat(me.quadratic2curve(d.x, d.y, d.qx, d.qy, pathCommand[1], pathCommand[2]));
break;
case "Q":
d.qx = pathCommand[1];
d.qy = pathCommand[2];
pathCommand = ["C"].concat(me.quadratic2curve(d.x, d.y, pathCommand[1], pathCommand[2], pathCommand[3], pathCommand[4]));
break;
case "L":
pathCommand = ["C"].concat(d.x, d.y, pathCommand[1], pathCommand[2], pathCommand[1], pathCommand[2]);
break;
case "H":
pathCommand = ["C"].concat(d.x, d.y, pathCommand[1], d.y, pathCommand[1], d.y);
break;
case "V":
pathCommand = ["C"].concat(d.x, d.y, d.x, pathCommand[1], d.x, pathCommand[1]);
break;
case "Z":
pathCommand = ["C"].concat(d.x, d.y, d.X, d.Y, d.X, d.Y);
break;
}
return pathCommand;
},
quadratic2curve: function (x1, y1, ax, ay, x2, y2) {
var _13 = 1 / 3,
_23 = 2 / 3;
return [
_13 * x1 + _23 * ax,
_13 * y1 + _23 * ay,
_13 * x2 + _23 * ax,
_13 * y2 + _23 * ay,
x2,
y2
];
},

rotate: function (x, y, rad) {
var cos = Math.cos(rad),
sin = Math.sin(rad),
X = x * cos - y * sin,
Y = x * sin + y * cos;
return {x: X, y: Y};
},
arc2curve: function (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
// for more information of where this Math came from visit:
// http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
var me = this,
PI = Math.PI,
radian = me.radian,
_120 = PI * 120 / 180,
rad = radian * (+angle || 0),
res = [],
math = Math,
mcos = math.cos,
msin = math.sin,
msqrt = math.sqrt,
mabs = math.abs,
masin = math.asin,
xy, x, y, h, rx2, ry2, k, cx, cy, f1, f2, df, c1, s1, c2, s2,
t, hx, hy, m1, m2, m3, m4, newres, i, ln, f2old, x2old, y2old;
if (!recursive) {
xy = me.rotate(x1, y1, -rad);
x1 = xy.x;
y1 = xy.y;
xy = me.rotate(x2, y2, -rad);
x2 = xy.x;
y2 = xy.y;
x = (x1 - x2) / 2;
y = (y1 - y2) / 2;
h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
if (h > 1) {
h = msqrt(h);
rx = h * rx;
ry = h * ry;
}
rx2 = rx * rx;
ry2 = ry * ry;
k = (large_arc_flag == sweep_flag ? -1 : 1) *
msqrt(mabs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
cx = k * rx * y / ry + (x1 + x2) / 2;
cy = k * -ry * x / rx + (y1 + y2) / 2;
f1 = masin(((y1 - cy) / ry).toFixed(7));
f2 = masin(((y2 - cy) / ry).toFixed(7));
f1 = x1 < cx ? PI - f1 : f1;
f2 = x2 < cx ? PI - f2 : f2;
if (f1 < 0) {
f1 = PI * 2 + f1;
}
if (f2 < 0) {
f2 = PI * 2 + f2;
}
if (sweep_flag && f1 > f2) {
f1 = f1 - PI * 2;
}
if (!sweep_flag && f2 > f1) {
f2 = f2 - PI * 2;
}
}
else {
f1 = recursive[0];
f2 = recursive[1];
cx = recursive[2];
cy = recursive[3];
}
df = f2 - f1;
if (mabs(df) > _120) {
f2old = f2;
x2old = x2;
y2old = y2;
f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
x2 = cx + rx * mcos(f2);
y2 = cy + ry * msin(f2);
res = me.arc2curve(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
}
df = f2 - f1;
c1 = mcos(f1);
s1 = msin(f1);
c2 = mcos(f2);
s2 = msin(f2);
t = math.tan(df / 4);
hx = 4 / 3 * rx * t;
hy = 4 / 3 * ry * t;
m1 = [x1, y1];
m2 = [x1 + hx * s1, y1 - hy * c1];
m3 = [x2 + hx * s2, y2 - hy * c2];
m4 = [x2, y2];
m2[0] = 2 * m1[0] - m2[0];
m2[1] = 2 * m1[1] - m2[1];
if (recursive) {
return [m2, m3, m4].concat(res);
}
else {
res = [m2, m3, m4].concat(res).join().split(",");
newres = [];
ln = res.length;
for (i = 0; i < ln; i++) {
newres[i] = i % 2 ? me.rotate(res[i - 1], res[i], rad).y : me.rotate(res[i], res[i + 1], rad).x;
}
return newres;
}
},
// TO BE DEPRECATED
rotateAndTranslatePath: function (sprite) {
var alpha = sprite.rotation.degrees,
cx = sprite.rotation.x,
cy = sprite.rotation.y,
dx = sprite.translation.x,
dy = sprite.translation.y,
path,
i,
p,
xy,
j,
res = [];
if (!alpha && !dx && !dy) {
return this.pathToAbsolute(sprite.attr.path);
}
dx = dx || 0;
dy = dy || 0;
path = this.pathToAbsolute(sprite.attr.path);
for (i = path.length; i--;) {
p = res[i] = path[i].slice();
if (p[0] == "A") {
xy = this.rotatePoint(p[6], p[7], alpha, cx, cy);
p[6] = xy.x + dx;
p[7] = xy.y + dy;
} else {
j = 1;
while (p[j + 1] != null) {
xy = this.rotatePoint(p[j], p[j + 1], alpha, cx, cy);
p[j] = xy.x + dx;
p[j + 1] = xy.y + dy;
j += 2;
}
}
}
return res;
},
// TO BE DEPRECATED
rotatePoint: function (x, y, alpha, cx, cy) {
if (!alpha) {
return {
x: x,
y: y
};
}
cx = cx || 0;
cy = cy || 0;
x = x - cx;
y = y - cy;
alpha = alpha * this.radian;
var cos = Math.cos(alpha),
sin = Math.sin(alpha);
return {
x: x * cos - y * sin + cx,
y: x * sin + y * cos + cy
};
},
pathDimensions: function (path) {
if (!path || !(path + "")) {
return {x: 0, y: 0, width: 0, height: 0};
}
path = this.path2curve(path);
var x = 0, 
y = 0,
X = [],
Y = [],
i = 0,
ln = path.length,
p, xmin, ymin, xmax, ymax, dim;
for (; i < ln; i++) {
p = path[i];
if (p[0] == "M") {
x = p[1];
y = p[2];
X.push(x);
Y.push(y);
}
else {
dim = this.curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
X = X.concat(dim.min.x, dim.max.x);
Y = Y.concat(dim.min.y, dim.max.y);
x = p[5];
y = p[6];
}
}
xmin = Math.min.apply(0, X);
ymin = Math.min.apply(0, Y);
xmax = Math.max.apply(0, X);
ymax = Math.max.apply(0, Y);
return {
x: Math.round(xmin),
y: Math.round(ymin),
path: path,
width: Math.round(xmax - xmin),
height: Math.round(ymax - ymin)
};
},
intersectInside: function(path, cp1, cp2) {
return (cp2[0] - cp1[0]) * (path[1] - cp1[1]) > (cp2[1] - cp1[1]) * (path[0] - cp1[0]);
},
intersectIntersection: function(s, e, cp1, cp2) {
var p = [],
dcx = cp1[0] - cp2[0],
dcy = cp1[1] - cp2[1],
dpx = s[0] - e[0],
dpy = s[1] - e[1],
n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0],
n2 = s[0] * e[1] - s[1] * e[0],
n3 = 1 / (dcx * dpy - dcy * dpx);
p[0] = (n1 * dpx - n2 * dcx) * n3;
p[1] = (n1 * dpy - n2 * dcy) * n3;
return p;
},
intersect: function(subjectPolygon, clipPolygon) {
var me = this,
i = 0,
ln = clipPolygon.length,
cp1 = clipPolygon[ln - 1],
outputList = subjectPolygon,
cp2, s, e, ln2, inputList, j;
for (; i < ln; ++i) {
cp2 = clipPolygon[i];
inputList = outputList;
outputList = [];
s = inputList[inputList.length - 1];
j = 0;
ln2 = inputList.length;
for (; j < ln2; j++) {
e = inputList[j];
if (me.intersectInside(e, cp1, cp2)) {
if (!me.intersectInside(s, cp1, cp2)) {
outputList.push(me.intersectIntersection(s, e, cp1, cp2));
}
outputList.push(e);
}
else if (me.intersectInside(s, cp1, cp2)) {
outputList.push(me.intersectIntersection(s, e, cp1, cp2));
}
s = e;
}
cp1 = cp2;
}
return outputList;
},

bezier : function (a, b, c, d, x) {
if (x === 0) {
return a;
} 
else if (x === 1) {
return d;
}
var du = 1 - x,
d3 = du * du * du,
r = x / du;
return d3 * (a + r * (3 * b + r * (3 * c + d * r)));
},

bezierDim : function (a, b, c, d) {
var points = [], r,
A, top, C, delta, bottom, s,
min, max, i;
// The min and max happens on boundary or b' == 0
if (a + 3 * c == d + 3 * b) { 
r = a - b;
r /= 2 * (a - b - b + c);
if ( r < 1 && r > 0) {
points.push(r);
}
} else {
// b'(x) / -3 = (a-3b+3c-d)x^2+ (-2a+4b-2c)x + (a-b)
// delta = -4 (-b^2+a c+b c-c^2-a d+b d)
A = a - 3 * b + 3 * c - d;
top = 2 * (a - b - b + c);
C = a - b;
delta = top * top - 4 * A * C;
bottom = A + A;
if (delta === 0) {
r = top / bottom;
if (r < 1 && r > 0) {
points.push(r);
}
} else if (delta > 0) {
s = Math.sqrt(delta);
r = (s + top) / bottom;

if (r < 1 && r > 0) {
points.push(r);
}

r = (top - s) / bottom;

if (r < 1 && r > 0) {
points.push(r);
}
}
}
min = Math.min(a, d);
max = Math.max(a, d);
for (i = 0; i < points.length; i++) {
min = Math.min(min, this.bezier(a, b, c, d, points[i]));
max = Math.max(max, this.bezier(a, b, c, d, points[i]));
}
return [min, max];
},

curveDim: function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
var x = this.bezierDim(p1x, c1x, c2x, p2x),
y = this.bezierDim(p1y, c1y, c2y, p2y);
return {
min: {
x: x[0],
y: y[0]
},
max: {
x: x[1],
y: y[1]
}
};
},

getAnchors: function (prevX, prevY, curX, curY, nextX, nextY, value) {
value = value || 4;
var M = Math,
PI = M.PI,
halfPI = PI / 2,
abs = M.abs,
sin = M.sin,
cos = M.cos,
atan = M.atan,
control1Length, control2Length, control1Angle, control2Angle,
control1X, control1Y, control2X, control2Y, alpha;
// Find the length of each control anchor line, by dividing the horizontal distance
// between points by the value parameter.
control1Length = (curX - prevX) / value;
control2Length = (nextX - curX) / value;
// Determine the angle of each control anchor line. If the middle point is a vertical
// turnaround then we force it to a flat horizontal angle to prevent the curve from
// dipping above or below the middle point. Otherwise we use an angle that points
// toward the previous/next target point.
if ((curY >= prevY && curY >= nextY) || (curY <= prevY && curY <= nextY)) {
control1Angle = control2Angle = halfPI;
} else {
control1Angle = atan((curX - prevX) / abs(curY - prevY));
if (prevY < curY) {
control1Angle = PI - control1Angle;
}
control2Angle = atan((nextX - curX) / abs(curY - nextY));
if (nextY < curY) {
control2Angle = PI - control2Angle;
}
}
// Adjust the calculated angles so they point away from each other on the same line
alpha = halfPI - ((control1Angle + control2Angle) % (PI * 2)) / 2;
if (alpha > halfPI) {
alpha -= PI;
}
control1Angle += alpha;
control2Angle += alpha;
// Find the control anchor points from the angles and length
control1X = curX - control1Length * sin(control1Angle);
control1Y = curY + control1Length * cos(control1Angle);
control2X = curX + control2Length * sin(control2Angle);
control2Y = curY + control2Length * cos(control2Angle);
// One last adjustment, make sure that no control anchor point extends vertically past
// its target prev/next point, as that results in curves dipping above or below and
// bending back strangely. If we find this happening we keep the control angle but
// reduce the length of the control line so it stays within bounds.
if ((curY > prevY && control1Y < prevY) || (curY < prevY && control1Y > prevY)) {
control1X += abs(prevY - control1Y) * (control1X - curX) / (control1Y - curY);
control1Y = prevY;
}
if ((curY > nextY && control2Y < nextY) || (curY < nextY && control2Y > nextY)) {
control2X -= abs(nextY - control2Y) * (control2X - curX) / (control2Y - curY);
control2Y = nextY;
}

return {
x1: control1X,
y1: control1Y,
x2: control2X,
y2: control2Y
};
},

smooth: function (originalPath, value) {
var path = this.path2curve(originalPath),
newp = [path[0]],
x = path[0][1],
y = path[0][2],
j,
points,
i = 1,
ii = path.length,
beg = 1,
mx = x,
my = y,
pathi,
pathil,
pathim,
pathiml,
pathip,
pathipl,
begl;

for (; i < ii; i++) {
pathi = path[i];
pathil = pathi.length;
pathim = path[i - 1];
pathiml = pathim.length;
pathip = path[i + 1];
pathipl = pathip && pathip.length;
if (pathi[0] == "M") {
mx = pathi[1];
my = pathi[2];
j = i + 1;
while (path[j][0] != "C") {
j++;
}
newp.push(["M", mx, my]);
beg = newp.length;
x = mx;
y = my;
continue;
}
if (pathi[pathil - 2] == mx && pathi[pathil - 1] == my && (!pathip || pathip[0] == "M")) {
begl = newp[beg].length;
points = this.getAnchors(pathim[pathiml - 2], pathim[pathiml - 1], mx, my, newp[beg][begl - 2], newp[beg][begl - 1], value);
newp[beg][1] = points.x2;
newp[beg][2] = points.y2;
}
else if (!pathip || pathip[0] == "M") {
points = {
x1: pathi[pathil - 2],
y1: pathi[pathil - 1]
};
} else {
points = this.getAnchors(pathim[pathiml - 2], pathim[pathiml - 1], pathi[pathil - 2], pathi[pathil - 1], pathip[pathipl - 2], pathip[pathipl - 1], value);
}
newp.push(["C", x, y, points.x1, points.y1, pathi[pathil - 2], pathi[pathil - 1]]);
x = points.x2;
y = points.y2;
}
return newp;
},
findDotAtSegment: function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
var t1 = 1 - t;
return {
x: Math.pow(t1, 3) * p1x + Math.pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + Math.pow(t, 3) * p2x,
y: Math.pow(t1, 3) * p1y + Math.pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + Math.pow(t, 3) * p2y
};
},

snapEnds: function (from, to, stepsMax, prettyNumbers) {
if (Ext.isDate(from)) {
return this.snapEndsByDate(from, to, stepsMax);
}
var step = (to - from) / stepsMax,
level = Math.floor(Math.log(step) / Math.LN10) + 1,
m = Math.pow(10, level),
cur,
floor,
modulo = Math.round((step % m) * Math.pow(10, 2 - level)),
interval = [[0, 15], [10, 1], [20, 4], [25, 2], [50, 9], [100, 15]],
stepCount = 0,
value,
weight,
i,
topValue,
topWeight = 1e9,
ln = interval.length;
floor = Math.floor(from / m) * m;
if (from == floor && floor > 0) {
floor = Math.floor((from - (m/10)) / m) * m;
}

if (prettyNumbers) {
for (i = 0; i < ln; i++) {
value = interval[i][0];
weight = (value - modulo) < 0 ? 1e6 : (value - modulo) / interval[i][1];
if (weight < topWeight) {
topValue = value;
topWeight = weight;
}
}
step = Math.floor(step * Math.pow(10, -level)) * Math.pow(10, level) + topValue * Math.pow(10, level - 2);
if (from < 0 && to >= 0) {
cur = 0;
while (cur > from) {
cur -= step;
stepCount++;
}
from = +cur.toFixed(10);
cur = 0;
while (cur < to) {
cur += step;
stepCount++;
}
to = +cur.toFixed(10);
} else {
cur = from = floor;
while (cur < to) {
cur += step;
stepCount++;
}
}
to = +cur.toFixed(10);
} else {
from = floor;
stepCount = stepsMax;
}

return {
from: from,
to: to,
power: level,
step: step,
steps: stepCount
};
},

snapEndsByDate: function (from, to, stepsMax, lockEnds) {
var selectedStep = false,
scales = [
[Ext.Date.MILLI, [1, 2, 5, 10, 20, 50, 100, 200, 250, 500]],
[Ext.Date.SECOND, [1, 2, 5, 10, 15, 30]],
[Ext.Date.MINUTE, [1, 2, 5, 10, 15, 30]],
[Ext.Date.HOUR, [1, 2, 3, 4, 6, 12]],
[Ext.Date.DAY, [1, 2, 7, 14]],
[Ext.Date.MONTH, [1, 2, 3, 6]]
],
sLen = scales.length,
stop = false,
scale, j, yearDiff, s;
// Find the most desirable scale
for (s = 0; s < sLen; s++) {
scale = scales[s];
if (!stop) {
for (j = 0; j < scale[1].length; j++) {
if (to < Ext.Date.add(from, scale[0], scale[1][j] * stepsMax)) {
selectedStep = [scale[0], scale[1][j]];
stop = true;
break;
}
}
}
}
if (!selectedStep) {
yearDiff = this.snapEnds(from.getFullYear(), to.getFullYear() + 1, stepsMax, lockEnds);
selectedStep = [Date.YEAR, Math.round(yearDiff.step)];
}
return this.snapEndsByDateAndStep(from, to, selectedStep, lockEnds);
},

snapEndsByDateAndStep: function(from, to, step, lockEnds) {
var fromStat = [from.getFullYear(), from.getMonth(), from.getDate(),
from.getHours(), from.getMinutes(), from.getSeconds(), from.getMilliseconds()],
steps, testFrom, testTo, date, year, month, day, fractionalMonth,
stepUnit = step[0], stepValue = step[1];
if (lockEnds) {
testFrom = from;
} else {
switch (stepUnit) {
case Ext.Date.MILLI:
testFrom = new Date(fromStat[0], fromStat[1], fromStat[2], fromStat[3],
fromStat[4], fromStat[5], Math.floor(fromStat[6] / stepValue) * stepValue);
break;
case Ext.Date.SECOND:
testFrom = new Date(fromStat[0], fromStat[1], fromStat[2], fromStat[3],
fromStat[4], Math.floor(fromStat[5] / stepValue) * stepValue, 0);
break;
case Ext.Date.MINUTE:
testFrom = new Date(fromStat[0], fromStat[1], fromStat[2], fromStat[3],
Math.floor(fromStat[4] / stepValue) * stepValue, 0, 0);
break;
case Ext.Date.HOUR:
testFrom = new Date(fromStat[0], fromStat[1], fromStat[2],
Math.floor(fromStat[3] / stepValue) * stepValue, 0, 0, 0);
break;
case Ext.Date.DAY:
testFrom = new Date(fromStat[0], fromStat[1],
Math.floor((fromStat[2] - 1) / stepValue) * stepValue + 1, 0, 0, 0, 0);
break;
case Ext.Date.MONTH:
testFrom = new Date(fromStat[0], Math.floor(fromStat[1] / stepValue) * stepValue, 1, 0, 0, 0, 0);
break;
default: // Ext.Date.YEAR
testFrom = new Date(Math.floor(fromStat[0] / stepValue) * stepValue, 0, 1, 0, 0, 0, 0);
break;
}
}
fractionalMonth = ((stepUnit === Ext.Date.MONTH) && (stepValue == 1/2 || stepValue == 1/3 || stepValue == 1/4));
steps = (fractionalMonth ? [] : 0);
// TODO(zhangbei) : We can do it better somehow...
testTo = new Date(testFrom);
while (testTo < to) {
if (fractionalMonth) {
date = new Date(testTo);
year = date.getFullYear();
month = date.getMonth();
day = date.getDate();
switch(stepValue) {
case 1/2: // the 1st and 15th of every month
if (day >= 15) {
day = 1;
if (++month > 11) {
year++;
}
}
else {
day = 15;
}
break;
case 1/3: // the 1st, 10th and 20th of every month
if (day >= 20) {
day = 1;
if (++month > 11) {
year++;
}
}
else {
if (day >= 10) {
day = 20
}
else {
day = 10;
}
}
break;
case 1/4: // the 1st, 8th, 15th and 22nd of every month
if (day >= 22) {
day = 1;
if (++month > 11) {
year++;
}
}
else {
if (day >= 15) {
day = 22
}
else {
if (day >= 8) {
day = 15
}
else {
day = 8;
}
}
}
break;
}
testTo.setYear(year);
testTo.setMonth(month);
testTo.setDate(day);
steps.push(new Date(testTo));
}
else {
testTo = Ext.Date.add(testTo, stepUnit, stepValue); 
steps++;
}
}
if (lockEnds) {
testTo = to;
}

if (fractionalMonth) {
return {
from : +testFrom,
to : +testTo,
steps : steps // array of steps
}; 
}
else {
return {
from : +testFrom,
to : +testTo,
step : (testTo - testFrom) / steps,
steps : steps // number of steps
}; 
}
},
sorter: function (a, b) {
return a.offset - b.offset;
},
rad: function(degrees) {
return degrees % 360 * Math.PI / 180;
},
degrees: function(radian) {
return radian * 180 / Math.PI % 360;
},
withinBox: function(x, y, bbox) {
bbox = bbox || {};
return (x >= bbox.x && x <= (bbox.x + bbox.width) && y >= bbox.y && y <= (bbox.y + bbox.height));
},
parseGradient: function(gradient) {
var me = this,
type = gradient.type || 'linear',
angle = gradient.angle || 0,
radian = me.radian,
stops = gradient.stops,
stopsArr = [],
stop,
vector,
max,
stopObj;
if (type == 'linear') {
vector = [0, 0, Math.cos(angle * radian), Math.sin(angle * radian)];
max = 1 / (Math.max(Math.abs(vector[2]), Math.abs(vector[3])) || 1);
vector[2] *= max;
vector[3] *= max;
if (vector[2] < 0) {
vector[0] = -vector[2];
vector[2] = 0;
}
if (vector[3] < 0) {
vector[1] = -vector[3];
vector[3] = 0;
}
}
for (stop in stops) {
if (stops.hasOwnProperty(stop) && me.stopsRE.test(stop)) {
stopObj = {
offset: parseInt(stop, 10),
color: Ext.draw.Color.toHex(stops[stop].color) || '#ffffff',
opacity: stops[stop].opacity || 1
};
stopsArr.push(stopObj);
}
}
// Sort by pct property
Ext.Array.sort(stopsArr, me.sorter);
if (type == 'linear') {
return {
id: gradient.id,
type: type,
vector: vector,
stops: stopsArr
};
}
else {
return {
id: gradient.id,
type: type,
centerX: gradient.centerX,
centerY: gradient.centerY,
focalX: gradient.focalX,
focalY: gradient.focalY,
radius: gradient.radius,
vector: vector,
stops: stopsArr
};
}
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/fx/PropertyHandler.js */
(function(Ext) {
Ext.define('Ext.fx.PropertyHandler', {

requires: ['Ext.draw.Draw'],
statics: {
defaultHandler: {
pixelDefaultsRE: /width|height|top$|bottom$|left$|right$/i,
unitRE: /^(-?\d*\.?\d*){1}(em|ex|px|in|cm|mm|pt|pc|%)*$/,
scrollRE: /^scroll/i,
computeDelta: function(from, end, damper, initial, attr) {
damper = (typeof damper == 'number') ? damper : 1;
var unitRE = this.unitRE,
match = unitRE.exec(from),
start, units;
if (match) {
from = match[1];
units = match[2];
if (!this.scrollRE.test(attr) && !units && this.pixelDefaultsRE.test(attr)) {
units = 'px';
}
}
from = +from || 0;
match = unitRE.exec(end);
if (match) {
end = match[1];
units = match[2] || units;
}
end = +end || 0;
start = (initial != null) ? initial : from;
return {
from: from,
delta: (end - start) * damper,
units: units
};
},
get: function(from, end, damper, initialFrom, attr) {
var ln = from.length,
out = [],
i, initial, res, j, len;
for (i = 0; i < ln; i++) {
if (initialFrom) {
initial = initialFrom[i][1].from;
}
if (Ext.isArray(from[i][1]) && Ext.isArray(end)) {
res = [];
j = 0;
len = from[i][1].length;
for (; j < len; j++) {
res.push(this.computeDelta(from[i][1][j], end[j], damper, initial, attr));
}
out.push([from[i][0], res]);
}
else {
out.push([from[i][0], this.computeDelta(from[i][1], end, damper, initial, attr)]);
}
}
return out;
},
set: function(values, easing) {
var ln = values.length,
out = [],
i, val, res, len, j;
for (i = 0; i < ln; i++) {
val = values[i][1];
if (Ext.isArray(val)) {
res = [];
j = 0;
len = val.length;
for (; j < len; j++) {
res.push(val[j].from + val[j].delta * easing + (val[j].units || 0));
}
out.push([values[i][0], res]);
} else {
out.push([values[i][0], val.from + val.delta * easing + (val.units || 0)]);
}
}
return out;
}
},
stringHandler: {
computeDelta: function(from, end, damper, initial, attr) {
return {
from: from,
delta: end
};
},
get: function(from, end, damper, initialFrom, attr) {
var ln = from.length,
out = [],
i, initial, res, j, len;
for (i = 0; i < ln; i++) {
out.push([from[i][0], this.computeDelta(from[i][1], end, damper, initial, attr)]);
}
return out;
},
set: function(values, easing) {
var ln = values.length,
out = [],
i, val, res, len, j;
for (i = 0; i < ln; i++) {
val = values[i][1];
out.push([values[i][0], val.delta]);
}
return out;
}
},
color: {
rgbRE: /^rgb\(([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\)$/i,
hexRE: /^#?([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})$/i,
hex3RE: /^#?([0-9A-F]{1})([0-9A-F]{1})([0-9A-F]{1})$/i,
parseColor : function(color, damper) {
damper = (typeof damper == 'number') ? damper : 1;
var out = false,
reList = [this.hexRE, this.rgbRE, this.hex3RE],
length = reList.length,
match, base, re, i;
for (i = 0; i < length; i++) {
re = reList[i];
base = (i % 2 === 0) ? 16 : 10;
match = re.exec(color);
if (match && match.length === 4) {
if (i === 2) {
match[1] += match[1];
match[2] += match[2];
match[3] += match[3];
}
out = {
red: parseInt(match[1], base),
green: parseInt(match[2], base),
blue: parseInt(match[3], base)
};
break;
}
}
return out || color;
},
computeDelta: function(from, end, damper, initial) {
from = this.parseColor(from);
end = this.parseColor(end, damper);
var start = initial ? initial : from,
tfrom = typeof start,
tend = typeof end;
//Extra check for when the color string is not recognized.
if (tfrom == 'string' || tfrom == 'undefined'
|| tend == 'string' || tend == 'undefined') {
return end || start;
}
return {
from: from,
delta: {
red: Math.round((end.red - start.red) * damper),
green: Math.round((end.green - start.green) * damper),
blue: Math.round((end.blue - start.blue) * damper)
}
};
},
get: function(start, end, damper, initialFrom) {
var ln = start.length,
out = [],
i, initial;
for (i = 0; i < ln; i++) {
if (initialFrom) {
initial = initialFrom[i][1].from;
}
out.push([start[i][0], this.computeDelta(start[i][1], end, damper, initial)]);
}
return out;
},
set: function(values, easing) {
var ln = values.length,
out = [],
i, val, parsedString, from, delta;
for (i = 0; i < ln; i++) {
val = values[i][1];
if (val) {
from = val.from;
delta = val.delta;
//multiple checks to reformat the color if it can't recognized by computeDelta.
val = (typeof val == 'object' && 'red' in val)? 
'rgb(' + val.red + ', ' + val.green + ', ' + val.blue + ')' : val;
val = (typeof val == 'object' && val.length)? val[0] : val;
if (typeof val == 'undefined') {
return [];
}
parsedString = typeof val == 'string'? val :
'rgb(' + [
(from.red + Math.round(delta.red * easing)) % 256,
(from.green + Math.round(delta.green * easing)) % 256,
(from.blue + Math.round(delta.blue * easing)) % 256
].join(',') + ')';
out.push([
values[i][0],
parsedString
]);
}
}
return out;
}
},
object: {
interpolate: function(prop, damper) {
damper = (typeof damper == 'number') ? damper : 1;
var out = {},
p;
for(p in prop) {
out[p] = parseFloat(prop[p]) * damper;
}
return out;
},
computeDelta: function(from, end, damper, initial) {
from = this.interpolate(from);
end = this.interpolate(end, damper);
var start = initial ? initial : from,
delta = {},
p;
for(p in end) {
delta[p] = end[p] - start[p];
}
return {
from: from,
delta: delta
};
},
get: function(start, end, damper, initialFrom) {
var ln = start.length,
out = [],
i, initial;
for (i = 0; i < ln; i++) {
if (initialFrom) {
initial = initialFrom[i][1].from;
}
out.push([start[i][0], this.computeDelta(start[i][1], end, damper, initial)]);
}
return out;
},
set: function(values, easing) {
var ln = values.length,
out = [],
outObject = {},
i, from, delta, val, p;
for (i = 0; i < ln; i++) {
val = values[i][1];
from = val.from;
delta = val.delta;
for (p in from) {
outObject[p] = from[p] + delta[p] * easing;
}
out.push([
values[i][0],
outObject
]);
}
return out;
}
},
path: {
computeDelta: function(from, end, damper, initial) {
damper = (typeof damper == 'number') ? damper : 1;
var start;
from = +from || 0;
end = +end || 0;
start = (initial != null) ? initial : from;
return {
from: from,
delta: (end - start) * damper
};
},
forcePath: function(path) {
if (!Ext.isArray(path) && !Ext.isArray(path[0])) {
path = Ext.draw.Draw.parsePathString(path);
}
return path;
},
get: function(start, end, damper, initialFrom) {
var endPath = this.forcePath(end),
out = [],
startLn = start.length,
startPathLn, pointsLn, i, deltaPath, initial, j, k, path, startPath;
for (i = 0; i < startLn; i++) {
startPath = this.forcePath(start[i][1]);
deltaPath = Ext.draw.Draw.interpolatePaths(startPath, endPath);
startPath = deltaPath[0];
endPath = deltaPath[1];
startPathLn = startPath.length;
path = [];
for (j = 0; j < startPathLn; j++) {
deltaPath = [startPath[j][0]];
pointsLn = startPath[j].length;
for (k = 1; k < pointsLn; k++) {
initial = initialFrom && initialFrom[0][1][j][k].from;
deltaPath.push(this.computeDelta(startPath[j][k], endPath[j][k], damper, initial));
}
path.push(deltaPath);
}
out.push([start[i][0], path]);
}
return out;
},
set: function(values, easing) {
var ln = values.length,
out = [],
i, j, k, newPath, calcPath, deltaPath, deltaPathLn, pointsLn;
for (i = 0; i < ln; i++) {
deltaPath = values[i][1];
newPath = [];
deltaPathLn = deltaPath.length;
for (j = 0; j < deltaPathLn; j++) {
calcPath = [deltaPath[j][0]];
pointsLn = deltaPath[j].length;
for (k = 1; k < pointsLn; k++) {
calcPath.push(deltaPath[j][k].from + deltaPath[j][k].delta * easing);
}
newPath.push(calcPath.join(','));
}
out.push([values[i][0], newPath.join(',')]);
}
return out;
}
}

}
}, function() {
//set color properties to color interpolator
var props = [
'outlineColor',
'backgroundColor',
'borderColor',
'borderTopColor',
'borderRightColor',
'borderBottomColor',
'borderLeftColor',
'fill',
'stroke'
],
length = props.length,
i = 0,
prop;
for (; i<length; i++) {
prop = props[i];
this[prop] = this.color;
}

//set string properties to string
props = ['cursor'];
length = props.length;
i = 0;
for (; i<length; i++) {
prop = props[i];
this[prop] = this.stringHandler;
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/fx/Anim.js */
(function(Ext) {
Ext.define('Ext.fx.Anim', {

mixins: {
observable: 'Ext.util.Observable'
},
requires: ['Ext.fx.Manager', 'Ext.fx.Animator', 'Ext.fx.Easing', 'Ext.fx.CubicBezier', 'Ext.fx.PropertyHandler'],


isAnimation: true,



duration: 250,

delay: 0,

delayStart: 0,

dynamic: false,

easing: 'ease',


damper: 1,

bezierRE: /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,

reverse: false,

running: false,

paused: false,

iterations: 1,

alternate: false,

currentIteration: 0,

startTime: 0,





// @private
frameCount: 0,
// @private
constructor: function(config) {
var me = this,
curve;

config = config || {};
// If keyframes are passed, they really want an Animator instead.
if (config.keyframes) {
return new Ext.fx.Animator(config);
}
Ext.apply(me, config);
if (me.from === undefined) {
me.from = {};
}
me.propHandlers = {};
me.config = config;
me.target = Ext.fx.Manager.createTarget(me.target);
me.easingFn = Ext.fx.Easing[me.easing];
me.target.dynamic = me.dynamic;
// If not a pre-defined curve, try a cubic-bezier
if (!me.easingFn) {
me.easingFn = String(me.easing).match(me.bezierRE);
if (me.easingFn && me.easingFn.length == 5) {
curve = me.easingFn;
me.easingFn = Ext.fx.CubicBezier.cubicBezier(+curve[1], +curve[2], +curve[3], +curve[4]);
}
}
me.id = Ext.id(null, 'ext-anim-');
me.addEvents(

'beforeanimate',

'afteranimate',

'lastframe'
);
me.mixins.observable.constructor.call(me);
Ext.fx.Manager.addAnim(me);
},

setAttr: function(attr, value) {
return Ext.fx.Manager.items.get(this.id).setAttr(this.target, attr, value);
},

initAttrs: function() {
var me = this,
from = me.from,
to = me.to,
initialFrom = me.initialFrom || {},
out = {},
start, end, propHandler, attr;
for (attr in to) {
if (to.hasOwnProperty(attr)) {
start = me.target.getAttr(attr, from[attr]);
end = to[attr];
// Use default (numeric) property handler
if (!Ext.fx.PropertyHandler[attr]) {
if (Ext.isObject(end)) {
propHandler = me.propHandlers[attr] = Ext.fx.PropertyHandler.object;
} else {
propHandler = me.propHandlers[attr] = Ext.fx.PropertyHandler.defaultHandler;
}
}
// Use custom handler
else {
propHandler = me.propHandlers[attr] = Ext.fx.PropertyHandler[attr];
}
out[attr] = propHandler.get(start, end, me.damper, initialFrom[attr], attr);
}
}
me.currentAttrs = out;
},

start: function(startTime) {
var me = this,
delay = me.delay,
delayStart = me.delayStart,
delayDelta;

if (delay) {
if (!delayStart) {
me.delayStart = startTime;
return;
}
else {
delayDelta = startTime - delayStart;
if (delayDelta < delay) {
return;
}
else {
// Compensate for frame delay;
startTime = new Date(delayStart.getTime() + delay);
}
}
}
if (me.fireEvent('beforeanimate', me) !== false) {
me.startTime = startTime;
if (!me.paused && !me.currentAttrs) {
me.initAttrs();
}
me.running = true;
me.frameCount = 0;
}
},

runAnim: function(elapsedTime) {
var me = this,
attrs = me.currentAttrs,
duration = me.duration,
easingFn = me.easingFn,
propHandlers = me.propHandlers,
ret = {},
easing, values, attr, lastFrame;
if (elapsedTime >= duration) {
elapsedTime = duration;
lastFrame = true;
}
if (me.reverse) {
elapsedTime = duration - elapsedTime;
}
for (attr in attrs) {
if (attrs.hasOwnProperty(attr)) {
values = attrs[attr];
easing = lastFrame ? 1 : easingFn(elapsedTime / duration);
ret[attr] = propHandlers[attr].set(values, easing);
}
}
me.frameCount++;

return ret;
},

lastFrame: function() {
var me = this,
iter = me.iterations,
iterCount = me.currentIteration;
iterCount++;
if (iterCount < iter) {
if (me.alternate) {
me.reverse = !me.reverse;
}
me.startTime = new Date();
me.currentIteration = iterCount;
// Turn off paused for CSS3 Transitions
me.paused = false;
}
else {
me.currentIteration = 0;
me.end();
me.fireEvent('lastframe', me, me.startTime);
}
},
endWasCalled: 0,

end: function() {
if (this.endWasCalled++) {
return;
}
var me = this;
me.startTime = 0;
me.paused = false;
me.running = false;
Ext.fx.Manager.removeAnim(me);
me.fireEvent('afteranimate', me, me.startTime);
Ext.callback(me.callback, me.scope, [me, me.startTime]);
},

isReady: function() {
return this.paused === false && this.running === false && this.iterations > 0;
},

isRunning: function() {
return this.paused === false && this.running === true && this.isAnimator !== true;
}
});
// Set flag to indicate that Fx is available. Class might not be available immediately.
Ext.enableFx = true;
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/util/Animate.js */
(function(Ext) {
Ext.define('Ext.util.Animate', {
requires: [
'Ext.Element', 
'Ext.CompositeElementLite',
'Ext.fx.Manager', 
'Ext.fx.Anim'
],

isAnimate: true,

animate: function(animObj) {
var me = this;
if (Ext.fx.Manager.hasFxBlock(me.id)) {
return me;
}
Ext.fx.Manager.queueFx(new Ext.fx.Anim(me.anim(animObj)));
return this;
},
// @private - process the passed fx configuration.
anim: function(config) {
if (!Ext.isObject(config)) {
return (config) ? {} : false;
}
var me = this;
if (config.stopAnimation) {
me.stopAnimation();
}
Ext.applyIf(config, Ext.fx.Manager.getFxDefaults(me.id));
return Ext.apply({
target: me,
paused: true
}, config);
},

stopFx: Ext.Function.alias(Ext.util.Animate, 'stopAnimation'),

stopAnimation: function() {
Ext.fx.Manager.stopAnimation(this.id);
return this;
},

syncFx: function() {
Ext.fx.Manager.setFxDefaults(this.id, {
concurrent: true
});
return this;
},

sequenceFx: function() {
Ext.fx.Manager.setFxDefaults(this.id, {
concurrent: false
});
return this;
},

hasActiveFx: Ext.Function.alias(Ext.util.Animate, 'getActiveAnimation'),

getActiveAnimation: function() {
return Ext.fx.Manager.getActiveAnimation(this.id);
}
}, function(){
// Apply Animate mixin manually until Element is defined in the proper 4.x way
Ext.applyIf(Ext.Element.prototype, this.prototype);
// We need to call this again so the animation methods get copied over to CE
Ext.CompositeElementLite.importElementMethods();
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/util/ElementContainer.js */
(function(Ext) {
Ext.define('Ext.util.ElementContainer', {
childEls: [
// empty - this solves a couple problems:
// 1. It ensures that all classes have a childEls (avoid null ptr)
// 2. It prevents mixins from smashing on their own childEls (these are gathered
// specifically)
],
constructor: function () {
var me = this,
childEls;
// if we have configured childEls, we need to merge them with those from this
// class, its bases and the set of mixins...
if (me.hasOwnProperty('childEls')) {
childEls = me.childEls;
delete me.childEls;
me.addChildEls.apply(me, childEls);
}
},
destroy: function () {
var me = this,
childEls = me.getChildEls(),
child, childName, i, k;
for (i = childEls.length; i--; ) {
childName = childEls[i];
if (typeof childName != 'string') {
childName = childName.name;
}
child = me[childName];
if (child) {
me[childName] = null; // better than delete since that changes the "shape"
child.remove();
}
}
},

addChildEls: function () {
var me = this,
args = arguments;
if (me.hasOwnProperty('childEls')) {
me.childEls.push.apply(me.childEls, args);
} else {
me.childEls = me.getChildEls().concat(Array.prototype.slice.call(args));
}

me.prune(me.childEls, false);
},

applyChildEls: function(el, id) {
var me = this,
childEls = me.getChildEls(),
baseId, childName, i, selector, value;
baseId = (id || me.id) + '-';
for (i = childEls.length; i--; ) {
childName = childEls[i];
if (typeof childName == 'string') {
// We don't use Ext.get because that is 3x (or more) slower on IE6-8. Since
// we know the el's are children of our el we use getById instead:
value = el.getById(baseId + childName);
} else {
if ((selector = childName.select)) {
value = Ext.select(selector, true, el.dom); // a CompositeElement
} else if ((selector = childName.selectNode)) {
value = Ext.get(Ext.DomQuery.selectNode(selector, el.dom));
} else {
// see above re:getById...
value = el.getById(childName.id || (baseId + childName.itemId));
}
childName = childName.name;
}
me[childName] = value;
}
},
getChildEls: function () {
var me = this,
self;
// If an instance has its own childEls, that is the complete set:
if (me.hasOwnProperty('childEls')) {
return me.childEls;
}
// Typically, however, the childEls is a class-level concept, so check to see if
// we have cached the complete set on the class:
self = me.self;
return self.$childEls || me.getClassChildEls(self);
},
getClassChildEls: function (cls) {
var me = this,
result = cls.$childEls,
childEls, i, length, forked, mixin, mixins, name, parts, proto, supr, superMixins;
if (!result) {
// We put the various childEls arrays into parts in the order of superclass,
// new mixins and finally from cls. These parts can be null or undefined and
// we will skip them later.
supr = cls.superclass;
if (supr) {
supr = supr.self;
parts = [supr.$childEls || me.getClassChildEls(supr)]; // super+mixins
superMixins = supr.prototype.mixins || {};
} else {
parts = [];
superMixins = {};
}
proto = cls.prototype;
mixins = proto.mixins; // since we are a mixin, there will be at least us
for (name in mixins) {
if (mixins.hasOwnProperty(name) && !superMixins.hasOwnProperty(name)) {
mixin = mixins[name].self;
parts.push(mixin.$childEls || me.getClassChildEls(mixin));
}
}
parts.push(proto.hasOwnProperty('childEls') && proto.childEls);
for (i = 0, length = parts.length; i < length; ++i) {
childEls = parts[i];
if (childEls && childEls.length) {
if (!result) {
result = childEls;
} else {
if (!forked) {
forked = true;
result = result.slice(0);
}
result.push.apply(result, childEls);
}
}
}
cls.$childEls = result = (result ? me.prune(result, !forked) : []);
}
return result;
},
prune: function (childEls, shared) {
var index = childEls.length,
map = {},
name;
while (index--) {
name = childEls[index];
if (typeof name != 'string') {
name = name.name;
}
if (!map[name]) {
map[name] = 1;
} else {
if (shared) {
shared = false;
childEls = childEls.slice(0);
}
Ext.Array.erase(childEls, index, 1);
}
}
return childEls;
},

removeChildEls: function (testFn) {
var me = this,
old = me.getChildEls(),
keepers = (me.childEls = []),
n, i, cel;
for (i = 0, n = old.length; i < n; ++i) {
cel = old[i];
if (!testFn(cel)) {
keepers.push(cel);
}
}
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/util/Renderable.js */
(function(Ext) {
Ext.define('Ext.util.Renderable', {
requires: [
'Ext.dom.Element'
],
frameCls: Ext.baseCSSPrefix + 'frame',
frameIdRegex: /[\-]frame\d+[TMB][LCR]$/,

frameElNames: ['TL','TC','TR','ML','MC','MR','BL','BC','BR'],
frameTpl: [
'{%this.renderDockedItems(out,values,0);%}',
'<tpl if="top">',
'<tpl if="left"><div id="{fgid}TL" class="{frameCls}-tl {baseCls}-tl {baseCls}-{ui}-tl<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tl</tpl>{frameElCls}" role="presentation"></tpl>',
'<tpl if="right"><div id="{fgid}TR" class="{frameCls}-tr {baseCls}-tr {baseCls}-{ui}-tr<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tr</tpl>{frameElCls}" role="presentation"></tpl>',
'<div id="{fgid}TC" class="{frameCls}-tc {baseCls}-tc {baseCls}-{ui}-tc<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tc</tpl>{frameElCls}" role="presentation"></div>',
'<tpl if="right"></div></tpl>',
'<tpl if="left"></div></tpl>',
'</tpl>',
'<tpl if="left"><div id="{fgid}ML" class="{frameCls}-ml {baseCls}-ml {baseCls}-{ui}-ml<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-ml</tpl>{frameElCls}" role="presentation"></tpl>',
'<tpl if="right"><div id="{fgid}MR" class="{frameCls}-mr {baseCls}-mr {baseCls}-{ui}-mr<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-mr</tpl>{frameElCls}" role="presentation"></tpl>',
'<div id="{fgid}MC" class="{frameCls}-mc {baseCls}-mc {baseCls}-{ui}-mc<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-mc</tpl>{frameElCls}" role="presentation">',
'{%this.applyRenderTpl(out, values)%}',
'</div>',
'<tpl if="right"></div></tpl>',
'<tpl if="left"></div></tpl>',
'<tpl if="bottom">',
'<tpl if="left"><div id="{fgid}BL" class="{frameCls}-bl {baseCls}-bl {baseCls}-{ui}-bl<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-bl</tpl>{frameElCls}" role="presentation"></tpl>',
'<tpl if="right"><div id="{fgid}BR" class="{frameCls}-br {baseCls}-br {baseCls}-{ui}-br<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-br</tpl>{frameElCls}" role="presentation"></tpl>',
'<div id="{fgid}BC" class="{frameCls}-bc {baseCls}-bc {baseCls}-{ui}-bc<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-bc</tpl>{frameElCls}" role="presentation"></div>',
'<tpl if="right"></div></tpl>',
'<tpl if="left"></div></tpl>',
'</tpl>',
'{%this.renderDockedItems(out,values,1);%}'
],
frameTableTpl: [
'{%this.renderDockedItems(out,values,0);%}',
'<table class="', Ext.plainTableCls, '" cellpadding="0"><tbody>',
'<tpl if="top">',
'<tr>',
'<tpl if="left"><td id="{fgid}TL" class="{frameCls}-tl {baseCls}-tl {baseCls}-{ui}-tl<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tl</tpl>{frameElCls}" role="presentation"></td></tpl>',
'<td id="{fgid}TC" class="{frameCls}-tc {baseCls}-tc {baseCls}-{ui}-tc<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tc</tpl>{frameElCls}" role="presentation"></td>',
'<tpl if="right"><td id="{fgid}TR" class="{frameCls}-tr {baseCls}-tr {baseCls}-{ui}-tr<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-tr</tpl>{frameElCls}" role="presentation"></td></tpl>',
'</tr>',
'</tpl>',
'<tr>',
'<tpl if="left"><td id="{fgid}ML" class="{frameCls}-ml {baseCls}-ml {baseCls}-{ui}-ml<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-ml</tpl>{frameElCls}" role="presentation"></td></tpl>',
'<td id="{fgid}MC" class="{frameCls}-mc {baseCls}-mc {baseCls}-{ui}-mc<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-mc</tpl>{frameElCls}" role="presentation">',
'{%this.applyRenderTpl(out, values)%}',
'</td>',
'<tpl if="right"><td id="{fgid}MR" class="{frameCls}-mr {baseCls}-mr {baseCls}-{ui}-mr<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-mr</tpl>{frameElCls}" role="presentation"></td></tpl>',
'</tr>',
'<tpl if="bottom">',
'<tr>',
'<tpl if="left"><td id="{fgid}BL" class="{frameCls}-bl {baseCls}-bl {baseCls}-{ui}-bl<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-bl</tpl>{frameElCls}" role="presentation"></td></tpl>',
'<td id="{fgid}BC" class="{frameCls}-bc {baseCls}-bc {baseCls}-{ui}-bc<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-bc</tpl>{frameElCls}" role="presentation"></td>',
'<tpl if="right"><td id="{fgid}BR" class="{frameCls}-br {baseCls}-br {baseCls}-{ui}-br<tpl for="uiCls"> {parent.baseCls}-{parent.ui}-{.}-br</tpl>{frameElCls}" role="presentation"></td></tpl>',
'</tr>',
'</tpl>',
'</tbody></table>',
'{%this.renderDockedItems(out,values,1);%}'
],

afterRender : function() {
var me = this,
data = {},
protoEl = me.protoEl,
target = me.el,
item, pre, hide, contentEl;
me.finishRenderChildren();

// We need to do the contentEl here because it depends on the layout items (inner/outerCt)
// to be rendered before we can put it in
if (me.contentEl) {
pre = Ext.baseCSSPrefix;
hide = pre + 'hide-';
contentEl = Ext.get(me.contentEl);
contentEl.removeCls([pre+'hidden', hide+'display', hide+'offsets', hide+'nosize']);
me.getContentTarget().appendChild(contentEl.dom);
}
protoEl.writeTo(data);

// Here we apply any styles that were set on the protoEl during the rendering phase
// A majority of times this will not happen, but we still need to handle it

item = data.removed;
if (item) {
target.removeCls(item);
}

item = data.cls;
if (item.length) {
target.addCls(item);
}

item = data.style;
if (data.style) {
target.setStyle(item);
}

me.protoEl = null;
// If this is the outermost Container, lay it out as soon as it is rendered.
if (!me.ownerCt) {
me.updateLayout();
}
},
afterFirstLayout : function(width, height) {
var me = this,
x = me.x,
y = me.y,
hasX,
hasY,
pos, xy;
// We only have to set absolute position here if there is no ownerlayout which should take responsibility.
// Consider the example of rendered components outside of a viewport - these might need their positions setting.
if (!me.ownerLayout) {
hasX = Ext.isDefined(x);
hasY = Ext.isDefined(y);
}
// For floaters, calculate x and y if they aren't defined by aligning
// the sized element to the center of either the container or the ownerCt
if (me.floating && (!hasX || !hasY)) {
if (me.floatParent) {
pos = me.floatParent.getTargetEl().getViewRegion();
xy = me.el.getAlignToXY(me.floatParent.getTargetEl(), 'c-c');
pos.x = xy[0] - pos.x;
pos.y = xy[1] - pos.y;
} else {
xy = me.el.getAlignToXY(me.container, 'c-c');
pos = me.container.translateXY(xy[0], xy[1]);
}
x = hasX ? x : pos.x;
y = hasY ? y : pos.y;
hasX = hasY = true;
}
if (hasX || hasY) {
me.setPosition(x, y);
}
me.onBoxReady(width, height);
},

applyRenderSelectors: function() {
var me = this,
selectors = me.renderSelectors,
el = me.el,
dom = el.dom,
selector;
me.applyChildEls(el);
// We still support renderSelectors. There are a few places in the framework that
// need them and they are a documented part of the API. In fact, we support mixing
// childEls and renderSelectors (no reason not to).
if (selectors) {
for (selector in selectors) {
if (selectors.hasOwnProperty(selector) && selectors[selector]) {
me[selector] = Ext.get(Ext.DomQuery.selectNode(selectors[selector], dom));
}
}
}
},
beforeRender: function () {
var me = this,
target = me.getTargetEl(),
overflowEl = me.getOverflowEl(),
layout = me.getComponentLayout(),
// Call the style calculation early which sets the public scrollFlags property
overflowStyle = me.getOverflowStyle();
// Just before rendering, set the frame flag if we are an always-framed component like Window or Tip.
me.frame = me.frame || me.alwaysFramed;
if (!layout.initialized) {
layout.initLayout();
}
// Attempt to set overflow style prior to render if the targetEl can be accessed.
// If the targetEl does not exist yet, this will take place in finishRender
if (overflowEl) {
overflowEl.setStyle(overflowStyle);
me.overflowStyleSet = true;
}
me.setUI(me.ui);
if (me.disabled) {
// pass silent so the event doesn't fire the first time.
me.disable(true);
}
},

doApplyRenderTpl: function(out, values) {
// Careful! This method is bolted on to the frameTpl so all we get for context is
// the renderData! The "this" pointer is the frameTpl instance!
var me = values.$comp,
tpl;
// Don't do this if the component is already rendered:
if (!me.rendered) {
tpl = me.initRenderTpl();
tpl.applyOut(values.renderData, out);
}
},

doAutoRender: function() {
var me = this;
if (!me.rendered) {
if (me.floating) {
me.render(document.body);
} else {
me.render(Ext.isBoolean(me.autoRender) ? Ext.getBody() : me.autoRender);
}
}
},
doRenderContent: function (out, renderData) {
// Careful! This method is bolted on to the renderTpl so all we get for context is
// the renderData! The "this" pointer is the renderTpl instance!
var me = renderData.$comp;
if (me.html) {
Ext.DomHelper.generateMarkup(me.html, out);
delete me.html;
}
if (me.tpl) {
// Make sure this.tpl is an instantiated XTemplate
if (!me.tpl.isTemplate) {
me.tpl = new Ext.XTemplate(me.tpl);
}
if (me.data) {
//me.tpl[me.tplWriteMode](target, me.data);
me.tpl.applyOut(me.data, out);
delete me.data;
}
}
},
doRenderFramingDockedItems: function (out, renderData, after) {
// Careful! This method is bolted on to the frameTpl so all we get for context is
// the renderData! The "this" pointer is the frameTpl instance!
var me = renderData.$comp;
// Most components don't have dockedItems, so check for doRenderDockedItems on the
// component (also, don't do this if the component is already rendered):
if (!me.rendered && me.doRenderDockedItems) {
// The "renderData" property is placed in scope for the renderTpl, but we don't
// want to render docked items at that level in addition to the framing level:
renderData.renderData.$skipDockedItems = true;
// doRenderDockedItems requires the $comp property on renderData, but this is
// set on the frameTpl's renderData as well:
me.doRenderDockedItems.call(this, out, renderData, after);
}
},

finishRender: function(containerIdx) {
var me = this,
tpl, data, el;
// We are typically called w/me.el==null as a child of some ownerCt that is being
// rendered. We are also called by render for a normal component (w/o a configured
// me.el). In this case, render sets me.el and me.rendering (indirectly). Lastly
// we are also called on a component (like a Viewport) that has a configured me.el
// (body for a Viewport) when render is called. In this case, it is not flagged as
// "me.rendering" yet becasue it does not produce a renderTree. We use this to know
// not to regen the renderTpl.
if (!me.el || me.$pid) {
if (me.container) {
el = me.container.getById(me.id, true);
} else {
el = Ext.getDom(me.id);
}
if (!me.el) {
// Typical case: we produced the el during render
me.wrapPrimaryEl(el);
} else {
// We were configured with an el and created a proxy, so now we can swap
// the proxy for me.el:
delete me.$pid;
if (!me.el.dom) {
// make sure me.el is an Element
me.wrapPrimaryEl(me.el);
}
el.parentNode.insertBefore(me.el.dom, el);
Ext.removeNode(el); // remove placeholder el
// TODO - what about class/style?
}
} else if (!me.rendering) {
// We were configured with an el and then told to render (e.g., Viewport). We
// need to generate the proper DOM. Insert first because the layout system
// insists that child Component elements indices match the Component indices.
tpl = me.initRenderTpl();
if (tpl) {
data = me.initRenderData();
tpl.insertFirst(me.getTargetEl(), data);
}
}
// else we are rendering
if (!me.container) {
// top-level rendered components will already have me.container set up
me.container = Ext.get(me.el.dom.parentNode);
}
if (me.ctCls) {
me.container.addCls(me.ctCls);
}
// Sets the rendered flag and clears the rendering flag
me.onRender(me.container, containerIdx);
// If we could not access a target protoEl in beforeRender, we have to set the overflow styles here.
if (!me.overflowStyleSet) {
me.getOverflowEl().setStyle(me.getOverflowStyle());
}
// Tell the encapsulating element to hide itself in the way the Component is configured to hide
// This means DISPLAY, VISIBILITY or OFFSETS.
me.el.setVisibilityMode(Ext.Element[me.hideMode.toUpperCase()]);
if (me.overCls) {
me.el.hover(me.addOverCls, me.removeOverCls, me);
}
if (me.hasListeners.render) {
me.fireEvent('render', me);
}
me.afterRender(); // this can cause a layout
if (me.hasListeners.afterrender) {
me.fireEvent('afterrender', me);
}
me.initEvents();
if (me.hidden) {
// Hiding during the render process should not perform any ancillary
// actions that the full hide process does; It is not hiding, it begins in a hidden state.'
// So just make the element hidden according to the configured hideMode
me.el.hide();
}
},
finishRenderChildren: function () {
var layout = this.getComponentLayout();
layout.finishRender();
},
getElConfig : function() {
var me = this,
autoEl = me.autoEl,
frameInfo = me.getFrameInfo(),
config = {
tag: 'div',
tpl: frameInfo ? me.initFramingTpl(frameInfo.table) : me.initRenderTpl()
},
protoEl = me.protoEl,
i, frameElNames, len, suffix, frameGenId, frameData;
me.initStyles(protoEl);
protoEl.writeTo(config);
protoEl.flush();
if (Ext.isString(autoEl)) {
config.tag = autoEl;
} else {
Ext.apply(config, autoEl); // harmless if !autoEl
}
// It's important to assign the id here as an autoEl.id could have been (wrongly) applied and this would get things out of sync
config.id = me.id;
if (config.tpl) {
// Use the framingTpl as the main content creating template. It will call out to this.applyRenderTpl(out, values)
if (frameInfo) {
frameElNames = me.frameElNames;
len = frameElNames.length;
config.tplData = frameData = me.getFrameRenderData();
frameData.renderData = me.initRenderData();
frameGenId = frameData.fgid;
// Add the childEls for each of the frame elements
for (i = 0; i < len; i++) {
suffix = frameElNames[i];
me.addChildEls({ name: 'frame' + suffix, id: frameGenId + suffix });
}
// Panel must have a frameBody
me.addChildEls({
name: 'frameBody',
id: frameGenId + 'MC'
});
} else {
config.tplData = me.initRenderData();
}
}
return config;
},
// Create the framingTpl from the string.
// Poke in a reference to applyRenderTpl(frameInfo, out)
initFramingTpl: function(table) {
var tpl = this.getFrameTpl(table);
if (tpl && !tpl.applyRenderTpl) {
this.setupFramingTpl(tpl);
}
return tpl;
},

setupFramingTpl: function(frameTpl) {
frameTpl.applyRenderTpl = this.doApplyRenderTpl;
frameTpl.renderDockedItems = this.doRenderFramingDockedItems;
},

getInsertPosition: function(position) {
// Convert the position to an element to insert before
if (position !== undefined) {
if (Ext.isNumber(position)) {
position = this.container.dom.childNodes[position];
}
else {
position = Ext.getDom(position);
}
}
return position;
},
getRenderTree: function() {
var me = this;
if (!me.hasListeners.beforerender || me.fireEvent('beforerender', me) !== false) {
me.beforeRender();
// Flag to let the layout's finishRenderItems and afterFinishRenderItems
// know which items to process
me.rendering = true;
if (me.el) {
// Since we are producing a render tree, we produce a "proxy el" that will
// sit in the rendered DOM precisely where me.el belongs. We replace the
// proxy el in the finishRender phase.
return {
tag: 'div',
id: (me.$pid = Ext.id())
};
}
return me.getElConfig();
}
return null;
},
initContainer: function(container) {
var me = this;
// If you render a component specifying the el, we get the container
// of the el, and make sure we dont move the el around in the dom
// during the render
if (!container && me.el) {
container = me.el.dom.parentNode;
me.allowDomMove = false;
}
me.container = container.dom ? container : Ext.get(container);
return me.container;
},

initRenderData: function() {
var me = this;
return Ext.apply({
$comp: me,
id: me.id,
ui: me.ui,
uiCls: me.uiCls,
baseCls: me.baseCls,
componentCls: me.componentCls,
frame: me.frame,
childElCls: '' // overridden in RTL
}, me.renderData);
},

initRenderTpl: function() {
var tpl = this.getTpl('renderTpl');
if (tpl && !tpl.renderContent) {
this.setupRenderTpl(tpl);
}
return tpl;
},

onRender: function(parentNode, containerIdx) {
var me = this,
x = me.x,
y = me.y,
lastBox = null,
width, height,
el = me.el;
me.applyRenderSelectors();
// Flag set on getRenderTree to flag to the layout's postprocessing routine that
// the Component is in the process of being rendered and needs postprocessing.
me.rendering = null;
me.rendered = true;
// We need to remember these to avoid writing them during the initial layout:
if (x != null) {
lastBox = {x:x};
}
if (y != null) {
(lastBox = lastBox || {}).y = y;
}
// Framed components need their width/height to apply to the frame, which is
// best handled in layout at present.
// If we're using the content box model, we also cannot assign initial sizes since we do not know the border widths to subtract
if (!me.getFrameInfo() && Ext.isBorderBox) {
width = me.width;
height = me.height;
if (typeof width === 'number') {
lastBox = lastBox || {};
lastBox.width = width;
}
if (typeof height === 'number') {
lastBox = lastBox || {};
lastBox.height = height;
}
}
me.lastBox = el.lastBox = lastBox;
},

render: function(container, position) {
var me = this,
el = me.el && (me.el = Ext.get(me.el)), // ensure me.el is wrapped
vetoed,
tree,
nextSibling;
Ext.suspendLayouts();
container = me.initContainer(container);
nextSibling = me.getInsertPosition(position);
if (!el) {
tree = me.getRenderTree();
if (me.ownerLayout && me.ownerLayout.transformItemRenderTree) {
tree = me.ownerLayout.transformItemRenderTree(tree);
}
// tree will be null if a beforerender listener returns false
if (tree) {
if (nextSibling) {
el = Ext.DomHelper.insertBefore(nextSibling, tree);
} else {
el = Ext.DomHelper.append(container, tree);
}
me.wrapPrimaryEl(el);
}
} else {
if (!me.hasListeners.beforerender || me.fireEvent('beforerender', me) !== false) {
me.beforeRender();
// Set configured styles on pre-rendered Component's element
me.initStyles(el);
if (me.allowDomMove !== false) {
if (nextSibling) {
container.dom.insertBefore(el.dom, nextSibling);
} else {
container.dom.appendChild(el.dom);
}
}
} else {
vetoed = true;
}
}
if (el && !vetoed) {
me.finishRender(position);
}
Ext.resumeLayouts(!me.hidden && !container.isDetachedBody);
},

ensureAttachedToBody: function (runLayout) {
var comp = this,
body;
while (comp.ownerCt) {
comp = comp.ownerCt;
}
if (comp.container.isDetachedBody) {
comp.container = body = Ext.getBody();
body.appendChild(comp.el.dom);
if (runLayout) {
comp.updateLayout();
}
if (typeof comp.x == 'number' || typeof comp.y == 'number') {
comp.setPosition(comp.x, comp.y);
}
}
},
setupRenderTpl: function (renderTpl) {
renderTpl.renderBody = renderTpl.renderContent = this.doRenderContent;
},
wrapPrimaryEl: function (dom) {
this.el = Ext.get(dom, true);
},

initFrame : function() {
if (Ext.supports.CSS3BorderRadius || !this.frame) {
return;
}
var me = this,
frameInfo = me.getFrameInfo(),
frameTpl, frameGenId,
frameElNames = me.frameElNames,
len = frameElNames.length,
i, frameData, suffix;
if (frameInfo) {
frameTpl = me.getFrameTpl(frameInfo.table);
frameData = me.getFrameRenderData();
frameGenId = frameData.fgid;
// Here we render the frameTpl to this component. This inserts the 9point div
// or the table framing.
frameTpl.insertFirst(me.el, frameData);
// The frameBody is returned in getTargetEl, so that layouts render items to
// the correct target.
me.frameBody = me.el.down('.' + me.frameCls + '-mc');
// Clean out the childEls for the old frame elements (the majority of the els)
me.removeChildEls(function (c) {
return c.id && me.frameIdRegex.test(c.id);
});
// Grab references to the childEls for each of the new frame elements
for (i = 0; i < len; i++) {
suffix = frameElNames[i];
me['frame' + suffix] = me.el.getById(frameGenId + suffix);
}
}
},
getFrameRenderData: function () {
var me = this,
// we are only called if framing so this has already been determined:
frameInfo = me.frameSize,
frameGenId = (me.frameGenId || 0) + 1;
// since we render id's into the markup and id's NEED to be unique, we have a
// simple strategy for numbering their generations.
me.frameGenId = frameGenId;
return {
$comp: me,
fgid: me.id + '-frame' + frameGenId,
ui: me.ui,
uiCls: me.uiCls,
frameCls: me.frameCls,
baseCls: me.baseCls,
top: !!frameInfo.top,
left: !!frameInfo.left,
right: !!frameInfo.right,
bottom: !!frameInfo.bottom,
// can be optionally set by a subclass or override to be an extra class to
// be applied to all framing elements (used by RTL)
frameElCls: ''
};
},
updateFrame: function() {
if (Ext.supports.CSS3BorderRadius || !this.frame) {
return;
}
var me = this,
wasTable = me.frameSize && me.frameSize.table,
oldFrameTL = me.frameTL,
oldFrameBL = me.frameBL,
oldFrameML = me.frameML,
oldFrameMC = me.frameMC,
newMCClassName;
me.initFrame();
if (oldFrameMC) {
if (me.frame) {
// Store the class names set on the new MC
newMCClassName = me.frameMC.dom.className;
// Framing elements have been selected in initFrame, no need to run applyRenderSelectors
// Replace the new mc with the old mc
oldFrameMC.insertAfter(me.frameMC);
me.frameMC.remove();
// Restore the reference to the old frame mc as the framebody
me.frameBody = me.frameMC = oldFrameMC;
// Apply the new mc classes to the old mc element
oldFrameMC.dom.className = newMCClassName;
// Remove the old framing
if (wasTable) {
me.el.query('> table')[1].remove();
}
else {
if (oldFrameTL) {
oldFrameTL.remove();
}
if (oldFrameBL) {
oldFrameBL.remove();
}
if (oldFrameML) {
oldFrameML.remove();
}
}
}
}
else if (me.frame) {
me.applyRenderSelectors();
}
},

getFrameInfo: function() {
// If native framing can be used, or this component is not going to be framed, then do not attempt to read CSS framing info.
if (Ext.supports.CSS3BorderRadius || !this.frame) {
return false;
}
var me = this,
frameInfoCache = me.frameInfoCache,
cls = me.getFramingInfoCls() + '-frameInfo',
frameInfo = frameInfoCache[cls],
max = Math.max,
styleEl, match, info, frameTop, frameRight, frameBottom, frameLeft,
borderWidthT, borderWidthR, borderWidthB, borderWidthL,
paddingT, paddingR, paddingB, paddingL,
borderRadiusTL, borderRadiusTR, borderRadiusBR, borderRadiusBL;
if (frameInfo == null) {
// Get the singleton frame style proxy with our el class name stamped into it.
styleEl = Ext.fly(me.getStyleProxy(cls), 'frame-style-el');
info = styleEl.getStyle('font-family');
if (info) {
// The framing data is encoded as
// 
// D=div|T=table
// | H=horz|V=vert
// | |
// | |
// [DT][HV]-[T-R-B-L]-[T-R-B-L]-[T-R-B-L]
// / / | | \ \
// / / | | \ \
// / / / \ \ \
// / / border-width \ \
// border-radius padding
//
// The first 2 chars hold the div/table and horizontal/vertical flags.
// The 3 sets of TRBL 4-tuples are the CSS3 values for border-radius,
// border-width and padding, respectively.
//
info = info.split('-');

borderRadiusTL = parseInt(info[1], 10);
borderRadiusTR = parseInt(info[2], 10);
borderRadiusBR = parseInt(info[3], 10);
borderRadiusBL = parseInt(info[4], 10);
borderWidthT = parseInt(info[5], 10);
borderWidthR = parseInt(info[6], 10);
borderWidthB = parseInt(info[7], 10);
borderWidthL = parseInt(info[8], 10);
paddingT = parseInt(info[9], 10);
paddingR = parseInt(info[10], 10);
paddingB = parseInt(info[11], 10);
paddingL = parseInt(info[12], 10);
// This calculation should follow ext-theme-base/etc/mixins/frame.css
// with respect to the CSS3 equivalent formulation:
frameTop = max(borderWidthT, max(borderRadiusTL, borderRadiusTR));
frameRight = max(borderWidthR, max(borderRadiusTR, borderRadiusBR));
frameBottom = max(borderWidthB, max(borderRadiusBL, borderRadiusBR));
frameLeft = max(borderWidthL, max(borderRadiusTL, borderRadiusBL));
frameInfo = {
table: info[0].charAt(0) === 't',
vertical: info[0].charAt(1) === 'v',
top: frameTop,
right: frameRight,
bottom: frameBottom,
left: frameLeft,
width: frameLeft + frameRight,
height: frameTop + frameBottom,
maxWidth: max(frameTop, frameRight, frameBottom, frameLeft),
border: {
top: borderWidthT,
right: borderWidthR,
bottom: borderWidthB,
left: borderWidthL,
width: borderWidthL + borderWidthR,
height: borderWidthT + borderWidthB
},
padding: {
top: paddingT,
right: paddingR,
bottom: paddingB,
left: paddingL,
width: paddingL + paddingR,
height: paddingT + paddingB
},
radius: {
tl: borderRadiusTL,
tr: borderRadiusTR,
br: borderRadiusBR,
bl: borderRadiusBL
}
};
} else {
frameInfo = false;
}
//<debug error>
// This happens when you set frame: true explicitly without using the x-frame mixin in sass.
// This way IE can't figure out what sizes to use and thus framing can't work.
if (me.frame === true && !frameInfo) {
Ext.log.error('You have set frame: true explicity on this component (' + me.getXType() + ') and it ' +
'does not have any framing defined in the CSS template. In this case IE cannot figure out ' +
'what sizes to use and thus framing on this component will be disabled.');
}
//</debug>
frameInfoCache[cls] = frameInfo;
}
me.frame = !!frameInfo;
me.frameSize = frameInfo;
return frameInfo;
},

getFramingInfoCls: function(){
return this.baseCls + '-' + this.ui;
},

getStyleProxy: function(cls) {
var result = this.styleProxyEl || (Ext.AbstractComponent.prototype.styleProxyEl = Ext.getBody().createChild({
style: {
position: 'absolute',
top: '-10000px'
}
}, null, true));
result.className = cls;
return result;
},

getFrameTpl : function(table) {
return this.getTpl(table ? 'frameTableTpl' : 'frameTpl');
},
// Cache the frame information object so as not to cause style recalculations
frameInfoCache: {}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/state/Provider.js */
(function(Ext) {
Ext.define('Ext.state.Provider', {
mixins: {
observable: 'Ext.util.Observable'
},


prefix: 'ext-',

constructor : function(config){
config = config || {};
var me = this;
Ext.apply(me, config);

me.addEvents("statechange");
me.state = {};
me.mixins.observable.constructor.call(me);
},


get : function(name, defaultValue){
return typeof this.state[name] == "undefined" ?
defaultValue : this.state[name];
},

clear : function(name){
var me = this;
delete me.state[name];
me.fireEvent("statechange", me, name, null);
},

set : function(name, value){
var me = this;
me.state[name] = value;
me.fireEvent("statechange", me, name, value);
},

decodeValue : function(value){
// a -> Array
// n -> Number
// d -> Date
// b -> Boolean
// s -> String
// o -> Object
// -> Empty (null)
var me = this,
re = /^(a|n|d|b|s|o|e)\:(.*)$/,
matches = re.exec(unescape(value)),
all,
type,
keyValue,
values,
vLen,
v;

if(!matches || !matches[1]){
return; // non state
}

type = matches[1];
value = matches[2];
switch (type) {
case 'e':
return null;
case 'n':
return parseFloat(value);
case 'd':
return new Date(Date.parse(value));
case 'b':
return (value == '1');
case 'a':
all = [];
if(value != ''){
values = value.split('^');
vLen = values.length;
for (v = 0; v < vLen; v++) {
value = values[v];
all.push(me.decodeValue(value));
}
}
return all;
case 'o':
all = {};
if(value != ''){
values = value.split('^');
vLen = values.length;
for (v = 0; v < vLen; v++) {
value = values[v];
keyValue = value.split('=');
all[keyValue[0]] = me.decodeValue(keyValue[1]);
}
}
return all;
default:
return value;
}
},

encodeValue : function(value){
var flat = '',
i = 0,
enc,
len,
key;

if (value == null) {
return 'e:1'; 
} else if(typeof value == 'number') {
enc = 'n:' + value;
} else if(typeof value == 'boolean') {
enc = 'b:' + (value ? '1' : '0');
} else if(Ext.isDate(value)) {
enc = 'd:' + value.toGMTString();
} else if(Ext.isArray(value)) {
for (len = value.length; i < len; i++) {
flat += this.encodeValue(value[i]);
if (i != len - 1) {
flat += '^';
}
}
enc = 'a:' + flat;
} else if (typeof value == 'object') {
for (key in value) {
if (typeof value[key] != 'function' && value[key] !== undefined) {
flat += key + '=' + this.encodeValue(value[key]) + '^';
}
}
enc = 'o:' + flat.substring(0, flat.length-1);
} else {
enc = 's:' + value;
}
return escape(enc);
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/state/Manager.js */
(function(Ext) {
Ext.define('Ext.state.Manager', {
singleton: true,
requires: ['Ext.state.Provider'],
constructor: function() {
this.provider = new Ext.state.Provider();
},



setProvider : function(stateProvider){
this.provider = stateProvider;
},

get : function(key, defaultValue){
return this.provider.get(key, defaultValue);
},

set : function(key, value){
this.provider.set(key, value);
},

clear : function(key){
this.provider.clear(key);
},

getProvider : function(){
return this.provider;
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/state/Stateful.js */
(function(Ext) {
Ext.define('Ext.state.Stateful', {

mixins: {
observable: 'Ext.util.Observable'
},
requires: ['Ext.state.Manager'],


stateful: false,



saveDelay: 100,
constructor: function(config) {
var me = this;
config = config || {};
if (config.stateful !== undefined) {
me.stateful = config.stateful;
}
if (config.saveDelay !== undefined) {
me.saveDelay = config.saveDelay;
}
me.stateId = me.stateId || config.stateId;
if (!me.stateEvents) {
me.stateEvents = [];
}
if (config.stateEvents) {
me.stateEvents.concat(config.stateEvents);
}
this.addEvents(

'beforestaterestore',

'staterestore',

'beforestatesave',

'statesave'
);
me.mixins.observable.constructor.call(me);
if (me.stateful !== false) {
me.addStateEvents(me.stateEvents);
me.initState();
}
},

addStateEvents: function (events) {
var me = this,
i, event, stateEventsByName;
if (me.stateful && me.getStateId()) {
if (typeof events == 'string') {
events = Array.prototype.slice.call(arguments, 0);
}
stateEventsByName = me.stateEventsByName || (me.stateEventsByName = {});
for (i = events.length; i--; ) {
event = events[i];
if (!stateEventsByName[event]) {
stateEventsByName[event] = 1;
me.on(event, me.onStateChange, me);
}
}
}
},

onStateChange: function(){
var me = this,
delay = me.saveDelay,
statics, runner;
if (!me.stateful) {
return;
}
if (delay) {
if (!me.stateTask) {
statics = Ext.state.Stateful;
runner = statics.runner || (statics.runner = new Ext.util.TaskRunner());
me.stateTask = runner.newTask({
run: me.saveState,
scope: me,
interval: delay,
repeat: 1
});
}
me.stateTask.start();
} else {
me.saveState();
}
},

saveState: function() {
var me = this,
id = me.stateful && me.getStateId(),
hasListeners = me.hasListeners,
state;
if (id) {
state = me.getState() || {}; //pass along for custom interactions
if (!hasListeners.beforestatesave || me.fireEvent('beforestatesave', me, state) !== false) {
Ext.state.Manager.set(id, state);
if (hasListeners.statesave) {
me.fireEvent('statesave', me, state);
}
}
}
},

getState: function(){
return null;
},

applyState: function(state) {
if (state) {
Ext.apply(this, state);
}
},

getStateId: function() {
var me = this;
return me.stateId || (me.autoGenId ? null : me.id);
},

initState: function(){
var me = this,
id = me.stateful && me.getStateId(),
hasListeners = me.hasListeners,
state;
if (id) {
state = Ext.state.Manager.get(id);
if (state) {
state = Ext.apply({}, state);
if (!hasListeners.beforestaterestore || me.fireEvent('beforestaterestore', me, state) !== false) {
me.applyState(state);
if (hasListeners.staterestore) {
me.fireEvent('staterestore', me, state);
}
}
}
}
},

savePropToState: function (propName, state, stateName) {
var me = this,
value = me[propName],
config = me.initialConfig;
if (me.hasOwnProperty(propName)) {
if (!config || config[propName] !== value) {
if (state) {
state[stateName || propName] = value;
}
return true;
}
}
return false;
},

savePropsToState: function (propNames, state) {
var me = this,
i, n;
if (typeof propNames == 'string') {
me.savePropToState(propNames, state);
} else {
for (i = 0, n = propNames.length; i < n; ++i) {
me.savePropToState(propNames[i], state);
}
}
return state;
},

destroy: function(){
var me = this,
task = me.stateTask;
if (task) {
task.destroy();
me.stateTask = null;
}
me.clearListeners();
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/Template.js */
(function(Ext) {
// @tag core
Ext.define('Ext.Template', {

requires: ['Ext.dom.Helper', 'Ext.util.Format'],
inheritableStatics: {

from: function(el, config) {
el = Ext.getDom(el);
return new this(el.value || el.innerHTML, config || '');
}
},


constructor: function(html) {
var me = this,
args = arguments,
buffer = [],
i = 0,
length = args.length,
value;
me.initialConfig = {};

// Allow an array to be passed here so we can
// pass an array of strings and an object
// at the end
if (length === 1 && Ext.isArray(html)) {
args = html;
length = args.length;
}
if (length > 1) {
for (; i < length; i++) {
value = args[i];
if (typeof value == 'object') {
Ext.apply(me.initialConfig, value);
Ext.apply(me, value);
} else {
buffer.push(value);
}
}
} else {
buffer.push(html);
}
// @private
me.html = buffer.join('');
if (me.compiled) {
me.compile();
}
},

isTemplate: true,


disableFormats: false,
re: /\{([\w\-]+)(?:\:([\w\.]*)(?:\((.*?)?\))?)?\}/g,

apply: function(values) {
var me = this,
useFormat = me.disableFormats !== true,
fm = Ext.util.Format,
tpl = me,
ret;
if (me.compiled) {
return me.compiled(values).join('');
}
function fn(m, name, format, args) {
if (format && useFormat) {
if (args) {
args = [values[name]].concat(Ext.functionFactory('return ['+ args +'];')());
} else {
args = [values[name]];
}
if (format.substr(0, 5) == "this.") {
return tpl[format.substr(5)].apply(tpl, args);
}
else {
return fm[format].apply(fm, args);
}
}
else {
return values[name] !== undefined ? values[name] : "";
}
}
ret = me.html.replace(me.re, fn);
return ret;
},

applyOut: function(values, out) {
var me = this;
if (me.compiled) {
out.push.apply(out, me.compiled(values));
} else {
out.push(me.apply(values));
}
return out;
},

applyTemplate: function () {
return this.apply.apply(this, arguments);
},

set: function(html, compile) {
var me = this;
me.html = html;
me.compiled = null;
return compile ? me.compile() : me;
},
compileARe: /\\/g,
compileBRe: /(\r\n|\n)/g,
compileCRe: /'/g,

compile: function() {
var me = this,
fm = Ext.util.Format,
useFormat = me.disableFormats !== true,
body, bodyReturn;
function fn(m, name, format, args) {
if (format && useFormat) {
args = args ? ',' + args: "";
if (format.substr(0, 5) != "this.") {
format = "fm." + format + '(';
}
else {
format = 'this.' + format.substr(5) + '(';
}
}
else {
args = '';
format = "(values['" + name + "'] == undefined ? '' : ";
}
return "'," + format + "values['" + name + "']" + args + ") ,'";
}
bodyReturn = me.html.replace(me.compileARe, '\\\\').replace(me.compileBRe, '\\n').replace(me.compileCRe, "\\'").replace(me.re, fn);
body = "this.compiled = function(values){ return ['" + bodyReturn + "'];};";
eval(body);
return me;
},

insertFirst: function(el, values, returnElement) {
return this.doInsert('afterBegin', el, values, returnElement);
},

insertBefore: function(el, values, returnElement) {
return this.doInsert('beforeBegin', el, values, returnElement);
},

insertAfter: function(el, values, returnElement) {
return this.doInsert('afterEnd', el, values, returnElement);
},

append: function(el, values, returnElement) {
return this.doInsert('beforeEnd', el, values, returnElement);
},
doInsert: function(where, el, values, returnElement) {
var newNode = Ext.DomHelper.insertHtml(where, Ext.getDom(el), this.apply(values));
return returnElement ? Ext.get(newNode) : newNode;
},

overwrite: function(el, values, returnElement) {
var newNode = Ext.DomHelper.overwrite(Ext.getDom(el), this.apply(values));
return returnElement ? Ext.get(newNode) : newNode;
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/XTemplateParser.js */
(function(Ext) {
// @tag core
Ext.define('Ext.XTemplateParser', {
constructor: function (config) {
Ext.apply(this, config);
},


// doText: function (text)

// doExpr: function (expr)

// doTag: function (tag)

// doElse: function ()

// doEval: function (text)

// doIf: function (action, actions)

// doElseIf: function (action, actions)

// doSwitch: function (action, actions)

// doCase: function (action, actions)

// doDefault: function ()

// doEnd: function (type, actions) 

// doFor: function (action, actions)

// doForEach: function (action, actions)

// doExec: function (action, actions)

doTpl: Ext.emptyFn,
parse: function (str) {
var me = this,
len = str.length,
aliases = { elseif: 'elif' },
topRe = me.topRe,
actionsRe = me.actionsRe,
index, stack, s, m, t, prev, frame, subMatch, begin, end, actions,
prop;
me.level = 0;
me.stack = stack = [];
for (index = 0; index < len; index = end) {
topRe.lastIndex = index;
m = topRe.exec(str);
if (!m) {
me.doText(str.substring(index, len));
break;
}
begin = m.index;
end = topRe.lastIndex;
if (index < begin) {
me.doText(str.substring(index, begin));
}
if (m[1]) {
end = str.indexOf('%}', begin+2);
me.doEval(str.substring(begin+2, end));
end += 2;
} else if (m[2]) {
end = str.indexOf(']}', begin+2);
me.doExpr(str.substring(begin+2, end));
end += 2;
} else if (m[3]) { // if ('{' token)
me.doTag(m[3]);
} else if (m[4]) { // content of a <tpl xxxxxx xxx> tag
actions = null;
while ((subMatch = actionsRe.exec(m[4])) !== null) {
s = subMatch[2] || subMatch[3];
if (s) {
s = Ext.String.htmlDecode(s); // decode attr value
t = subMatch[1];
t = aliases[t] || t;
actions = actions || {};
prev = actions[t];
if (typeof prev == 'string') {
actions[t] = [prev, s];
} else if (prev) {
actions[t].push(s);
} else {
actions[t] = s;
}
}
}
if (!actions) {
if (me.elseRe.test(m[4])) {
me.doElse();
} else if (me.defaultRe.test(m[4])) {
me.doDefault();
} else {
me.doTpl();
stack.push({ type: 'tpl' });
}
}
else if (actions['if']) {
me.doIf(actions['if'], actions);
stack.push({ type: 'if' });
}
else if (actions['switch']) {
me.doSwitch(actions['switch'], actions);
stack.push({ type: 'switch' });
}
else if (actions['case']) {
me.doCase(actions['case'], actions);
}
else if (actions['elif']) {
me.doElseIf(actions['elif'], actions);
}
else if (actions['for']) {
++me.level;
// Extract property name to use from indexed item
if (prop = me.propRe.exec(m[4])) {
actions.propName = prop[1] || prop[2];
}
me.doFor(actions['for'], actions);
stack.push({ type: 'for', actions: actions });
}
else if (actions['foreach']) {
++me.level;
// Extract property name to use from indexed item
if (prop = me.propRe.exec(m[4])) {
actions.propName = prop[1] || prop[2];
}
me.doForEach(actions['foreach'], actions);
stack.push({ type: 'foreach', actions: actions });
}
else if (actions.exec) {
me.doExec(actions.exec, actions);
stack.push({ type: 'exec', actions: actions });
}

} else if (m[0].length === 5) {
// if the length of m[0] is 5, assume that we're dealing with an opening tpl tag with no attributes (e.g. <tpl>...</tpl>)
// in this case no action is needed other than pushing it on to the stack
stack.push({ type: 'tpl' });
} else {
frame = stack.pop();
me.doEnd(frame.type, frame.actions);
if (frame.type == 'for' || frame.type == 'foreach') {
--me.level;
}
}
}
},
// Internal regexes

topRe: /(?:(\{\%)|(\{\[)|\{([^{}]+)\})|(?:<tpl([^>]*)\>)|(?:<\/tpl>)/g,
actionsRe: /\s*(elif|elseif|if|for|foreach|exec|switch|case|eval|between)\s*\=\s*(?:(?:"([^"]*)")|(?:'([^']*)'))\s*/g,
propRe: /prop=(?:(?:"([^"]*)")|(?:'([^']*)'))/,
defaultRe: /^\s*default\s*$/,
elseRe: /^\s*else\s*$/
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/XTemplateCompiler.js */
(function(Ext) {
// @tag core
Ext.define('Ext.XTemplateCompiler', {
extend: 'Ext.XTemplateParser',
// Chrome really likes "new Function" to realize the code block (as in it is
// 2x-3x faster to call it than using eval), but Firefox chokes on it badly.
// IE and Opera are also fine with the "new Function" technique.
useEval: Ext.isGecko,
// See http://jsperf.com/nige-array-append for quickest way to append to an array of unknown length
// (Due to arbitrary code execution inside a template, we cannot easily track the length in var)
// On IE6 to 8, myArray[myArray.length]='foo' is better. On other browsers myArray.push('foo') is better.
useIndex: Ext.isIE8m,
useFormat: true,

propNameRe: /^[\w\d\$]*$/,
compile: function (tpl) {
var me = this,
code = me.generate(tpl);
// When using "new Function", we have to pass our "Ext" variable to it in order to
// support sandboxing. If we did not, the generated function would use the global
// "Ext", not the "Ext" from our sandbox (scope chain).
//
return me.useEval ? me.evalTpl(code) : (new Function('Ext', code))(Ext);
},
generate: function (tpl) {
var me = this,
// note: Ext here is properly sandboxed
definitions = 'var fm=Ext.util.Format,ts=Object.prototype.toString;',
code;
// Track how many levels we use, so that we only "var" each level's variables once
me.maxLevel = 0;
me.body = [
'var c0=values, a0=' + me.createArrayTest(0) + ', p0=parent, n0=xcount, i0=xindex, k0, v;\n'
];
if (me.definitions) {
if (typeof me.definitions === 'string') {
me.definitions = [me.definitions, definitions ];
} else {
me.definitions.push(definitions);
}
} else {
me.definitions = [ definitions ];
}
me.switches = [];
me.parse(tpl);
me.definitions.push(
(me.useEval ? '$=' : 'return') + ' function (' + me.fnArgs + ') {',
me.body.join(''),
'}'
);
code = me.definitions.join('\n');
// Free up the arrays.
me.definitions.length = me.body.length = me.switches.length = 0;
delete me.definitions;
delete me.body;
delete me.switches;
return code;
},
//-----------------------------------
// XTemplateParser callouts
doText: function (text) {
var me = this,
out = me.body;
text = text.replace(me.aposRe, "\\'").replace(me.newLineRe, '\\n');
if (me.useIndex) {
out.push('out[out.length]=\'', text, '\'\n');
} else {
out.push('out.push(\'', text, '\')\n');
}
},
doExpr: function (expr) {
var out = this.body;
out.push('if ((v=' + expr + ') != null) out');
// Coerce value to string using concatenation of an empty string literal.
// See http://jsperf.com/tostringvscoercion/5
if (this.useIndex) {
out.push('[out.length]=v+\'\'\n');
} else {
out.push('.push(v+\'\')\n');
}
},
doTag: function (tag) {
var expr = this.parseTag(tag);
if (expr) {
this.doExpr(expr);
} else {
// if we cannot match on tagRe handle as plain text
this.doText('{' + tag + '}');
}
},
doElse: function () {
this.body.push('} else {\n');
},
doEval: function (text) {
this.body.push(text, '\n');
},
doIf: function (action, actions) {
var me = this;
// If it's just a propName, use it directly in the if
if (action === '.') {
me.body.push('if (values) {\n');
} else if (me.propNameRe.test(action)) {
me.body.push('if (', me.parseTag(action), ') {\n');
}
// Otherwise, it must be an expression, and needs to be returned from an fn which uses with(values)
else {
me.body.push('if (', me.addFn(action), me.callFn, ') {\n');
}
if (actions.exec) {
me.doExec(actions.exec);
}
},
doElseIf: function (action, actions) {
var me = this;
// If it's just a propName, use it directly in the else if
if (action === '.') {
me.body.push('else if (values) {\n');
} else if (me.propNameRe.test(action)) {
me.body.push('} else if (', me.parseTag(action), ') {\n');
}
// Otherwise, it must be an expression, and needs to be returned from an fn which uses with(values)
else {
me.body.push('} else if (', me.addFn(action), me.callFn, ') {\n');
}
if (actions.exec) {
me.doExec(actions.exec);
}
},
doSwitch: function (action) {
var me = this;
// If it's just a propName, use it directly in the switch
if (action === '.') {
me.body.push('switch (values) {\n');
} else if (me.propNameRe.test(action)) {
me.body.push('switch (', me.parseTag(action), ') {\n');
}
// Otherwise, it must be an expression, and needs to be returned from an fn which uses with(values)
else {
me.body.push('switch (', me.addFn(action), me.callFn, ') {\n');
}
me.switches.push(0);
},
doCase: function (action) {
var me = this,
cases = Ext.isArray(action) ? action : [action],
n = me.switches.length - 1,
match, i;
if (me.switches[n]) {
me.body.push('break;\n');
} else {
me.switches[n]++;
}
for (i = 0, n = cases.length; i < n; ++i) {
match = me.intRe.exec(cases[i]);
cases[i] = match ? match[1] : ("'" + cases[i].replace(me.aposRe,"\\'") + "'");
}
me.body.push('case ', cases.join(': case '), ':\n');
},
doDefault: function () {
var me = this,
n = me.switches.length - 1;
if (me.switches[n]) {
me.body.push('break;\n');
} else {
me.switches[n]++;
}
me.body.push('default:\n');
},
doEnd: function (type, actions) {
var me = this,
L = me.level-1;
if (type == 'for' || type == 'foreach') {

if (actions.exec) {
me.doExec(actions.exec);
}
me.body.push('}\n');
me.body.push('parent=p',L,';values=r',L+1,';xcount=n'+L+';xindex=i',L,'+1;xkey=k',L,';\n');
} else if (type == 'if' || type == 'switch') {
me.body.push('}\n');
}
},
doFor: function (action, actions) {
var me = this,
s,
L = me.level,
up = L-1,
parentAssignment;
// If it's just a propName, use it directly in the switch
if (action === '.') {
s = 'values';
} else if (me.propNameRe.test(action)) {
s = me.parseTag(action);
}
// Otherwise, it must be an expression, and needs to be returned from an fn which uses with(values)
else {
s = me.addFn(action) + me.callFn;
}

// Declare the vars for a particular level only if we have not already declared them.
if (me.maxLevel < L) {
me.maxLevel = L;
me.body.push('var ');
}

if (action == '.') {
parentAssignment = 'c' + L;
} else {
parentAssignment = 'a' + up + '?c' + up + '[i' + up + ']:c' + up;
}

me.body.push('i',L,'=0,n', L, '=0,c',L,'=',s,',a',L,'=', me.createArrayTest(L),',r',L,'=values,p',L,',k',L,';\n',
'p',L,'=parent=',parentAssignment,'\n',
'if (c',L,'){if(a',L,'){n', L,'=c', L, '.length;}else if (c', L, '.isMixedCollection){c',L,'=c',L,'.items;n',L,'=c',L,'.length;}else if(c',L,'.isStore){c',L,'=c',L,'.data.items;n',L,'=c',L,'.length;}else{c',L,'=[c',L,'];n',L,'=1;}}\n',
'for (xcount=n',L,';i',L,'<n'+L+';++i',L,'){\n',
'values=c',L,'[i',L,']');
if (actions.propName) {
me.body.push('.', actions.propName);
}
me.body.push('\n',
'xindex=i',L,'+1\n');

if (actions.between) {
me.body.push('if(xindex>1){ out.push("',actions.between,'"); } \n');
}
},
doForEach: function (action, actions) {
var me = this,
s,
L = me.level,
up = L-1,
parentAssignment;
// If it's just a propName, use it directly in the switch
if (action === '.') {
s = 'values';
} else if (me.propNameRe.test(action)) {
s = me.parseTag(action);
}
// Otherwise, it must be an expression, and needs to be returned from an fn which uses with(values)
else {
s = me.addFn(action) + me.callFn;
}

// Declare the vars for a particular level only if we have not already declared them.
if (me.maxLevel < L) {
me.maxLevel = L;
me.body.push('var ');
}

if (action == '.') {
parentAssignment = 'c' + L;
} else {
parentAssignment = 'a' + up + '?c' + up + '[i' + up + ']:c' + up;
}

me.body.push('i',L,'=-1,n',L,'=0,c',L,'=',s,',a',L,'=',me.createArrayTest(L),',r',L,'=values,p',L,',k',L,';\n',
'p',L,'=parent=',parentAssignment,'\n',
'for(k',L,' in c',L,'){\n',
'xindex=++i',L,'+1;\n',
'xkey=k',L,';\n',
'values=c',L,'[k',L,'];');
if (actions.propName) {
me.body.push('.', actions.propName);
}

if (actions.between) {
me.body.push('if(xindex>1){ out.push("',actions.between,'"); } \n');
}
},
createArrayTest: ('isArray' in Array) ? function(L) {
return 'Array.isArray(c' + L + ')';
} : function(L) {
return 'ts.call(c' + L + ')==="[object Array]"';
},
doExec: function (action, actions) {
var me = this,
name = 'f' + me.definitions.length;
me.definitions.push('function ' + name + '(' + me.fnArgs + ') {',
' try { with(values) {',
' ' + action,
' }} catch(e) {',
//<debug>
'Ext.log("XTemplate Error: " + e.message);',
//</debug>
'}',
'}');
me.body.push(name + me.callFn + '\n');
},
//-----------------------------------
// Internal
addFn: function (body) {
var me = this,
name = 'f' + me.definitions.length;
if (body === '.') {
me.definitions.push('function ' + name + '(' + me.fnArgs + ') {',
' return values',
'}');
} else if (body === '..') {
me.definitions.push('function ' + name + '(' + me.fnArgs + ') {',
' return parent',
'}');
} else {
me.definitions.push('function ' + name + '(' + me.fnArgs + ') {',
' try { with(values) {',
' return(' + body + ')',
' }} catch(e) {',
//<debug>
'Ext.log("XTemplate Error: " + e.message);',
//</debug>
'}',
'}');
}
return name;
},
parseTag: function (tag) {
var me = this,
m = me.tagRe.exec(tag),
name, format, args, math, v;
if (!m) {
return null;
}
name = m[1];
format = m[2];
args = m[3];
math = m[4];
// name = "." - Just use the values object.
if (name == '.') {
// filter to not include arrays/objects/nulls
if (!me.validTypes) {
me.definitions.push('var validTypes={string:1,number:1,boolean:1};');
me.validTypes = true;
}
v = 'validTypes[typeof values] || ts.call(values) === "[object Date]" ? values : ""';
}
// name = "#" - Use the xindex
else if (name == '#') {
v = 'xindex';
}
// name = "$" - Use the xkey
else if (name == '$') {
v = 'xkey';
}
else if (name.substr(0, 7) == "parent.") {
v = name;
}
// compound Javascript property name (e.g., "foo.bar")
else if (isNaN(name) && name.indexOf('-') == -1 && name.indexOf('.') != -1) {
v = "values." + name;
}
// number or a '-' in it or a single word (maybe a keyword): use array notation
// (http://jsperf.com/string-property-access/4)
else { 
v = "values['" + name + "']";
}
if (math) {
v = '(' + v + math + ')';
}
if (format && me.useFormat) {
args = args ? ',' + args : "";
if (format.substr(0, 5) != "this.") {
format = "fm." + format + '(';
} else {
format += '(';
}
} else {
return v;
}
return format + v + args + ')';
},
// @private
evalTpl: function ($) {
// We have to use eval to realize the code block and capture the inner func we also
// don't want a deep scope chain. We only do this in Firefox and it is also unhappy
// with eval containing a return statement, so instead we assign to "$" and return
// that. Because we use "eval", we are automatically sandboxed properly.
eval($);
return $;
},
newLineRe: /\r\n|\r|\n/g,
aposRe: /[']/g,
intRe: /^\s*(\d+)\s*$/,
tagRe: /^([\w-\.\#\$]+)(?:\:([\w\.]*)(?:\((.*?)?\))?)?(\s?[\+\-\*\/]\s?[\d\.\+\-\*\/\(\)]+)?$/
}, function () {
var proto = this.prototype;
proto.fnArgs = 'out,values,parent,xindex,xcount,xkey';
proto.callFn = '.call(this,' + proto.fnArgs + ')';
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/XTemplate.js */
(function(Ext) {
// @tag core
Ext.define('Ext.XTemplate', {
extend: 'Ext.Template',
requires: 'Ext.XTemplateCompiler',

emptyObj: {},


apply: function(values, parent) {
return this.applyOut(values, [], parent).join('');
},
applyOut: function(values, out, parent) {
var me = this,
compiler;
if (!me.fn) {
compiler = new Ext.XTemplateCompiler({
useFormat: me.disableFormats !== true,
definitions: me.definitions
});
me.fn = compiler.compile(me.html);
}
try {
me.fn(out, values, parent || me.emptyObj, 1, 1);
} catch (e) {
//<debug>
Ext.log('Error: ' + e.message);
//</debug>
}
return out;
},

compile: function() {
return this;
},
statics: {

getTpl: function (instance, name) {
var tpl = instance[name], // go for it! 99% of the time we will get it!
owner;
if (tpl && !tpl.isTemplate) { // tpl is just a configuration (not an instance)
// create the template instance from the configuration:
tpl = Ext.ClassManager.dynInstantiate('Ext.XTemplate', tpl);
// and replace the reference with the new instance:
if (instance.hasOwnProperty(name)) { // the tpl is on the instance
owner = instance;
} else { // must be somewhere in the prototype chain
for (owner = instance.self.prototype; owner && !owner.hasOwnProperty(name); owner = owner.superclass) {
}
}
owner[name] = tpl;
tpl.owner = owner;
}
// else !tpl (no such tpl) or the tpl is an instance already... either way, tpl
// is ready to return
return tpl || null;
}
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/data/flash/BinaryXhr.js */
(function(Ext) {
Ext.define('Ext.data.flash.BinaryXhr', {

statics: {

flashPluginActivated: function() {
Ext.data.flash.BinaryXhr.flashPluginActive = true;
Ext.data.flash.BinaryXhr.flashPlugin = document.getElementById("ext-flash-polyfill");
Ext.globalEvents.fireEvent("flashready"); // let all pending connections know
},


flashPluginActive: false,


flashPluginInjected: false,



connectionIndex: 1,


liveConnections: {},


flashPlugin: null,


onFlashStateChange: function(javascriptId, state, data) {
var connection;
// Identify the request this is for
connection = this.liveConnections[Number(javascriptId)]; // Make sure its a native number
if (connection) {
connection.onFlashStateChange(state, data);
} 
//<debug>
else {
Ext.warn.log("onFlashStateChange for unknown connection ID: " + javascriptId);
}
//</debug>
},


registerConnection: function(conn) {
var i = this.connectionIndex;
this.conectionIndex = this.connectionIndex + 1;
this.liveConnections[i] = conn;
return i;
},


injectFlashPlugin: function() {
var divTag, pTag, aTag, iTag,
me=this,
flashLoaderPath, flashObjectPath;
// Generate the following HTML set of tags:
// + '<div id="ext-flash-polyfill">'
// + '<p>To view this page ensure that Adobe Flash Player version 11.1.0 or greater is installed, and that the FlashPlugin.swf file was correctly placed in the /resources directory.</p>'
//+ '<a href="http://www.adobe.com/go/getflashplayer"><img src="' + window.location.protocol + '//www.adobe.com/images/shared/download_buttons/get_flash_player.gif" alt="Get Adobe Flash player" /></a>'
//+ '</div>'

iTag=document.createElement("img");
iTag.setAttribute("src", window.location.protocol + '//www.adobe.com/images/shared/download_buttons/get_flash_player.gif');
iTag.setAttribute("alt", "Get Adobe Flash player");

aTag=document.createElement("a");
aTag.setAttribute("href", "http://www.adobe.com/go/getflashplayer");
aTag.appendChild(iTag);

pTag=document.createElement("p");
pTag.innerHTML="To view this page ensure that Adobe Flash Player version 11.1.0 or greater is installed.";

divTag=document.createElement("div");
divTag.setAttribute("id", "ext-flash-polyfill");
divTag.appendChild(pTag);
divTag.appendChild(iTag);

Ext.getBody().dom.appendChild(divTag);



// Now load the flash-loading script

flashLoaderPath = [Ext.Loader.getPath('Ext.data.Connection'), '../../../plugins/flash/swfobject.js'].join('/');
flashObjectPath = "/plugins/flash/FlashPlugin.swf";
//<debug>
flashObjectPath = [Ext.Loader.getPath('Ext.data.Connection'), '../../plugins/flash/FlashPlugin.swf'].join('/');
//</debug>
if (Ext.flashPluginPath) {
flashObjectPath = Ext.flashPluginPath;
}
//console.log('LOADING Flash plugin from: ' + flashObjectPath);
Ext.Loader.loadScript({
url:flashLoaderPath,
onLoad: function() {
// For version detection, set to min. required Flash Player version, or 0 (or 0.0.0), for no version detection. 
var swfVersionStr = "11.4.0";
// To use express install, set to playerProductInstall.swf, otherwise the empty string. 
var xiSwfUrlStr = "playerProductInstall.swf";
var flashvars = {};
var params = {};
params.quality = "high";
params.bgcolor = "#ffffff";
params.allowscriptaccess = "sameDomain";
params.allowfullscreen = "true";
var attributes = {};
attributes.id = "ext-flash-polyfill";
attributes.name = "polyfill";
attributes.align = "middle";
swfobject.embedSWF(
flashObjectPath, "ext-flash-polyfill", 
"0", "0", // no size so it's not visible. 
swfVersionStr, xiSwfUrlStr, 
flashvars, params, attributes);
},
onError: function() {
//<debug>
Ext.Error.raise("Could not load flash-loader file swfobject.js from " + flashLoader);
//</debug>
},
scope: me
});
Ext.globalEvents.addEvents("flashready"); // we'll fire this one once flash is loaded
Ext.data.flash.BinaryXhr.flashPluginInjected = true;
}

},


readyState: 0,


status: 0,



statusText: "",


responseBytes: null,


javascriptId: null,



constructor: function (config) {
// first, make sure flash is loading if needed
if (!Ext.data.flash.BinaryXhr.flashPluginInjected) {
Ext.data.flash.BinaryXhr.injectFlashPlugin();
}
var me = this;
Ext.apply(me, config);
me.requestHeaders = {};
},

abort: function () {
var me = this;
// if complete, nothing to abort 
if (me.readyState == 4) {
//<debug>
Ext.warn.log("Aborting a connection that's completed its transfer: " + this.url);
//</debug>
return;
}
// Mark as aborted
me.aborted = true;
// Remove ourselves from the listeners if flash isn't active yet
if (!Ext.data.flash.BinaryXhr.flashPluginActive) {
Ext.globalEvents.removeListener("flashready", me.onFlashReady, me);
return;
}
// Flash is already live, so we should have a javascriptID and should have called flash to get the request going. Cancel:
Ext.data.flash.BinaryXhr.flashPlugin.abortRequest(me.javascriptId);
// remove from list
delete Ext.data.flash.BinaryXhr.liveConnections[me.javascriptId];
},

getAllResponseHeaders: function () {
var headers = [];
Ext.Object.each(this.responseHeaders, function (name, value) {
headers.push(name + ': ' + value);
});
return headers.join('\x0d\x0a');
},

getResponseHeader: function (header) {
var headers = this.responseHeaders;
return (headers && headers[header]) || null;
},

open: function (method, url, async, user, password) {
var me = this;
me.method = method;
me.url = url;
me.async = async !== false;
me.user = user;
me.password = password;

//<debug>
if (!me.async) {
Ext.Error.raise("Binary posts are only supported in async mode: " + url);
}
if (me.method != "POST") {
Ext.log.warn("Binary data can only be sent as a POST request: " + url);
}
//</debug>
},

overrideMimeType: function (mimeType) {
this.mimeType = mimeType;
},

send: function (body) {
var me = this;
me.body = body;
if (!Ext.data.flash.BinaryXhr.flashPluginActive) {
Ext.globalEvents.addListener("flashready", me.onFlashReady, me);
} else {
this.onFlashReady();
}
},


onFlashReady: function() {
var me = this, req, status;
me.javascriptId = Ext.data.flash.BinaryXhr.registerConnection(me);

// Create the request object we're sending to flash
req = {
method: me.method, // ignored since we always POST binary data
url: me.url,
user: me.user,
password: me.password,
mimeType: me.mimeType,
requestHeaders: me.requestHeaders,
body: me.body,
javascriptId: me.javascriptId
};
status = Ext.data.flash.BinaryXhr.flashPlugin.postBinary(req);
},

setReadyState: function (state) {
var me = this;
if (me.readyState != state) {
me.readyState = state;
me.onreadystatechange();
}
},

setRequestHeader: function (header, value) {
this.requestHeaders[header] = value;
},

onreadystatechange: Ext.emptyFn,

parseData: function (data) {
var me = this;
// parse data and set up variables so that listeners can use this XHR
this.status = data.status || 0; 
// we get back no response headers, so fake what we know:
me.responseHeaders = {};
if (me.mimeType) {
me.responseHeaders["content-type"] = me.mimeType;
}
if (data.reason == "complete") {
// Transfer complete and data received
this.responseBytes = data.data;
me.responseHeaders["content-length"] = data.data.length;
} else if (data.reason == "error" || data.reason == "securityError") {
this.statusText = data.text;
me.responseHeaders["content-length"] = 0; // we don't get the error response data
}
//<debug>
else {
Ext.Error.raise("Unkown reason code in data: " + data.reason);
}
//</debug>
},

onFlashStateChange: function(state, data) {
var me = this;
if (state == 4) {
// parse data and prepare for handing back to initiator
me.parseData(data);
// remove from list
delete Ext.data.flash.BinaryXhr.liveConnections[me.javascriptId];
}
me.setReadyState(state); // notify all listeners
}

});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/data/Connection.js */
(function(Ext) {
Ext.define('Ext.data.Connection', {
mixins: {
observable: 'Ext.util.Observable'
},

requires: [
'Ext.data.flash.BinaryXhr'
],
statics: {
requestId: 0
},
url: null,
async: true,
method: null,
username: '',
password: '',

disableCaching: true,

withCredentials: false,

binary: false,

cors: false,
isXdr: false,
defaultXdrContentType: 'text/plain',

disableCachingParam: '_dc',

timeout : 30000,




useDefaultHeader : true,
defaultPostHeader : 'application/x-www-form-urlencoded; charset=UTF-8',
useDefaultXhrHeader : true,
defaultXhrHeader : 'XMLHttpRequest',
constructor : function(config) {
config = config || {};
Ext.apply(this, config);



this.requests = {};
this.mixins.observable.constructor.call(this);
},

request : function(options) {
options = options || {};
var me = this,
scope = options.scope || window,
username = options.username || me.username,
password = options.password || me.password || '',
async,
requestOptions,
request,
headers,
xhr;
if (me.fireEvent('beforerequest', me, options) !== false) {
requestOptions = me.setOptions(options, scope);
if (me.isFormUpload(options)) {
me.upload(options.form, requestOptions.url, requestOptions.data, options);
return null;
}
// if autoabort is set, cancel the current transactions
if (options.autoAbort || me.autoAbort) {
me.abort();
}
// create a connection object
async = options.async !== false ? (options.async || me.async) : false;
xhr = me.openRequest(options, requestOptions, async, username, password);
// XDR doesn't support setting any headers
if (!me.isXdr) {
headers = me.setupHeaders(xhr, options, requestOptions.data, requestOptions.params);
}
// create the transaction object
request = {
id: ++Ext.data.Connection.requestId,
xhr: xhr,
headers: headers,
options: options,
async: async,
binary: options.binary || me.binary,
timeout: setTimeout(function() {
request.timedout = true;
me.abort(request);
}, options.timeout || me.timeout)
};
me.requests[request.id] = request;
me.latestId = request.id;
// bind our statechange listener
if (async) {
if (!me.isXdr) {
xhr.onreadystatechange = Ext.Function.bind(me.onStateChange, me, [request]);
}
}
if (me.isXdr) {
me.processXdrRequest(request, xhr);
}
// start the request!
xhr.send(requestOptions.data);
if (!async) {
return me.onComplete(request);
}
return request;
} else {
Ext.callback(options.callback, options.scope, [options, undefined, undefined]);
return null;
}
},
processXdrRequest: function(request, xhr) {
var me = this;
// Mutate the request object as per XDR spec.
delete request.headers;
request.contentType = request.options.contentType || me.defaultXdrContentType;
xhr.onload = Ext.Function.bind(me.onStateChange, me, [request, true]);
xhr.onerror = xhr.ontimeout = Ext.Function.bind(me.onStateChange, me, [request, false]);
},
processXdrResponse: function(response, xhr) {
// Mutate the response object as per XDR spec.
response.getAllResponseHeaders = function () {
return [];
};
response.getResponseHeader = function () {
return '';
};
response.contentType = xhr.contentType || this.defaultXdrContentType;
},

upload: function(form, url, params, options) {
form = Ext.getDom(form);
options = options || {};
var id = Ext.id(),
frame = document.createElement('iframe'),
hiddens = [],
encoding = 'multipart/form-data',
buf = {
target: form.target,
method: form.method,
encoding: form.encoding,
enctype: form.enctype,
action: form.action
},
addField = function(name, value) {
hiddenItem = document.createElement('input');
Ext.fly(hiddenItem).set({
type: 'hidden',
value: value,
name: name
});
form.appendChild(hiddenItem);
hiddens.push(hiddenItem);
},
hiddenItem, obj, value, name, vLen, v, hLen, h;

Ext.fly(frame).set({
id: id,
name: id,
cls: Ext.baseCSSPrefix + 'hide-display',
src: Ext.SSL_SECURE_URL
});
document.body.appendChild(frame);
// This is required so that IE doesn't pop the response up in a new window.
if (document.frames) {
document.frames[id].name = id;
}
Ext.fly(form).set({
target: id,
method: 'POST',
enctype: encoding,
encoding: encoding,
action: url || buf.action
});
// add dynamic params
if (params) {
obj = Ext.Object.fromQueryString(params) || {};
for (name in obj) {
if (obj.hasOwnProperty(name)) {
value = obj[name]; 
if (Ext.isArray(value)) {
vLen = value.length;
for (v = 0; v < vLen; v++) {
addField(name, value[v]);
}
} else {
addField(name, value);
}
}
}
}
Ext.fly(frame).on('load', Ext.Function.bind(this.onUploadComplete, this, [frame, options]), null, {single: !Ext.isOpera});
form.submit();
Ext.fly(form).set(buf);
hLen = hiddens.length;
for (h = 0; h < hLen; h++) {
Ext.removeNode(hiddens[h]);
}
},

onUploadComplete: function(frame, options) {
var me = this,
// bogus response object
response = {
responseText: '',
responseXML: null
}, callback, success, doc, contentNode;
try {
doc = frame.contentWindow.document || frame.contentDocument || window.frames[frame.id].document;
// Opera will fire an extraneous load event on about:blank
// We want to ignore this since the load event will be fired twice
if (doc) {
if (Ext.isOpera && doc.location == 'about:blank') {
return;
}
if (doc.body) {
// Response sent as Content-Type: text/json or text/plain. Browser will embed in a <pre> element
// Note: The statement below tests the result of an assignment.
if ((contentNode = doc.body.firstChild) && /pre/i.test(contentNode.tagName)) {
response.responseText = contentNode.textContent;
}
// Response sent as Content-Type: text/html. We must still support JSON response wrapped in textarea.
// Note: The statement below tests the result of an assignment.
else if ((contentNode = doc.getElementsByTagName('textarea')[0])) {
response.responseText = contentNode.value;
}
// Response sent as Content-Type: text/html with no wrapping. Scrape JSON response out of text
else {
response.responseText = doc.body.textContent || doc.body.innerText;
}
}
//in IE the document may still have a body even if returns XML.
response.responseXML = doc.XMLDocument || doc;
callback = options.success;
success = true;
}
} catch (e) {
// Report any error in the message property
response.responseText = '{success:false,message:"' + Ext.String.trim(e.message || e.description) + '"}';
callback = options.failure;
success = false;
}
me.fireEvent('requestcomplete', me, response, options);
Ext.callback(callback, options.scope, [response, options]);
Ext.callback(options.callback, options.scope, [options, success, response]);
setTimeout(function() {
Ext.removeNode(frame);
}, 100);
},

isFormUpload: function(options) {
var form = this.getForm(options);
if (form) {
return (options.isUpload || (/multipart\/form-data/i).test(form.getAttribute('enctype')));
}
return false;
},

getForm: function(options) {
return Ext.getDom(options.form) || null;
},

setOptions: function(options, scope) {
var me = this,
params = options.params || {},
extraParams = me.extraParams,
urlParams = options.urlParams,
url = options.url || me.url,
jsonData = options.jsonData,
method,
disableCache,
data;
// allow params to be a method that returns the params object
if (Ext.isFunction(params)) {
params = params.call(scope, options);
}
// allow url to be a method that returns the actual url
if (Ext.isFunction(url)) {
url = url.call(scope, options);
}
url = this.setupUrl(options, url);
//<debug>
if (!url) {
Ext.Error.raise({
options: options,
msg: 'No URL specified'
});
}
//</debug>
// check for xml or json data, and make sure json data is encoded
data = options.rawData || options.binaryData || options.xmlData || jsonData || null;
if (jsonData && !Ext.isPrimitive(jsonData)) {
data = Ext.encode(data);
}
// Check for binary data. Transform if needed
if (options.binaryData) {
//<debug>
if (!Ext.isArray(options.binaryData)) {
Ext.log.warn("Binary submission data must be an array of byte values! Instead got " + typeof(options.binaryData));
}
//</debug>
if (me.nativeBinaryPostSupport()) {
data = (new Uint8Array(options.binaryData));
if ((Ext.isChrome && Ext.chromeVersion < 22) || Ext.isSafari || Ext.isGecko) {
data = data.buffer; // send the underlying buffer, not the view, since that's not supported on versions of chrome older than 22
}
}
}

// make sure params are a url encoded string and include any extraParams if specified
if (Ext.isObject(params)) {
params = Ext.Object.toQueryString(params);
}
if (Ext.isObject(extraParams)) {
extraParams = Ext.Object.toQueryString(extraParams);
}
params = params + ((extraParams) ? ((params) ? '&' : '') + extraParams : '');
urlParams = Ext.isObject(urlParams) ? Ext.Object.toQueryString(urlParams) : urlParams;
params = this.setupParams(options, params);
// decide the proper method for this request
method = (options.method || me.method || ((params || data) ? 'POST' : 'GET')).toUpperCase();
this.setupMethod(options, method);
disableCache = options.disableCaching !== false ? (options.disableCaching || me.disableCaching) : false;
// if the method is get append date to prevent caching
if (method === 'GET' && disableCache) {
url = Ext.urlAppend(url, (options.disableCachingParam || me.disableCachingParam) + '=' + (new Date().getTime()));
}
// if the method is get or there is json/xml data append the params to the url
if ((method == 'GET' || data) && params) {
url = Ext.urlAppend(url, params);
params = null;
}
// allow params to be forced into the url
if (urlParams) {
url = Ext.urlAppend(url, urlParams);
}
return {
url: url,
method: method,
data: data || params || null
};
},

setupUrl: function(options, url) {
var form = this.getForm(options);
if (form) {
url = url || form.action;
}
return url;
},

setupParams: function(options, params) {
var form = this.getForm(options),
serializedForm;
if (form && !this.isFormUpload(options)) {
serializedForm = Ext.Element.serializeForm(form);
params = params ? (params + '&' + serializedForm) : serializedForm;
}
return params;
},

setupMethod: function(options, method) {
if (this.isFormUpload(options)) {
return 'POST';
}
return method;
},

setupHeaders: function(xhr, options, data, params) {
var me = this,
headers = Ext.apply({}, options.headers || {}, me.defaultHeaders || {}),
contentType = me.defaultPostHeader,
jsonData = options.jsonData,
xmlData = options.xmlData,
key,
header;
if (!headers['Content-Type'] && (data || params)) {
if (data) {
if (options.rawData) {
contentType = 'text/plain';
} else {
if (xmlData && Ext.isDefined(xmlData)) {
contentType = 'text/xml';
} else if (jsonData && Ext.isDefined(jsonData)) {
contentType = 'application/json';
}
}
}
headers['Content-Type'] = contentType;
}
if (me.useDefaultXhrHeader && !headers['X-Requested-With']) {
headers['X-Requested-With'] = me.defaultXhrHeader;
}
// set up all the request headers on the xhr object
try {
for (key in headers) {
if (headers.hasOwnProperty(key)) {
header = headers[key];
xhr.setRequestHeader(key, header);
}
}
} catch(e) {
me.fireEvent('exception', key, header);
}
return headers;
},

newRequest: function (options) {
var me = this,
xhr;
if (options.binaryData) {
// This is a binary data request. Handle submission differently for differnet browsers
if (me.nativeBinaryPostSupport()) { 
xhr = this.getXhrInstance(); // On browsers that support this, use the native XHR object
} else {
// catch all for all other browser types
xhr = new Ext.data.flash.BinaryXhr();
}
} else if ((options.cors || me.cors) && Ext.isIE && Ext.ieVersion <= 9) {
xhr = me.getXdrInstance();
me.isXdr = true;
} else {
xhr = me.getXhrInstance();
}
return xhr;
},

openRequest: function (options, requestOptions, async, username, password) {
var me = this,
xhr = me.newRequest(options);
if (username) {
xhr.open(requestOptions.method, requestOptions.url, async, username, password);
} else {
if (me.isXdr) {
xhr.open(requestOptions.method, requestOptions.url);
} else {
xhr.open(requestOptions.method, requestOptions.url, async);
}
}
if (options.binary || me.binary) {
if (window.Uint8Array) {
xhr.responseType = 'arraybuffer';
} else if (xhr.overrideMimeType) {
// In some older non-IE browsers, e.g. ff 3.6, that do not
// support Uint8Array, a mime type override is required so that
// the unprocessed binary data can be read from the responseText
// (see createResponse())
xhr.overrideMimeType('text\/plain; charset=x-user-defined'); 
//<debug>
} else if (!Ext.isIE) {
Ext.log.warn("Your does not support loading binary data using Ajax.");
//</debug>
}
}
if (options.withCredentials || me.withCredentials) {
xhr.withCredentials = true;
}
return xhr;
},

getXdrInstance: function() {
var xdr;
if (Ext.ieVersion >= 8) {
xdr = new XDomainRequest();
} else {
Ext.Error.raise({
msg: 'Your browser does not support CORS'
});
}
return xdr;
},

getXhrInstance: (function() {
var options = [function() {
return new XMLHttpRequest();
}, function() {
return new ActiveXObject('MSXML2.XMLHTTP.3.0');
}, function() {
return new ActiveXObject('MSXML2.XMLHTTP');
}, function() {
return new ActiveXObject('Microsoft.XMLHTTP');
}], i = 0,
len = options.length,
xhr;
for (; i < len; ++i) {
try {
xhr = options[i];
xhr();
break;
} catch(e) {
}
}
return xhr;
}()),

isLoading : function(request) {
if (!request) {
request = this.getLatest();
}
if (!(request && request.xhr)) {
return false;
}
// if there is a connection and readyState is not 0 or 4, or in case of BinaryXHR, not 4
var state = request.xhr.readyState;
return ((request.xhr instanceof Ext.data.flash.BinaryXhr) && state != 4) || !(state === 0 || state == 4);
},

abort : function(request) {
var me = this,
xhr;

if (!request) {
request = me.getLatest();
}
if (request && me.isLoading(request)) {

xhr = request.xhr;
try {
xhr.onreadystatechange = null;
} catch (e) {
// Setting onreadystatechange to null can cause problems in IE, see
// http://www.quirksmode.org/blog/archives/2005/09/xmlhttp_notes_a_1.html
xhr.onreadystatechange = Ext.emptyFn;
}
xhr.abort();
me.clearTimeout(request);
if (!request.timedout) {
request.aborted = true;
}
me.onComplete(request);
me.cleanup(request);
}
},


abortAll: function(){
var requests = this.requests,
id;

for (id in requests) {
if (requests.hasOwnProperty(id)) {
this.abort(requests[id]);
}
}
},


getLatest: function(){
var id = this.latestId,
request;

if (id) {
request = this.requests[id];
}
return request || null;
},

onStateChange : function(request, xdrResult) {
var me = this;
// Using CORS with IE doesn't support readyState so we fake it
if ((request.xhr && request.xhr.readyState == 4) || me.isXdr) {
me.clearTimeout(request);
me.onComplete(request, xdrResult);
me.cleanup(request);
Ext.EventManager.idleEvent.fire();
}
},

clearTimeout: function(request) {
clearTimeout(request.timeout);
delete request.timeout;
},

cleanup: function(request) {
request.xhr = null;
delete request.xhr;
},

onComplete : function(request, xdrResult) {
var me = this,
options = request.options,
result,
success,
response;
try {
result = me.parseStatus(request.xhr.status);
} catch (e) {
// in some browsers we can't access the status if the readyState is not 4, so the request has failed
result = {
success : false,
isException : false
};
}
success = me.isXdr ? xdrResult : result.success;
if (success) {
response = me.createResponse(request);
me.fireEvent('requestcomplete', me, response, options);
Ext.callback(options.success, options.scope, [response, options]);
} else {
if (result.isException || request.aborted || request.timedout) {
response = me.createException(request);
} else {
response = me.createResponse(request);
}
me.fireEvent('requestexception', me, response, options);
Ext.callback(options.failure, options.scope, [response, options]);
}
Ext.callback(options.callback, options.scope, [options, success, response]);
delete me.requests[request.id];
return response;
},

parseStatus: function(status) {
// see: https://prototype.lighthouseapp.com/projects/8886/tickets/129-ie-mangles-http-response-status-code-204-to-1223
status = status == 1223 ? 204 : status;
var success = (status >= 200 && status < 300) || status == 304,
isException = false;
if (!success) {
switch (status) {
case 12002:
case 12029:
case 12030:
case 12031:
case 12152:
case 13030:
isException = true;
break;
}
}
return {
success: success,
isException: isException
};
},

createResponse : function(request) {
var me = this,
xhr = request.xhr,
isXdr = me.isXdr,
headers = {},
lines = isXdr ? [] : xhr.getAllResponseHeaders().replace(/\r\n/g, '\n').split('\n'),
count = lines.length,
line, index, key, response, byteArray;
while (count--) {
line = lines[count];
index = line.indexOf(':');
if (index >= 0) {
key = line.substr(0, index).toLowerCase();
if (line.charAt(index + 1) == ' ') {
++index;
}
headers[key] = line.substr(index + 1);
}
}
request.xhr = null;
delete request.xhr;
response = {
request: request,
requestId: request.id,
status: xhr.status,
statusText: xhr.statusText,
getResponseHeader: function(header) {
return headers[header.toLowerCase()];
},
getAllResponseHeaders: function() {
return headers;
}
};
if (isXdr) {
me.processXdrResponse(response, xhr);
}
if (request.binary) {
response.responseBytes = me.getByteArray(xhr);
} else {
// an error is thrown when trying to access responseText or responseXML
// on an xhr object with responseType of 'arraybuffer', so only attempt
// to set these properties in the response if we're not dealing with
// binary data
response.responseText = xhr.responseText;
response.responseXML = xhr.responseXML;
}
// If we don't explicitly tear down the xhr reference, IE6/IE7 will hold this in the closure of the
// functions created with getResponseHeader/getAllResponseHeaders
xhr = null;
return response;
},

createException : function(request) {
return {
request : request,
requestId : request.id,
status : request.aborted ? -1 : 0,
statusText : request.aborted ? 'transaction aborted' : 'communication failure',
aborted: request.aborted,
timedout: request.timedout
};
},

getByteArray: function(xhr) {
var response = xhr.response,
responseBody = xhr.responseBody,
byteArray, responseText, len, i;
if (xhr instanceof Ext.data.flash.BinaryXhr) {
// If this was a BinaryXHR request via flash, we already have the bytes ready
byteArray = xhr.responseBytes;
} else if (window.Uint8Array) {
// Modern browsers (including IE10) have a native byte array
// which can be created by passing the ArrayBuffer (returned as
// the xhr.response property) to the Uint8Array constructor.
byteArray = response ? new Uint8Array(response) : [];
} else if (Ext.isIE9p) {
// In IE9 and below the responseBody property contains a byte array
// but it is not directly accessible using javascript.
// In IE9p we can get the bytes by constructing a VBArray
// using the responseBody and then converting it to an Array.
try {
byteArray = new VBArray(responseBody).toArray();
} catch(e) {
// If the binary response is empty, the VBArray constructor will
// choke on the responseBody. We can't simply do a null check
// on responseBody because responseBody is always falsy when it
// contains binary data.
byteArray = [];
}
} else if (Ext.isIE) {
// IE8 and below also have a VBArray constructor, but throw a
// "VBArray Expected" error if you try to pass the responseBody to
// the VBArray constructor.
// http://msdn.microsoft.com/en-us/library/ye3x9by3%28v=vs.71%29.aspx
// so we have to use vbscript injection to access the bytes
if (!this.self.vbScriptInjected) {
this.injectVBScript();
}
getIEByteArray(xhr.responseBody, byteArray = []);
} else {
// in other older browsers make a best-effort attempt to read the
// bytes from responseText
byteArray = [];
responseText = xhr.responseText;
len = responseText.length;
for (i = 0; i < len; i++) {
// Some characters have an extra byte 0xF7 in the high order
// position. Throw away the high order byte and then push the
// result onto the byteArray.
byteArray.push(responseText.charCodeAt(i) & 0xFF);
}
}
return byteArray;
},

injectVBScript: function() {
var scriptTag = document.createElement('script');
scriptTag.type = 'text/vbscript';
scriptTag.text = [
'Function getIEByteArray(byteArray, out)',
'Dim len, i',
'len = LenB(byteArray)',
'For i = 1 to len',
'out.push(AscB(MidB(byteArray, i, 1)))',
'Next',
'End Function'
].join('\n');
Ext.getHead().dom.appendChild(scriptTag);
this.self.vbScriptInjected = true;
},


nativeBinaryPostSupport: function() {
return Ext.isChrome ||
(Ext.isSafari && Ext.isDefined(window.Uint8Array)) ||
(Ext.isGecko && Ext.isDefined(window.Uint8Array));
}


});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/Ajax.js */
(function(Ext) {
Ext.define('Ext.Ajax', {
extend: 'Ext.data.Connection',
singleton: true,













autoAbort : false
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/ElementLoader.js */
(function(Ext) {
Ext.define('Ext.ElementLoader', {

mixins: {
observable: 'Ext.util.Observable'
},
uses: [
'Ext.data.Connection',
'Ext.Ajax'
],
statics: {
Renderer: {
Html: function(loader, response, active){
loader.getTarget().update(response.responseText, active.scripts === true);
return true;
}
}
},


url: null,

params: null,

baseParams: null,

autoLoad: false,

target: null,

loadMask: false,

ajaxOptions: null,

scripts: false,






isLoader: true,
constructor: function(config) {
var me = this,
autoLoad;
config = config || {};
Ext.apply(me, config);
me.setTarget(me.target);
me.addEvents(

'beforeload',

'exception',

'load'
);
// don't pass config because we have already applied it.
me.mixins.observable.constructor.call(me);
if (me.autoLoad) {
autoLoad = me.autoLoad;
if (autoLoad === true) {
autoLoad = {};
}
me.load(autoLoad);
}
},

setTarget: function(target){
var me = this;
target = Ext.get(target);
if (me.target && me.target != target) {
me.abort();
}
me.target = target;
},

getTarget: function(){
return this.target || null;
},

abort: function(){
var active = this.active;
if (active !== undefined) {
Ext.Ajax.abort(active.request);
if (active.mask) {
this.removeMask();
}
delete this.active;
}
},

removeMask: function(){
this.target.unmask();
},

addMask: function(mask){
this.target.mask(mask === true ? null : mask);
},

load: function(options) {
//<debug>
if (!this.target) {
Ext.Error.raise('A valid target is required when loading content');
}
//</debug>
options = Ext.apply({}, options);
var me = this,
mask = Ext.isDefined(options.loadMask) ? options.loadMask : me.loadMask,
params = Ext.apply({}, options.params),
ajaxOptions = Ext.apply({}, options.ajaxOptions),
callback = options.callback || me.callback,
scope = options.scope || me.scope || me;
Ext.applyIf(ajaxOptions, me.ajaxOptions);
Ext.applyIf(options, ajaxOptions);
Ext.applyIf(params, me.params);
Ext.apply(params, me.baseParams);
Ext.applyIf(options, {
url: me.url
});
//<debug>
if (!options.url) {
Ext.Error.raise('You must specify the URL from which content should be loaded');
}
//</debug>
Ext.apply(options, {
scope: me,
params: params,
callback: me.onComplete
});
if (me.fireEvent('beforeload', me, options) === false) {
return;
}
if (mask) {
me.addMask(mask);
}
me.active = {
options: options,
mask: mask,
scope: scope,
callback: callback,
success: options.success || me.success,
failure: options.failure || me.failure,
renderer: options.renderer || me.renderer,
scripts: Ext.isDefined(options.scripts) ? options.scripts : me.scripts
};
me.active.request = Ext.Ajax.request(options);
me.setOptions(me.active, options);
},

setOptions: Ext.emptyFn,

onComplete: function(options, success, response) {
var me = this,
active = me.active,
scope;
if (active) {
scope = active.scope;
if (success) {
success = me.getRenderer(active.renderer).call(me, me, response, active) !== false;
}
if (success) {
Ext.callback(active.success, scope, [me, response, options]);
me.fireEvent('load', me, response, options);
} else {
Ext.callback(active.failure, scope, [me, response, options]);
me.fireEvent('exception', me, response, options);
}
Ext.callback(active.callback, scope, [me, success, response, options]);
if (active.mask) {
me.removeMask();
}
}
delete me.active;
},

getRenderer: function(renderer){
if (Ext.isFunction(renderer)) {
return renderer;
}
return this.statics().Renderer.Html;
},

startAutoRefresh: function(interval, options){
var me = this;
me.stopAutoRefresh();
me.autoRefresh = setInterval(function(){
me.load(options);
}, interval);
},

stopAutoRefresh: function(){
clearInterval(this.autoRefresh);
delete this.autoRefresh;
},

isAutoRefreshing: function(){
return Ext.isDefined(this.autoRefresh);
},

destroy: function(){
var me = this;
me.stopAutoRefresh();
delete me.target;
me.abort();
me.clearListeners();
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/ComponentLoader.js */
(function(Ext) {
Ext.define('Ext.ComponentLoader', {

extend: 'Ext.ElementLoader',
statics: {
Renderer: {
Data: function(loader, response, active){
var success = true;
try {
loader.getTarget().update(Ext.decode(response.responseText));
} catch (e) {
success = false;
}
return success;
},
Component: function(loader, response, active){
var success = true,
target = loader.getTarget(),
items = [];
//<debug>
if (!target.isContainer) {
Ext.Error.raise({
target: target,
msg: 'Components can only be loaded into a container'
});
}
//</debug>
try {
items = Ext.decode(response.responseText);
} catch (e) {
success = false;
}
if (success) {
target.suspendLayouts();
if (active.removeAll) {
target.removeAll();
}
target.add(items);
target.resumeLayouts(true);
}
return success;
}
}
},


target: null,

loadMask: false,


renderer: 'html',

setTarget: function(target){
var me = this;
if (Ext.isString(target)) {
target = Ext.getCmp(target);
}
if (me.target && me.target != target) {
me.abort();
}
me.target = target;
},
// inherit docs
removeMask: function(){
this.target.setLoading(false);
},

addMask: function(mask){
this.target.setLoading(mask);
},
setOptions: function(active, options){
active.removeAll = Ext.isDefined(options.removeAll) ? options.removeAll : this.removeAll;
},

getRenderer: function(renderer){
if (Ext.isFunction(renderer)) {
return renderer;
}
var renderers = this.statics().Renderer;
switch (renderer) {
case 'component':
return renderers.Component;
case 'data':
return renderers.Data;
default:
return Ext.ElementLoader.Renderer.Html;
}
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/util/Queue.js */
(function(Ext) {
Ext.define('Ext.util.Queue', {
constructor: function() {
this.clear();
},
add : function(obj) {
var me = this,
key = me.getKey(obj);
if (!me.map[key]) {
++me.length;
me.items.push(obj);
me.map[key] = obj;
}
return obj;
},

clear : function(){
var me = this,
items = me.items;
me.items = [];
me.map = {};
me.length = 0;
return items;
},
contains: function (obj) {
var key = this.getKey(obj);
return this.map.hasOwnProperty(key);
},

getCount : function(){
return this.length;
},
getKey : function(obj){
return obj.id;
},

remove : function(obj){
var me = this,
key = me.getKey(obj),
items = me.items,
index;
if (me.map[key]) {
index = Ext.Array.indexOf(items, obj);
Ext.Array.erase(items, index, 1);
delete me.map[key];
--me.length;
}
return obj;
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/layout/ClassList.js */
(function(Ext) {
Ext.define('Ext.layout.ClassList', (function () {
var splitWords = Ext.String.splitWords,
toMap = Ext.Array.toMap;
return {
dirty: false,
constructor: function (owner) {
this.owner = owner;
this.map = toMap(this.classes = splitWords(owner.el.className));
},

add: function (cls) {
var me = this;
if (!me.map[cls]) {
me.map[cls] = true;
me.classes.push(cls);
if (!me.dirty) {
me.dirty = true;
me.owner.markDirty();
}
}
},

addMany: function (classes) {
Ext.each(splitWords(classes), this.add, this);
},
contains: function (cls) {
return this.map[cls];
},
flush: function () {
this.owner.el.className = this.classes.join(' ');
this.dirty = false;
},

remove: function (cls) {
var me = this;
if (me.map[cls]) {
delete me.map[cls];
me.classes = Ext.Array.filter(me.classes, function (c) {
return c != cls;
});
if (!me.dirty) {
me.dirty = true;
me.owner.markDirty();
}
}
},

removeMany: function (classes) {
var me = this,
remove = toMap(splitWords(classes));
me.classes = Ext.Array.filter(me.classes, function (c) {
if (!remove[c]) {
return true;
}
delete me.map[c];
if (!me.dirty) {
me.dirty = true;
me.owner.markDirty();
}
return false;
});
}
};
}()));
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/layout/ContextItem.js */
(function(Ext) {
Ext.define('Ext.layout.ContextItem', {
requires: ['Ext.layout.ClassList'],
heightModel: null,
widthModel: null,
sizeModel: null,

optOut: false,
ownerSizePolicy: null, // plaed here by AbstractComponent.getSizeModel
boxChildren: null,
boxParent: null,
isBorderBoxValue: null,
children: [],
dirty: null,
// The number of dirty properties
dirtyCount: 0,
hasRawContent: true,
isContextItem: true,
isTopLevel: false,
consumersContentHeight: 0,
consumersContentWidth: 0,
consumersContainerHeight: 0,
consumersContainerWidth: 0,
consumersHeight: 0,
consumersWidth: 0,
ownerCtContext: null,
remainingChildDimensions: 0,
// the current set of property values:
props: null,

state: null,

wrapsComponent: false,
constructor: function (config) {
var me = this,
sizeModels = Ext.layout.SizeModel.sizeModels,
configured = sizeModels.configured,
shrinkWrap = sizeModels.shrinkWrap,
el, lastBox, ownerCt, ownerCtContext, props, sizeModel, target,
lastWidth, lastHeight, sameWidth, sameHeight, widthModel, heightModel, optOut;
Ext.apply(me, config);
el = me.el;
me.id = el.id;
// These hold collections of layouts that are either blocked or triggered by sets
// to our properties (either ASAP or after flushing to the DOM). All of them have
// the same structure:
//
// me.blocks = {
// width: {
// 'layout-1001': layout1001
// }
// }
//
// The property name is the primary key which yields an object keyed by layout id
// with the layout instance as the value. This prevents duplicate entries for one
// layout and gives O(1) access to the layout instance when we need to iterate and
// process them.
// 
// me.blocks = {};
// me.domBlocks = {};
// me.domTriggers = {};
// me.triggers = {};
me.flushedProps = {};
me.props = props = {};
// the set of cached styles for the element:
me.styles = {};
target = me.target;
if (!target.isComponent) {
lastBox = el.lastBox;
} else {
me.wrapsComponent = true;
me.framing = target.frameSize || null;
me.isComponentChild = target.ownerLayout && target.ownerLayout.isComponentLayout;
lastBox = target.lastBox;
// These items are created top-down, so the ContextItem of our ownerCt should
// be available (if it is part of this layout run).
ownerCt = target.ownerCt;
if (ownerCt && (ownerCtContext = ownerCt.el && me.context.items[ownerCt.el.id])) {
me.ownerCtContext = ownerCtContext;
}
// If our ownerCtContext is in the run, it will have a SizeModel that we use to
// optimize the determination of our sizeModel.
me.sizeModel = sizeModel = target.getSizeModel(ownerCtContext &&
ownerCtContext.widthModel.pairsByHeightOrdinal[ownerCtContext.heightModel.ordinal]);
// NOTE: The initial determination of sizeModel is valid (thankfully) and is
// needed to cope with adding components to a layout run on-the-fly (e.g., in
// the menu overflow handler of a box layout). Since this is the case, we do
// not need to recompute the sizeModel in init unless it is a "full" init (as
// our ownerCt's sizeModel could have changed in that case).
me.widthModel = widthModel = sizeModel.width;
me.heightModel = heightModel = sizeModel.height;
// The lastBox is populated early but does not get an "invalid" property
// until layout has occurred. The "false" value is placed in the lastBox
// by Component.finishedLayout.
if (lastBox && lastBox.invalid === false) {
sameWidth = (target.width === (lastWidth = lastBox.width));
sameHeight = (target.height === (lastHeight = lastBox.height));
if (widthModel === shrinkWrap && heightModel === shrinkWrap) {
optOut = true;
} else if (widthModel === configured && sameWidth) {
optOut = heightModel === shrinkWrap ||
(heightModel === configured && sameHeight);
}
if (optOut) {
// Flag this component and capture its last size...
me.optOut = true;
props.width = lastWidth;
props.height = lastHeight;
}
}
}
me.lastBox = lastBox;
},

init: function (full, options) {
var me = this,
oldProps = me.props,
oldDirty = me.dirty,
ownerCtContext = me.ownerCtContext,
ownerLayout = me.target.ownerLayout,
firstTime = !me.state,
ret = full || firstTime,
children, i, n, ownerCt, sizeModel, target,
oldHeightModel = me.heightModel,
oldWidthModel = me.widthModel,
newHeightModel, newWidthModel,
remainingCount = 0;
me.dirty = me.invalid = false;
me.props = {};
// Reset the number of child dimensions since the children will add their part:
me.remainingChildDimensions = 0;
if (me.boxChildren) {
me.boxChildren.length = 0; // keep array (more GC friendly)
}
if (!firstTime) {
me.clearAllBlocks('blocks');
me.clearAllBlocks('domBlocks');
}
// For Element wrappers, we are done...
if (!me.wrapsComponent) {
return ret;
}
// From here on, we are only concerned with Component wrappers...
target = me.target;
me.state = {}; // only Component wrappers need a "state"
if (firstTime) {
// This must occur before we proceed since it can do many things (like add
// child items perhaps):
if (target.beforeLayout && target.beforeLayout !== Ext.emptyFn) {
target.beforeLayout();
}
// Determine the ownerCtContext if we aren't given one. Normally the firstTime
// we meet a component is before the context is run, but it is possible for
// components to be added to a run that is already in progress. If so, we have
// to lookup the ownerCtContext since the odds are very high that the new
// component is a child of something already in the run. It is currently
// unsupported to drag in the owner of a running component (needs testing).
if (!ownerCtContext && (ownerCt = target.ownerCt)) {
ownerCtContext = me.context.items[ownerCt.el.id];
}
if (ownerCtContext) {
me.ownerCtContext = ownerCtContext;
me.isBoxParent = target.ownerLayout.isItemBoxParent(me);
} else {
me.isTopLevel = true; // this is used by initAnimation...
}
me.frameBodyContext = me.getEl('frameBody');
} else {
ownerCtContext = me.ownerCtContext;
// In theory (though untested), this flag can change on-the-fly...
me.isTopLevel = !ownerCtContext;
// Init the children element items since they may have dirty state (no need to
// do this the firstTime).
children = me.children;
for (i = 0, n = children.length; i < n; ++i) {
children[i].init(true);
}
}
// We need to know how we will determine content size: containers can look at the
// results of their items but non-containers or item-less containers with just raw
// markup need to be measured in the DOM:
me.hasRawContent = !(target.isContainer && target.items.items.length > 0);
if (full) {
// We must null these out or getSizeModel will assume they are the correct,
// dynamic size model and return them (the previous dynamic sizeModel).
me.widthModel = me.heightModel = null;
sizeModel = target.getSizeModel(ownerCtContext && 
ownerCtContext.widthModel.pairsByHeightOrdinal[ownerCtContext.heightModel.ordinal]);
if (firstTime) {
me.sizeModel = sizeModel;
}
me.widthModel = sizeModel.width;
me.heightModel = sizeModel.height;
// if we are a container child (e.g., not a docked item), and this is a full
// init, that means our parent was invalidated, and therefore both our width
// and our height are included in remainingChildDimensions
if (ownerCtContext && !me.isComponentChild) {
ownerCtContext.remainingChildDimensions += 2;
}
} else if (oldProps) {
// these are almost always calculated by the ownerCt (we might need to track
// this at some point more carefully):
me.recoverProp('x', oldProps, oldDirty);
me.recoverProp('y', oldProps, oldDirty);

// if these are calculated by the ownerCt, don't trash them:
if (me.widthModel.calculated) {
me.recoverProp('width', oldProps, oldDirty);
} else if ('width' in oldProps) {
++remainingCount;
}
if (me.heightModel.calculated) {
me.recoverProp('height', oldProps, oldDirty);
} else if ('height' in oldProps) {
++remainingCount;
}

// if we are a container child and this is not a full init, that means our
// parent was not invalidated and therefore only the dimensions that were
// set last time and removed from remainingChildDimensions last time, need to
// be added back to remainingChildDimensions. This only needs to happen for
// properties that we don't recover above (model=calculated)
if (ownerCtContext && !me.isComponentChild) {
ownerCtContext.remainingChildDimensions += remainingCount;
}
}
if (oldProps && ownerLayout && ownerLayout.manageMargins) {
me.recoverProp('margin-top', oldProps, oldDirty);
me.recoverProp('margin-right', oldProps, oldDirty);
me.recoverProp('margin-bottom', oldProps, oldDirty);
me.recoverProp('margin-left', oldProps, oldDirty);
}
// Process any invalidate options present. These can only come from explicit calls
// to the invalidate() method.
if (options) {
// Consider a container box with wrapping text. If the box is made wider, the
// text will take up less height (until there is no more wrapping). Conversely,
// if the box is made narrower, the height starts to increase due to wrapping.
//
// Imposing a minWidth constraint would increase the width. This may decrease
// the height. If the box is shrinkWrap, however, the width will already be
// such that there is no wrapping, so the height will not further decrease.
// Since the height will also not increase if we widen the box, there is no
// problem simultaneously imposing a minHeight or maxHeight constraint.
//
// When we impose as maxWidth constraint, however, we are shrinking the box
// which may increase the height. If we are imposing a maxHeight constraint,
// that is fine because a further increased height will still need to be
// constrained. But if we are imposing a minHeight constraint, we cannot know
// whether the increase in height due to wrapping will be greater than the
// minHeight. If we impose a minHeight constraint at the same time, then, we
// could easily be locking in the wrong height.
//
// It is important to note that this logic applies to simultaneously *adding*
// both a maxWidth and a minHeight constraint. It is perfectly fine to have
// a state with both constraints, but we cannot add them both at once.
newHeightModel = options.heightModel;
newWidthModel = options.widthModel;
if (newWidthModel && newHeightModel && oldWidthModel && oldHeightModel) {
if (oldWidthModel.shrinkWrap && oldHeightModel.shrinkWrap) {
if (newWidthModel.constrainedMax && newHeightModel.constrainedMin) {
newHeightModel = null;
}
}
}
// Apply size model updates (if any) and state updates (if any).
if (newWidthModel) {
me.widthModel = newWidthModel;
}
if (newHeightModel) {
me.heightModel = newHeightModel;
}
if (options.state) {
Ext.apply(me.state, options.state);
}
}
return ret;
},

initContinue: function (full) {
var me = this,
ownerCtContext = me.ownerCtContext,
comp = me.target,
widthModel = me.widthModel,
hierarchyState = comp.getHierarchyState(),
boxParent;
if (widthModel.fixed) { // calculated or configured
hierarchyState.inShrinkWrapTable = false;
} else {
delete hierarchyState.inShrinkWrapTable;
}
if (full) {
if (ownerCtContext && widthModel.shrinkWrap) {
boxParent = ownerCtContext.isBoxParent ? ownerCtContext : ownerCtContext.boxParent;
if (boxParent) {
boxParent.addBoxChild(me);
}
} else if (widthModel.natural) {
me.boxParent = ownerCtContext;
}
}
return full;
},

initDone: function(containerLayoutDone) {
var me = this,
props = me.props,
state = me.state;
// These properties are only set when they are true:
if (me.remainingChildDimensions === 0) {
props.containerChildrenSizeDone = true;
}
if (containerLayoutDone) {
props.containerLayoutDone = true;
}
if (me.boxChildren && me.boxChildren.length && me.widthModel.shrinkWrap) {
// set a very large width to allow the children to measure their natural
// widths (this is cleared once all children have been measured):
me.el.setWidth(10000);
// don't run layouts for this component until we clear this width...
state.blocks = (state.blocks || 0) + 1;
}
},

initAnimation: function() {
var me = this,
target = me.target,
ownerCtContext = me.ownerCtContext;
if (ownerCtContext && ownerCtContext.isTopLevel) {
// See which properties we are supposed to animate to their new state.
// If there are any, queue ourself to be animated by the owning Context
me.animatePolicy = target.ownerLayout.getAnimatePolicy(me);
} else if (!ownerCtContext && target.isCollapsingOrExpanding && target.animCollapse) {
// Collapsing/expnding a top level Panel with animation. We need to fabricate
// an animatePolicy depending on which dimension the collapse is using,
// isCollapsingOrExpanding is set during the collapse/expand process.
me.animatePolicy = target.componentLayout.getAnimatePolicy(me);
}
if (me.animatePolicy) {
me.context.queueAnimation(me);
}
},

addCls: function(newCls) {
this.getClassList().addMany(newCls);
},

removeCls: function(removeCls) {
this.getClassList().removeMany(removeCls);
},

addBlock: function (name, layout, propName) {
var me = this,
collection = me[name] || (me[name] = {}),
blockedLayouts = collection[propName] || (collection[propName] = {});
if (!blockedLayouts[layout.id]) {
blockedLayouts[layout.id] = layout;
++layout.blockCount;
++me.context.blockCount;
}
},
addBoxChild: function (boxChildItem) {
var me = this,
children,
widthModel = boxChildItem.widthModel;
boxChildItem.boxParent = this;
// Children that are widthModel.auto (regardless of heightModel) that measure the
// DOM (by virtue of hasRawContent), need to wait for their "box parent" to be sized.
// If they measure too early, they will be wrong results. In the widthModel.shrinkWrap
// case, the boxParent "crushes" the child. In the case of widthModel.natural, the
// boxParent's width is likely a key part of the child's width (e.g., "50%" or just
// normal block-level behavior of 100% width)
boxChildItem.measuresBox = widthModel.shrinkWrap ? boxChildItem.hasRawContent : widthModel.natural;
if (boxChildItem.measuresBox) {
children = me.boxChildren;
if (children) {
children.push(boxChildItem);
} else {
me.boxChildren = [ boxChildItem ];
}
}
},

addPositionStyles: function(styles, props) {
var x = props.x,
y = props.y,
count = 0;
if (x !== undefined) {
styles.left = x + 'px';
++count;
}
if (y !== undefined) {
styles.top = y + 'px';
++count;
}
return count;
},

addTrigger: function (propName, inDom) {
var me = this,
name = inDom ? 'domTriggers' : 'triggers',
collection = me[name] || (me[name] = {}),
context = me.context,
layout = context.currentLayout,
triggers = collection[propName] || (collection[propName] = {});
if (!triggers[layout.id]) {
triggers[layout.id] = layout;
++layout.triggerCount;
triggers = context.triggers[inDom ? 'dom' : 'data'];
(triggers[layout.id] || (triggers[layout.id] = [])).push({
item: this,
prop: propName
});
if (me.props[propName] !== undefined) {
if (!inDom || !(me.dirty && (propName in me.dirty))) {
++layout.firedTriggers;
}
}
}
},
boxChildMeasured: function () {
var me = this,
state = me.state,
count = (state.boxesMeasured = (state.boxesMeasured || 0) + 1);
if (count == me.boxChildren.length) {
// all of our children have measured themselves, so we can clear the width
// and resume layouts for this component...
state.clearBoxWidth = 1;
++me.context.progressCount;
me.markDirty();
}
},
borderNames: [ 'border-top-width', 'border-right-width', 'border-bottom-width', 'border-left-width'],
marginNames: [ 'margin-top', 'margin-right', 'margin-bottom', 'margin-left' ],
paddingNames: [ 'padding-top', 'padding-right', 'padding-bottom', 'padding-left' ],
trblNames: [ 'top', 'right', 'bottom', 'left' ],
cacheMissHandlers: {
borderInfo: function (me) {
var info = me.getStyles(me.borderNames, me.trblNames);
info.width = info.left + info.right;
info.height = info.top + info.bottom;
return info;
},
marginInfo: function (me) {
var info = me.getStyles(me.marginNames, me.trblNames);
info.width = info.left + info.right;
info.height = info.top + info.bottom;
return info;
},
paddingInfo: function (me) {
// if this context item's target is a framed component the padding is on the frameBody, not on the main el
var item = me.frameBodyContext || me,
info = item.getStyles(me.paddingNames, me.trblNames);
info.width = info.left + info.right;
info.height = info.top + info.bottom;
return info;
}
},
checkCache: function (entry) {
return this.cacheMissHandlers[entry](this);
},
clearAllBlocks: function (name) {
var collection = this[name],
propName;
if (collection) {
for (propName in collection) {
this.clearBlocks(name, propName);
}
}
},

clearBlocks: function (name, propName) {
var collection = this[name],
blockedLayouts = collection && collection[propName],
context, layout, layoutId;
if (blockedLayouts) {
delete collection[propName];
context = this.context;
for (layoutId in blockedLayouts) {
layout = blockedLayouts[layoutId];
--context.blockCount;
if (! --layout.blockCount && !layout.pending && !layout.done) {
context.queueLayout(layout);
}
}
}
},

block: function (layout, propName) {
this.addBlock('blocks', layout, propName);
},

domBlock: function (layout, propName) {
this.addBlock('domBlocks', layout, propName);
},

fireTriggers: function (name, propName) {
var collection = this[name],
triggers = collection && collection[propName],
context = this.context,
layout, layoutId;
if (triggers) {
for (layoutId in triggers) {
layout = triggers[layoutId];
++layout.firedTriggers;
if (!layout.done && !layout.blockCount && !layout.pending) {
context.queueLayout(layout);
}
}
}
},

flush: function () {
var me = this,
dirty = me.dirty,
state = me.state,
targetEl = me.el;
me.dirtyCount = 0;
// Flush added/removed classes
if (me.classList && me.classList.dirty) {
me.classList.flush();
}
// Set any queued DOM attributes
if ('attributes' in me) {
targetEl.set(me.attributes);
delete me.attributes;
}
// Set any queued DOM HTML content
if ('innerHTML' in me) {
targetEl.innerHTML = me.innerHTML;
delete me.innerHTML;
}
if (state && state.clearBoxWidth) {
state.clearBoxWidth = 0;
me.el.setStyle('width', null);
if (! --state.blocks) {
me.context.queueItemLayouts(me);
}
}
if (dirty) {
delete me.dirty;
me.writeProps(dirty, true);
}
},

flushAnimations: function() {
var me = this,
animateFrom = me.previousSize,
target, targetAnim, duration, animateProps, anim,
changeCount, j, propsLen, propName, oldValue, newValue;
// Only animate if the Component has been previously layed out: first layout should not animate
if (animateFrom) {
target = me.target;
targetAnim = target.layout && target.layout.animate;
if (targetAnim) {
duration = Ext.isNumber(targetAnim) ? targetAnim : targetAnim.duration;
}
animateProps = Ext.Object.getKeys(me.animatePolicy);
// Create an animation block using the targetAnim configuration to provide defaults.
// They may want custom duration, or easing, or listeners.
anim = Ext.apply({}, {
from: {},
to: {},
duration: duration || Ext.fx.Anim.prototype.duration
}, targetAnim);
for (changeCount = 0, j = 0, propsLen = animateProps.length; j < propsLen; j++) {
propName = animateProps[j];
oldValue = animateFrom[propName];
newValue = me.peek(propName);
if (oldValue != newValue) {
propName = me.translateProps[propName]||propName;
anim.from[propName] = oldValue;
anim.to[propName] = newValue;
++changeCount;
}
}
// If any values have changed, kick off animation from the cached old values to the new values
if (changeCount) {
// It'a Panel being collapsed. rollback, and then fix the class name string
if (me.isCollapsingOrExpanding === 1) {
target.componentLayout.undoLayout(me);
}
// Otherwise, undo just the animated properties so the animation can proceed from the old layout.
else {
me.writeProps(anim.from);
}
me.el.animate(anim);
Ext.fx.Manager.getFxQueue(me.el.id)[0].on({
afteranimate: function() {
if (me.isCollapsingOrExpanding === 1) {
target.componentLayout.redoLayout(me);
target.afterCollapse(true);
} else if (me.isCollapsingOrExpanding === 2) {
target.afterExpand(true);
}
}
});
}
}
},

getBorderInfo: function () {
var me = this,
info = me.borderInfo;
if (!info) {
me.borderInfo = info = me.checkCache('borderInfo');
}
return info;
},

getClassList: function () {
return this.classList || (this.classList = new Ext.layout.ClassList(this));
},

getEl: function (nameOrEl, owner) {
var me = this,
src, el, elContext;
if (nameOrEl) {
if (nameOrEl.dom) {
el = nameOrEl;
} else {
src = me.target;
if (owner) {
src = owner;
}
el = src[nameOrEl];
if (typeof el == 'function') { // ex 'getTarget'
el = el.call(src);
if (el === me.el) {
return this; // comp.getTarget() often returns comp.el
}
}
}
if (el) {
elContext = me.context.getEl(me, el);
}
}
return elContext || null;
},

getFrameInfo: function () {
var me = this,
info = me.frameInfo,
framing, border;
if (!info) {
framing = me.framing;
border = me.getBorderInfo();
me.frameInfo = info = 
framing ? {
top : framing.top + border.top,
right : framing.right + border.right,
bottom: framing.bottom + border.bottom,
left : framing.left + border.left,
width : framing.width + border.width,
height: framing.height + border.height
} : border;
}
return info;
},

getMarginInfo: function () {
var me = this,
info = me.marginInfo,
comp, manageMargins, margins, ownerLayout, ownerLayoutId;
if (!info) {
if (!me.wrapsComponent) {
info = me.checkCache('marginInfo');
} else {
comp = me.target;
ownerLayout = comp.ownerLayout;
ownerLayoutId = ownerLayout ? ownerLayout.id : null;
manageMargins = ownerLayout && ownerLayout.manageMargins;
// Option #1 for configuring margins on components is the "margin" config
// property. When supplied, this config is written to the DOM during the
// render process (see AbstractComponent#initStyles).
//
// Option #2 is available to some layouts (e.g., Box, Border, Fit) that
// handle margin calculations themselves. These layouts support a "margins"
// config property on their items and they have a "defaultMargins" config
// property. These margin values are added to the "natural" margins read
// from the DOM and 0's are written to the DOM after they are added.
// To avoid having to do all this on every layout, we cache the results on
// the component in the (private) "margin$" property. We identify the cache
// results as belonging to the appropriate ownerLayout in case items are
// moved around.
info = comp.margin$;
if (info && info.ownerId !== ownerLayoutId) {
// got one but from the wrong owner
info = null;
// if (manageMargins) {
// TODO: clear inline margins (the 0's we wrote last time)???
// }
}
if (!info) { // if (no cache)
// CSS margins are only checked if there isn't a margin property on the component
info = me.parseMargins(comp, comp.margin) || me.checkCache('marginInfo');
// Some layouts also support margins and defaultMargins, e.g. Fit, Border, Box
if (manageMargins) {
margins = me.parseMargins(comp, comp.margins, ownerLayout.defaultMargins);
if (margins) { // if (using 'margins' and/or 'defaultMargins')
// margin and margins can both be present at the same time and must be combined
info = {
top: info.top + margins.top,
right: info.right + margins.right,
bottom: info.bottom + margins.bottom,
left: info.left + margins.left
};
}
me.setProp('margin-top', 0);
me.setProp('margin-right', 0);
me.setProp('margin-bottom', 0);
me.setProp('margin-left', 0);
}
// cache the layout margins and tag them with the layout id:
info.ownerId = ownerLayoutId;
comp.margin$ = info;
}
info.width = info.left + info.right;
info.height = info.top + info.bottom;
}
me.marginInfo = info;
}
return info;
},

clearMarginCache: function() {
delete this.marginInfo;
delete this.target.margin$;
},

getPaddingInfo: function () {
var me = this,
info = me.paddingInfo;
if (!info) {
me.paddingInfo = info = me.checkCache('paddingInfo');
}
return info;
},

getProp: function (propName) {
var me = this,
result = me.props[propName];
me.addTrigger(propName);
return result;
},

getDomProp: function (propName) {
var me = this,
result = (me.dirty && (propName in me.dirty)) ? undefined : me.props[propName];
me.addTrigger(propName, true);
return result;
},

getStyle: function (styleName) {
var me = this,
styles = me.styles,
info, value;
if (styleName in styles) {
value = styles[styleName];
} else {
info = me.styleInfo[styleName];
value = me.el.getStyle(styleName);
if (info && info.parseInt) {
value = parseInt(value, 10) || 0;
}
styles[styleName] = value;
}
return value;
},

getStyles: function (styleNames, altNames) {
var me = this,
styleCache = me.styles,
values = {},
hits = 0,
n = styleNames.length,
i, missing, missingAltNames, name, info, styleInfo, styles, value;
altNames = altNames || styleNames;
// We are optimizing this for all hits or all misses. If we hit on all styles, we
// don't create a missing[]. If we miss on all styles, we also don't create one.
for (i = 0; i < n; ++i) {
name = styleNames[i];
if (name in styleCache) {
values[altNames[i]] = styleCache[name];
++hits;
if (i && hits==1) { // if (first hit was after some misses)
missing = styleNames.slice(0, i);
missingAltNames = altNames.slice(0, i);
}
} else if (hits) {
(missing || (missing = [])).push(name);
(missingAltNames || (missingAltNames = [])).push(altNames[i]);
}
}
if (hits < n) {
missing = missing || styleNames;
missingAltNames = missingAltNames || altNames;
styleInfo = me.styleInfo;
styles = me.el.getStyle(missing);
for (i = missing.length; i--; ) {
name = missing[i];
info = styleInfo[name];
value = styles[name];
if (info && info.parseInt) {
value = parseInt(value, 10) || 0;
}
values[missingAltNames[i]] = value;
styleCache[name] = value;
}
}
return values;
},

hasProp: function (propName) {
return this.getProp(propName) != null;
},

hasDomProp: function (propName) {
return this.getDomProp(propName) != null;
},

invalidate: function (options) {
this.context.queueInvalidate(this, options);
},
markDirty: function () {
if (++this.dirtyCount == 1) {
// our first dirty property... queue us for flush
this.context.queueFlush(this);
}
},
onBoxMeasured: function () {
var boxParent = this.boxParent,
state = this.state;
if (boxParent && boxParent.widthModel.shrinkWrap && !state.boxMeasured && this.measuresBox) {
// since an autoWidth boxParent is holding a width on itself to allow each
// child to measure
state.boxMeasured = 1; // best to only call once per child
boxParent.boxChildMeasured();
}
},
parseMargins: function (comp, margins, defaultMargins) {
if (margins === true) {
margins = 5;
}
var type = typeof margins,
ret;
if (type == 'string' || type == 'number') {
ret = comp.parseBox(margins);
} else if (margins || defaultMargins) {
ret = { top: 0, right: 0, bottom: 0, left: 0 }; // base defaults
if (defaultMargins) {
Ext.apply(ret, this.parseMargins(comp, defaultMargins)); // + layout defaults
}
if (margins) {
margins = Ext.apply(ret, comp.parseBox(margins)); // + config
}
}
return ret;
},
peek: function (propName) {
return this.props[propName];
},

recoverProp: function (propName, oldProps, oldDirty) {
var me = this,
props = me.props,
dirty;
if (propName in oldProps) {
props[propName] = oldProps[propName];
if (oldDirty && propName in oldDirty) {
dirty = me.dirty || (me.dirty = {});
dirty[propName] = oldDirty[propName];
}
}
},
redo: function(deep) {
var me = this,
items, len, i;
me.revertProps(me.props);
if (deep && me.wrapsComponent) {
// Rollback the state of child Components
if (me.childItems) {
for (i = 0, items = me.childItems, len = items.length; i < len; i++) {
items[i].redo(deep);
}
}
// Rollback the state of child Elements
for (i = 0, items = me.children, len = items.length; i < len; i++) {
items[i].redo();
}
}
},

removeEl: function(nameOrEl, owner) {
var me = this,
src, el;
if (nameOrEl) {
if (nameOrEl.dom) {
el = nameOrEl;
} else {
src = me.target;
if (owner) {
src = owner;
}
el = src[nameOrEl];
if (typeof el == 'function') { // ex 'getTarget'
el = el.call(src);
if (el === me.el) {
return this; // comp.getTarget() often returns comp.el
}
}
}
if (el) {
me.context.removeEl(me, el);
}
}
},
revertProps: function (props) {
var name,
flushed = this.flushedProps,
reverted = {};
for (name in props) {
if (flushed.hasOwnProperty(name)) {
reverted[name] = props[name];
}
}
this.writeProps(reverted);
},

setAttribute: function(name, value) {
var me = this;
if (!me.attributes) {
me.attributes = {};
}
me.attributes[name] = value;
me.markDirty();
},
setBox: function (box) {
var me = this;
if ('left' in box) {
me.setProp('x', box.left);
}
if ('top' in box) {
me.setProp('y', box.top);
}
// if sizeModel says we should not be setting these, the appropriate calls will be
// null operations... otherwise, we must set these values, so what we have in box
// is what we go with (undefined, NaN and no change are handled at a lower level):
me.setSize(box.width, box.height);
},

setContentHeight: function (height, measured) {
if (!measured && this.hasRawContent) {
return 1;
}
return this.setProp('contentHeight', height);
},

setContentWidth: function (width, measured) {
if (!measured && this.hasRawContent) {
return 1;
}
return this.setProp('contentWidth', width);
},

setContentSize: function (width, height, measured) {
return this.setContentWidth(width, measured) +
this.setContentHeight(height, measured) == 2;
},

setProp: function (propName, value, dirty) {
var me = this,
valueType = typeof value,
borderBox, info;
if (valueType == 'undefined' || (valueType === 'number' && isNaN(value))) {
return 0;
}
if (me.props[propName] === value) {
return 1;
}
me.props[propName] = value;
++me.context.progressCount;
if (dirty === false) {
// if the prop is equivalent to what is in the DOM (we won't be writing it),
// we need to clear hard blocks (domBlocks) on that property.
me.fireTriggers('domTriggers', propName);
me.clearBlocks('domBlocks', propName);
} else {
info = me.styleInfo[propName];
if (info) {
if (!me.dirty) {
me.dirty = {};
}
if (propName == 'width' || propName == 'height') {
borderBox = me.isBorderBoxValue;
if (borderBox === null) {
me.isBorderBoxValue = borderBox = !!me.el.isBorderBox();
}
if (!borderBox) {
me.borderInfo || me.getBorderInfo();
me.paddingInfo || me.getPaddingInfo();
}
}
me.dirty[propName] = value;
me.markDirty();
}
}
// we always clear soft blocks on set
me.fireTriggers('triggers', propName);
me.clearBlocks('blocks', propName);
return 1;
},

setHeight: function (height, dirty ) {
var me = this,
comp = me.target,
ownerCtContext = me.ownerCtContext,
frameBody, frameInfo, min, oldHeight, rem;
if (height < 0) {
height = 0;
}
if (!me.wrapsComponent) {
if (!me.setProp('height', height, dirty)) {
return NaN;
}
} else {
min = me.collapsedVert ? 0 : (comp.minHeight || 0);
height = Ext.Number.constrain(height, min, comp.maxHeight);
oldHeight = me.props.height;
if (!me.setProp('height', height, dirty)) {
return NaN;
}
// if we are a container child, since the height is now known we can decrement
// the number of remainingChildDimensions that the ownerCtContext is waiting on.
if (ownerCtContext && !me.isComponentChild && isNaN(oldHeight)) {
rem = --ownerCtContext.remainingChildDimensions;
if (!rem) {
// if there are 0 remainingChildDimensions set containerChildrenSizeDone
// on the ownerCtContext to indicate that all of its children's dimensions
// are known
ownerCtContext.setProp('containerChildrenSizeDone', true);
}
}
frameBody = me.frameBodyContext;
if (frameBody){
frameInfo = me.getFrameInfo();
frameBody.setHeight(height - frameInfo.height, dirty);
}
}
return height;
},

setWidth: function (width, dirty ) {
var me = this,
comp = me.target,
ownerCtContext = me.ownerCtContext,
frameBody, frameInfo, min, oldWidth, rem;
if (width < 0) {
width = 0;
}
if (!me.wrapsComponent) {
if (!me.setProp('width', width, dirty)) {
return NaN;
}
} else {
min = me.collapsedHorz ? 0 : (comp.minWidth || 0);
width = Ext.Number.constrain(width, min, comp.maxWidth);
oldWidth = me.props.width
if (!me.setProp('width', width, dirty)) {
return NaN;
}
// if we are a container child, since the width is now known we can decrement
// the number of remainingChildDimensions that the ownerCtContext is waiting on.
if (ownerCtContext && !me.isComponentChild && isNaN(oldWidth)) {
rem = --ownerCtContext.remainingChildDimensions;
if (!rem) {
// if there are 0 remainingChildDimensions set containerChildrenSizeDone
// on the ownerCtContext to indicate that all of its children's dimensions
// are known
ownerCtContext.setProp('containerChildrenSizeDone', true);
}
}
//if ((frameBody = me.target.frameBody) && (frameBody = me.getEl(frameBody))){
frameBody = me.frameBodyContext;
if (frameBody) {
frameInfo = me.getFrameInfo();
frameBody.setWidth(width - frameInfo.width, dirty);
}

}
return width;
},
setSize: function (width, height, dirty) {
this.setWidth(width, dirty);
this.setHeight(height, dirty);
},
translateProps: {
x: 'left',
y: 'top'
},
undo: function(deep) {
var me = this,
items, len, i;
me.revertProps(me.lastBox);
if (deep && me.wrapsComponent) {
// Rollback the state of child Components
if (me.childItems) {
for (i = 0, items = me.childItems, len = items.length; i < len; i++) {
items[i].undo(deep);
}
}
// Rollback the state of child Elements
for (i = 0, items = me.children, len = items.length; i < len; i++) {
items[i].undo();
}
}
},
unsetProp: function (propName) {
var dirty = this.dirty;
delete this.props[propName];
if (dirty) {
delete dirty[propName];
}
},
writeProps: function(dirtyProps, flushing) {
if (!(dirtyProps && typeof dirtyProps == 'object')) {
//<debug warn>
Ext.Logger.warn('writeProps expected dirtyProps to be an object');
//</debug>
return;
}
var me = this,
el = me.el,
styles = {},
styleCount = 0, // used as a boolean, the exact count doesn't matter
styleInfo = me.styleInfo,
info,
propName,
numericValue,
width = dirtyProps.width,
height = dirtyProps.height,
isBorderBox = me.isBorderBoxValue,
target = me.target,
max = Math.max,
paddingWidth = 0,
paddingHeight = 0,
hasWidth, hasHeight, isAbsolute, scrollbarSize, style, targetEl;
// Process non-style properties:
if ('displayed' in dirtyProps) {
el.setDisplayed(dirtyProps.displayed);
}
// Unblock any hard blocks (domBlocks) and copy dom styles into 'styles'
for (propName in dirtyProps) {
if (flushing) {
me.fireTriggers('domTriggers', propName);
me.clearBlocks('domBlocks', propName);
me.flushedProps[propName] = 1;
}
info = styleInfo[propName];
if (info && info.dom) {
// Numeric dirty values should have their associated suffix added
if (info.suffix && (numericValue = parseInt(dirtyProps[propName], 10))) {
styles[propName] = numericValue + info.suffix;
}
// Non-numeric (eg "auto") go in unchanged.
else {
styles[propName] = dirtyProps[propName];
}
++styleCount;
}
}
// convert x/y into setPosition (for a component) or left/top styles (for an el)
if ('x' in dirtyProps || 'y' in dirtyProps) {
if (target.isComponent) {
target.setPosition(dirtyProps.x, dirtyProps.y);
} else {
// we wrap an element, so convert x/y to styles:
styleCount += me.addPositionStyles(styles, dirtyProps);
}
}
// Support for the content-box box model...
if (!isBorderBox && (width > 0 || height > 0)) { // no need to subtract from 0
// The width and height values assume the border-box box model,
// so we must remove the padding & border to calculate the content-box.
//<debug>
if (!(me.borderInfo && me.paddingInfo)) {
throw Error("Needed to have gotten the borderInfo and paddingInfo when the width or height was setProp'd");
}
//</debug>
if(!me.frameBodyContext) {
// Padding needs to be removed only if the element is not framed.
paddingWidth = me.paddingInfo.width;
paddingHeight = me.paddingInfo.height;
}
if (width) {
width = max(parseInt(width, 10) - (me.borderInfo.width + paddingWidth), 0);
styles.width = width + 'px';
++styleCount;
}
if (height) {
height = max(parseInt(height, 10) - (me.borderInfo.height + paddingHeight), 0);
styles.height = height + 'px';
++styleCount;
}
}
// IE9 strict subtracts the scrollbar size from the element size when the element
// is absolutely positioned and uses box-sizing: border-box. To workaround this
// issue we have to add the the scrollbar size.
// 
// See http://social.msdn.microsoft.com/Forums/da-DK/iewebdevelopment/thread/47c5148f-a142-4a99-9542-5f230c78cb3b
//
if (me.wrapsComponent && Ext.isIE9 && Ext.isStrict) {
// when we set a width and we have a vertical scrollbar (overflowY), we need
// to add the scrollbar width... conversely for the height and overflowX
if ((hasWidth = width !== undefined && me.hasOverflowY) ||
(hasHeight = height !== undefined && me.hasOverflowX)) {
// check that the component is absolute positioned and border-box:
isAbsolute = me.isAbsolute;
if (isAbsolute === undefined) {
isAbsolute = false;
targetEl = me.target.getTargetEl();
style = targetEl.getStyle('position');
if (style == 'absolute') {
style = targetEl.getStyle('box-sizing');
isAbsolute = (style == 'border-box');
}
me.isAbsolute = isAbsolute; // cache it
}
if (isAbsolute) {
scrollbarSize = Ext.getScrollbarSize();
if (hasWidth) {
width = parseInt(width, 10) + scrollbarSize.width;
styles.width = width + 'px';
++styleCount;
}
if (hasHeight) {
height = parseInt(height, 10) + scrollbarSize.height;
styles.height = height + 'px';
++styleCount;
}
}
}
}
// we make only one call to setStyle to allow it to optimize itself:
if (styleCount) {
el.setStyle(styles);
}
}
}, function () {
var px = { dom: true, parseInt: true, suffix: 'px' },
isDom = { dom: true },
faux = { dom: false };
// If a property exists in styleInfo, it participates in some way with the DOM. It may
// be virtualized (like 'x' and y') and be indirect, but still requires a flush cycle
// to reach the DOM. Properties (like 'contentWidth' and 'contentHeight') have no real
// presence in the DOM and hence have no flush intanglements.
// 
// For simple styles, the object value on the right contains properties that help in
// decoding values read by getStyle and preparing values to pass to setStyle.
//
this.prototype.styleInfo = {
containerChildrenSizeDone: faux,
containerLayoutDone: faux,
displayed: faux,
done: faux,
x: faux,
y: faux,
// For Ext.grid.ColumnLayout
columnWidthsDone: faux,
left: px,
top: px,
right: px,
bottom: px,
width: px,
height: px,
'border-top-width': px,
'border-right-width': px,
'border-bottom-width': px,
'border-left-width': px,
'margin-top': px,
'margin-right': px,
'margin-bottom': px,
'margin-left': px,
'padding-top': px,
'padding-right': px,
'padding-bottom': px,
'padding-left': px,
'line-height': isDom,
display: isDom
};
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/layout/SizeModel.js */
(function(Ext) {
Ext.define('Ext.layout.SizeModel', {
constructor: function (config) {
var me = this,
SizeModel = me.self,
sizeModelsArray = SizeModel.sizeModelsArray,
name;
Ext.apply(me, config);
me[name = me.name] = true; // set the one special flag that matches our name
me.fixed = !(me.auto = me.natural || me.shrinkWrap);

sizeModelsArray[me.ordinal = sizeModelsArray.length] =
SizeModel[name] =
SizeModel.sizeModels[name] = me;
},
statics: {

sizeModelsArray: [],

sizeModels: {}
},



calculated: false,

configured: false,

constrainedMax: false,

constrainedMin: false,


natural: false,

shrinkWrap: false,

calculatedFromConfigured: false,

calculatedFromNatural: false,

calculatedFromShrinkWrap: false,

names: null
},
function () {
var SizeModel = this,
sizeModelsArray = SizeModel.sizeModelsArray,
i, j, n, pairs, sizeModel;
//-------------------------------------------------------------------------------
// These are the 4 fundamental size models.
new SizeModel({
name: 'calculated'
});
new SizeModel({
name: 'configured',
names: { width: 'width', height: 'height' }
});
new SizeModel({
name: 'natural'
});
new SizeModel({
name: 'shrinkWrap'
});
//-------------------------------------------------------------------------------
// These are the size models are flavors of the above but with some extra detail
// about their dynamic use.
new SizeModel({
name: 'calculatedFromConfigured',
configured: true,
names: { width: 'width', height: 'height' }
});
new SizeModel({
name: 'calculatedFromNatural',
natural: true
});
new SizeModel({
name: 'calculatedFromShrinkWrap',
shrinkWrap: true
});
new SizeModel({
name: 'constrainedMax',
configured: true,
constrained: true,
names: { width: 'maxWidth', height: 'maxHeight' }
});
new SizeModel({
name: 'constrainedMin',
configured: true,
constrained: true,
names: { width: 'minWidth', height: 'minHeight' }
});
new SizeModel({
name: 'constrainedDock',
configured: true,
constrained: true,
constrainedByMin: true,
names: { width: 'dockConstrainedWidth', height: 'dockConstrainedHeight' }
});
for (i = 0, n = sizeModelsArray.length; i < n; ++i) {
sizeModel = sizeModelsArray[i];

sizeModel.pairsByHeightOrdinal = pairs = [];
for (j = 0; j < n; ++j) {
pairs.push({
width: sizeModel,
height: sizeModelsArray[j]
});
}
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/layout/Layout.js */
(function(Ext) {
Ext.define('Ext.layout.Layout', {
requires: [
'Ext.XTemplate',
'Ext.layout.SizeModel'
],
uses: [ 'Ext.layout.Context' ],

isLayout: true,
initialized: false,
running: false,
autoSizePolicy: {
readsWidth: 1,
readsHeight: 1,
setsWidth: 0,
setsHeight: 0
},
statics: {
layoutsByType: {},
create: function(layout, defaultType) {
var ClassManager = Ext.ClassManager,
layoutsByType = this.layoutsByType,
alias, className, config, layoutClass, type, load;
if (!layout || typeof layout === 'string') {
type = layout || defaultType;
config = {}; 
} else if (layout.isLayout) {
return layout;
} else {
config = layout;
type = layout.type || defaultType;
}
if (!(layoutClass = layoutsByType[type])) {
alias = 'layout.' + type;
className = ClassManager.getNameByAlias(alias);
// this is needed to support demand loading of the class
if (!className) {
load = true;
}

layoutClass = ClassManager.get(className);
if (load || !layoutClass) {
return ClassManager.instantiateByAlias(alias, config || {});
}
layoutsByType[type] = layoutClass;
}
return new layoutClass(config);
}
},
constructor : function(config) {
var me = this;
me.id = Ext.id(null, me.type + '-');
Ext.apply(me, config);
me.layoutCount = 0;
},


beginLayout: Ext.emptyFn,

beginLayoutCycle: function (ownerContext) {
var me = this,
context = me.context,
changed;
if (me.lastWidthModel != ownerContext.widthModel) {
if (me.lastWidthModel) {
changed = true;
}
me.lastWidthModel = ownerContext.widthModel;
}
if (me.lastHeightModel != ownerContext.heightModel) {
if (me.lastWidthModel) {
changed = true;
}
me.lastHeightModel = ownerContext.heightModel;
}
if (changed) {
(context = ownerContext.context).clearTriggers(me, false);
context.clearTriggers(me, true);
me.triggerCount = 0;
}
},




finishedLayout: function (ownerContext) {
this.lastWidthModel = ownerContext.widthModel;
this.lastHeightModel = ownerContext.heightModel;
this.ownerContext = null;
},



redoLayout: Ext.emptyFn,
undoLayout: Ext.emptyFn,
getAnimatePolicy: function() {
return this.animatePolicy;
},

getItemSizePolicy: function (item) {
return this.autoSizePolicy;
},
isItemBoxParent: function (itemContext) {
return false;
},
isItemLayoutRoot: function (item) {
var sizeModel = item.getSizeModel(),
width = sizeModel.width,
height = sizeModel.height;
// If this component has never had a layout and some of its dimensions are set by
// its ownerLayout, we cannot be the layoutRoot...
if (!item.componentLayout.lastComponentSize && (width.calculated || height.calculated)) {
return false;
}
// otherwise an ownerCt whose size is not effected by its content is a root
return !width.shrinkWrap && !height.shrinkWrap;
},
isItemShrinkWrap: function (item) {
return item.shrinkWrap;
},
isRunning: function () {
return !!this.ownerContext;
},
//-----------------------------------------------------

//-----------------------------------------------------
getItemsRenderTree: function (items, renderCfgs) {
var length = items.length,
i, item, itemConfig, result;
if (length) {
result = [];
for (i = 0; i < length; ++i) {
item = items[i];
// If we are being asked to move an already rendered Component, we must not recalculate its renderTree
// and rerun its render process. The Layout's isValidParent check will ensure that the DOM is moved into place.
if (!item.rendered) {
// If we've already calculated the item's element config, don't calculate it again.
// This may happen if the rendering process mutates the owning Container's items
// collection, and Ext.layout.Container#getRenderTree runs through the collection again.
// Note that the config may be null if a beforerender listener vetoed the operation, so
// we must compare to undefined.
if (renderCfgs && (renderCfgs[item.id] !== undefined)) {
itemConfig = renderCfgs[item.id];
} else {
// Perform layout preprocessing in the bulk render path
this.configureItem(item);
itemConfig = item.getRenderTree();
if (renderCfgs) {
renderCfgs[item.id] = itemConfig;
}
}
// itemConfig mey be null if a beforerender listener vetoed the operation.
if (itemConfig) {
result.push(itemConfig);
}
}
}
}
return result;
},
finishRender: Ext.emptyFn,
finishRenderItems: function (target, items) {
var length = items.length,
i, item;
for (i = 0; i < length; i++) {
item = items[i];
// Only postprocess items which are being rendered. deferredRender may mean that only one has been rendered.
if (item.rendering) {
// Tell the item at which index in the Container it is
item.finishRender(i);
this.afterRenderItem(item);
}
}
},
renderChildren: function () {
var me = this,
items = me.getLayoutItems(),
target = me.getRenderTarget();
me.renderItems(items, target);
},

renderItems : function(items, target) {
var me = this,
ln = items.length,
i = 0,
item;
if (ln) {
Ext.suspendLayouts();
for (; i < ln; i++) {
item = items[i];
if (item && !item.rendered) {
me.renderItem(item, target, i);
} else if (!me.isValidParent(item, target, i)) {
me.moveItem(item, target, i);
} else {
// still need to configure the item, it may have moved in the container.
me.configureItem(item);
}
}
Ext.resumeLayouts(true);
}
},

isValidParent : function(item, target, position) {
var itemDom = item.el ? item.el.dom : Ext.getDom(item),
targetDom = (target && target.dom) || target,
parentNode = itemDom.parentNode,
className;
// If it's resizable+wrapped, the position element is the wrapper.
if (parentNode) {
className = parentNode.className;
if (className && className.indexOf(Ext.baseCSSPrefix + 'resizable-wrap') !== -1) {
itemDom = itemDom.parentNode;
}
}
// Test DOM nodes for equality using "===" : http://jsperf.com/dom-equality-test
if (itemDom && targetDom) {
if (typeof position == 'number') {
position = this.getPositionOffset(position);
return itemDom === targetDom.childNodes[position];
}
return itemDom.parentNode === targetDom;
}
return false;
},

getPositionOffset: function(position){
return position;
},

configureItem: function(item) {
item.ownerLayout = this;
},

renderItem : function(item, target, position) {
var me = this;
if (!item.rendered) {
me.configureItem(item);
item.render(target, position);
me.afterRenderItem(item);
}
},

moveItem : function(item, target, position) {
target = target.dom || target;
if (typeof position == 'number') {
position = target.childNodes[position];
}
target.insertBefore(item.el.dom, position || null);
item.container = Ext.get(target);
this.configureItem(item);
},

onContentChange: function () {
this.owner.updateLayout();
return true;
},

initLayout : function() {
this.initialized = true;
},
// @private Sets the layout owner
setOwner : function(owner) {
this.owner = owner;
},

getLayoutItems : function() {
return [];
},
onAdd: function (item) {
item.ownerLayout = this;
},
afterRenderItem: Ext.emptyFn,
onRemove : Ext.emptyFn,
onDestroy : Ext.emptyFn,

afterRemove : function(item) {
var me = this,
el = item.el,
owner = me.owner,
removeClasses;
if (item.rendered) {
removeClasses = [].concat(me.itemCls || []);
if (owner.itemCls) {
removeClasses = Ext.Array.push(removeClasses, owner.itemCls);
}
if (removeClasses.length) {
el.removeCls(removeClasses);
}
}
delete item.ownerLayout;
},

destroy : function() {
var me = this,
target;
if (me.targetCls) {
target = me.getTarget();
if (target) {
target.removeCls(me.targetCls);
}
}
me.onDestroy();
},
sortWeightedItems: function (items, reverseProp) {
for (var i = 0, length = items.length; i < length; ++i) {
items[i].$i = i;
}
Ext.Array.sort(items, function (item1, item2) {
var ret = item2.weight - item1.weight;
if (!ret) {
ret = item1.$i - item2.$i;
if (item1[reverseProp]) {
ret = -ret;
}
}
return ret;
});
for (i = 0; i < length; ++i) {
delete items[i].$i;
}
}
}, function () {
var Layout = this;
Layout.prototype.sizeModels = Layout.sizeModels = Ext.layout.SizeModel.sizeModels;
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/layout/Context.js */
(function(Ext) {
Ext.define('Ext.layout.Context', {
requires: [
'Ext.util.Queue',
'Ext.layout.ContextItem',
'Ext.layout.Layout',
'Ext.fx.Anim',
'Ext.fx.Manager'
],
remainingLayouts: 0,

state: 0,
constructor: function (config) {
var me = this;
Ext.apply(me, config);
// holds the ContextItem collection, keyed by element id
me.items = {};
// a collection of layouts keyed by layout id
me.layouts = {};
// the number of blocks of any kind:
me.blockCount = 0;
// the number of cycles that have been run:
me.cycleCount = 0;
// the number of flushes to the DOM:
me.flushCount = 0;
// the number of layout calculate calls:
me.calcCount = 0;
me.animateQueue = me.newQueue();
me.completionQueue = me.newQueue();
me.finalizeQueue = me.newQueue();
me.finishQueue = me.newQueue();
me.flushQueue = me.newQueue();
me.invalidateData = {};

me.layoutQueue = me.newQueue();
// this collection is special because we ensure that there are no parent/child pairs
// present, only distinct top-level components
me.invalidQueue = [];
me.triggers = {
data: {

},
dom: {}
};
},
callLayout: function (layout, methodName) {
this.currentLayout = layout;
layout[methodName](this.getCmp(layout.owner));
},
cancelComponent: function (comp, isChild, isDestroying) {
var me = this,
components = comp,
isArray = !comp.isComponent,
length = isArray ? components.length : 1,
i, k, klen, items, layout, newQueue, oldQueue, entry, temp,
ownerCtContext;
for (i = 0; i < length; ++i) {
if (isArray) {
comp = components[i];
}
// If the component is being destroyed, remove the component's ContextItem from its parent's contextItem.childItems array
if (isDestroying && comp.ownerCt) {
ownerCtContext = this.items[comp.ownerCt.el.id];
if (ownerCtContext) {
Ext.Array.remove(ownerCtContext.childItems, me.getCmp(comp));
}
}
if (!isChild) {
oldQueue = me.invalidQueue;
klen = oldQueue.length;
if (klen) {
me.invalidQueue = newQueue = [];
for (k = 0; k < klen; ++k) {
entry = oldQueue[k];
temp = entry.item.target;
if (temp != comp && !temp.isDescendant(comp)) {
newQueue.push(entry);
}
}
}
}
layout = comp.componentLayout;
me.cancelLayout(layout);
if (layout.getLayoutItems) {
items = layout.getLayoutItems();
if (items.length) {
me.cancelComponent(items, true);
}
}
if (comp.isContainer && !comp.collapsed) {
layout = comp.layout;
me.cancelLayout(layout);
items = layout.getVisibleItems();
if (items.length) {
me.cancelComponent(items, true);
}
}
}
},
cancelLayout: function (layout) {
var me = this;
me.completionQueue.remove(layout);
me.finalizeQueue.remove(layout);
me.finishQueue.remove(layout);
me.layoutQueue.remove(layout);
if (layout.running) {
me.layoutDone(layout);
}
layout.ownerContext = null;
},
clearTriggers: function (layout, inDom) {
var id = layout.id,
collection = this.triggers[inDom ? 'dom' : 'data'],
triggers = collection && collection[id],
length = (triggers && triggers.length) || 0,
i, item, trigger;
for (i = 0; i < length; ++i) {
trigger = triggers[i];
item = trigger.item;
collection = inDom ? item.domTriggers : item.triggers;
delete collection[trigger.prop][id];
}
},

flush: function () {
var me = this,
items = me.flushQueue.clear(),
length = items.length, i;
if (length) {
++me.flushCount;
for (i = 0; i < length; ++i) {
items[i].flush();
}
}
},
flushAnimations: function() {
var me = this,
items = me.animateQueue.clear(),
len = items.length,
i;
if (len) {
for (i = 0; i < len; i++) {
// Each Component may refuse to participate in animations.
// This is used by the BoxReorder plugin which drags a Component,
// during which that Component must be exempted from layout positioning.
if (items[i].target.animate !== false) {
items[i].flushAnimations();
}
}
// Ensure the first frame fires now to avoid a browser repaint with the elements in the "to" state
// before they are returned to their "from" state by the animation.
Ext.fx.Manager.runner();
}
},
flushInvalidates: function () {
var me = this,
queue = me.invalidQueue,
length = queue && queue.length,
comp, components, entry, i;
me.invalidQueue = [];
if (length) {
components = [];
for (i = 0; i < length; ++i) {
comp = (entry = queue[i]).item.target;
// we filter out-of-body components here but allow them into the queue to
// ensure that their child components are coalesced out (w/no additional
// cost beyond our normal effort to avoid parent/child components in the
// queue)
if (!comp.container.isDetachedBody) {
components.push(comp);
if (entry.options) {
me.invalidateData[comp.id] = entry.options;
}
}
}
me.invalidate(components, null);
}
},
flushLayouts: function (queueName, methodName, dontClear) {
var me = this,
layouts = dontClear ? me[queueName].items : me[queueName].clear(),
length = layouts.length,
i, layout;
if (length) {
for (i = 0; i < length; ++i) {
layout = layouts[i];
if (!layout.running) {
me.callLayout(layout, methodName);
}
}
me.currentLayout = null;
}
},

getCmp: function (cmp) {
return this.getItem(cmp, cmp.el);
},

getEl: function (parent, el) {
var item = this.getItem(el, el);
if (!item.parent) {
item.parent = parent;
// all items share an empty children array (to avoid null checks), so we can
// only push on to the children array if there is already something there (we
// copy-on-write):
if (parent.children.length) {
parent.children.push(item);
} else {
parent.children = [ item ]; // now parent has its own children[] (length=1)
}
}
return item;
},
getItem: function (target, el) {
var id = el.id,
items = this.items,
item = items[id] ||
(items[id] = new Ext.layout.ContextItem({
context: this,
target: target,
el: el
}));
return item;
},
handleFailure: function () {
// This method should never be called, but is need when layouts fail (hence the
// "should never"). We just disconnect any of the layouts from the run and return
// them to the state they would be in had the layout completed properly.
var layouts = this.layouts,
layout, key;
Ext.failedLayouts = (Ext.failedLayouts || 0) + 1;
for (key in layouts) {
layout = layouts[key];
if (layouts.hasOwnProperty(key)) {
layout.running = false;
layout.ownerContext = null;
}
}
//<debug>
if (Ext.repoDevMode && !this.pageAnalyzerMode) {
Ext.Error.raise('Layout run failed');
} else {
Ext.log.error('Layout run failed');
}
//</debug>
},

invalidate: function (components, full) {
var me = this,
isArray = !components.isComponent,
containerLayoutDone,
firstTime, i, comp, item, items, length, componentLayout, layout,
invalidateOptions, token;
for (i = 0, length = isArray ? components.length : 1; i < length; ++i) {
comp = isArray ? components[i] : components;
if (comp.rendered && !comp.hidden) {
item = me.getCmp(comp);

// Layout optimizations had to be disabled because they break
// Dock layout behavior.
// if (item.optOut) {
// continue;
// }
componentLayout = comp.componentLayout;
firstTime = !componentLayout.ownerContext;
layout = (comp.isContainer && !comp.collapsed) ? comp.layout : null;
// Extract any invalidate() options for this item.
invalidateOptions = me.invalidateData[item.id];
delete me.invalidateData[item.id];
// We invalidate the contextItem's in a top-down manner so that SizeModel
// info for containers is available to their children. This is a critical
// optimization since sizeModel determination often requires knowing the
// sizeModel of the ownerCt. If this weren't cached as we descend, this
// would be an O(N^2) operation! (where N=number of components, or 300+/-
// in Themes)
token = item.init(full, invalidateOptions);
if (invalidateOptions) {
me.processInvalidate(invalidateOptions, item, 'before');
}
// Allow the component layout a chance to effect its size model before we
// recurse down the component hierarchy (since children need to know the
// size model of their ownerCt).
if (componentLayout.beforeLayoutCycle) {
componentLayout.beforeLayoutCycle(item);
}

if (layout && layout.beforeLayoutCycle) {
// allow the container layout take a peek as well. Table layout can
// influence its children's styling due to the interaction of nesting
// table-layout:fixed and auto inside each other without intervening
// elements of known size.
layout.beforeLayoutCycle(item);
}
// Finish up the item-level processing that is based on the size model of
// the component.
token = item.initContinue(token);
// Start this state variable at true, since that is the value we want if
// they do not apply (i.e., no work of this kind on which to wait).
containerLayoutDone = true;
// A ComponentLayout MUST implement getLayoutItems to allow its children
// to be collected. Ext.container.Container does this, but non-Container
// Components which manage Components as part of their structure (e.g.,
// HtmlEditor) must still return child Components via getLayoutItems.
if (componentLayout.getLayoutItems) {
componentLayout.renderChildren();
items = componentLayout.getLayoutItems();
if (items.length) {
me.invalidate(items, true);
}
}
if (layout) {
containerLayoutDone = false;
layout.renderChildren();
items = layout.getVisibleItems();
if (items.length) {
me.invalidate(items, true);
}
}
// Finish the processing that requires the size models of child items to
// be determined (and some misc other stuff).
item.initDone(containerLayoutDone);
// Inform the layouts that we are about to begin (or begin again) now that
// the size models of the component and its children are setup.
me.resetLayout(componentLayout, item, firstTime);
if (layout) {
me.resetLayout(layout, item, firstTime);
}
// This has to occur after the component layout has had a chance to begin
// so that we can determine what kind of animation might be needed. TODO-
// move this determination into the layout itself.
item.initAnimation();
if (invalidateOptions) {
me.processInvalidate(invalidateOptions, item, 'after');
}
}
}
me.currentLayout = null;
},
layoutDone: function (layout) {
var ownerContext = layout.ownerContext;
layout.running = false;
// Once a component layout completes, we can mark it as "done".
if (layout.isComponentLayout) {
if (ownerContext.measuresBox) {
ownerContext.onBoxMeasured(); // be sure to release our boxParent
}
ownerContext.setProp('done', true);
} else {
ownerContext.setProp('containerLayoutDone', true);
}
--this.remainingLayouts;
++this.progressCount; // a layout completion is progress
},
newQueue: function () {
return new Ext.util.Queue();
},
processInvalidate: function (options, item, name) {
// When calling a callback, the currentLayout needs to be adjusted so
// that whichever layout caused the invalidate is the currentLayout...
if (options[name]) {
var me = this,
currentLayout = me.currentLayout;
me.currentLayout = options.layout || null;
options[name](item, options);
me.currentLayout = currentLayout;
}
},

queueAnimation: function (item) {
this.animateQueue.add(item);
},

queueCompletion: function (layout) {
this.completionQueue.add(layout);
},

queueFinalize: function (layout) {
this.finalizeQueue.add(layout);
},

queueFlush: function (item) {
this.flushQueue.add(item);
},
chainFns: function (oldOptions, newOptions, funcName) {
var me = this,
oldLayout = oldOptions.layout,
newLayout = newOptions.layout,
oldFn = oldOptions[funcName],
newFn = newOptions[funcName];
// Call newFn last so it can get the final word on things... also, the "this"
// pointer will be passed correctly by createSequence with oldFn first.
return function (contextItem) {
var prev = me.currentLayout;
if (oldFn) {
me.currentLayout = oldLayout;
oldFn.call(oldOptions.scope || oldOptions, contextItem, oldOptions);
}
me.currentLayout = newLayout;
newFn.call(newOptions.scope || newOptions, contextItem, newOptions);
me.currentLayout = prev;
};
},

queueInvalidate: function (item, options) {
var me = this,
newQueue = [],
oldQueue = me.invalidQueue,
index = oldQueue.length,
comp, old, oldComp, oldOptions, oldState;
if (item.isComponent) {
item = me.getCmp(comp = item);
} else {
comp = item.target;
}
item.invalid = true;
// See if comp is contained by any component already in the queue (ignore comp if
// that is the case). Eliminate any components in the queue that are contained by
// comp (by not adding them to newQueue).
while (index--) {
old = oldQueue[index];
oldComp = old.item.target;
if (comp.isDescendant(oldComp)) {
return; // oldComp contains comp, so this invalidate is redundant
}
if (oldComp == comp) {
// if already in the queue, update the options...
if (!(oldOptions = old.options)) {
old.options = options;
} else if (options) {
if (options.widthModel) {
oldOptions.widthModel = options.widthModel;
}
if (options.heightModel) {
oldOptions.heightModel = options.heightModel;
}
if (!(oldState = oldOptions.state)) {
oldOptions.state = options.state;
} else if (options.state) {
Ext.apply(oldState, options.state);
}
if (options.before) {
oldOptions.before = me.chainFns(oldOptions, options, 'before');
}
if (options.after) {
oldOptions.after = me.chainFns(oldOptions, options, 'after');
}
}
// leave the old queue alone now that we've update this comp's entry...
return;
}
if (!oldComp.isDescendant(comp)) {
newQueue.push(old); // comp does not contain oldComp
}
// else if (oldComp isDescendant of comp) skip
}
// newQueue contains only those components not a descendant of comp
// to get here, comp must not be a child of anything already in the queue, so it
// needs to be added along with its "options":
newQueue.push({ item: item, options: options });
me.invalidQueue = newQueue;
},
queueItemLayouts: function (item) {
var comp = item.isComponent ? item : item.target,
layout = comp.componentLayout;
if (!layout.pending && !layout.invalid && !layout.done) {
this.queueLayout(layout);
}
layout = comp.layout;
if (layout && !layout.pending && !layout.invalid && !layout.done) {
this.queueLayout(layout);
}
},

queueLayout: function (layout) {
this.layoutQueue.add(layout);
layout.pending = true;
},

removeEl: function (parent, el) {
var id = el.id,
children = parent.children,
items = this.items;
if(children) {
Ext.Array.remove(children, items[id]);
}
delete items[id];
},

resetLayout: function (layout, ownerContext, firstTime) {
var me = this;
me.currentLayout = layout;
layout.done = false;
layout.pending = true;
layout.firedTriggers = 0;
me.layoutQueue.add(layout);
if (firstTime) {
me.layouts[layout.id] = layout; // track the layout for this run by its id
layout.running = true;
if (layout.finishedLayout) {
me.finishQueue.add(layout);
}
// reset or update per-run counters:
++me.remainingLayouts;
++layout.layoutCount; // the number of whole layouts run for the layout
layout.ownerContext = ownerContext;
layout.beginCount = 0; // the number of beginLayout calls
layout.blockCount = 0; // the number of blocks set for the layout
layout.calcCount = 0; // the number of times calculate is called
layout.triggerCount = 0; // the number of triggers set for the layout
if (!layout.initialized) {
layout.initLayout();
}
layout.beginLayout(ownerContext);
} else {
++layout.beginCount;
if (!layout.running) {
// back into the mahem with this one:
++me.remainingLayouts;
layout.running = true;
if (layout.isComponentLayout) {
// this one is fun... if we call setProp('done', false) that would still
// trigger/unblock layouts, but what layouts are really looking for with
// this property is for it to go to true, not just be set to a value...
ownerContext.unsetProp('done');
}
// and it needs to be removed from the completion and/or finalize queues...
me.completionQueue.remove(layout);
me.finalizeQueue.remove(layout);
}
}
layout.beginLayoutCycle(ownerContext, firstTime);
},

run: function () {
var me = this,
flushed = false,
watchDog = 100;
me.flushInvalidates();
me.state = 1;
me.totalCount = me.layoutQueue.getCount();
// We may start with unflushed data placed by beginLayout calls. Since layouts may
// use setProp as a convenience, even in a write phase, we don't want to transition
// to a read phase with unflushed data since we can write it now "cheaply". Also,
// these value could easily be needed in the DOM in order to really get going with
// the calculations. In particular, fixed (configured) dimensions fall into this
// category.
me.flush();
// While we have layouts that have not completed...
while ((me.remainingLayouts || me.invalidQueue.length) && watchDog--) {
if (me.invalidQueue.length) {
me.flushInvalidates();
}
// if any of them can run right now, run them
if (me.runCycle()) {
flushed = false; // progress means we probably need to flush something
// but not all progress appears in the flushQueue (e.g. 'contentHeight')
} else if (!flushed) {
// as long as we are making progress, flush updates to the DOM and see if
// that triggers or unblocks any layouts...
me.flush();
flushed = true; // all flushed now, so more progress is required
me.flushLayouts('completionQueue', 'completeLayout');
} else if (!me.invalidQueue.length) {
// after a flush, we must make progress or something is WRONG
me.state = 2;
break;
}
if (!(me.remainingLayouts || me.invalidQueue.length)) {
me.flush();
me.flushLayouts('completionQueue', 'completeLayout');
me.flushLayouts('finalizeQueue', 'finalizeLayout');
}
}
return me.runComplete();
},
runComplete: function () {
var me = this;
me.state = 2;
if (me.remainingLayouts) {
me.handleFailure();
return false;
}
me.flush();
// Call finishedLayout on all layouts, but do not clear the queue.
me.flushLayouts('finishQueue', 'finishedLayout', true);
// Call notifyOwner on all layouts and then clear the queue.
me.flushLayouts('finishQueue', 'notifyOwner');
me.flush(); // in case any setProp calls were made
me.flushAnimations();
return true;
},

runCycle: function () {
var me = this,
layouts = me.layoutQueue.clear(),
length = layouts.length,
i;
++me.cycleCount;
// This value is incremented by ContextItem#setProp whenever new values are set
// (thereby detecting forward progress):
me.progressCount = 0;
for (i = 0; i < length; ++i) {
me.runLayout(me.currentLayout = layouts[i]);
}
me.currentLayout = null;
return me.progressCount > 0;
},

runLayout: function (layout) {
var me = this,
ownerContext = me.getCmp(layout.owner);
layout.pending = false;
if (ownerContext.state.blocks) {
return;
}
// We start with the assumption that the layout will finish and if it does not, it
// must clear this flag. It turns out this is much simpler than knowing when a layout
// is done (100% correctly) when base classes and derived classes are collaborating.
// Knowing that some part of the layout is not done is much more obvious.
layout.done = true;
++layout.calcCount;
++me.calcCount;
layout.calculate(ownerContext);
if (layout.done) {
me.layoutDone(layout);
if (layout.completeLayout) {
me.queueCompletion(layout);
}
if (layout.finalizeLayout) {
me.queueFinalize(layout);
}
} else if (!layout.pending && !layout.invalid && !(layout.blockCount + layout.triggerCount - layout.firedTriggers)) {
// A layout that is not done and has no blocks or triggers that will queue it
// automatically, must be queued now:
me.queueLayout(layout);
}
},

setItemSize: function(item, width, height) {
var items = item,
len = 1,
contextItem, i;
// NOTE: we don't pre-check for validity because:
// - maybe only one dimension is valid
// - the diagnostics layer will track the setProp call to help find who is trying
// (but failing) to set a property
// - setProp already checks this anyway
if (item.isComposite) {
items = item.elements;
len = items.length;
item = items[0];
} else if (!item.dom && !item.el) { // array by process of elimination
len = items.length;
item = items[0];
}
// else len = 1 and items = item (to avoid error on "items[++i]")
for (i = 0; i < len; ) {
contextItem = this.get(item);
contextItem.setSize(width, height);
item = items[++i]; // this accomodation avoids making an array of 1
}
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/layout/component/Component.js */
(function(Ext) {
Ext.define('Ext.layout.component.Component', {

extend: 'Ext.layout.Layout',

type: 'component',
isComponentLayout: true,
nullBox: {},
usesContentHeight: true,
usesContentWidth: true,
usesHeight: true,
usesWidth: true,
beginLayoutCycle: function (ownerContext, firstCycle) {
var me = this,
owner = me.owner,
ownerCtContext = ownerContext.ownerCtContext,
heightModel = ownerContext.heightModel,
widthModel = ownerContext.widthModel,
body = owner.el.dom === document.body,
lastBox = owner.lastBox || me.nullBox,
lastSize = owner.el.lastBox || me.nullBox,
dirty = !body,
ownerLayout, v, widthName, heightName;
me.callParent(arguments);
if (firstCycle) {
if (me.usesContentWidth) {
++ownerContext.consumersContentWidth;
}
if (me.usesContentHeight) {
++ownerContext.consumersContentHeight;
}
if (me.usesWidth) {
++ownerContext.consumersWidth;
}
if (me.usesHeight) {
++ownerContext.consumersHeight;
}
if (ownerCtContext && !ownerCtContext.hasRawContent) {
ownerLayout = owner.ownerLayout;
if (ownerLayout.usesWidth) {
++ownerContext.consumersWidth;
}
if (ownerLayout.usesHeight) {
++ownerContext.consumersHeight;
}
}
}
// we want to publish configured dimensions as early as possible and since this is
// a write phase...
if (widthModel.configured) {
// If the owner.el is the body, owner.width is not dirty (we don't want to write
// it to the body el). For other el's, the width may already be correct in the
// DOM (e.g., it is rendered in the markup initially). If the width is not
// correct in the DOM, this is only going to be the case on the first cycle.
widthName = widthModel.names.width;
if (!body) {
dirty = firstCycle ? owner[widthName] !== lastSize.width
: widthModel.constrained;
}

ownerContext.setWidth(owner[widthName], dirty);
} else if (ownerContext.isTopLevel) {
if (widthModel.calculated) {
v = lastBox.width;
ownerContext.setWidth(v, v != lastSize.width);
}
v = lastBox.x;
ownerContext.setProp('x', v, v != lastSize.x);
}
if (heightModel.configured) {
heightName = heightModel.names.height;
if (!body) {
dirty = firstCycle ? owner[heightName] !== lastSize.height
: heightModel.constrained;
}
ownerContext.setHeight(owner[heightName], dirty);
} else if (ownerContext.isTopLevel) {
if (heightModel.calculated) {
v = lastBox.height;
ownerContext.setHeight(v, v != lastSize.height);
}
v = lastBox.y;
ownerContext.setProp('y', v, v != lastSize.y);
}
},
finishedLayout: function(ownerContext) {
var me = this,
elementChildren = ownerContext.children,
owner = me.owner,
len, i, elContext, lastBox, props;
// NOTE: In the code below we cannot use getProp because that will generate a layout dependency
// Set lastBox on managed child Elements.
// So that ContextItem.constructor can snag the lastBox for use by its undo method.
if (elementChildren) {
len = elementChildren.length;
for (i = 0; i < len; i++) {
elContext = elementChildren[i];
elContext.el.lastBox = elContext.props;
}
}
// Cache the size from which we are changing so that notifyOwner can notify the owningComponent with all essential information
ownerContext.previousSize = me.lastComponentSize;
// Cache the currently layed out size
me.lastComponentSize = owner.el.lastBox = props = ownerContext.props;

// lastBox is a copy of the defined props to allow save/restore of these (panel
// collapse needs this)
lastBox = owner.lastBox || (owner.lastBox = {});
lastBox.x = props.x;
lastBox.y = props.y;
lastBox.width = props.width;
lastBox.height = props.height;
lastBox.invalid = false;

me.callParent(arguments);
},

notifyOwner: function(ownerContext) {
var me = this,
currentSize = me.lastComponentSize,
prevSize = ownerContext.previousSize,
args = [currentSize.width, currentSize.height];
if (prevSize) {
args.push(prevSize.width, prevSize.height);
}
// Call afterComponentLayout passing new size, and only passing old size if there *was* an old size.
me.owner.afterComponentLayout.apply(me.owner, args);
},

getTarget : function() {
return this.owner.el;
},

getRenderTarget : function() {
return this.owner.el;
},
cacheTargetInfo: function(ownerContext) {
var me = this,
targetInfo = me.targetInfo,
target;
if (!targetInfo) {
target = ownerContext.getEl('getTarget', me);
me.targetInfo = targetInfo = {
padding: target.getPaddingInfo(),
border: target.getBorderInfo()
};
}
return targetInfo;
},
measureAutoDimensions: function (ownerContext, dimensions) {
// Subtle But Important:
// 
// We don't want to call getProp/hasProp et.al. unless we in fact need that value
// for our results! If we call it and don't need it, the layout manager will think
// we depend on it and will schedule us again should it change.
var me = this,
owner = me.owner,
containerLayout = owner.layout,
heightModel = ownerContext.heightModel,
widthModel = ownerContext.widthModel,
boxParent = ownerContext.boxParent,
isBoxParent = ownerContext.isBoxParent,
props = ownerContext.props,
isContainer,
ret = {
gotWidth: false,
gotHeight: false,
isContainer: (isContainer = !ownerContext.hasRawContent)
},
hv = dimensions || 3,
zeroWidth, zeroHeight,
needed = 0,
got = 0,
ready, size, temp;
// Note: this method is called *a lot*, so we have to be careful not to waste any
// time or make useless calls or, especially, read the DOM when we can avoid it.
//---------------------------------------------------------------------
// Width
if (widthModel.shrinkWrap && ownerContext.consumersContentWidth) {
++needed;
zeroWidth = !(hv & 1);
if (isContainer) {
// as a componentLayout for a container, we rely on the container layout to
// produce contentWidth...
if (zeroWidth) {
ret.contentWidth = 0;
ret.gotWidth = true;
++got;
} else if ((ret.contentWidth = ownerContext.getProp('contentWidth')) !== undefined) {
ret.gotWidth = true;
++got;
}
} else {
size = props.contentWidth;
if (typeof size == 'number') { // if (already determined)
ret.contentWidth = size;
ret.gotWidth = true;
++got;
} else {
if (zeroWidth) {
ready = true;
} else if (!ownerContext.hasDomProp('containerChildrenSizeDone')) {
ready = false;
} else if (isBoxParent || !boxParent || boxParent.widthModel.shrinkWrap) {
// if we have no boxParent, we are ready, but a shrinkWrap boxParent
// artificially provides width early in the measurement process so
// we are ready to go in that case as well...
ready = true;
} else {
// lastly, we have a boxParent that will be given a width, so we
// can wait for that width to be set in order to properly measure
// whatever is inside...
ready = boxParent.hasDomProp('width');
}
if (ready) {
if (zeroWidth) {
temp = 0;
} else if (containerLayout && containerLayout.measureContentWidth) {
// Allow the container layout to do the measurement since it
// may have a better idea of how to do it even with no items:
temp = containerLayout.measureContentWidth(ownerContext);
} else {
temp = me.measureContentWidth(ownerContext);
}
if (!isNaN(ret.contentWidth = temp)) {
ownerContext.setContentWidth(temp, true);
ret.gotWidth = true;
++got;
}
}
}
}
} else if (widthModel.natural && ownerContext.consumersWidth) {
++needed;
size = props.width;
// zeroWidth does not apply
if (typeof size == 'number') { // if (already determined)
ret.width = size;
ret.gotWidth = true;
++got;
} else {
if (isBoxParent || !boxParent) {
ready = true;
} else {
// lastly, we have a boxParent that will be given a width, so we
// can wait for that width to be set in order to properly measure
// whatever is inside...
ready = boxParent.hasDomProp('width');
}
if (ready) {
if (!isNaN(ret.width = me.measureOwnerWidth(ownerContext))) {
ownerContext.setWidth(ret.width, false);
ret.gotWidth = true;
++got;
}
}
}
}
//---------------------------------------------------------------------
// Height
if (heightModel.shrinkWrap && ownerContext.consumersContentHeight) {
++needed;
zeroHeight = !(hv & 2);
if (isContainer) {
// don't ask unless we need to know...
if (zeroHeight) {
ret.contentHeight = 0;
ret.gotHeight = true;
++got;
} else if ((ret.contentHeight = ownerContext.getProp('contentHeight')) !== undefined) {
ret.gotHeight = true;
++got;
}
} else {
size = props.contentHeight;
if (typeof size == 'number') { // if (already determined)
ret.contentHeight = size;
ret.gotHeight = true;
++got;
} else {
if (zeroHeight) {
ready = true;
} else if (!ownerContext.hasDomProp('containerChildrenSizeDone')) {
ready = false;
} else if (owner.noWrap) {
ready = true;
} else if (!widthModel.shrinkWrap) {
// fixed width, so we need the width to determine the height...
ready = (ownerContext.bodyContext || ownerContext).hasDomProp('width');// && (!ownerContext.bodyContext || ownerContext.bodyContext.hasDomProp('width'));
} else if (isBoxParent || !boxParent || boxParent.widthModel.shrinkWrap) {
// if we have no boxParent, we are ready, but an autoWidth boxParent
// artificially provides width early in the measurement process so
// we are ready to go in that case as well...
ready = true;
} else {
// lastly, we have a boxParent that will be given a width, so we
// can wait for that width to be set in order to properly measure
// whatever is inside...
ready = boxParent.hasDomProp('width');
}
if (ready) {
if (zeroHeight) {
temp = 0;
} else if (containerLayout && containerLayout.measureContentHeight) {
// Allow the container layout to do the measurement since it
// may have a better idea of how to do it even with no items:
temp = containerLayout.measureContentHeight(ownerContext);
} else {
temp = me.measureContentHeight(ownerContext);
}
if (!isNaN(ret.contentHeight = temp)) {
ownerContext.setContentHeight(temp, true);
ret.gotHeight = true;
++got;
}
}
}
}
} else if (heightModel.natural && ownerContext.consumersHeight) {
++needed;
size = props.height;
// zeroHeight does not apply
if (typeof size == 'number') { // if (already determined)
ret.height = size;
ret.gotHeight = true;
++got;
} else {
if (isBoxParent || !boxParent) {
ready = true;
} else {
// lastly, we have a boxParent that will be given a width, so we
// can wait for that width to be set in order to properly measure
// whatever is inside...
ready = boxParent.hasDomProp('width');
}
if (ready) {
if (!isNaN(ret.height = me.measureOwnerHeight(ownerContext))) {
ownerContext.setHeight(ret.height, false);
ret.gotHeight = true;
++got;
}
}
}
}
if (boxParent) {
ownerContext.onBoxMeasured();
}
ret.gotAll = got == needed;
// see if we can avoid calling this method by storing something on ownerContext.
return ret;
},
measureContentWidth: function (ownerContext) {
// contentWidth includes padding, but not border, framing or margins
return ownerContext.el.getWidth() - ownerContext.getFrameInfo().width;
},
measureContentHeight: function (ownerContext) {
// contentHeight includes padding, but not border, framing or margins
return ownerContext.el.getHeight() - ownerContext.getFrameInfo().height;
},
measureOwnerHeight: function (ownerContext) {
return ownerContext.el.getHeight();
},
measureOwnerWidth: function (ownerContext) {
return ownerContext.el.getWidth();
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/layout/component/Auto.js */
(function(Ext) {
Ext.define('Ext.layout.component.Auto', {

alias: 'layout.autocomponent',
extend: 'Ext.layout.component.Component',

type: 'autocomponent',

setHeightInDom: false,

setWidthInDom: false,
waitForOuterHeightInDom: false,
waitForOuterWidthInDom: false,

beginLayoutCycle: function(ownerContext, firstCycle){
var me = this,
lastWidthModel = me.lastWidthModel,
lastHeightModel = me.lastHeightModel,
el = me.owner.el;

me.callParent(arguments);

if (lastWidthModel && lastWidthModel.fixed && ownerContext.widthModel.shrinkWrap) {
el.setWidth(null);
}

if (lastHeightModel && lastHeightModel.fixed && ownerContext.heightModel.shrinkWrap) {
el.setHeight(null);
} 
},
calculate: function(ownerContext) {
var me = this,
measurement = me.measureAutoDimensions(ownerContext),
heightModel = ownerContext.heightModel,
widthModel = ownerContext.widthModel,
width, height;
// It is generally important to process widths before heights, since widths can
// often effect heights...
if (measurement.gotWidth) {
if (widthModel.shrinkWrap) {
me.publishOwnerWidth(ownerContext, measurement.contentWidth);
} else if (me.publishInnerWidth) {
me.publishInnerWidth(ownerContext, measurement.width);
}
} else if (!widthModel.auto && me.publishInnerWidth) {
width = me.waitForOuterWidthInDom ? ownerContext.getDomProp('width')
: ownerContext.getProp('width');
if (width === undefined) {
me.done = false;
} else {
me.publishInnerWidth(ownerContext, width);
}
}
if (measurement.gotHeight) {
if (heightModel.shrinkWrap) {
me.publishOwnerHeight(ownerContext, measurement.contentHeight);
} else if (me.publishInnerHeight) {
me.publishInnerHeight(ownerContext, measurement.height);
}
} else if (!heightModel.auto && me.publishInnerHeight) {
height = me.waitForOuterHeightInDom ? ownerContext.getDomProp('height')
: ownerContext.getProp('height');
if (height === undefined) {
me.done = false;
} else {
me.publishInnerHeight(ownerContext, height);
}
}
if (!measurement.gotAll) {
me.done = false;
}
},
calculateOwnerHeightFromContentHeight: function (ownerContext, contentHeight) {
return contentHeight + ownerContext.getFrameInfo().height;
},
calculateOwnerWidthFromContentWidth: function (ownerContext, contentWidth) {
return contentWidth + ownerContext.getFrameInfo().width;
},
publishOwnerHeight: function (ownerContext, contentHeight) {
var me = this,
owner = me.owner,
height = me.calculateOwnerHeightFromContentHeight(ownerContext, contentHeight),
constrainedHeight, dirty, heightModel;
if (isNaN(height)) {
me.done = false;
} else {
constrainedHeight = Ext.Number.constrain(height, owner.minHeight, owner.maxHeight);
if (constrainedHeight == height) {
dirty = me.setHeightInDom;
} else {
heightModel = me.sizeModels[
(constrainedHeight < height) ? 'constrainedMax' : 'constrainedMin'];
height = constrainedHeight;
if (ownerContext.heightModel.calculatedFromShrinkWrap) {
// Don't bother to invalidate since that will come soon... but we need
// to signal our ownerLayout that we need an invalidate to actually
// make good on the determined (constrained) size!
ownerContext.heightModel = heightModel;
} else {
ownerContext.invalidate({ heightModel: heightModel });
}
}

ownerContext.setHeight(height, dirty);
}
},
publishOwnerWidth: function (ownerContext, contentWidth) {
var me = this,
owner = me.owner,
width = me.calculateOwnerWidthFromContentWidth(ownerContext, contentWidth),
constrainedWidth, dirty, widthModel;
if (isNaN(width)) {
me.done = false;
} else {
constrainedWidth = Ext.Number.constrain(width, owner.minWidth, owner.maxWidth);
if (constrainedWidth == width) {
dirty = me.setWidthInDom;
} else {
widthModel = me.sizeModels[
(constrainedWidth < width) ? 'constrainedMax' : 'constrainedMin'];
width = constrainedWidth;
if (ownerContext.widthModel.calculatedFromShrinkWrap) {
// Don't bother to invalidate since that will come soon... but we need
// to signal our ownerLayout that we need an invalidate to actually
// make good on the determined (constrained) size!
ownerContext.widthModel = widthModel;
} else {
ownerContext.invalidate({ widthModel: widthModel });
}
}
ownerContext.setWidth(width, dirty);
}
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/ShadowPool.js */
(function(Ext) {
Ext.define('Ext.ShadowPool', {
singleton: true,
requires: ['Ext.DomHelper'],
markup: (function() {
return Ext.String.format(
'<div class="{0}{1}-shadow" role="presentation"></div>',
Ext.baseCSSPrefix,
Ext.isIE && !Ext.supports.CSS3BoxShadow ? 'ie' : 'css'
);
}()),
shadows: [],
pull: function() {
var sh = this.shadows.shift();
if (!sh) {
sh = Ext.get(Ext.DomHelper.insertHtml("beforeBegin", document.body.firstChild, this.markup));
sh.autoBoxAdjust = false;
}
return sh;
},
push: function(sh) {
this.shadows.push(sh);
},

reset: function() {
var shadows = [].concat(this.shadows),
s,
sLen = shadows.length;
for (s = 0; s < sLen; s++) {
shadows[s].remove();
}
this.shadows = [];
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/Shadow.js */
(function(Ext) {
Ext.define('Ext.Shadow', {
requires: ['Ext.ShadowPool'],
localXYNames: {
get: 'getLocalXY',
set: 'setLocalXY'
},

constructor: function(config) {
var me = this,
adjusts,
offset,
rad;

Ext.apply(me, config);
if (!Ext.isString(me.mode)) {
me.mode = me.defaultMode;
}
offset = me.offset;
rad = Math.floor(offset / 2);
me.opacity = 50;
switch (me.mode.toLowerCase()) {
// all this hideous nonsense calculates the various offsets for shadows
case "drop":
if (Ext.supports.CSS3BoxShadow) {
adjusts = {
t: offset,
l: offset,
h: -offset,
w: -offset
};
}
else {
adjusts = {
t: -rad,
l: -rad,
h: -rad,
w: -rad
};
}
break;
case "sides":
if (Ext.supports.CSS3BoxShadow) {
adjusts = {
t: offset,
l: 0,
h: -offset,
w: 0
};
}
else {
adjusts = {
t: - (1 + rad),
l: 1 + rad - 2 * offset,
h: -1,
w: rad - 1
};
}
break;
case "frame":
if (Ext.supports.CSS3BoxShadow) {
adjusts = {
t: 0,
l: 0,
h: 0,
w: 0
};
}
else {
adjusts = {
t: 1 + rad - 2 * offset,
l: 1 + rad - 2 * offset,
h: offset - rad - 1,
w: offset - rad - 1
};
}
break;
case "bottom":
if (Ext.supports.CSS3BoxShadow) {
adjusts = {
t: offset,
l: 0,
h: -offset,
w: 0
};
}
else {
adjusts = {
t: offset,
l: 0,
h: 0,
w: 0
};
}
break;
}
me.adjusts = adjusts;
},

getShadowSize: function() {
var me = this,
offset = me.el ? me.offset : 0,
result = [offset, offset, offset, offset],
mode = me.mode.toLowerCase();
// There are only offsets if the shadow element is present.
if (me.el && mode !== 'frame') {
result[0] = 0;
if (mode == 'drop') {
result[3] = 0;
}
}
return result;
},


offset: 4,
// private
defaultMode: "drop",
// private - CSS property to use to set the box shadow
boxShadowProperty: (function() {
var property = 'boxShadow',
style = document.documentElement.style;
if (!('boxShadow' in style)) {
if ('WebkitBoxShadow' in style) {
// Safari prior to version 5.1 and Chrome prior to version 10
property = 'WebkitBoxShadow';
}
else if ('MozBoxShadow' in style) {
// FF 3.5 & 3.6
property = 'MozBoxShadow';
}
}
return property;
}()),

show: function(target) {
var me = this,
index, xy;
target = Ext.get(target);

// DOM reads first...
index = (parseInt(target.getStyle("z-index"), 10) - 1) || 0;
xy = target[me.localXYNames.get]();
// DOM writes...
if (!me.el) {
me.el = Ext.ShadowPool.pull();
// Shadow elements are shared, so fix position to match current owner
if (me.fixed) {
me.el.dom.style.position = 'fixed';
} else {
me.el.dom.style.position = '';
}
if (me.el.dom.nextSibling != target.dom) {
me.el.insertBefore(target);
}
}
me.el.setStyle("z-index", me.zIndex || index);
if (Ext.isIE && !Ext.supports.CSS3BoxShadow) {
me.el.dom.style.filter = "progid:DXImageTransform.Microsoft.alpha(opacity=" + me.opacity + ") progid:DXImageTransform.Microsoft.Blur(pixelradius=" + (me.offset) + ")";
}
me.realign(
xy[0],
xy[1],
target.dom.offsetWidth,
target.dom.offsetHeight
);
me.el.dom.style.display = "block";
},

isVisible: function() {
return this.el ? true: false;
},

realign: function(l, t, targetWidth, targetHeight) {
if (!this.el) {
return;
}
var adjusts = this.adjusts,
el = this.el,
targetStyle = el.dom.style,
shadowWidth,
shadowHeight,
sws,
shs;
el[this.localXYNames.set](l + adjusts.l, t + adjusts.t);
shadowWidth = Math.max(targetWidth + adjusts.w, 0);
shadowHeight = Math.max(targetHeight + adjusts.h, 0);
sws = shadowWidth + "px";
shs = shadowHeight + "px";
if (targetStyle.width != sws || targetStyle.height != shs) {
targetStyle.width = sws;
targetStyle.height = shs;
if (Ext.supports.CSS3BoxShadow) {
targetStyle[this.boxShadowProperty] = '0 0 ' + (this.offset + 2) + 'px #888';
}
}
},

hide: function() {
var me = this;

if (me.el) {
me.el.dom.style.display = "none";
Ext.ShadowPool.push(me.el);
delete me.el;
}
},

setZIndex: function(z) {
this.zIndex = z;
if (this.el) {
this.el.setStyle("z-index", z);
}
},


setOpacity: function(opacity){
if (this.el) {
if (Ext.isIE && !Ext.supports.CSS3BoxShadow) {
opacity = Math.floor(opacity * 100 / 2) / 100;
}
this.opacity = opacity;
this.el.setOpacity(opacity);
}
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/dom/Layer.js */
(function(Ext) {
Ext.define('Ext.dom.Layer', {
extend: 'Ext.Element',
uses: ['Ext.Shadow'],
alternateClassName: 'Ext.Layer',










// shims are shared among layer to keep from having 100 iframes
statics: {
shims: []
},

isLayer: true,
localXYNames: {
get: 'getLocalXY',
set: 'setLocalXY'
},

constructor: function(config, existingEl) {
config = config || {};
var me = this,
dh = Ext.DomHelper,
cp = config.parentEl,
pel = cp ? Ext.getDom(cp) : document.body,
hm = config.hideMode,
cls = Ext.baseCSSPrefix + (config.fixed && !(Ext.isIE6 || Ext.isIEQuirks) ? 'fixed-layer' : 'layer');
// set an "el" property that references "this". This allows
// Ext.util.Positionable methods to operate on this.el.dom since it
// gets mixed into both Element and Component
me.el = me;
if (existingEl) {
me.dom = Ext.getDom(existingEl);
}
if (!me.dom) {
me.dom = dh.append(pel, config.dh || {
tag: 'div',
cls: cls // primarily to give el 'position:absolute' or, if fixed, 'position:fixed'
});
} else {
me.addCls(cls);
if (!me.dom.parentNode) {
pel.appendChild(me.dom);
}
}

if (config.preventSync) {
me.preventSync = true;
}
if (config.id) {
me.id = me.dom.id = config.id;
} else {
me.id = Ext.id(me.dom);
}
Ext.Element.addToCache(me);
if (config.cls) {
me.addCls(config.cls);
}
me.constrain = config.constrain !== false;
// Allow Components to pass their hide mode down to the Layer if they are floating.
// Otherwise, allow useDisplay to override the default hiding method which is visibility.
// TODO: Have ExtJS's Element implement visibilityMode by using classes as in Mobile.
if (hm) {
me.setVisibilityMode(Ext.Element[hm.toUpperCase()]);
if (me.visibilityMode == Ext.Element.ASCLASS) {
me.visibilityCls = config.visibilityCls;
}
} else if (config.useDisplay) {
me.setVisibilityMode(Ext.Element.DISPLAY);
} else {
me.setVisibilityMode(Ext.Element.VISIBILITY);
}
if (config.shadow) {
me.shadowOffset = config.shadowOffset || 4;
me.shadow = new Ext.Shadow({
offset: me.shadowOffset,
mode: config.shadow,
fixed: config.fixed
});
me.disableShadow();
} else {
me.shadowOffset = 0;
}
me.useShim = config.shim !== false && Ext.useShims;
if (config.hidden === true) {
me.hide();
} else {
me.show();
}
},
getZIndex: function() {
return parseInt((this.getShim() || this).getStyle('z-index'), 10);
},
getShim: function() {
var me = this,
shim, pn;
if (!me.useShim) {
return null;
}
if (!me.shim) {
shim = me.self.shims.shift();
if (!shim) {
shim = me.createShim();
shim.enableDisplayMode('block');
shim.hide();
}
pn = me.dom.parentNode;
if (shim.dom.parentNode != pn) {
pn.insertBefore(shim.dom, me.dom);
}
me.shim = shim;
}
return me.shim;
},
hideShim: function() {
var me = this;

if (me.shim) {
me.shim.setDisplayed(false);
me.self.shims.push(me.shim);
delete me.shim;
}
},
disableShadow: function() {
var me = this;

if (me.shadow && !me.shadowDisabled) {
me.shadowDisabled = true;
me.shadow.hide();
me.lastShadowOffset = me.shadowOffset;
me.shadowOffset = 0;
}
},
enableShadow: function(show) {
var me = this;

if (me.shadow && me.shadowDisabled) {
me.shadowDisabled = false;
me.shadowOffset = me.lastShadowOffset;
delete me.lastShadowOffset;
if (show) {
me.sync(true);
}
}
},

sync: function(doShow) {
var me = this,
shadow = me.shadow,
shadowPos, shimStyle, shadowSize,
shim, xy, x, y, w, h, shimIndex;

if (me.preventSync) {
return;
}
if (!me.updating && me.isVisible() && (shadow || me.useShim)) {
shim = me.getShim();
xy = me[me.localXYNames.get]();
x = xy[0];
y = xy[1];
w = me.dom.offsetWidth;
h = me.dom.offsetHeight;
if (shadow && !me.shadowDisabled) {
if (doShow && !shadow.isVisible()) {
shadow.show(me);
} else {
shadow.realign(x, y, w, h);
}
if (shim) {
// TODO: Determine how the shims zIndex is above the layer zIndex at this point
shimIndex = shim.getStyle('z-index');
if (shimIndex > me.zindex) {
me.shim.setStyle('z-index', me.zindex - 2);
}
shim.show();
// fit the shim behind the shadow, so it is shimmed too
if (shadow.isVisible()) {
shadowPos = shadow.el.getXY();
shimStyle = shim.dom.style;
shadowSize = shadow.el.getSize();
if (Ext.supports.CSS3BoxShadow) {
shadowSize.height += 6;
shadowSize.width += 4;
shadowPos[0] -= 2;
shadowPos[1] -= 4;
}
shimStyle.left = (shadowPos[0]) + 'px';
shimStyle.top = (shadowPos[1]) + 'px';
shimStyle.width = (shadowSize.width) + 'px';
shimStyle.height = (shadowSize.height) + 'px';
} else {
shim.setSize(w, h);
shim[me.localXYNames.set](x, y);
}
}
} else if (shim) {
// TODO: Determine how the shims zIndex is above the layer zIndex at this point
shimIndex = shim.getStyle('z-index');
if (shimIndex > me.zindex) {
me.shim.setStyle('z-index', me.zindex - 2);
}
shim.show();
shim.setSize(w, h);
shim[me.localXYNames.set](x, y);
}
}
return me;
},
remove: function() {
this.hideUnders();
this.callParent();
},
// @private
beginUpdate: function() {
this.updating = true;
},
// @private
endUpdate: function() {
this.updating = false;
this.sync(true);
},
// @private
hideUnders: function() {
if (this.shadow) {
this.shadow.hide();
}
this.hideShim();
},
// @private
constrainXY: function() {
if (this.constrain) {
var vw = Ext.Element.getViewWidth(),
vh = Ext.Element.getViewHeight(),
s = Ext.getDoc().getScroll(),
xy = this.getXY(),
x = xy[0],
y = xy[1],
so = this.shadowOffset,
w = this.dom.offsetWidth + so,
h = this.dom.offsetHeight + so,
moved = false; // only move it if it needs it
// first validate right/bottom
if ((x + w) > vw + s.left) {
x = vw - w - so;
moved = true;
}
if ((y + h) > vh + s.top) {
y = vh - h - so;
moved = true;
}
// then make sure top/left isn't negative
if (x < s.left) {
x = s.left;
moved = true;
}
if (y < s.top) {
y = s.top;
moved = true;
}
if (moved) {
Ext.Layer.superclass.setXY.call(this, [x, y]);
this.sync();
}
}
return this;
},
getConstrainOffset: function() {
return this.shadowOffset;
},
// overridden Element method
setVisible: function(visible, animate, duration, callback, easing) {
var me = this,
cb;
// post operation processing
cb = function() {
if (visible) {
me.sync(true);
}
if (callback) {
callback();
}
};
// Hide shadow and shim if hiding
if (!visible) {
me.hideUnders(true);
}
me.callParent([visible, animate, duration, callback, easing]);
if (!animate) {
cb();
}
return me;
},
// @private
beforeFx: function() {
this.beforeAction();
return this.callParent(arguments);
},
// @private
afterFx: function() {
this.callParent(arguments);
this.sync(this.isVisible());
},
// @private
beforeAction: function() {
if (!this.updating && this.shadow) {
this.shadow.hide();
}
},
// overridden Element method
setLeft: function(left) {
this.callParent(arguments);
return this.sync();
},
setTop: function(top) {
this.callParent(arguments);
return this.sync();
},
setLeftTop: function(left, top) {
this.callParent(arguments);
return this.sync();
},
setLocalX: function() {
this.callParent(arguments);
return this.sync();
},
setLocalXY: function() {
this.callParent(arguments);
return this.sync();
},
setLocalY: function() {
this.callParent(arguments);
return this.sync();
},
setXY: function(xy, animate, duration, callback, easing) {
var me = this;

// Callback will restore shadow state and call the passed callback
callback = me.createCB(callback);
me.fixDisplay();
me.beforeAction();
me.callParent([xy, animate, duration, callback, easing]);
if (!animate) {
callback();
}
return me;
},
// @private
createCB: function(callback) {
var me = this,
showShadow = me.shadow && me.shadow.isVisible();
return function() {
me.constrainXY();
me.sync(showShadow);
if (callback) {
callback();
}
};
},
// overridden Element method
setX: function(x, animate, duration, callback, easing) {
this.setXY([x, this.getY()], animate, duration, callback, easing);
return this;
},
// overridden Element method
setY: function(y, animate, duration, callback, easing) {
this.setXY([this.getX(), y], animate, duration, callback, easing);
return this;
},
// overridden Element method
setSize: function(w, h, animate, duration, callback, easing) {
var me = this;

// Callback will restore shadow state and call the passed callback
callback = me.createCB(callback);
me.beforeAction();
me.callParent([w, h, animate, duration, callback, easing]);
if (!animate) {
callback();
}
return me;
},
// overridden Element method
setWidth: function(w, animate, duration, callback, easing) {
var me = this;

// Callback will restore shadow state and call the passed callback
callback = me.createCB(callback);
me.beforeAction();
me.callParent([w, animate, duration, callback, easing]);
if (!animate) {
callback();
}
return me;
},
// overridden Element method
setHeight: function(h, animate, duration, callback, easing) {
var me = this;

// Callback will restore shadow state and call the passed callback
callback = me.createCB(callback);
me.beforeAction();
me.callParent([h, animate, duration, callback, easing]);
if (!animate) {
callback();
}
return me;
},
// overridden Element method
setBounds: function(x, y, width, height, animate, duration, callback, easing) {
var me = this;

// Callback will restore shadow state and call the passed callback
callback = me.createCB(callback);
me.beforeAction();
if (!animate) {
Ext.Layer.superclass.setXY.call(me, [x, y]);
Ext.Layer.superclass.setSize.call(me, width, height);
callback();
} else {
me.callParent([x, y, width, height, animate, duration, callback, easing]);
}
return me;
},

setZIndex: function(zindex) {
var me = this;

me.zindex = zindex;
if (me.getShim()) {
me.shim.setStyle('z-index', zindex++);
}
if (me.shadow) {
me.shadow.setZIndex(zindex++);
}
return me.setStyle('z-index', zindex);
},

onOpacitySet: function(opacity){
var shadow = this.shadow;
if (shadow) {
shadow.setOpacity(opacity);
}
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/util/Floating.js */
(function(Ext) {
Ext.define('Ext.util.Floating', {
uses: ['Ext.Layer', 'Ext.window.Window'],

focusOnToFront: true,

shadow: 'sides',

constrain: false,


constructor: function (dom) {
var me = this;
// We do not support fixed on legacy browsers.
me.fixed = me.fixed && !(Ext.isIE6 || Ext.isIEQuirks);
me.el = new Ext.dom.Layer(Ext.apply({
preventSync : true,
hideMode : me.hideMode,
hidden : me.hidden,
shadow : (typeof me.shadow != 'undefined') ? me.shadow : 'sides',
shadowOffset : me.shadowOffset,
constrain : false,
fixed : me.fixed,
shim : (me.shim === false) ? false : undefined
}, me.floating), dom);
// If modal, and focus navigation not being handled by the FocusManager,
// catch tab navigation, and loop back in on tab off first or last item.
if (me.modal && !(Ext.FocusManager && Ext.FocusManager.enabled)) {
me.mon(me.el, {
keydown: me.onKeyDown,
scope: me
});
}
// clickToRaise
me.mon(me.el, {
mousedown: me.onMouseDown,
scope: me
});
// release config object (if it was one)
me.floating = true;
// Register with the configured ownerCt.
// With this we acquire a floatParent for relative positioning, and a zIndexParent which is an
// ancestor floater which provides zIndex management.
me.registerWithOwnerCt();
me.initHierarchyEvents();
},
initHierarchyEvents: function() {
var me = this,
syncHidden = this.syncHidden;
if (!me.hasHierarchyEventListeners) {
me.mon(me.hierarchyEventSource, {
hide: syncHidden,
collapse: syncHidden,
show: syncHidden,
expand: syncHidden,
added: syncHidden,
scope: me
});
me.hasHierarchyEventListeners = true;
}
},
registerWithOwnerCt: function() {
var me = this,
ownerCt = me.ownerCt,
zip = me.zIndexParent;
if (zip) {
zip.unregisterFloatingItem(me);
}
// Acquire a zIndexParent by traversing the ownerCt axis for the nearest floating ancestor.
// This is to find a base which can allocate relative z-index values
zip = me.zIndexParent = me.up('[floating]');
// Set the floatParent to the ownertCt if one has been provided.
// Otherwise use the zIndexParent.
// Developers must only use ownerCt if there is really a containing relationship.
me.setFloatParent(ownerCt || zip);
delete me.ownerCt;
if (zip) {
zip.registerFloatingItem(me);
} else {
Ext.WindowManager.register(me);
}
},
// Listen for TAB events and wrap round if tabbing of either end of the Floater
onKeyDown: function(e) {
var me = this,
shift,
focusables,
first,
last;
// If tabbing off either end, wrap round.
// See Ext.dom.Element.isFocusable
// Certain browsers always report tabIndex zero in the absence of the tabIndex attribute.
// Testing the specified property (Standards: http://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-862529273)
// Should filter out these cases.
// The exceptions are IE6 to IE8. In these browsers all elements will yield a tabIndex
// and therefore all elements will appear to be focusable.
// This adversely affects modal Floating components.
// These listen for the TAB key, and then test whether the event target === last focusable
// or first focusable element, and forcibly to a circular navigation.
// We cannot know the true first or last focusable element, so this problem still exists for IE6,7,8
if (e.getKey() == Ext.EventObject.TAB) {
shift = e.shiftKey;
focusables = me.el.query(':focusable');
first = focusables[0];
last = focusables[focusables.length - 1];
if (first && last && e.target === (shift ? first : last)) {
e.stopEvent();
(shift ? last : first).focus(false, true);
}
}
},
// @private
// Mousedown brings to front, and programatically grabs focus *unless the mousedown was on a focusable element*
onMouseDown: function (e) {
var focusTask = this.focusTask;

if (this.floating &&
// get out of here if there is already a pending focus. This usually means
// that the handler for a mousedown on a child element set the focus on some
// other component, and we so not want to steal it back. See EXTJSIV-9458
(!focusTask || !focusTask.id)) {
// If what was mousedowned upon is going to claim focus anyway, pass preventFocus as true.
this.toFront(!!e.getTarget(':focusable'));
}
},
setFloatParent: function(floatParent) {
var me = this;
me.floatParent = floatParent;
// If a floating Component is configured to be constrained, but has no configured
// constrainTo setting, set its constrainTo to be it's ownerCt before rendering.
if ((me.constrain || me.constrainHeader) && !me.constrainTo) {
me.constrainTo = floatParent ? floatParent.getTargetEl() : me.container;
}
},

// @private
syncShadow : function() {
if (this.floating) {
this.el.sync(true);
}
},

onBeforeFloatLayout: function(){
this.el.preventSync = true;
},

onAfterFloatLayout: function(){
delete this.el.preventSync;
this.syncShadow(); 
},

syncHidden: function() {
var me = this,
hidden = me.hidden || !me.rendered,
hierarchicallyHidden = me.hierarchicallyHidden = me.isHierarchicallyHidden(),
pendingShow = me.pendingShow;
if (hidden !== hierarchicallyHidden) {
if (hierarchicallyHidden) {
me.hide();
me.pendingShow = true;
} else if (pendingShow) {
delete me.pendingShow;
if (pendingShow.length) {
me.show.apply(me, pendingShow);
} else {
me.show();
}
}
}
},
// @private
// z-index is managed by the zIndexManager and may be overwritten at any time.
// Returns the next z-index to be used.
// If this is a Container, then it will have rebased any managed floating Components,
// and so the next available z-index will be approximately 10000 above that.
setZIndex: function(index) {
var me = this;
me.el.setZIndex(index);
// Next item goes 10 above;
index += 10;
// When a Container with floating descendants has its z-index set, it rebases any floating descendants it is managing.
// The returned value is a round number approximately 10000 above the last z-index used.
if (me.floatingDescendants) {
index = Math.floor(me.floatingDescendants.setBase(index) / 100) * 100 + 10000;
}
return index;
},

doConstrain: function(constrainTo) {
var me = this,
// Calculate the constrained poition.
// calculateConstrainedPosition will provide a default constraint
// region if there is no explicit constrainTo, *and* there is no floatParent owner Component.
xy = me.calculateConstrainedPosition(constrainTo, null, true);
// false is returned if no movement is needed
if (xy) {
me.setPosition(xy);
}
},

toFront: function(preventFocus) {
var me = this,
zip = me.zIndexParent,
preventFocusSetting = me.preventFocusOnActivate;
// Find the floating Component which provides the base for this Component's zIndexing.
// That must move to front to then be able to rebase its zIndex stack and move this to the front
if (zip && me.bringParentToFront !== false) {
zip.toFront(true);
}
if (!Ext.isDefined(preventFocus)) {
preventFocus = !me.focusOnToFront;
}
if (preventFocus) {
me.preventFocusOnActivate = true;
}
if (me.zIndexManager.bringToFront(me, preventFocus)) { 
if (!preventFocus) {
// Kick off a delayed focus request.
// If another floating Component is toFronted before the delay expires
// this will not receive focus.
me.focus(false, true);
}
}

// Restore to original setting
me.preventFocusOnActivate = preventFocusSetting;
return me;
},

setActive: function(active, newActive) {
var me = this;

if (active) {
if (me.el.shadow && !me.maximized) {
me.el.enableShadow(true);
}
if (!me.preventFocusOnActivate) {
me.focus(false, true);
}
me.fireEvent('activate', me);
} else {
// Only the *Windows* in a zIndex stack share a shadow. All other types of floaters
// can keep their shadows all the time
if (me.isWindow && (newActive && newActive.isWindow) && me.hideShadowOnDeactivate) {
me.el.disableShadow();
}
me.fireEvent('deactivate', me);
}
},

toBack: function() {
this.zIndexManager.sendToBack(this);
return this;
},

center: function() {
var me = this,
xy;

if (me.isVisible()) {
xy = me.getAlignToXY(me.container, 'c-c');
me.setPagePosition(xy);
} else {
me.needsCenter = true;
}
return me;
},

onFloatShow: function() {
if (this.needsCenter) {
this.center(); 
}
delete this.needsCenter;
},
// @private
fitContainer: function(animate) {
var me = this,
parent = me.floatParent,
container = parent ? parent.getTargetEl() : me.container,
newBox = container.getViewSize(false),
newPosition = parent || (container.dom !== document.body) ?
// If we are a contained floater, or rendered to a div, maximized position is (0,0)
[0, 0] :
// If no parent and rendered to body, align with origin of container el.
container.getXY();
newBox.x = newPosition[0];
newBox.y = newPosition[1];
me.setBox(newBox, animate);
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/util/Bindable.js */
(function(Ext) {
Ext.define('Ext.util.Bindable', {

bindStore: function(store, initial, propertyName) {
// Private params
// @param {Boolean} [initial=false] True to not remove listeners from existing store.
// @param {String} [propertyName="store"] The property in this object under which to cache the passed Store.
propertyName = propertyName || 'store';
var me = this,
oldStore = me[propertyName];
if (!initial && oldStore) {
// Perform implementation-specific unbinding operations *before* possible Store destruction.
me.onUnbindStore(oldStore, initial, propertyName);
if (store !== oldStore && oldStore.autoDestroy) {
oldStore.destroyStore();
} else {
me.unbindStoreListeners(oldStore);
}
}
if (store) {
store = Ext.data.StoreManager.lookup(store);
me.bindStoreListeners(store);
me.onBindStore(store, initial, propertyName);
}
me[propertyName] = store || null;
return me;
},

getStore: function(){
return this.store;
},

unbindStoreListeners: function(store) {
// Can be overridden in the subclass for more complex removal
var listeners = this.storeListeners;
if (listeners) {
store.un(listeners);
}
},

bindStoreListeners: function(store) {
// Can be overridden in the subclass for more complex binding
var me = this,
listeners = Ext.apply({}, me.getStoreListeners(store));
if (!listeners.scope) {
listeners.scope = me;
}
me.storeListeners = listeners;
store.on(listeners);
},

getStoreListeners: Ext.emptyFn,

onUnbindStore: Ext.emptyFn,

onBindStore: Ext.emptyFn 
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/data/association/Association.js */
(function(Ext) {
Ext.define('Ext.data.association.Association', {
alternateClassName: 'Ext.data.Association',




primaryKey: 'id',



associationKeyFunction : null,
defaultReaderType: 'json',
isAssociation: true,
initialConfig: null,
statics: {
AUTO_ID: 1000,

create: function(association){
if (Ext.isString(association)) {
association = {
type: association
};
}
switch (association.type) {
case 'belongsTo':
return new Ext.data.association.BelongsTo(association);
case 'hasMany':
return new Ext.data.association.HasMany(association);
case 'hasOne':
return new Ext.data.association.HasOne(association);
//TODO Add this back when it's fixed
// case 'polymorphic':
// return Ext.create('Ext.data.PolymorphicAssociation', association);
default:
//<debug>
Ext.Error.raise('Unknown Association type: "' + association.type + '"');
//</debug>
}
return association;
}
},

constructor: function(config) {
Ext.apply(this, config);
var me = this,
types = Ext.ModelManager.types,
ownerName = config.ownerModel,
associatedName = config.associatedModel,
ownerModel = types[ownerName],
associatedModel = types[associatedName],
associationKey = config.associationKey,
keyReIdx;
if (associationKey) {
keyReIdx = String(associationKey).search(/[\[\.]/);
if (keyReIdx >= 0) {
me.associationKeyFunction = Ext.functionFactory('obj', 'return obj' + (keyReIdx > 0 ? '.' : '') + associationKey);
}
}
me.initialConfig = config;
//<debug>
if (ownerModel === undefined) {
Ext.Error.raise("The configured ownerModel was not valid (you tried " + ownerName + ")");
}
if (associatedModel === undefined) {
Ext.Error.raise("The configured associatedModel was not valid (you tried " + associatedName + ")");
}
//</debug>
me.ownerModel = ownerModel;
me.associatedModel = associatedModel;


Ext.applyIf(me, {
ownerName : ownerName,
associatedName: associatedName
});

me.associationId = 'association' + (++me.statics().AUTO_ID);
},

getReader: function(){
var me = this,
reader = me.reader,
model = me.associatedModel;
if (reader) {
if (Ext.isString(reader)) {
reader = {
type: reader
};
}
if (reader.isReader) {
reader.setModel(model);
} else {
Ext.applyIf(reader, {
model: model,
type : me.defaultReaderType
});
}
me.reader = Ext.createByAlias('reader.' + reader.type, reader);
}
return me.reader || null;
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/ModelManager.js */
(function(Ext) {
Ext.define('Ext.ModelManager', {
extend: 'Ext.AbstractManager',
alternateClassName: 'Ext.ModelMgr',
requires: ['Ext.data.association.Association'],

singleton: true,
typeName: 'mtype',

associationStack: [],

registerType: function(name, config) {
var proto = config.prototype,
model;
if (proto && proto.isModel) {
// registering an already defined model
model = config;
} else {
// passing in a configuration
if (!config.extend) {
config.extend = 'Ext.data.Model';
}
model = Ext.define(name, config);
}
this.types[name] = model;
return model;
},


unregisterType: function(name) {
delete this.types[name];
},

onModelDefined: function(model) {
var stack = this.associationStack,
length = stack.length,
create = [],
association, i, created;
for (i = 0; i < length; i++) {
association = stack[i];
if (association.associatedModel == model.modelName) {
create.push(association);
}
}
for (i = 0, length = create.length; i < length; i++) {
created = create[i];
this.types[created.ownerModel].prototype.associations.add(Ext.data.association.Association.create(created));
Ext.Array.remove(stack, created);
}
},

registerDeferredAssociation: function(association){
this.associationStack.push(association);
},

getModel: function(id) {
var model = id;
if (typeof model == 'string') {
model = this.types[model];
}
return model;
},

create: function(config, name, id) {
var Con = typeof name == 'function' ? name : this.types[name || config.name];
return new Con(config, id);
}
}, function() {

Ext.regModel = function() {
//<debug>
if (Ext.isDefined(Ext.global.console)) {
Ext.global.console.warn('Ext.regModel has been deprecated. Models can now be created by extending Ext.data.Model: Ext.define("MyModel", {extend: "Ext.data.Model", fields: []});.');
}
//</debug>
return this.ModelManager.registerType.apply(this.ModelManager, arguments);
};
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/data/IdGenerator.js */
(function(Ext) {
Ext.define('Ext.data.IdGenerator', {

isGenerator: true,

constructor: function(config) {
var me = this;
Ext.apply(me, config);
if (me.id) {
Ext.data.IdGenerator.all[me.id] = me;
}
},

getRecId: function (rec) {
return rec.modelName + '-' + rec.internalId;
},

statics: {

all: {},

get: function (config) {
var generator,
id,
type;
if (typeof config == 'string') {
id = type = config;
config = null;
} else if (config.isGenerator) {
return config;
} else {
id = config.id || config.type;
type = config.type;
}
generator = this.all[id];
if (!generator) {
generator = Ext.create('idgen.' + type, config);
}
return generator;
}
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/data/SortTypes.js */
(function(Ext) {
Ext.define('Ext.data.SortTypes', {

singleton: true,


none : Ext.identityFn,

stripTagsRE : /<\/?[^>]+>/gi,

asText : function(s) {
return String(s).replace(this.stripTagsRE, "");
},

asUCText : function(s) {
return String(s).toUpperCase().replace(this.stripTagsRE, "");
},

asUCString : function(s) {
return String(s).toUpperCase();
},

asDate : function(s) {
if(!s){
return 0;
}
if(Ext.isDate(s)){
return s.getTime();
}
return Date.parse(String(s));
},

asFloat : function(s) {
var val = parseFloat(String(s).replace(/,/g, ""));
return isNaN(val) ? 0 : val;
},

asInt : function(s) {
var val = parseInt(String(s).replace(/,/g, ""), 10);
return isNaN(val) ? 0 : val;
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/data/Types.js */
(function(Ext) {
Ext.define('Ext.data.Types', {
singleton: true,
requires: ['Ext.data.SortTypes']
}, function() {
var st = Ext.data.SortTypes;
Ext.apply(Ext.data.Types, {

stripRe: /[\$,%]/g,

AUTO: {
sortType: st.none,
type: 'auto'
},

STRING: {
convert: function(v) {
var defaultValue = this.useNull ? null : '';
return (v === undefined || v === null) ? defaultValue : String(v);
},
sortType: st.asUCString,
type: 'string'
},

INT: {
convert: function(v) {
// Handle values which are already numbers.
// Value truncation behaviour of parseInt is historic and must be maintained.
// parseInt(35.9) and parseInt("35.9") returns 35
if (typeof v == 'number') {
return parseInt(v);
}
return v !== undefined && v !== null && v !== '' ?
parseInt(String(v).replace(Ext.data.Types.stripRe, ''), 10) : (this.useNull ? null : 0);
},
sortType: st.none,
type: 'int'
},

FLOAT: {
convert: function(v) {
if (typeof v === 'number') {
return v;
}
return v !== undefined && v !== null && v !== '' ?
parseFloat(String(v).replace(Ext.data.Types.stripRe, ''), 10) : (this.useNull ? null : 0);
},
sortType: st.none,
type: 'float'
},

BOOL: {
convert: function(v) {
if (typeof v === 'boolean') {
return v;
}
if (this.useNull && (v === undefined || v === null || v === '')) {
return null;
}
return v === 'true' || v == 1;
},
sortType: st.none,
type: 'bool'
},

DATE: {
convert: function(v) {
var df = this.dateReadFormat || this.dateFormat,
parsed;
if (!v) {
return null;
}
// instanceof check ~10 times faster than Ext.isDate. Values here will not be cross-document objects
if (v instanceof Date) {
return v;
}
if (df) {
return Ext.Date.parse(v, df);
}
parsed = Date.parse(v);
return parsed ? new Date(parsed) : null;
},
sortType: st.asDate,
type: 'date'
}
});
Ext.apply(Ext.data.Types, {

BOOLEAN: this.BOOL,

INTEGER: this.INT,

NUMBER: this.FLOAT
});
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/data/Field.js */
(function(Ext) {
Ext.define('Ext.data.Field', {
requires: ['Ext.data.Types', 'Ext.data.SortTypes'],
alias: 'data.field',
isField: true,

constructor : function(config) {
var me = this,
types = Ext.data.Types,
st;

if (Ext.isString(config)) {
config = {name: config};
}
Ext.apply(me, config);
st = me.sortType;
if (me.type) {
if (Ext.isString(me.type)) {
me.type = types[me.type.toUpperCase()] || types.AUTO;
}
} else {
me.type = types.AUTO;
}
// named sortTypes are supported, here we look them up
if (Ext.isString(st)) {
me.sortType = Ext.data.SortTypes[st];
} else if(Ext.isEmpty(st)) {
me.sortType = me.type.sortType;
}
// Reference this type's default converter if we did not recieve one in configuration.
if (!config.hasOwnProperty('convert')) {
me.convert = me.type.convert; // this may be undefined (e.g., AUTO)
} else if (!me.convert && me.type.convert && !config.hasOwnProperty('defaultValue')) {
// If the converter has been nulled out, and we have not been configured
// with a field-specific defaultValue, then coerce the inherited defaultValue into our data type.
me.defaultValue = me.type.convert(me.defaultValue);
}
if (config.convert) {
me.hasCustomConvert = true;
}
},







dateFormat: null,


dateReadFormat: null,


dateWriteFormat: null,


useNull: false,


defaultValue: "",

mapping: null,

sortType : null,

sortDir : "ASC",

allowBlank : true,

persist: true
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/data/Errors.js */
(function(Ext) {
Ext.define('Ext.data.Errors', {
extend: 'Ext.util.MixedCollection',

isValid: function() {
return this.length === 0;
},

getByField: function(fieldName) {
var errors = [],
error, i;
for (i = 0; i < this.length; i++) {
error = this.items[i];
if (error.field == fieldName) {
errors.push(error);
}
}
return errors;
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/data/Operation.js */
(function(Ext) {
Ext.define('Ext.data.Operation', {

synchronous: true,

action: undefined,

filters: undefined,

sorters: undefined,

groupers: undefined,

start: undefined,

limit: undefined,

batch: undefined,



callback: undefined,

scope: undefined,

started: false,

running: false,

complete: false,

success: undefined,

exception: false,

error: undefined,

actionCommitRecordsRe: /^(?:create|update)$/i,

actionSkipSyncRe: /^destroy$/i,

constructor: function(config) {
Ext.apply(this, config || {});
},

commitRecords: function(serverRecords) {
var me = this,
commitRecords = me.actionCommitRecordsRe.test(me.action),
mc, index, clientRecords, serverRec, clientRec, i, len,
modifiedFields, recordModifiedFields;
if (!me.actionSkipSyncRe.test(me.action)) {
clientRecords = me.records;
if (clientRecords && clientRecords.length) {
// If we plan to commit the records modified by the server's return records
// we collect all the fields which were modified as a result.
// This is so that a modifiedFields array can be passed into the commit codepath
// so that minimal UI updating can be applied.
if (commitRecords) {
recordModifiedFields = [];
}
if (clientRecords.length > 1) {
// If this operation has multiple records, client records need to be matched up with server records
// so that any data returned from the server can be updated in the client records. If we don't have
// a clientIdProperty specified on the model and we've done a create, just assume the data is returned in order.
// If it's an update, the records should already have an id which should match what the server returns.
if (me.action == 'update' || clientRecords[0].clientIdProperty) {
mc = new Ext.util.MixedCollection();
mc.addAll(serverRecords);
for (index = clientRecords.length; index--; ) {
clientRec = clientRecords[index];
serverRec = mc.findBy(me.matchClientRec, clientRec);
// Replace client record data with server record data
modifiedFields = clientRec.copyFrom(serverRec);
// If we plan to commit the records, collect modified field list for each record
if (commitRecords) {
recordModifiedFields.push(modifiedFields);
}
}
} else {
for (i = 0, len = clientRecords.length; i < len; ++i) {
clientRec = clientRecords[i];
serverRec = serverRecords[i];
if (clientRec && serverRec) {
modifiedFields = me.updateRecord(clientRec, serverRec);
// If we plan to commit the records, collect modified field list for each record
if (commitRecords) {
recordModifiedFields.push(modifiedFields);
}
}
}
}
} else {
// operation only has one record, so just match the first client record up with the first server record
modifiedFields = me.updateRecord(clientRecords[0], serverRecords[0]); 
// If we plan to commit the records, collect modified field list for each record
if (commitRecords) {
recordModifiedFields[0] = modifiedFields;
}
}
if (commitRecords) {
for (index = clientRecords.length; index--; ) {
// Pass array of field names which were modified as a result of the server's reply
// In a grid, this avoids full row refreshes when the record returns unmodified.
// See Ext.view.Table#shouldUpdateCell
clientRecords[index].commit(false, recordModifiedFields[index]);
}
}
}
}
},

updateRecord: function(clientRec, serverRec) {
// if the client record is not a phantom, make sure the ids match before replacing the client data with server data.
if (serverRec && (clientRec.phantom || clientRec.getId() === serverRec.getId())) {
return clientRec.copyFrom(serverRec);
}
// ID could not be matched up, no fields were modified.
return [];
},
// Private.
// Record matching function used by commitRecords
// IMPORTANT: This is called in the scope of the clientRec being matched
matchClientRec: function(record) {
var clientRec = this,
clientRecordId = clientRec.getId();
if(clientRecordId && record.getId() === clientRecordId) {
return true;
}
// if the server record cannot be found by id, find by internalId.
// this allows client records that did not previously exist on the server
// to be updated with the correct server id and data.
return record.internalId === clientRec.internalId;
},

setStarted: function() {
this.started = true;
this.running = true;
},

setCompleted: function() {
this.complete = true;
this.running = false;
},

setSuccessful: function() {
this.success = true;
},

setException: function(error) {
this.exception = true;
this.success = false;
this.running = false;
this.error = error;
},

hasException: function() {
return this.exception === true;
},

getError: function() {
return this.error;
},

getRecords: function() {
var resultSet = this.getResultSet();
return this.records || (resultSet ? resultSet.records : null);
},

getResultSet: function() {
return this.resultSet;
},

isStarted: function() {
return this.started === true;
},

isRunning: function() {
return this.running === true;
},

isComplete: function() {
return this.complete === true;
},

wasSuccessful: function() {
return this.isComplete() && this.success === true;
},

setBatch: function(batch) {
this.batch = batch;
},

allowWrite: function() {
return this.action != 'read';
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/data/validations.js */
(function(Ext) {
Ext.define('Ext.data.validations', {
singleton: true,


presenceMessage: 'must be present',


lengthMessage: 'is the wrong length',


formatMessage: 'is the wrong format',


inclusionMessage: 'is not included in the list of acceptable values',


exclusionMessage: 'is not an acceptable value',


emailMessage: 'is not a valid email address',


emailRe: /^([a-zA-Z0-9_\.\-])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]{2,4})+$/,


presence: function(config, value) {
// No configs read, so allow just value to be passed
if (arguments.length === 1) {
value = config;
}

//we need an additional check for zero here because zero is an acceptable form of present data
return !!value || value === 0 || value === false;
},


length: function(config, value) {
if (value === undefined || value === null) {
return false;
}

var length = value.length,
min = config.min,
max = config.max;

if ((min && length < min) || (max && length > max)) {
return false;
} else {
return true;
}
},


email: function(config, email) {
return Ext.data.validations.emailRe.test(email);
},


format: function(config, value) {
return !!(config.matcher && config.matcher.test(value));
},


inclusion: function(config, value) {
return config.list && Ext.Array.indexOf(config.list,value) != -1;
},


exclusion: function(config, value) {
return config.list && Ext.Array.indexOf(config.list,value) == -1;
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/data/Model.js */
(function(Ext) {
Ext.define('Ext.data.Model', {
alternateClassName: 'Ext.data.Record',
mixins: {
observable: 'Ext.util.Observable'
},
requires: [
'Ext.ModelManager',
'Ext.data.IdGenerator',
'Ext.data.Field',
'Ext.data.Errors',
'Ext.data.Operation',
'Ext.data.validations',
'Ext.util.MixedCollection'
],
compareConvertFields: function(f1, f2) {
var f1SpecialConvert = f1.convert && f1.type && f1.convert !== f1.type.convert,
f2SpecialConvert = f2.convert && f2.type && f2.convert !== f2.type.convert;
if (f1SpecialConvert && !f2SpecialConvert) {
return 1;
}
if (!f1SpecialConvert && f2SpecialConvert) {
return -1;
}
return 0;
},
itemNameFn: function(item) {
return item.name;
},
onClassExtended: function(cls, data, hooks) {
var onBeforeClassCreated = hooks.onBeforeCreated;
hooks.onBeforeCreated = function(cls, data) {
var me = this,
name = Ext.getClassName(cls),
prototype = cls.prototype,
superCls = cls.prototype.superclass,
validations = data.validations || [],
fields = data.fields || [],
field,
associationsConfigs = data.associations || [],
addAssociations = function(items, type) {
var i = 0,
len,
item;
if (items) {
items = Ext.Array.from(items);
for (len = items.length; i < len; ++i) {
item = items[i];
if (!Ext.isObject(item)) {
item = {model: item};
}
item.type = type;
associationsConfigs.push(item);
}
}
},
idgen = data.idgen,
fieldsMixedCollection = new Ext.util.MixedCollection(false, prototype.itemNameFn),
associationsMixedCollection = new Ext.util.MixedCollection(false, prototype.itemNameFn),
superValidations = superCls.validations,
superFields = superCls.fields,
superAssociations = superCls.associations,
associationConfig, i, ln,
dependencies = [],
// Use the idProperty from the configuration if there is one, else fall back to the default from the prototype
idProperty = 'idProperty' in data ? data.idProperty : prototype.idProperty,
// If an idProperty was specified, we create an idField
idField = idProperty ? (idProperty.isField ? idProperty : new Ext.data.Field(idProperty)) : null,
// Set if there is a Field in the defined fields which encapsulates the idProperty
idFieldDefined = false,
// Process each Field upon add into the collection
onFieldAddReplace = function(arg0, arg1, arg2) {
var newField,
pos;
if (fieldsMixedCollection.events.add.firing) {
// Add event signature is (position, value, key);
pos = arg0;
newField = arg1;
} else {
// Replace event signature is (key, oldValue, newValue);
newField = arg2;
pos = arg1.originalIndex;
}
// Set the originalIndex for ArrayReader to get the default mapping from in case
// compareConvertFields changes the order due to some fields having custom convert functions.
newField.originalIndex = pos;
// If a defined Field encapsulates the idProperty, then we do not have to create a separate identifying field.
// Also, this field must never have a default value set if no value arrives from the server side.
// So override any possible prototype-provided defaultValue with undefined which will inhibit generation of defaulting code in Reader.buildRecordDataExtractor
if (idField && ((newField.mapping && (newField.mapping === idField.mapping)) || (newField.name === idField.name))) {
prototype.idField = newField;
idFieldDefined = true;
newField.defaultValue = undefined;
}
},
// The configured Proxy if any. If there is none, we may inherit one from the superclass, or fall back to the defaultProxyType
clsProxy = data.proxy,
// Sort upon add function to be used in case of dynamically added Fields
fieldConvertSortFn = function() {
fieldsMixedCollection.sortBy(prototype.compareConvertFields);
};
// Save modelName on class and its prototype
cls.modelName = name;
prototype.modelName = name;
// Merge the validations of the superclass and the new subclass
if (superValidations) {
validations = superValidations.concat(validations);
}
data.validations = validations;
// Merge the fields of the superclass and the new subclass
if (superFields) {
fields = superFields.items.concat(fields);
}
fieldsMixedCollection.on({
add: onFieldAddReplace,
replace: onFieldAddReplace
}); 
for (i = 0, ln = fields.length; i < ln; ++i) {
field = fields[i];
fieldsMixedCollection.add(field.isField ? field : new Ext.data.Field(field));
}
// If there was an idProperty specified, and there has *not* been a field defined which encapsulates that property,
// then create a field which encapsulates that property.
// This must never provide a default value.
if (idField && !idFieldDefined) {
prototype.idField = idField;
idField.defaultValue = undefined;
fieldsMixedCollection.add(idField);
}
// Ensure the Fields are on correct order: Fields with custom convert function last
fieldConvertSortFn();
fieldsMixedCollection.on({
add: fieldConvertSortFn,
replace: fieldConvertSortFn
});
data.fields = fieldsMixedCollection;
if (idgen) {
data.idgen = Ext.data.IdGenerator.get(idgen);
}
//associations can be specified in the more convenient format (e.g. not inside an 'associations' array).
//we support that here
addAssociations(data.belongsTo, 'belongsTo');
delete data.belongsTo;
addAssociations(data.hasMany, 'hasMany');
delete data.hasMany;
addAssociations(data.hasOne, 'hasOne');
delete data.hasOne;
if (superAssociations) {
associationsConfigs = superAssociations.items.concat(associationsConfigs);
}
for (i = 0, ln = associationsConfigs.length; i < ln; ++i) {
dependencies.push('association.' + associationsConfigs[i].type.toLowerCase());
}
// If we have been configured with a proxy *configuration* (not a full Proxy), push it onto our dependency requirements
if (clsProxy) {
if (!clsProxy.isProxy) {
dependencies.push('proxy.' + (clsProxy.type || clsProxy));
}
}
// Not inheriting a proxy, push the defaultProxyType onto our dependency requirements, and set the
// proxy type for instantiation later.
else if (!cls.prototype.proxy) {
cls.prototype.proxy = cls.prototype.defaultProxyType;
dependencies.push('proxy.' + cls.prototype.defaultProxyType);
}
Ext.require(dependencies, function() {
Ext.ModelManager.registerType(name, cls);
for (i = 0, ln = associationsConfigs.length; i < ln; ++i) {
associationConfig = associationsConfigs[i];
if (associationConfig.isAssociation) {
associationConfig = Ext.applyIf({
ownerModel: name,
associatedModel: associationConfig.model
}, associationConfig.initialConfig);
} else {
Ext.apply(associationConfig, {
ownerModel: name,
associatedModel: associationConfig.model
});
}
if (Ext.ModelManager.getModel(associationConfig.model) === undefined) {
Ext.ModelManager.registerDeferredAssociation(associationConfig);
} else {
associationsMixedCollection.add(Ext.data.association.Association.create(associationConfig));
}
}
data.associations = associationsMixedCollection;
// onBeforeCreated may get called *asynchronously* if any of those required classes caused
// an asynchronous script load. This would mean that the class definition object
// has not been applied to the prototype when the Model definition has returned.
// The Reader constructor does not attempt to buildExtractors if the fields MixedCollection
// has not yet been set. The cls.setProxy call triggers a build of extractor methods.
onBeforeClassCreated.call(me, cls, data, hooks);
// If we have been configured with an instantiated proxy, set it now.
if (clsProxy && clsProxy.isProxy) {
cls.setProxy(clsProxy);
}
// Fire the onModelDefined template method on ModelManager
Ext.ModelManager.onModelDefined(cls);
});
};
},
inheritableStatics: {

setProxy: function(proxy) {
//make sure we have an Ext.data.proxy.Proxy object
if (!proxy.isProxy) {
if (typeof proxy == "string") {
proxy = {
type: proxy
};
}
proxy = Ext.createByAlias("proxy." + proxy.type, proxy);
}
proxy.setModel(this);
this.proxy = this.prototype.proxy = proxy;
return proxy;
},

getProxy: function() {
var proxy = this.proxy;
// Not yet been created wither from prototype property set in onClassExtended, or by cloning superclass's Proxy...
if (!proxy) {
proxy = this.prototype.proxy;
// If we inherited an instantiated Propxy, we can't share it, so clone it.
if (proxy.isProxy) {
proxy = proxy.clone()
}
return this.setProxy(proxy);
}
return proxy;
},

setFields: function(fields, idProperty, clientIdProperty) {
var me = this,
newField,
idField,
idFieldDefined = false,
proto = me.prototype,
prototypeFields = proto.fields,
superFields = proto.superclass.fields,
len,
i;
if (idProperty) {
proto.idProperty = idProperty;
idField = idProperty.isField ? idProperty : new Ext.data.Field(idProperty);
}
if (clientIdProperty) {
proto.clientIdProperty = clientIdProperty;
}
if (prototypeFields) {
prototypeFields.clear();
}
else {
prototypeFields = me.prototype.fields = new Ext.util.MixedCollection(false, function(field) {
return field.name;
});
}
// Merge the fields of the superclass and the passed in fields
if (superFields) {
fields = superFields.items.concat(fields);
}
for (i = 0, len = fields.length; i < len; i++) {
newField = new Ext.data.Field(fields[i]);
// If a defined Field encapsulates the idProperty, then we do not have to create a separate identifying field.
// Also, this field must never have a default value set if no value arrives from the server side.
// So override any possible prototype-provided defaultValue with undefined which will inhibit generation of defaulting code in Reader.buildRecordDataExtractor
if (idField && ((newField.mapping && (newField.mapping === idField.mapping)) || (newField.name === idField.name))) {
idFieldDefined = true;
newField.defaultValue = undefined;
}
prototypeFields.add(newField);
}
// If there was an idProperty specified, and there has *not* been a field defined which encapsulates that property,
// then create a field which encapsulates that property.
// This must never provide a default value.
if (idField && !idFieldDefined) {
idField.defaultValue = undefined;
prototypeFields.add(idField);
}
me.fields = prototypeFields;
return prototypeFields;
},

getFields: function() {
return this.prototype.fields.items;
},

load: function(id, config) {
config = Ext.apply({}, config);
config = Ext.applyIf(config, {
action: 'read',
id : id
});
var operation = new Ext.data.Operation(config),
scope = config.scope || this,
callback;
callback = function(operation) {
var record = null,
success = operation.wasSuccessful();

if (success) {
record = operation.getRecords()[0];
// If the server didn't set the id, do it here
if (!record.hasId()) {
record.setId(id);
}
Ext.callback(config.success, scope, [record, operation]);
} else {
Ext.callback(config.failure, scope, [record, operation]);
}
Ext.callback(config.callback, scope, [record, operation, success]);
};
this.getProxy().read(operation, callback, this);
}
},
statics: {

PREFIX : 'ext-record',

AUTO_ID: 1,

EDIT : 'edit',

REJECT : 'reject',

COMMIT : 'commit',

id: function(rec) {
var id = [this.PREFIX, '-', this.AUTO_ID++].join('');
rec.phantom = true;
rec.internalId = id;
return id;
}
},

idgen: {
isGenerator: true,
type: 'default',
generate: function () {
return null;
},
getRecId: function (rec) {
return rec.modelName + '-' + rec.internalId;
}
},

editing : false,

dirty : false,

persistenceProperty: 'data',
evented: false,

isModel: true,

phantom : false,

idProperty: 'id',

clientIdProperty: null,

defaultProxyType: 'ajax',
// Used as a dummy source array when constructor is called with no args
emptyData: [],
// Fields config and property



// Associations configs and properties






constructor: function(data, id, raw, convertedData) {
// id, raw and convertedData not documented intentionally, meant to be used internally.
// TODO: find where "raw" is used and remove it. The first parameter, "data" is raw, unconverted data.
// 
// The "convertedData" parameter is a converted object hash with all properties corresponding to defined Fields
// and all values of the defined type. It is used directly as this record's data property.
// When the convertedData parameter is used, raw data is passed in using the "raw" parameter and
// is not processed
var me = this,
passedId = (id || id === 0),
hasId,
fields,
length,
field,
name,
value,
newId,
persistenceProperty,
idProperty = me.idProperty,
idField = me.idField,
i;

me.raw = raw || data; // If created using data in constructor, use data

me.modified = {};
//<debug>
// exclude types since it's new
if (me.persistenceProperty !== 'data') {
Ext.log.warn(this.$className, 'The persistenceProperty will be deprecated, all data will be stored in the underlying data property.');
}
//</debug>
persistenceProperty = me[me.persistenceProperty] = convertedData || {};
// Until persistenceProperty is deprecated, keep a reference in me.data
me.data = me[me.persistenceProperty];
me.mixins.observable.constructor.call(me);
if (!convertedData) {
if (data) {
// If no ID passed, use the id property from the converted data
if (!passedId && idProperty) {
id = data[idProperty];
hasId = (id || id === 0);
}
}
// No data passed. Use the static empty array.
else {
data = me.emptyData;
} 
//add default field values if present
fields = me.fields.items;
length = fields.length;
i = 0;
if (Ext.isArray(data)) {
for (; i < length; i++) {
field = fields[i];
name = field.name;
// Use the original ordinal position at which the Model inserted the field into its collection.
// Fields are sorted to place fields with a *convert* function last.
value = data[field.originalIndex];
if (value === undefined) {
value = field.defaultValue;
}
// Have to map array data so the values get assigned to the named fields
// rather than getting set as the field names with undefined values.
if (field.convert) {
value = field.convert(value, me);
}
// On instance construction, do not create data properties based on undefined input properties
if (value !== undefined) {
persistenceProperty[name] = value;
}
}
} else {
for (; i < length; i++) {
field = fields[i];
name = field.name;
value = data[name];
if (value === undefined) {
value = field.defaultValue;
}
if (field.convert) {
value = field.convert(value, me);
}
// On instance construction, do not create data properties based on undefined input properties
if (value !== undefined) {
persistenceProperty[name] = value;
}
}
}
}

me.stores = [];
// Caller passed an id, put the converted value into our data object.
// The *unconverted* value is used as the internalId.
if (passedId) {
hasId = true;
persistenceProperty[idProperty] = idField && idField.convert ? idField.convert(id) : id;
}
// If there's no id, we are a phantom so we have to generate an id.
else if (!hasId) {
// Generate a key using the supplied idgen function
newId = me.idgen.generate();
if (newId != null) {
me.preventInternalUpdate = true;
me.setId(newId);
delete me.preventInternalUpdate;
}
}

me.internalId = hasId ? id : Ext.data.Model.id(me);
// The Ext.data.Model.id call sets the phantom property. So it will be set now if !hasId
if (typeof me.init == 'function') {
me.init();
}
// Generate an observable ID
me.id = me.idgen.getRecId(me);
},

get: function(field) {
return this[this.persistenceProperty][field];
},
// This object is used whenever the set() method is called and given a string as the
// first argument. This approach saves memory (and GC costs) since we could be called
// a lot.
_singleProp: {},

set: function (fieldName, newValue) {
var me = this,
data = me[me.persistenceProperty],
fields = me.fields,
modified = me.modified,
single = (typeof fieldName == 'string'),
currentValue, field, idChanged, key, modifiedFieldNames, name, oldId,
newId, value, values;
if (single) {
values = me._singleProp;
values[fieldName] = newValue;
} else {
values = fieldName;
}
for (name in values) {
if (values.hasOwnProperty(name)) {
value = values[name];
if (fields && (field = fields.get(name)) && field.convert) {
value = field.convert(value, me);
}
currentValue = data[name];
if (me.isEqual(currentValue, value)) {
continue; // new value is the same, so no change...
}
data[name] = value;
(modifiedFieldNames || (modifiedFieldNames = [])).push(name);
if (field && field.persist) {
if (modified.hasOwnProperty(name)) {
if (me.isEqual(modified[name], value)) {
// The original value in me.modified equals the new value, so
// the field is no longer modified:
delete modified[name];
// We might have removed the last modified field, so check to
// see if there are any modified fields remaining and correct
// me.dirty:
me.dirty = false;
for (key in modified) {
if (modified.hasOwnProperty(key)){
me.dirty = true;
break;
}
}
}
} else {
me.dirty = true;
modified[name] = currentValue;
}
}
if (name == me.idProperty) {
idChanged = true;
oldId = currentValue;
newId = value;
}
}
}
if (single) {
// cleanup our reused object for next time... important to do this before
// we fire any events or call anyone else (like afterEdit)!
delete values[fieldName];
}
if (idChanged) {
me.changeId(oldId, newId);
}
if (!me.editing && modifiedFieldNames) {
me.afterEdit(modifiedFieldNames);
}
return modifiedFieldNames || null;
},

copyFrom: function(sourceRecord) {
var me = this,
fields = me.fields.items,
fieldCount = fields.length,
modifiedFieldNames = [],
field, i = 0,
myData,
sourceData,
idProperty = me.idProperty,
name,
value;
if (sourceRecord) {
myData = me[me.persistenceProperty];
sourceData = sourceRecord[sourceRecord.persistenceProperty];
for (; i < fieldCount; i++) {
field = fields[i];
name = field.name;
// Do not use setters.
// Copy returned values in directly from the data object.
// Converters have already been called because new Records
// have been created to copy from.
// This is a direct record-to-record value copy operation.
// don't copy the id, we'll do it at the end
if (name != idProperty) {
value = sourceData[name];
// If source property is specified, and value is different
// copy field value in and build updatedFields
if (value !== undefined && !me.isEqual(myData[name], value)) {
myData[name] = value;
modifiedFieldNames.push(name);
}
}
}
// If this is a phantom record being updated from a concrete record, copy the ID in.
if (me.phantom && !sourceRecord.phantom) {
// beginEdit to prevent events firing
// commit at the end to prevent dirty being set
me.beginEdit();
me.setId(sourceRecord.getId());
me.endEdit(true);
me.commit(true);
}
}
return modifiedFieldNames;
},

isEqual: function(a, b) {
// instanceof is ~10 times faster then Ext.isDate. Values here will not be cross-document objects
if (a instanceof Date && b instanceof Date) {
return a.getTime() === b.getTime();
}
return a === b;
},

beginEdit : function(){
var me = this,
key,
data,
o;
if (!me.editing) {
me.editing = true;
me.dirtySave = me.dirty;
o = me[me.persistenceProperty];
data = me.dataSave = {};
for (key in o) {
if (o.hasOwnProperty(key)) {
data[key] = o[key];
}
}
o = me.modified;
data = me.modifiedSave = {}; 
for (key in o) {
if (o.hasOwnProperty(key)) {
data[key] = o[key];
}
}
}
},

cancelEdit : function(){
var me = this;
if (me.editing) {
me.editing = false;
// reset the modified state, nothing changed since the edit began
me.modified = me.modifiedSave;
me[me.persistenceProperty] = me.dataSave;
me.dirty = me.dirtySave;
me.modifiedSave = me.dataSave = me.dirtySave = null;
}
},

endEdit : function(silent, modifiedFieldNames){
var me = this,
dataSave,
changed;
silent = silent === true;
if (me.editing) {
me.editing = false;
dataSave = me.dataSave;
me.modifiedSave = me.dataSave = me.dirtySave = null;
if (!silent) {
if (!modifiedFieldNames) {
modifiedFieldNames = me.getModifiedFieldNames(dataSave);
}
changed = me.dirty || modifiedFieldNames.length > 0;
if (changed) {
me.afterEdit(modifiedFieldNames);
}
}
}
},

getModifiedFieldNames: function(saved){
var me = this,
data = me[me.persistenceProperty],
modified = [],
key;
saved = saved || me.dataSave;
for (key in data) {
if (data.hasOwnProperty(key)) {
if (!me.isEqual(data[key], saved[key])) {
modified.push(key);
}
}
}
return modified; 
},

getChanges : function(){
var modified = this.modified,
changes = {},
field;
for (field in modified) {
if (modified.hasOwnProperty(field)){
changes[field] = this.get(field);
}
}
return changes;
},

isModified : function(fieldName) {
return this.modified.hasOwnProperty(fieldName);
},

setDirty : function() {
var me = this,
fields = me.fields.items,
fLen = fields.length,
field, name, f;
me.dirty = true;
for (f = 0; f < fLen; f++) {
field = fields[f];
if (field.persist) {
name = field.name;
me.modified[name] = me.get(name);
}
}
},
//<debug>
markDirty : function() {
Ext.log.warn('Ext.data.Model: markDirty has been deprecated. Use setDirty instead.');
return this.setDirty.apply(this, arguments);
},
//</debug>

reject : function(silent) {
var me = this,
modified = me.modified,
field;
for (field in modified) {
if (modified.hasOwnProperty(field)) {
if (typeof modified[field] != "function") {
me[me.persistenceProperty][field] = modified[field];
}
}
}
me.dirty = false;
me.editing = false;
me.modified = {};
if (silent !== true) {
me.afterReject();
}
},

commit : function(silent, modifiedFieldNames) {
var me = this;
me.phantom = me.dirty = me.editing = false;
me.modified = {};
if (silent !== true) {
me.afterCommit(modifiedFieldNames);
}
},

copy : function(newId) {
var me = this;
return new me.self(me.raw, newId, null, Ext.apply({}, me[me.persistenceProperty]));
},

setProxy: function(proxy) {
//make sure we have an Ext.data.proxy.Proxy object
if (!proxy.isProxy) {
if (typeof proxy === "string") {
proxy = {
type: proxy
};
}
proxy = Ext.createByAlias("proxy." + proxy.type, proxy);
}
proxy.setModel(this.self);
this.proxy = proxy;
return proxy;
},

getProxy: function() {
return this.hasOwnProperty('proxy') ? this.proxy : this.self.getProxy();
},

validate: function() {
var errors = new Ext.data.Errors(),
validations = this.validations,
validators = Ext.data.validations,
length, validation, field, valid, type, i;
if (validations) {
length = validations.length;
for (i = 0; i < length; i++) {
validation = validations[i];
field = validation.field || validation.name;
type = validation.type;
valid = validators[type](validation, this.get(field));
if (!valid) {
errors.add({
field : field,
message: validation.message || validators[type + 'Message']
});
}
}
}
return errors;
},

isValid: function(){
return this.validate().isValid();
},

save: function(options) {
options = Ext.apply({}, options);
var me = this,
action = me.phantom ? 'create' : 'update',
scope = options.scope || me,
stores = me.stores,
i = 0,
storeCount,
store,
operation,
callback;
Ext.apply(options, {
records: [me],
action : action
});
operation = new Ext.data.Operation(options);
callback = function(operation) {
var success = operation.wasSuccessful();

if (success) {
for(storeCount = stores.length; i < storeCount; i++) {
store = stores[i];
store.fireEvent('write', store, operation);
store.fireEvent('datachanged', store);
// Not firing refresh here, since it's a single record
}
Ext.callback(options.success, scope, [me, operation]);
}
else {
Ext.callback(options.failure, scope, [me, operation]);
}
Ext.callback(options.callback, scope, [me, operation, success]);
};
me.getProxy()[action](operation, callback, me);
return me;
},

destroy: function(options) {
options = Ext.apply({
records: [this],
action : 'destroy'
}, options);
var me = this,
isNotPhantom = me.phantom !== true,
scope = options.scope || me,
stores,
i = 0,
storeCount,
store,
args,
operation,
callback;
operation = new Ext.data.Operation(options);
callback = function(operation) {
args = [me, operation];
// The stores property will be mutated, so clone it first
stores = Ext.Array.clone(me.stores);
if (operation.wasSuccessful()) {
for (storeCount = stores.length; i < storeCount; i++) {
store = stores[i];
// If the store has a remove (it's not a TreeStore), then
// remove this record from Store. Avoid Store handling anything by passing the "isMove" flag
if (store.remove) {
store.remove(me, true);
}
// Other parties may need to know that the record as gone
// eg View SelectionModels
store.fireEvent('bulkremove', store, [me], [store.indexOf(me)], false);
if (isNotPhantom) {
store.fireEvent('write', store, operation);
}
}
me.clearListeners();
Ext.callback(options.success, scope, args);
} else {
Ext.callback(options.failure, scope, args);
}
Ext.callback(options.callback, scope, args);
};
// Not a phantom, then we must perform this operation on the remote datasource.
// Record will be removed from the store in the callback upon a success response
if (isNotPhantom) {
me.getProxy().destroy(operation, callback, me);
}
// If it's a phantom, then call the callback directly with a dummy successful ResultSet
else {
operation.complete = operation.success = true;
operation.resultSet = me.getProxy().reader.nullResultSet;
callback(operation);
}
return me;
},

getId: function() {
return this.get(this.idField.name);
},

getObservableId: function() {
return this.id;
},

setId: function(id) {
this.set(this.idProperty, id);
},
changeId: function(oldId, newId) {
var me = this,
hasOldId, hasId, oldInternalId;
if (!me.preventInternalUpdate) { 
hasOldId = me.hasId(oldId);
hasId = me.hasId(newId);
oldInternalId = me.internalId;
me.phantom = !hasId;
// The internal id changes if:
// a) We had an id before and now we don't
// b) We didn't have an id before and now we do
// c) We had an id and we're setting a new id
if (hasId !== hasOldId || (hasId && hasOldId)) {
me.internalId = hasId ? newId : Ext.data.Model.id(me);
}
me.fireEvent('idchanged', me, oldId, newId, oldInternalId);
me.callStore('onIdChanged', oldId, newId, oldInternalId);
}
},

hasId: function(id) {
if (arguments.length === 0) {
id = this.getId();
}
return !!(id || id === 0);
},

join : function(store) {
var me = this;
// Code for the 99% use case using fast way!
if (!me.stores.length) {
me.stores[0] = store;
} else {
Ext.Array.include(this.stores, store);
}

this.store = this.stores[0]; // compat w/all releases ever
},

unjoin: function(store) {
Ext.Array.remove(this.stores, store);
this.store = this.stores[0] || null; // compat w/all releases ever
},

afterEdit : function(modifiedFieldNames) {
this.callStore('afterEdit', modifiedFieldNames);
},

afterReject : function() {
this.callStore('afterReject');
},

afterCommit: function(modifiedFieldNames) {
this.callStore('afterCommit', modifiedFieldNames);
},

callStore: function(fn) {
var args = Ext.Array.clone(arguments),
stores = this.stores,
i = 0,
len = stores.length,
store;
args[0] = this;
for (; i < len; ++i) {
store = stores[i];
if (store && Ext.isFunction(store[fn])) {
store[fn].apply(store, args);
}
}
},

getData: function(includeAssociated){
var me = this,
fields = me.fields.items,
fLen = fields.length,
data = {},
name, f;
for (f = 0; f < fLen; f++) {
name = fields[f].name;
data[name] = me.get(name);
}
if (includeAssociated === true) {
Ext.apply(data, me.getAssociatedData());
}
return data;
},

getAssociatedData: function(){
return this.prepareAssociatedData({}, 1);
},

prepareAssociatedData: function(seenKeys, depth) {

var me = this,
associations = me.associations.items,
associationCount = associations.length,
associationData = {},
// We keep 3 lists at the same index instead of using an array of objects.
// The reasoning behind this is that this method gets called a lot
// So we want to minimize the amount of objects we create for GC.
toRead = [],
toReadKey = [],
toReadIndex = [],
associatedStore, associatedRecords, associatedRecord, o, index, result, seenDepth,
associationId, associatedRecordCount, association, i, j, type, name;
for (i = 0; i < associationCount; i++) {
association = associations[i];
associationId = association.associationId;
seenDepth = seenKeys[associationId];
if (seenDepth && seenDepth !== depth) {
continue;
}
seenKeys[associationId] = depth;
type = association.type;
name = association.name;
if (type == 'hasMany') {
//this is the hasMany store filled with the associated data
associatedStore = me[association.storeName];
//we will use this to contain each associated record's data
associationData[name] = [];
//if it's loaded, put it into the association data
if (associatedStore && associatedStore.getCount() > 0) {
associatedRecords = associatedStore.data.items;
associatedRecordCount = associatedRecords.length;
//now we're finally iterating over the records in the association. Get
// all the records so we can process them
for (j = 0; j < associatedRecordCount; j++) {
associatedRecord = associatedRecords[j];
associationData[name][j] = associatedRecord.getData();
toRead.push(associatedRecord);
toReadKey.push(name);
toReadIndex.push(j);
}
}
} else if (type == 'belongsTo' || type == 'hasOne') {
associatedRecord = me[association.instanceName];
// If we have a record, put it onto our list
if (associatedRecord !== undefined) {
associationData[name] = associatedRecord.getData();
toRead.push(associatedRecord);
toReadKey.push(name);
toReadIndex.push(-1);
}
}
}
for (i = 0, associatedRecordCount = toRead.length; i < associatedRecordCount; ++i) {
associatedRecord = toRead[i];
o = associationData[toReadKey[i]];
index = toReadIndex[i];
result = associatedRecord.prepareAssociatedData(seenKeys, depth + 1);
if (index === -1) {
Ext.apply(o, result);
} else {
Ext.apply(o[index], result);
}
}
return associationData;
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/data/ResultSet.js */
(function(Ext) {
Ext.define('Ext.data.ResultSet', {

loaded: true,

count: 0,

total: 0,

success: false,


constructor: function(config) {
Ext.apply(this, config);

this.totalRecords = this.total;
if (config.count === undefined) {
this.count = this.records.length;
}
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/data/reader/Reader.js */
(function(Ext) {
Ext.define('Ext.data.reader.Reader', {
requires: ['Ext.data.ResultSet', 'Ext.XTemplate'],
alternateClassName: ['Ext.data.Reader', 'Ext.data.DataReader'],
mixins: {
observable: 'Ext.util.Observable'
},


totalProperty: 'total',

successProperty: 'success',

root: '',




implicitIncludes: true,


readRecordsOnFailure: true,




isReader: true,
// Private flag to the generated convertRecordData function to indicate whether to apply Field default
// values to fields for which no value is present in the raw data.
// This is set to false by a Server Proxy which is reading the response from a "create" or "update" operation.
applyDefaults: true,
lastFieldGeneration: null,


constructor: function(config) {
var me = this;

me.mixins.observable.constructor.call(me, config);
me.fieldCount = 0;
me.model = Ext.ModelManager.getModel(me.model);
// Extractors can only be calculated if the fields MixedCollection has been set.
// A Model may only complete its setup (set the prototype properties) after asynchronous loading
// which would mean that there may be no "fields"
// If this happens, the load callback will call proxy.setModel which calls reader.setModel which
// triggers buildExtractors.
if (me.model && me.model.prototype.fields) {
me.buildExtractors();
}
this.addEvents(

'exception'
);
},

setModel: function(model, setOnProxy) {
var me = this;

me.model = Ext.ModelManager.getModel(model);
if (model) {
me.buildExtractors(true);
}

if (setOnProxy && me.proxy) {
me.proxy.setModel(me.model, true);
}
},

read: function(response) {
var data;
if (response) {
data = response.responseText ? this.getResponseData(response) : this.readRecords(response);
}
return data || this.nullResultSet;
},

readRecords: function(data) {
var me = this,
success,
recordCount,
records,
root,
total,
value,
message;


if (me.lastFieldGeneration !== me.model.prototype.fields.generation) {
me.buildExtractors(true);
}


me.rawData = data;
data = me.getData(data);

success = true;
recordCount = 0;
records = [];

if (me.successProperty) {
value = me.getSuccess(data);
if (value === false || value === 'false') {
success = false;
}
}

if (me.messageProperty) {
message = me.getMessage(data);
}

// Only try and extract other data if call was successful
if (me.readRecordsOnFailure || success) {
// If we pass an array as the data, we dont use getRoot on the data.
// Instead the root equals to the data.
root = Ext.isArray(data) ? data : me.getRoot(data);

if (root) {
total = root.length;
}
if (me.totalProperty) {
value = parseInt(me.getTotal(data), 10);
if (!isNaN(value)) {
total = value;
}
}
if (root) {
records = me.extractData(root);
recordCount = records.length;
}
}
return new Ext.data.ResultSet({
total : total || recordCount,
count : recordCount,
records: records,
success: success,
message: message
});
},

extractData : function(root) {
var me = this,
Model = me.model,
length = root.length,
records = new Array(length),
convertedValues, node, record, i;
if (!root.length && Ext.isObject(root)) {
root = [root];
length = 1;
}
for (i = 0; i < length; i++) {
node = root[i];
if (node.isModel) {
// If we're given a model instance in the data, just push it on
// without doing any conversion
records[i] = node;
} else {
// Create a record with an empty data object.
// Populate that data object by extracting and converting field values from raw data.
// Must pass the ID to use because we pass no data for the constructor to pluck an ID from
records[i] = record = new Model(undefined, me.getId(node), node, convertedValues = {});
// If the server did not include an id in the response data, the Model constructor will mark the record as phantom.
// We need to set phantom to false here because records created from a server response using a reader by definition are not phantom records.
record.phantom = false;
// Use generated function to extract all fields at once
me.convertRecordData(convertedValues, node, record);
if (me.implicitIncludes && record.associations.length) {
me.readAssociated(record, node);
}
}
}
return records;
},

readAssociated: function(record, data) {
var associations = record.associations.items,
i = 0,
length = associations.length,
association, associationData, proxy, reader;

for (; i < length; i++) {
association = associations[i];
associationData = this.getAssociatedDataRoot(data, association.associationKeyFunction || association.associationKey || association.name);

if (associationData) {
reader = association.getReader();
if (!reader) {
proxy = association.associatedModel.getProxy();
// if the associated model has a Reader already, use that, otherwise attempt to create a sensible one
if (proxy) {
reader = proxy.getReader();
} else {
reader = new this.constructor({
model: association.associatedName
});
}
}
association.read(record, reader, associationData);
} 
}
},


getAssociatedDataRoot: function(data, associationName) {
if (Ext.isFunction(associationName)) {
return associationName(data);
}
return data[associationName];
},

getFields: function() {
return this.model.prototype.fields.items;
},

getData: Ext.identityFn,

getRoot: Ext.identityFn,

getResponseData: function(response) {
//<debug>
Ext.Error.raise("getResponseData must be implemented in the Ext.data.reader.Reader subclass");
//</debug>
},

onMetaChange : function(meta) {
var me = this,
fields = meta.fields || me.getFields(),
newModel,
clientIdProperty;

// save off the raw meta data
me.metaData = meta;

// set any reader-specific configs from meta if available
me.root = meta.root || me.root;
me.idProperty = meta.idProperty || me.idProperty;
me.totalProperty = meta.totalProperty || me.totalProperty;
me.successProperty = meta.successProperty || me.successProperty;
me.messageProperty = meta.messageProperty || me.messageProperty;
clientIdProperty = meta.clientIdProperty;
if (me.model) {
me.model.setFields(fields, me.idProperty, clientIdProperty);
me.setModel(me.model, true);
}
else {
newModel = Ext.define("Ext.data.reader.Json-Model" + Ext.id(), {
extend: 'Ext.data.Model',
fields: fields,
clientIdProperty: clientIdProperty
});
if (me.idProperty) {
// We only do this if the reader actually has a custom idProperty set,
// otherwise let the model use its own default value. It is valid for
// the reader idProperty to be undefined, in which case it will use the
// model's idProperty (in getIdProperty()).
newModel.idProperty = me.idProperty;
}
me.setModel(newModel, true);
}
},


getIdProperty: function() {
var idField = this.model.prototype.idField,
idProperty = this.idProperty;
if (!idProperty && idField && (idProperty = idField.mapping) == null) {
idProperty = idField.name;
}
return idProperty;
},

buildExtractors: function(force) {
var me = this,
idProp = me.getIdProperty(),
totalProp = me.totalProperty,
successProp = me.successProperty,
messageProp = me.messageProperty,
accessor;

if (force === true) {
delete me.convertRecordData;
}

if (me.convertRecordData) {
return;
} 
//build the extractors for all the meta data
if (totalProp) {
me.getTotal = me.createAccessor(totalProp);
}
if (successProp) {
me.getSuccess = me.createAccessor(successProp);
}
if (messageProp) {
me.getMessage = me.createAccessor(messageProp);
}
// Generate a getter for the raw identifying property if any
if (idProp) {
accessor = me.createAccessor(idProp);
me.getId = function(record) {
var id = accessor.call(me, record);
return (id === undefined || id === '') ? null : id;
};
} else {
me.getId = function() {
return null;
};
}
me.convertRecordData = me.buildRecordDataExtractor();
me.lastFieldGeneration = me.model.prototype.fields.generation;
},
recordDataExtractorTemplate : [
'var me = this\n',
' ,fields = me.model.prototype.fields\n',
' ,value\n',
' ,internalId\n',
'<tpl for="fields">',
' ,__field{#} = fields.map["{name}"]\n',
'</tpl>', ';\n',
'return function(dest, source, record) {\n',
'<tpl for="fields">',
'{% var fieldAccessExpression = this.createFieldAccessExpression(values, "__field" + xindex, "source");',
' if (fieldAccessExpression) { %}',
// createFieldAccessExpression must be implemented in subclasses to extract data from the source object in the correct way
' value = {[ this.createFieldAccessExpression(values, "__field" + xindex, "source") ]};\n',
// Code for processing a source property when a custom convert is defined
'<tpl if="hasCustomConvert">',
' dest["{name}"] = value === undefined ? __field{#}.convert(__field{#}.defaultValue, record) : __field{#}.convert(value, record);\n',
// Code for processing a source property when there is a default value
'<tpl elseif="defaultValue !== undefined">',
' if (value === undefined) {\n',
' if (me.applyDefaults) {\n',
'<tpl if="convert">',
' dest["{name}"] = __field{#}.convert(__field{#}.defaultValue, record);\n',
'<tpl else>',
' dest["{name}"] = __field{#}.defaultValue\n',
'</tpl>',
' };\n',
' } else {\n',
'<tpl if="convert">',
' dest["{name}"] = __field{#}.convert(value, record);\n',
'<tpl else>',
' dest["{name}"] = value;\n',
'</tpl>',
' };\n',
// Code for processing a source property value when there is no default value
'<tpl else>',
' if (value !== undefined) {\n',
'<tpl if="convert">',
' dest["{name}"] = __field{#}.convert(value, record);\n',
'<tpl else>',
' dest["{name}"] = value;\n',
'</tpl>',
' }\n',
'</tpl>',

// For when createFieldExpression yielded nothing.
// There's no mapping - the field is not intended to be read from server data.
// This is the case with NodeInterface fields.
'{% } else { %}',
'<tpl if="defaultValue !== undefined">',
'<tpl if="convert">',
' dest["{name}"] = __field{#}.convert(__field{#}.defaultValue, record);\n',
'<tpl else>',
' dest["{name}"] = __field{#}.defaultValue\n',
'</tpl>',
'</tpl>',
'{% } %}',
'</tpl>',
// set the client id as the internalId of the record.
// clientId handles the case where a client side record did not previously exist on the server,
// so the server is passing back a client id that can be used to pair the server side record up with the client record
'<tpl if="clientIdProp">',
' if (record && (internalId = {[ this.createFieldAccessExpression(\{mapping: values.clientIdProp\}, null, "source") ]})) {\n',
' record.{["internalId"]} = internalId;\n',
' }\n',
'</tpl>',
'};'
],

buildRecordDataExtractor: function() {
var me = this,
modelProto = me.model.prototype,
templateData = {
clientIdProp: modelProto.clientIdProperty,
fields: modelProto.fields.items
};
me.recordDataExtractorTemplate.createFieldAccessExpression = function() { 
return me.createFieldAccessExpression.apply(me,arguments);
};

// Here we are creating a new Function and invoking it immediately in the scope of this Reader
// It declares several vars capturing the configured context of this Reader, and returns a function
// which, when passed a record data object, a raw data row in the format this Reader is configured to read,
// and the record which is being created, will populate the record's data object from the raw row data.
return Ext.functionFactory(me.recordDataExtractorTemplate.apply(templateData)).call(me);
},
destroyReader: function() {
var me = this;
delete me.proxy;
delete me.model;
delete me.convertRecordData;
delete me.getId;
delete me.getTotal;
delete me.getSuccess;
delete me.getMessage;
}
}, function() {
var proto = this.prototype;
Ext.apply(proto, {
// Private. Empty ResultSet to return when response is falsy (null|undefined|empty string)
nullResultSet: new Ext.data.ResultSet({
total : 0,
count : 0,
records: [],
success: true,
message: ''
}),
recordDataExtractorTemplate: new Ext.XTemplate(proto.recordDataExtractorTemplate)
});
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/data/reader/Json.js */
(function(Ext) {
Ext.define('Ext.data.reader.Json', {
extend: 'Ext.data.reader.Reader',
alternateClassName: 'Ext.data.JsonReader',
alias : 'reader.json',
root: '',



metaProperty: 'metaData',

useSimpleAccessors: false,

readRecords: function(data) {
var me = this,
meta;

//this has to be before the call to super because we use the meta data in the superclass readRecords
if (me.getMeta) {
meta = me.getMeta(data);
if (meta) {
me.onMetaChange(meta);
}
} else if (data.metaData) {
me.onMetaChange(data.metaData);
}

me.jsonData = data;
return me.callParent([data]);
},
//inherit docs
getResponseData: function(response) {
var data, error;

try {
data = Ext.decode(response.responseText);
return this.readRecords(data);
} catch (ex) {
error = new Ext.data.ResultSet({
total : 0,
count : 0,
records: [],
success: false,
message: ex.message
});
this.fireEvent('exception', this, response, error);
Ext.Logger.warn('Unable to parse the JSON returned by the server');
return error;
}
},
//inherit docs
buildExtractors : function() {
var me = this,
metaProp = me.metaProperty;
me.callParent(arguments);
if (me.root) {
me.getRoot = me.createAccessor(me.root);
} else {
me.getRoot = Ext.identityFn;
}

if (metaProp) {
me.getMeta = me.createAccessor(metaProp);
}
},

extractData: function(root) {
var recordName = this.record,
data = [],
length, i;
if (recordName) {
length = root.length;

if (!length && Ext.isObject(root)) {
length = 1;
root = [root];
}
for (i = 0; i < length; i++) {
data[i] = root[i][recordName];
}
} else {
data = root;
}
return this.callParent([data]);
},

createAccessor: (function() {
var re = /[\[\.]/;
return function(expr) {
if (Ext.isEmpty(expr)) {
return Ext.emptyFn;
}
if (Ext.isFunction(expr)) {
return expr;
}
if (this.useSimpleAccessors !== true) {
var i = String(expr).search(re);
if (i >= 0) {
return Ext.functionFactory('obj', 'return obj' + (i > 0 ? '.' : '') + expr);
}
}
return function(obj) {
return obj[expr];
};
};
}()),

createFieldAccessExpression: (function() {
var re = /[\[\.]/;
return function(field, fieldVarName, dataName) {
var mapping = field.mapping,
hasMap = mapping || mapping === 0,
map = hasMap ? mapping : field.name,
result,
operatorIndex;
// mapping: false means that the Field will never be read from server data.
if (mapping === false) {
return;
}
if (typeof map === 'function') {
result = fieldVarName + '.mapping(' + dataName + ', this)';
} else if (this.useSimpleAccessors === true || ((operatorIndex = String(map).search(re)) < 0)) {
if (!hasMap || isNaN(map)) {
// If we don't provide a mapping, we may have a field name that is numeric
map = '"' + map + '"';
}
result = dataName + "[" + map + "]";
} else if (operatorIndex === 0) {
// If it matched at index 0 then it must be bracket syntax (e.g. ["foo"]). In this case simply
// join the two, e.g. 'field["foo"]':
result = dataName + map;
} else {
// If it matched at index > 0 it must be either dot syntax (e.g. field.foo) or a values array
// item (e.g. values[0]). For the latter, we can simply concatenate the values reference to
// the source directly like 'field.values[0]'. For dot notation we have to support arbitrary
// levels (field.foo.bar), any of which could be null or undefined, so we have to create the
// returned value such that the references will be assigned defensively in the calling code.
// The output should look like 'field.foo && field.foo.bar' in that case.
var parts = map.split('.'),
len = parts.length,
i = 1,
tempResult = dataName + '.' + parts[0],
buffer = [tempResult]; // for 'field.values[0]' this will be the returned result

for (; i < len; i++) {
tempResult += '.' + parts[i];
buffer.push(tempResult);
}
result = buffer.join(' && ');
}
return result;
};
}())
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/data/writer/Writer.js */
(function(Ext) {
Ext.define('Ext.data.writer.Writer', {
alias: 'writer.base',
alternateClassName: ['Ext.data.DataWriter', 'Ext.data.Writer'],

writeAllFields: true,


nameProperty: 'name',

writeRecordId: true,

isWriter: true,

constructor: function(config) {
Ext.apply(this, config);
},

write: function(request) {
var operation = request.operation,
records = operation.records || [],
len = records.length,
i = 0,
data = [];
for (; i < len; i++) {
data.push(this.getRecordData(records[i], operation));
}
return this.writeRecords(request, data);
},

getRecordData: function(record, operation) {
var isPhantom = record.phantom === true,
writeAll = this.writeAllFields || isPhantom,
fields = record.fields,
fieldItems = fields.items,
data = {},
clientIdProperty = record.clientIdProperty,
changes,
field,
key,
mappedIdProperty,
f, fLen;
if (writeAll) {
fLen = fieldItems.length;
for (f = 0; f < fLen; f++) {
field = fieldItems[f];
if (field.persist) {
this.writeValue(data, field, record);
}
}
} else {
// Only write the changes
changes = record.getChanges();
for (key in changes) {
if (changes.hasOwnProperty(key)) {
field = fields.get(key);
if (field.persist) {
this.writeValue(data, field, record);
}
}
}
}
if (isPhantom) {
if (clientIdProperty && operation && operation.records.length > 1) {
// include clientId for phantom records, if multiple records are being written to the server in one operation.
// The server can then return the clientId with each record so the operation can match the server records with the client records
data[clientIdProperty] = record.internalId;
}
} else if (this.writeRecordId) {
// Make sure that if a mapping is in place the mapped id name is used instead of the default field name. 
mappedIdProperty = fields.get(record.idProperty)[this.nameProperty] || record.idProperty;
data[mappedIdProperty] = record.getId();
}
return data;
},
writeValue: function(data, field, record){
var name = field[this.nameProperty],
dateFormat = this.dateFormat || field.dateWriteFormat || field.dateFormat,
value = record.get(field.name);
// Allow the nameProperty to yield a numeric value which may be zero.
// For example, using a field's numeric mapping to write an array for output.
if (name == null) {
name = field.name;
}
if (field.serialize) {
data[name] = field.serialize(value, record);
} else if (field.type === Ext.data.Types.DATE && dateFormat && Ext.isDate(value)) {
data[name] = Ext.Date.format(value, dateFormat);
} else {
data[name] = value;
}
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/data/writer/Json.js */
(function(Ext) {
Ext.define('Ext.data.writer.Json', {
extend: 'Ext.data.writer.Writer',
alternateClassName: 'Ext.data.JsonWriter',
alias: 'writer.json',


root: undefined,


encode: false,


allowSingle: true,


expandData: false,


getExpandedData: function(data) {
var dataLength = data.length,
i = 0,
item,
prop,
nameParts,
j,
tempObj,

toObject = function(name, value) {
var o = {};
o[name] = value;
return o;
};

for (; i < dataLength; i++) {
item = data[i];

for (prop in item) {
if (item.hasOwnProperty(prop)) {
// e.g. my.nested.property: 'foo'
nameParts = prop.split('.');
j = nameParts.length - 1;

if (j > 0) {
// Initially this will be the value 'foo'.
// Equivalent to rec['my.nested.property']
tempObj = item[prop];

for (; j > 0; j--) {
// Starting with the value above, we loop inside out, assigning the
// current object as the value for the parent name. Work all
// the way up until only the root name is left to assign.
tempObj = toObject(nameParts[j], tempObj);
}

// At this point we'll have all child properties rolled up into a single
// object like `{ nested: { property: 'foo' }}`. Now add the root name
// (e.g. 'my') to the record data if needed (do not overwrite existing):
item[nameParts[0]] = item[nameParts[0]] || {};
// Since there could be duplicate names at any level of the nesting be sure
// to merge rather than assign when setting the object as the value:
Ext.Object.merge(item[nameParts[0]], tempObj);
// Finally delete the original mapped property from the record
delete item[prop];
}
}
}
}
return data;
},

//inherit docs
writeRecords: function(request, data) {
var root = this.root;

if (this.expandData) {
data = this.getExpandedData(data);
}

if (this.allowSingle && data.length === 1) {
// convert to single object format
data = data[0];
}

if (this.encode) {
if (root) {
// sending as a param, need to encode
request.params[root] = Ext.encode(data);
} else {
//<debug>
Ext.Error.raise('Must specify a root when using encode');
//</debug>
}
} else {
// send as jsonData
request.jsonData = request.jsonData || {};
if (root) {
request.jsonData[root] = data;
} else {
request.jsonData = data;
}
}
return request;
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/data/Batch.js */
(function(Ext) {
Ext.define('Ext.data.Batch', {
mixins: {
observable: 'Ext.util.Observable'
},

autoStart: false,


pauseOnException: false,

current: -1,

total: 0,

isRunning: false,

isComplete: false,

hasException: false,

constructor: function(config) {
var me = this;



me.mixins.observable.constructor.call(me, config);

me.operations = [];


me.exceptions = [];
},

add: function(operation) {
this.total++;
operation.setBatch(this);
this.operations.push(operation);

return this;
},

start: function( index) {
var me = this;

if (me.isRunning) {
return me;
}

me.exceptions.length = 0;
me.hasException = false;
me.isRunning = true;
return me.runOperation(Ext.isDefined(index) ? index : me.current + 1);
},


retry: function() {
return this.start(this.current);
},

runNextOperation: function() {
return this.runOperation(this.current + 1);
},

pause: function() {
this.isRunning = false;
return this;
},

runOperation: function(index) {
var me = this,
operations = me.operations,
operation = operations[index],
onProxyReturn;
if (operation === undefined) {
me.isRunning = false;
me.isComplete = true;
me.fireEvent('complete', me, operations[operations.length - 1]);
} else {
me.current = index;
onProxyReturn = function(operation) {
var hasException = operation.hasException();
if (hasException) {
me.hasException = true;
me.exceptions.push(operation);
me.fireEvent('exception', me, operation);
}
if (hasException && me.pauseOnException) {
me.pause();
} else {
operation.setCompleted();
me.fireEvent('operationcomplete', me, operation);
me.runNextOperation();
}
};
operation.setStarted();
me.proxy[operation.action](operation, onProxyReturn, me);
}

return me;
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/data/proxy/Proxy.js */
(function(Ext) {
Ext.define('Ext.data.proxy.Proxy', {
alias: 'proxy.proxy',
alternateClassName: ['Ext.data.DataProxy', 'Ext.data.Proxy'],
requires: [
'Ext.data.reader.Json',
'Ext.data.writer.Json'
],
uses: [
'Ext.data.Batch',
'Ext.data.Operation',
'Ext.data.Model'
],
mixins: {
observable: 'Ext.util.Observable'
},

batchOrder: 'create,update,destroy',

batchActions: true,

defaultReaderType: 'json',

defaultWriterType: 'json',




isProxy: true,

isSynchronous: false,

constructor: function(config) {
var me = this;
config = config || {};
me.proxyConfig = config;
me.mixins.observable.constructor.call(me, config);
if (me.model !== undefined && !(me.model instanceof Ext.data.Model)) {
me.setModel(me.model);
} else {
if (me.reader) {
me.setReader(me.reader);
}

if (me.writer) {
me.setWriter(me.writer);
}
}

},

setModel: function(model, setOnStore) {
var me = this;

me.model = Ext.ModelManager.getModel(model);
me.setReader(this.reader);
me.setWriter(this.writer);
if (setOnStore && me.store) {
me.store.setModel(me.model);
}
},

getModel: function() {
return this.model;
},

setReader: function(reader) {
var me = this,
needsCopy = true,
current = me.reader;
if (reader === undefined || typeof reader == 'string') {
reader = {
type: reader
};
needsCopy = false;
}
if (reader.isReader) {
reader.setModel(me.model);
} else {
if (needsCopy) {
reader = Ext.apply({}, reader);
}
Ext.applyIf(reader, {
proxy: me,
model: me.model,
type : me.defaultReaderType
});
reader = Ext.createByAlias('reader.' + reader.type, reader);
}
if (reader !== current && reader.onMetaChange) {
reader.onMetaChange = Ext.Function.createSequence(reader.onMetaChange, this.onMetaChange, this);
}
me.reader = reader;
return me.reader;
},

getReader: function() {
return this.reader;
},

onMetaChange: function(meta) {
this.fireEvent('metachange', this, meta);
},

setWriter: function(writer) {
var me = this,
needsCopy = true;

if (writer === undefined || typeof writer == 'string') {
writer = {
type: writer
};
needsCopy = false;
}
if (!writer.isWriter) {
if (needsCopy) {
writer = Ext.apply({}, writer);
}
Ext.applyIf(writer, {
model: me.model,
type : me.defaultWriterType
});
writer = Ext.createByAlias('writer.' + writer.type, writer);
}
me.writer = writer;
return me.writer;
},

getWriter: function() {
return this.writer;
},

create: Ext.emptyFn,

read: Ext.emptyFn,

update: Ext.emptyFn,

destroy: Ext.emptyFn,

batch: function(options, listeners) {
var me = this,
useBatch = me.batchActions,
batch,
records,
actions, aLen, action, a, r, rLen, record;
if (options.operations === undefined) {
// the old-style (operations, listeners) signature was called
// so convert to the single options argument syntax
options = {
operations: options,
listeners: listeners
};
}
if (options.batch) {
if (Ext.isDefined(options.batch.runOperation)) {
batch = Ext.applyIf(options.batch, {
proxy: me,
listeners: {}
});
}
} else {
options.batch = {
proxy: me,
listeners: options.listeners || {}
};
}
if (!batch) {
batch = new Ext.data.Batch(options.batch);
}
batch.on('complete', Ext.bind(me.onBatchComplete, me, [options], 0));
actions = me.batchOrder.split(',');
aLen = actions.length;
for (a = 0; a < aLen; a++) {
action = actions[a];
records = options.operations[action];
if (records) {
if (useBatch) {
batch.add(new Ext.data.Operation({
action : action,
records : records
}));
} else {
rLen = records.length;
for (r = 0; r < rLen; r++) {
record = records[r];
batch.add(new Ext.data.Operation({
action : action,
records : [record]
}));
}
}
}
}
batch.start();
return batch;
},

onBatchComplete: function(batchOptions, batch) {
var scope = batchOptions.scope || this;
if (batch.hasException) {
if (Ext.isFunction(batchOptions.failure)) {
Ext.callback(batchOptions.failure, scope, [batch, batchOptions]);
}
} else if (Ext.isFunction(batchOptions.success)) {
Ext.callback(batchOptions.success, scope, [batch, batchOptions]);
}
if (Ext.isFunction(batchOptions.callback)) {
Ext.callback(batchOptions.callback, scope, [batch, batchOptions]);
}
},
clone: function() {
return new this.self(this.proxyConfig);
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/data/AbstractStore.js */
(function(Ext) {
Ext.define('Ext.data.AbstractStore', {
requires: [
'Ext.util.MixedCollection',
'Ext.data.proxy.Proxy',
'Ext.data.Operation',
'Ext.util.Filter'
],
mixins: {
observable: 'Ext.util.Observable',
sortable: 'Ext.util.Sortable'
},
statics: {

create: function(store) {
if (!store.isStore) {
if (!store.type) {
store.type = 'store';
}
store = Ext.createByAlias('store.' + store.type, store);
}
return store;
}
},
onClassExtended: function(cls, data, hooks) {
var model = data.model,
onBeforeClassCreated;
if (typeof model == 'string') {
onBeforeClassCreated = hooks.onBeforeCreated;
hooks.onBeforeCreated = function() {
var me = this,
args = arguments;
Ext.require(model, function() {
onBeforeClassCreated.apply(me, args);
});
};
}
},

remoteSort : false,

remoteFilter: false,


autoLoad: undefined,

autoSync: false,

batchUpdateMode: 'operation',

filterOnLoad: true,

sortOnLoad: true,

implicitModel: false,

defaultProxyType: 'memory',

isDestroyed: false,

isStore: true,





sortRoot: 'data',
//documented above
constructor: function(config) {
var me = this,
filters;













Ext.apply(me, config);
// don't use *config* anymore from here on... use *me* instead...

me.removed = [];
me.mixins.observable.constructor.apply(me, arguments);
// <debug>
var configModel = me.model;
// </debug>
me.model = Ext.ModelManager.getModel(me.model);

Ext.applyIf(me, {
modelDefaults: null
});
//Supports the 3.x style of simply passing an array of fields to the store, implicitly creating a model
if (!me.model && me.fields) {
me.model = Ext.define('Ext.data.Store.ImplicitModel-' + (me.storeId || Ext.id()), {
extend: 'Ext.data.Model',
fields: me.fields,
proxy: me.proxy || me.defaultProxyType
});
delete me.fields;
me.implicitModel = true;
}
// <debug>
if (!me.model && me.useModelWarning !== false) {
// There are a number of ways things could have gone wrong, try to give as much information as possible
var logMsg = [
Ext.getClassName(me) || 'Store',
' created with no model.'
];
if (typeof configModel === 'string') {
logMsg.push(" The name '", configModel, "'", ' does not correspond to a valid model.');
}
Ext.log.warn(logMsg.join(''));
}
// </debug>
//ensures that the Proxy is instantiated correctly
me.setProxy(me.proxy || me.model.getProxy());
if (!me.disableMetaChangeEvent) {
me.proxy.on('metachange', me.onMetaChange, me);
}
if (me.id && !me.storeId) {
me.storeId = me.id;
delete me.id;
}
if (me.storeId) {
Ext.data.StoreManager.register(me);
}
me.mixins.sortable.initSortable.call(me);

filters = me.decodeFilters(me.filters);
me.filters = new Ext.util.MixedCollection();
me.filters.addAll(filters);
},

setProxy: function(proxy) {
var me = this;
if (proxy instanceof Ext.data.proxy.Proxy) {
proxy.setModel(me.model);
} else {
if (Ext.isString(proxy)) {
proxy = {
type: proxy
};
}
Ext.applyIf(proxy, {
model: me.model
});
proxy = Ext.createByAlias('proxy.' + proxy.type, proxy);
}
me.proxy = proxy;
return me.proxy;
},

getProxy: function() {
return this.proxy;
},
// private
onMetaChange: function(proxy, meta) {
this.fireEvent('metachange', this, meta);
},
//saves any phantom records
create: function(data, options) {
var me = this,
instance = Ext.ModelManager.create(Ext.applyIf(data, me.modelDefaults), me.model.modelName),
operation;
options = options || {};
Ext.applyIf(options, {
action : 'create',
records: [instance]
});
operation = new Ext.data.Operation(options);
me.proxy.create(operation, me.onProxyWrite, me);
return instance;
},
read: function() {
return this.load.apply(this, arguments);
},
update: function(options) {
var me = this,
operation;
options = options || {};
Ext.applyIf(options, {
action : 'update',
records: me.getUpdatedRecords()
});
operation = new Ext.data.Operation(options);
return me.proxy.update(operation, me.onProxyWrite, me);
},

onProxyWrite: function(operation) {
var me = this,
success = operation.wasSuccessful(),
records = operation.getRecords();
switch (operation.action) {
case 'create':
me.onCreateRecords(records, operation, success);
break;
case 'update':
me.onUpdateRecords(records, operation, success);
break;
case 'destroy':
me.onDestroyRecords(records, operation, success);
break;
}
if (success) {
me.fireEvent('write', me, operation);
me.fireEvent('datachanged', me);
me.fireEvent('refresh', me);
}
//this is a callback that would have been passed to the 'create', 'update' or 'destroy' function and is optional
Ext.callback(operation.callback, operation.scope || me, [records, operation, success]);
},

// may be implemented by store subclasses
onCreateRecords: Ext.emptyFn,

// may be implemented by store subclasses
onUpdateRecords: Ext.emptyFn,


onDestroyRecords: function(records, operation, success) {
if (success) {
this.removed = [];
}
},
// tells the attached proxy to destroy the given records
// @since 3.4.0
destroy: function(options) {
var me = this,
operation;
options = options || {};
Ext.applyIf(options, {
action : 'destroy',
records: me.getRemovedRecords()
});
operation = new Ext.data.Operation(options);
return me.proxy.destroy(operation, me.onProxyWrite, me);
},

onBatchOperationComplete: function(batch, operation) {
return this.onProxyWrite(operation);
},

onBatchComplete: function(batch, operation) {
var me = this,
operations = batch.operations,
length = operations.length,
i;
me.suspendEvents();
for (i = 0; i < length; i++) {
me.onProxyWrite(operations[i]);
}
me.resumeEvents();
me.fireEvent('datachanged', me);
me.fireEvent('refresh', me);
},

onBatchException: function(batch, operation) {
// //decide what to do... could continue with the next operation
// batch.start();
//
// //or retry the last operation
// batch.retry();
},

filterNew: function(item) {
// only want phantom records that are valid
return item.phantom === true && item.isValid();
},

getNewRecords: function() {
return [];
},

getUpdatedRecords: function() {
return [];
},

getModifiedRecords : function(){
return [].concat(this.getNewRecords(), this.getUpdatedRecords());
},


filterUpdated: function(item) {
// only want dirty records, not phantoms that are valid
return item.dirty === true && item.phantom !== true && item.isValid();
},

getRemovedRecords: function() {
return this.removed;
},
filter: function(filters, value) {
},

decodeFilters: function(filters) {
if (!Ext.isArray(filters)) {
if (filters === undefined) {
filters = [];
} else {
filters = [filters];
}
}
var length = filters.length,
Filter = Ext.util.Filter,
config, i;
for (i = 0; i < length; i++) {
config = filters[i];
if (!(config instanceof Filter)) {
Ext.apply(config, {
root: 'data'
});
//support for 3.x style filters where a function can be defined as 'fn'
if (config.fn) {
config.filterFn = config.fn;
}
//support a function to be passed as a filter definition
if (typeof config == 'function') {
config = {
filterFn: config
};
}
filters[i] = new Filter(config);
}
}
return filters;
},
clearFilter: function(supressEvent) {
},
isFiltered: function() {
},
filterBy: function(fn, scope) {
},

sync: function(options) {
var me = this,
operations = {},
toCreate = me.getNewRecords(),
toUpdate = me.getUpdatedRecords(),
toDestroy = me.getRemovedRecords(),
needsSync = false;
if (toCreate.length > 0) {
operations.create = toCreate;
needsSync = true;
}
if (toUpdate.length > 0) {
operations.update = toUpdate;
needsSync = true;
}
if (toDestroy.length > 0) {
operations.destroy = toDestroy;
needsSync = true;
}
if (needsSync && me.fireEvent('beforesync', operations) !== false) {
options = options || {};
me.proxy.batch(Ext.apply(options, {
operations: operations,
listeners: me.getBatchListeners()
}));
}

return me;
},


getBatchListeners: function() {
var me = this,
listeners = {
scope: me,
exception: me.onBatchException
};
if (me.batchUpdateMode == 'operation') {
listeners.operationcomplete = me.onBatchOperationComplete;
} else {
listeners.complete = me.onBatchComplete;
}
return listeners;
},

save: function() {
return this.sync.apply(this, arguments);
},

load: function(options) {
var me = this,
operation;
options = Ext.apply({
action: 'read',
filters: me.filters.items,
sorters: me.getSorters()
}, options);
me.lastOptions = options;
operation = new Ext.data.Operation(options);
if (me.fireEvent('beforeload', me, operation) !== false) {
me.loading = true;
me.proxy.read(operation, me.onProxyLoad, me);
}
return me;
},

reload: function(options) {
return this.load(Ext.apply(this.lastOptions, options));
},

afterEdit : function(record, modifiedFieldNames) {
var me = this,
i, shouldSync;
if (me.autoSync && !me.autoSyncSuspended) {
for (i = modifiedFieldNames.length; i--;) {
// only sync if persistent fields were modified
if (record.fields.get(modifiedFieldNames[i]).persist) {
shouldSync = true;
break;
}
}
if (shouldSync) {
me.sync();
}
}
me.onUpdate(record, Ext.data.Model.EDIT, modifiedFieldNames);
me.fireEvent('update', me, record, Ext.data.Model.EDIT, modifiedFieldNames);
},

afterReject : function(record) {
// Must pass the 5th param (modifiedFieldNames) as null, otherwise the
// event firing machinery appends the listeners "options" object to the arg list
// which may get used as the modified fields array by a handler.
// This array is used for selective grid cell updating by Grid View.
// Null will be treated as though all cells need updating.
this.onUpdate(record, Ext.data.Model.REJECT, null);
this.fireEvent('update', this, record, Ext.data.Model.REJECT, null);
},

afterCommit : function(record, modifiedFieldNames) {
if (!modifiedFieldNames) {
modifiedFieldNames = null;
}
this.onUpdate(record, Ext.data.Model.COMMIT, modifiedFieldNames);
this.fireEvent('update', this, record, Ext.data.Model.COMMIT, modifiedFieldNames);
},
onUpdate: Ext.emptyFn,
onIdChanged: function(model, oldId, newId, oldInternalId){
this.fireEvent('idchanged', this, model, oldId, newId, oldInternalId);
},
// private
destroyStore: function() {
var implicitModelName,
me = this;
if (!me.isDestroyed) {
me.clearListeners();
if (me.storeId) {
Ext.data.StoreManager.unregister(me);
}
me.clearData();
me.data = me.tree = me.sorters = me.filters = me.groupers = null;
if (me.reader) {
me.reader.destroyReader();
}
me.proxy = me.reader = me.writer = null;
me.isDestroyed = true;
if (me.implicitModel) {
implicitModelName = Ext.getClassName(me.model);
Ext.undefine(implicitModelName);
Ext.ModelManager.unregisterType(implicitModelName);
} else {
me.model = null;
}
}
},


getState: function() {
var me = this,
hasState,
result,
hasGroupers = !!me.groupers,
groupers = [],
sorters = [],
filters = [];
if (hasGroupers) {
me.groupers.each(function(g) {
groupers[groupers.length] = g.serialize();
hasState = true;
});
}
if (me.sorters) {
// Create sorters config array.
me.sorters.each(function(s) {
// Sorters collection gets groupers prepended to it, so do not duplicate
if (hasGroupers && !me.groupers.contains(s)) {
sorters[sorters.length] = s.serialize();
hasState = true;
}
});
}
// Because we do not provide a filter changing mechanism, only statify the filters if they opt in.
// Otherwise filters would get "stuck".
if (me.filters && me.statefulFilters) {
me.filters.each(function(f) {
filters[filters.length] = f.serialize();
hasState = true;
});
}
// If there is any state to save, return it as an object
if (hasState) {
result = {};
if (groupers.length) {
result.groupers = groupers;
}
if (sorters.length) {
result.sorters = sorters;
}
if (filters.length) {
result.filters = filters;
}
return result;
}
},

applyState: function(state) {
var me = this,
hasSorters = !!me.sorters,
hasGroupers = !!me.groupers,
hasFilters = !!me.filters,
locallySorted;
if (hasGroupers && state.groupers) {
me.groupers.clear();
me.groupers.addAll(me.decodeGroupers(state.groupers));
}
if (hasSorters && state.sorters) {
me.sorters.clear();
me.sorters.addAll(me.decodeSorters(state.sorters));
}
if (hasFilters && state.filters) {
me.filters.clear();
me.filters.addAll(me.decodeFilters(state.filters));
}
if (hasSorters && hasGroupers) {
// Sorters collection gets groupers prepended to it
me.sorters.insert(0, me.groupers.getRange());
}
// Data manipulated by the server - reload 
if (me.autoLoad && (me.remoteSort || me.remoteGroup || me.remoteFilter)) {
if (me.autoLoad === true) {
me.reload();
} else {
me.reload(me.autoLoad);
}
}
// If we have local filters, filter the data
if (hasFilters && me.filters.length && !me.remoteFilter) {
me.filter();
locallySorted = me.sortOnFilter;
}
// If we have local sorters, and the data is not already sorted by a sortOnFilter operation, then sort.
if (hasSorters && me.sorters.length && !me.remoteSort && !locallySorted) {
me.sort();
}
},
// private
doSort: function(sorterFn) {
var me = this;
if (me.remoteSort) {
//the load function will pick up the new sorters and request the sorted data from the proxy
me.load();
} else {
me.data.sortBy(sorterFn);
me.fireEvent('datachanged', me);
me.fireEvent('refresh', me);
}
me.fireEvent('sort', me, me.sorters.getRange());
},
// to be implemented by subclasses
clearData: Ext.emptyFn,

// to be implemented by subclasses
getCount: Ext.emptyFn,
// to be implemented by subclasses
getById: Ext.emptyFn,

removeAll: Ext.emptyFn,
// individual store subclasses should implement a "fast" remove
// and fire a clear event afterwards

isLoading: function() {
return !!this.loading;
},

suspendAutoSync: function() {
this.autoSyncSuspended = true;
},

resumeAutoSync: function() {
this.autoSyncSuspended = false;
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/data/proxy/Server.js */
(function(Ext) {
Ext.define('Ext.data.proxy.Server', {
extend: 'Ext.data.proxy.Proxy',
alias : 'proxy.server',
alternateClassName: 'Ext.data.ServerProxy',
uses : ['Ext.data.Request'],


pageParam: 'page',

startParam: 'start',

limitParam: 'limit',

groupParam: 'group',

groupDirectionParam: 'groupDir',

sortParam: 'sort',

filterParam: 'filter',

directionParam: 'dir',

idParam: 'id',

simpleSortMode: false,

simpleGroupMode: false,

noCache : true,

cacheString: "_dc",

timeout : 30000,

constructor: function(config) {
var me = this;
config = config || {};

me.callParent([config]);

me.extraParams = config.extraParams || {};
me.api = Ext.apply({}, config.api || me.api);

//backwards compatibility, will be deprecated in 5.0
me.nocache = me.noCache;
},
//in a ServerProxy all four CRUD operations are executed in the same manner, so we delegate to doRequest in each case
create: function() {
return this.doRequest.apply(this, arguments);
},
read: function() {
return this.doRequest.apply(this, arguments);
},
update: function() {
return this.doRequest.apply(this, arguments);
},
destroy: function() {
return this.doRequest.apply(this, arguments);
},

setExtraParam: function(name, value) {
this.extraParams[name] = value;
},

buildRequest: function(operation) {
var me = this,
// Clone params right now so that they can be mutated at any point further down the call stack
params = operation.params = Ext.apply({}, operation.params, me.extraParams),
request;
//copy any sorters, filters etc into the params so they can be sent over the wire
Ext.applyIf(params, me.getParams(operation));
// Set up the entity id parameter according to the configured name.
// This defaults to "id". But TreeStore has a "nodeParam" configuration which
// specifies the id parameter name of the node being loaded.
if (operation.id !== undefined && params[me.idParam] === undefined) {
params[me.idParam] = operation.id;
}
request = new Ext.data.Request({
params : params,
action : operation.action,
records : operation.records,
operation: operation,
url : operation.url,
// this is needed by JsonSimlet in order to properly construct responses for
// requests from this proxy
proxy: me
});
request.url = me.buildUrl(request);

operation.request = request;
return request;
},
// Should this be documented as protected method?
processResponse: function(success, operation, request, response, callback, scope) {
var me = this,
reader,
result;
if (success === true) {
reader = me.getReader();
// Apply defaults to incoming data only for read operations.
// For create and update, there will already be a client-side record
// to match with which will contain any defaulted in values.
reader.applyDefaults = operation.action === 'read';
result = reader.read(me.extractResponseData(response));
if (result.success !== false) {
//see comment in buildRequest for why we include the response object here
Ext.apply(operation, {
response: response,
resultSet: result
});
operation.commitRecords(result.records);
operation.setCompleted();
operation.setSuccessful();
} else {
operation.setException(result.message);
me.fireEvent('exception', this, response, operation);
}
} else {
me.setException(operation, response);
me.fireEvent('exception', this, response, operation);
}
//this callback is the one that was passed to the 'read' or 'write' function above
if (typeof callback == 'function') {
callback.call(scope || me, operation);
}
me.afterRequest(request, success);
},

setException: function(operation, response) {
operation.setException({
status: response.status,
statusText: response.statusText
});
},

extractResponseData: Ext.identityFn,

applyEncoding: function(value) {
return Ext.encode(value);
},

encodeSorters: function(sorters) {
var min = [],
length = sorters.length,
i = 0;
for (; i < length; i++) {
min[i] = {
property : sorters[i].property,
direction: sorters[i].direction
};
}
return this.applyEncoding(min);
},

encodeFilters: function(filters) {
var min = [],
length = filters.length,
i = 0;
for (; i < length; i++) {
min[i] = {
property: filters[i].property,
value : filters[i].value
};
}
return this.applyEncoding(min);
},

getParams: function(operation) {
var me = this,
params = {},
isDef = Ext.isDefined,
groupers = operation.groupers,
sorters = operation.sorters,
filters = operation.filters,
page = operation.page,
start = operation.start,
limit = operation.limit,
simpleSortMode = me.simpleSortMode,
simpleGroupMode = me.simpleGroupMode,
pageParam = me.pageParam,
startParam = me.startParam,
limitParam = me.limitParam,
groupParam = me.groupParam,
groupDirectionParam = me.groupDirectionParam,
sortParam = me.sortParam,
filterParam = me.filterParam,
directionParam = me.directionParam,
hasGroups, index;
if (pageParam && isDef(page)) {
params[pageParam] = page;
}
if (startParam && isDef(start)) {
params[startParam] = start;
}
if (limitParam && isDef(limit)) {
params[limitParam] = limit;
}
hasGroups = groupParam && groupers && groupers.length > 0;
if (hasGroups) {
// Grouper is a subclass of sorter, so we can just use the sorter method
if (simpleGroupMode) {
params[groupParam] = groupers[0].property;
params[groupDirectionParam] = groupers[0].direction || 'ASC';
} else {
params[groupParam] = me.encodeSorters(groupers);
}
}
if (sortParam && sorters && sorters.length > 0) {
if (simpleSortMode) {
index = 0;
// Group will be included in sorters, so grab the next one
if (sorters.length > 1 && hasGroups) {
index = 1;
}
params[sortParam] = sorters[index].property;
params[directionParam] = sorters[index].direction;
} else {
params[sortParam] = me.encodeSorters(sorters);
}
}
if (filterParam && filters && filters.length > 0) {
params[filterParam] = me.encodeFilters(filters);
}
return params;
},

buildUrl: function(request) {
var me = this,
url = me.getUrl(request);
//<debug>
if (!url) {
Ext.Error.raise("You are using a ServerProxy but have not supplied it with a url.");
}
//</debug>
if (me.noCache) {
url = Ext.urlAppend(url, Ext.String.format("{0}={1}", me.cacheString, Ext.Date.now()));
}
return url;
},

getUrl: function(request) {
return request.url || this.api[request.action] || this.url;
},

doRequest: function(operation, callback, scope) {
//<debug>
Ext.Error.raise("The doRequest function has not been implemented on your Ext.data.proxy.Server subclass. See src/data/ServerProxy.js for details");
//</debug>
},

afterRequest: Ext.emptyFn,
onDestroy: function() {
Ext.destroy(this.reader, this.writer);
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/data/proxy/Ajax.js */
(function(Ext) {
Ext.define('Ext.data.proxy.Ajax', {
requires: ['Ext.util.MixedCollection', 'Ext.Ajax'],
extend: 'Ext.data.proxy.Server',
alias: 'proxy.ajax',
alternateClassName: ['Ext.data.HttpProxy', 'Ext.data.AjaxProxy'],


actionMethods: {
create : 'POST',
read : 'GET',
update : 'POST',
destroy: 'POST'
},

binary: false,



doRequest: function(operation, callback, scope) {
var writer = this.getWriter(),
request = this.buildRequest(operation);

if (operation.allowWrite()) {
request = writer.write(request);
}

Ext.apply(request, {
binary : this.binary,
headers : this.headers,
timeout : this.timeout,
scope : this,
callback : this.createRequestCallback(request, operation, callback, scope),
method : this.getMethod(request),
disableCaching: false // explicitly set it to false, ServerProxy handles caching
});

Ext.Ajax.request(request);

return request;
},


getMethod: function(request) {
return this.actionMethods[request.action];
},


createRequestCallback: function(request, operation, callback, scope) {
var me = this;

return function(options, success, response) {
me.processResponse(success, operation, request, response, callback, scope);
};
}
}, function() {
//backwards compatibility, remove in Ext JS 5.0
Ext.data.HttpProxy = this;
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/data/proxy/Client.js */
(function(Ext) {
Ext.define('Ext.data.proxy.Client', {
extend: 'Ext.data.proxy.Proxy',
alternateClassName: 'Ext.data.ClientProxy',


isSynchronous: true,

clear: function() {
//<debug>
Ext.Error.raise("The Ext.data.proxy.Client subclass that you are using has not defined a 'clear' function. See src/data/ClientProxy.js for details.");
//</debug>
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/data/proxy/Memory.js */
(function(Ext) {
Ext.define('Ext.data.proxy.Memory', {
extend: 'Ext.data.proxy.Client',
alias: 'proxy.memory',
alternateClassName: 'Ext.data.MemoryProxy',


constructor: function(config) {
this.callParent([config]);
//ensures that the reader has been instantiated properly
this.setReader(this.reader);
},


updateOperation: function(operation, callback, scope) {
var i = 0,
recs = operation.getRecords(),
len = recs.length;

for (i; i < len; i++) {
recs[i].commit();
}
operation.setCompleted();
operation.setSuccessful();

Ext.callback(callback, scope || this, [operation]);
},


create: function() {
this.updateOperation.apply(this, arguments);
},


update: function() {
this.updateOperation.apply(this, arguments);
},


destroy: function() {
this.updateOperation.apply(this, arguments);
},

read: function(operation, callback, scope) {
var me = this,
resultSet = operation.resultSet = me.getReader().read(me.data),
records = resultSet.records,
sorters = operation.sorters,
groupers = operation.groupers,
filters = operation.filters;
operation.setCompleted();
// Apply filters, sorters, and start/limit options
if (resultSet.success) {
// Filter the resulting array of records
if (filters && filters.length) {
records = resultSet.records = Ext.Array.filter(records, Ext.util.Filter.createFilterFn(filters));
}
// Remotely, groupers just mean top priority sorters
if (groupers && groupers.length) {
// Must concat so as not to mutate passed sorters array which could be the items property of the sorters collection
sorters = sorters ? sorters.concat(groupers) : sorters;
}
// Sort by the specified groupers and sorters
if (sorters && sorters.length) {
resultSet.records = Ext.Array.sort(records, Ext.util.Sortable.createComparator(sorters));
}
// Reader reads the whole passed data object.
// If successful and we were given a start and limit, slice the result.
if (me.enablePaging && operation.start !== undefined && operation.limit !== undefined) {
// Attempt to read past end of memory dataset - convert to failure
if (operation.start >= resultSet.total) {
resultSet.success = false;
resultSet.count = 0;
resultSet.records = [];
}
// Range is valid, slice it up.
else {
resultSet.records = Ext.Array.slice(resultSet.records, operation.start, operation.start + operation.limit);
resultSet.count = resultSet.records.length;
}
}
}
if (resultSet.success) {
operation.setSuccessful();
} else {
me.fireEvent('exception', me, null, operation);
}
Ext.callback(callback, scope || me, [operation]);
},
clear: Ext.emptyFn
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/util/LruCache.js */
(function(Ext) {
Ext.define('Ext.util.LruCache', {
extend: 'Ext.util.HashMap',

constructor: function(config) {
Ext.apply(this, config);
this.callParent([config]);
},

add: function(key, newValue) {
var me = this,
existingKey = me.findKey(newValue),
entry;
// "new" value is in the list.
if (existingKey) {
me.unlinkEntry(entry = me.map[existingKey]);
entry.prev = me.last;
entry.next = null;
}
// Genuinely new: create an entry for it.
else {
entry = {
prev: me.last,
next: null,
key: key,
value: newValue
};
}
// If the list is not empty, update the last entry
if (me.last) {
me.last.next = entry;
}
// List is empty
else {
me.first = entry;
}
me.last = entry;
me.callParent([key, entry]);
me.prune();
return newValue;
},
// @private
insertBefore: function(key, newValue, sibling) {
var me = this,
existingKey,
entry;
// NOT an assignment.
// If there is a following sibling
if (sibling = this.map[this.findKey(sibling)]) {
existingKey = me.findKey(newValue);
// "new" value is in the list.
if (existingKey) {
me.unlinkEntry(entry = me.map[existingKey]);
}
// Genuinely new: create an entry for it.
else {
entry = {
prev: sibling.prev,
next: sibling,
key: key,
value: newValue
};
}
if (sibling.prev) {
entry.prev.next = entry;
} else {
me.first = entry;
}
entry.next = sibling;
sibling.prev = entry;
me.prune();
return newValue;
}
// No following sibling, it's just an add.
else {
return me.add(key, newValue);
}
},

get: function(key) {
var entry = this.map[key];
if (entry) {
// If it's not the end, move to end of list on get
if (entry.next) {
this.moveToEnd(entry);
}
return entry.value;
}
},

removeAtKey: function(key) {
this.unlinkEntry(this.map[key]);
return this.callParent(arguments);
},

clear: function( initial) {
this.first = this.last = null;
return this.callParent(arguments);
},
// private. Only used by internal methods.
unlinkEntry: function(entry) {
// Stitch the list back up.
if (entry) {
if (entry.next) {
entry.next.prev = entry.prev;
} else {
this.last = entry.prev;
}
if (entry.prev) {
entry.prev.next = entry.next;
} else {
this.first = entry.next;
}
entry.prev = entry.next = null;
}
},
// private. Only used by internal methods.
moveToEnd: function(entry) {
this.unlinkEntry(entry);
// NOT an assignment.
// If the list is not empty, update the last entry
if (entry.prev = this.last) {
this.last.next = entry;
}
// List is empty
else {
this.first = entry;
}
this.last = entry;
},

getArray: function(isKey) {
var arr = [],
entry = this.first;
while (entry) {
arr.push(isKey ? entry.key: entry.value);
entry = entry.next;
}
return arr;
},

each: function(fn, scope, reverse) {
var me = this,
entry = reverse ? me.last : me.first,
length = me.length;
scope = scope || me;
while (entry) {
if (fn.call(scope, entry.key, entry.value, length) === false) {
break;
}
entry = reverse ? entry.prev : entry.next;
}
return me;
},

findKey: function(value) {
var key,
map = this.map;
for (key in map) {
// Attention. Differs from subclass in that this compares the value property
// of the entry.
if (map.hasOwnProperty(key) && map[key].value === value) {
return key;
}
}
return undefined;
},

clone: function() {
var newCache = new this.self(this.initialConfig),
map = this.map,
key;
newCache.suspendEvents();
for (key in map) {
if (map.hasOwnProperty(key)) {
newCache.add(key, map[key].value);
}
}
newCache.resumeEvents();
return newCache;
},

prune: function() {
var me = this,
purgeCount = me.maxSize ? (me.length - me.maxSize) : 0;
if (purgeCount > 0) {
for (; me.first && purgeCount; purgeCount--) {
me.removeAtKey(me.first.key);
}
}
}




});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/data/PageMap.js */
(function(Ext) {
Ext.define('Ext.data.PageMap', {
extend: 'Ext.util.LruCache',
// Maintain a generation counter, so that the Store can reject incoming pages destined for the previous generation
clear: function(initial) {
var me = this;
me.pageMapGeneration = (me.pageMapGeneration || 0) + 1;
me.callParent(arguments);
},
forEach: function(fn, scope) {
var me = this,
pageNumbers = Ext.Object.getKeys(me.map),
pageCount = pageNumbers.length,
i, j,
pageNumber,
page,
pageSize;
for (i = 0; i < pageCount; i++) {
pageNumbers[i] = Number(pageNumbers[i]);
}
Ext.Array.sort(pageNumbers);
scope = scope || me;
for (i = 0; i < pageCount; i++) {
pageNumber = pageNumbers[i];
page = me.getPage(pageNumber);
pageSize = page.length;
for (j = 0; j < pageSize; j++) {
if (fn.call(scope, page[j], (pageNumber - 1) * me.pageSize + j) === false) {
return;
}
}
}
},

findBy: function(fn, scope) {
var me = this,
result = null;
scope = scope || me;
me.forEach(function(rec, index) {
if (fn.call(scope, rec, index)) {
result = rec;
return false;
}
});
return result;
},

findIndexBy: function(fn, scope) {
var me = this,
result = -1;
scope = scope || me;
me.forEach(function(rec, index) {
if (fn.call(scope, rec)) {
result = index;
return false;
}
});
return result;
},
getPageFromRecordIndex: function() {
return Ext.data.Store.prototype.getPageFromRecordIndex.apply(this, arguments);
},
addAll: function(records) {
//<debug>
if (this.getCount()) {
Ext.Error.raise('Cannot addAll to a non-empty PageMap');
}
//</debug>
this.addPage(1, records);
},
addPage: function(pageNumber, records) {
var me = this,
lastPage = pageNumber + Math.floor((records.length - 1) / me.pageSize),
startIdx,
page;
// Account for being handed a block of records spanning several pages.
// This can happen when loading from a MemoryProxy before a viewSize has been determined.
for (startIdx = 0; pageNumber <= lastPage; pageNumber++, startIdx += me.pageSize) {
page = Ext.Array.slice(records, startIdx, startIdx + me.pageSize);
me.add(pageNumber, page);
me.fireEvent('pageAdded', pageNumber, page);
}
},
getCount: function() {
var result = this.callParent();
if (result) {
result = (result - 1) * this.pageSize + this.last.value.length;
}
return result;
},
indexOf: function(record) {
return record ? record.index : -1;
},
insert: function() {
//<debug>
Ext.Error.raise('insert operation not suppported into buffered Store');
//</debug>
},
remove: function() {
//<debug>
Ext.Error.raise('remove operation not suppported from buffered Store');
//</debug>
},
removeAt: function() {
//<debug>
Ext.Error.raise('removeAt operation not suppported from buffered Store');
//</debug>
},
getPage: function(pageNumber) {
return this.get(pageNumber);
},
hasRange: function(start, end) {
var pageNumber = this.getPageFromRecordIndex(start),
endPageNumber = this.getPageFromRecordIndex(end);
for (; pageNumber <= endPageNumber; pageNumber++) {
if (!this.hasPage(pageNumber)) {
return false;
}
}
return true;
},
hasPage: function(pageNumber) {
// We must use this.get to trigger an access so that the page which is checked for presence is not eligible for pruning
return !!this.get(pageNumber);
},
getAt: function(index) {
return this.getRange(index, index)[0];
},
getRange: function(start, end) {
if (!this.hasRange(start, end)) {
Ext.Error.raise('PageMap asked for range which it does not have');
}
var me = this,
startPageNumber = me.getPageFromRecordIndex(start),
endPageNumber = me.getPageFromRecordIndex(end),
dataStart = (startPageNumber - 1) * me.pageSize,
dataEnd = (endPageNumber * me.pageSize) - 1,
pageNumber = startPageNumber,
result = [],
sliceBegin, sliceEnd, doSlice,
i = 0, len;
for (; pageNumber <= endPageNumber; pageNumber++) {
// First and last pages will need slicing to cut into the actual wanted records
if (pageNumber == startPageNumber) {
sliceBegin = start - dataStart;
doSlice = true;
} else {
sliceBegin = 0;
doSlice = false;
}
if (pageNumber == endPageNumber) {
sliceEnd = me.pageSize - (dataEnd - end);
doSlice = true;
}
// First and last pages will need slicing
if (doSlice) {
Ext.Array.push(result, Ext.Array.slice(me.getPage(pageNumber), sliceBegin, sliceEnd));
} else {
Ext.Array.push(result, me.getPage(pageNumber));
}
}
// Inject the dataset ordinal position into the record as the index
for (len = result.length; i < len; i++) {
result[i].index = start++;
}
return result;
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/data/Group.js */
(function(Ext) {
Ext.define('Ext.data.Group', {
extend: 'Ext.util.Observable',
key: undefined,
dirty: true,
constructor: function(){
this.callParent(arguments);
this.records = []; 
},
contains: function(record){
return Ext.Array.indexOf(this.records, record) !== -1;
},
add: function(records) {
Ext.Array.push(this.records, records);
this.dirty = true; 
},
remove: function(records) {
if (!Ext.isArray(records)) {
records = [records];
}
var len = records.length,
i;
for (i = 0; i < len; ++i) {
Ext.Array.remove(this.records, records[i]);
}
this.dirty = true;
},
isDirty: function(){
return this.dirty; 
},
hasAggregate: function(){
return !!this.aggregate;
},
setDirty: function(){
this.dirty = true;
},
commit: function(){
this.dirty = false;
},
isCollapsed: function(){
return this.collapsed; 
},
getAggregateRecord: function(forceNew){
var me = this,
Model;
if (forceNew === true || me.dirty || !me.aggregate) {
Model = me.store.model;
me.aggregate = new Model();
me.aggregate.isSummary = true;
}
return me.aggregate;
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/util/Grouper.js */
(function(Ext) {

Ext.define('Ext.util.Grouper', {

extend: 'Ext.util.Sorter',


isGrouper: true,

getGroupString: function(instance) {
return instance.get(this.property);
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/data/Store.js */
(function(Ext) {
Ext.define('Ext.data.Store', {
extend: 'Ext.data.AbstractStore',
alias: 'store.store',
// Required classes must be loaded before the definition callback runs
// The class definition callback creates a dummy Store which requires that
// all the classes below have been loaded.
requires: [
'Ext.data.StoreManager',
'Ext.data.Model',
'Ext.data.proxy.Ajax',
'Ext.data.proxy.Memory',
'Ext.data.reader.Json',
'Ext.data.writer.Json',
'Ext.data.PageMap',
'Ext.data.Group'
],
uses: [
'Ext.ModelManager',
'Ext.util.Grouper'
],

remoteSort: false,

remoteFilter: false,

remoteGroup : false,




groupField: undefined,

groupDir: "ASC",

trailingBufferZone: 25,

leadingBufferZone: 200,

pageSize: undefined,

currentPage: 1,

clearOnPageLoad: true,

loading: false,

sortOnFilter: true,

buffered: false,

purgePageCount: 5,

clearRemovedOnLoad: true,
defaultPageSize: 25,
// Number of records to load into a buffered grid before it has been bound to a view of known size
defaultViewSize: 100,
// Private. Used as parameter to loadRecords
addRecordsOptions: {
addRecords: true
},
statics: {
recordIdFn: function(record) {
return record.internalId;
},
recordIndexFn: function(record) {
return record.index;
},
grouperIdFn: function(grouper) {
return grouper.id || grouper.property;
},
groupIdFn: function(group) {
return group.key;
}
},

constructor: function(config) {
// Clone the config so we don't modify the original config object
config = Ext.apply({}, config);
var me = this,
groupers = config.groupers || me.groupers,
groupField = config.groupField || me.groupField,
proxy,
data;




data = config.data || me.data;
if (data) {
me.inlineData = data;
delete config.data;
}
if (!groupers && groupField) {
groupers = [{
property : groupField,
direction: config.groupDir || me.groupDir
}];

// Allow a custom getGroupString implementation to prevail
if (config.getGroupString || (me.getGroupString !== Ext.data.Store.prototype.getGroupString)) {
groupers[0].getGroupString = function(record) {
return me.getGroupString(record);
}
}
}
delete config.groupers;

me.groupers = new Ext.util.MixedCollection(false, Ext.data.Store.grouperIdFn);
me.groupers.addAll(me.decodeGroupers(groupers));
me.groups = new Ext.util.MixedCollection(false, Ext.data.Store.groupIdFn);
// AbstractStore.constructor initializes the sorters collection
me.callParent([config]);
// don't use *config* anymore from here on... use *me* instead...
if (me.buffered) {
me.data = new Ext.data.PageMap({
store: me,
keyFn: Ext.data.Store.recordIdFn,
pageSize: me.pageSize,
maxSize: me.purgePageCount,
listeners: {
// Whenever PageMap gets cleared, it means we re no longer interested in 
// any outstanding page prefetches, so cancel tham all
clear: me.onPageMapClear,
scope: me
}
});
me.pageRequests = {};
// Sorting, grouping and filtering may only be remote for buffered stores.
me.remoteSort = me.remoteGroup = me.remoteFilter = true;
me.sortOnLoad = false;
me.filterOnLoad = false;
} else {

me.data = new Ext.util.MixedCollection({
getKey: Ext.data.Store.recordIdFn,
maintainIndices: true
});
me.data.pageSize = me.pageSize;
}
// Only sort by group fields if we are doing local grouping
if (me.remoteGroup) {
me.remoteSort = true;
}
// Keep sorters updated with prepended groupers so that subsequent adds work
me.sorters.insert(0, me.groupers.getRange());
proxy = me.proxy;
data = me.inlineData;
// Page size for non-buffered Store defaults to 25
// For a buffered Store, the default page size is taken from the initial call to prefetch.
if (!me.buffered && !me.pageSize) {
me.pageSize = me.defaultPageSize;
}
// Load inline data
if (data) {
if (proxy instanceof Ext.data.proxy.Memory) {
proxy.data = data;
me.read();
} else {
me.add.apply(me, [data]);
}

// If there are sorters (These will include any groupers by this stage) and we are sorting locally,
// then call group. This will sort, and create groups only if this store has groupers.
if (me.sorters.items.length && !me.remoteSort) {
me.group(null, null, true);
}
delete me.inlineData;
}
else if (me.autoLoad) {
// Defer the load until after the current event handler has finished and set up any associated views.
Ext.defer(me.load, 1, me, [ typeof me.autoLoad === 'object' ? me.autoLoad : undefined ]);
}
},
onBeforeSort: function() {
var groupers = this.groupers;
if (groupers.getCount() > 0) {
this.sort(groupers.items, 'prepend', false);
}
},

decodeGroupers: function(groupers) {
if (!Ext.isArray(groupers)) {
if (groupers === undefined) {
groupers = [];
} else {
groupers = [groupers];
}
}
var length = groupers.length,
Grouper = Ext.util.Grouper,
config, i, result = [];
for (i = 0; i < length; i++) {
config = groupers[i];
if (!(config instanceof Grouper)) {
if (Ext.isString(config)) {
config = {
property: config
};
}
config = Ext.apply({
root : 'data',
direction: "ASC"
}, config);
//support for 3.x style sorters where a function can be defined as 'fn'
if (config.fn) {
config.sorterFn = config.fn;
}
//support a function to be passed as a sorter definition
if (typeof config == 'function') {
config = {
sorterFn: config
};
}
// return resulting Groupers in a separate array so as not to mutate passed in data objects.
result.push(new Grouper(config));
} else {
result.push(config);
}
}
return result;
},

group: function(groupers, direction, suppressEvent) {
var me = this,
grouper,
newGroupers;
// If we were passed groupers, we replace the existing groupers in the sorter collection with the new ones
if (groupers) {
// remove existing groupers from the sorter set
me.sorters.removeAll(me.groupers.items);
if (Ext.isArray(groupers)) {
newGroupers = groupers;
} else if (Ext.isObject(groupers)) {
newGroupers = [groupers];
} else if (Ext.isString(groupers)) {
grouper = me.groupers.get(groupers);
if (!grouper) {
grouper = {
property : groupers,
direction: direction || 'ASC'
};
newGroupers = [grouper];
} else if (direction === undefined) {
grouper.toggle();
} else {
grouper.setDirection(direction);
}
}
// If we were passed groupers, replace our grouper collection
if (newGroupers && newGroupers.length) {
me.groupers.clear();
me.groupers.addAll(me.decodeGroupers(newGroupers));
}
// Groupers are prepended into sorter set
me.sorters.insert(0, me.groupers.items);
}
if (me.remoteGroup) {
if (me.buffered) {
me.data.clear();
me.loadPage(1, { groupChange: true });
} else {
me.load({
scope: me,
callback: suppressEvent ? null : me.fireGroupChange
});
}
} else {
me.doSort(me.generateComparator());
me.constructGroups();
if (!suppressEvent) {
me.fireGroupChange();
}
}
},
getGroupField: function(){
var first = this.groupers.first(),
group;
if (first) {
group = first.property;
} 
return group; 
},
constructGroups: function(){
var me = this,
data = this.data.items,
len = data.length,
groups = me.groups,
groupValue, i, group, rec;
groups.clear();
if (me.isGrouped()) {
for (i = 0; i < len; ++i) {
rec = data[i];
groupValue = me.getGroupString(rec);
group = groups.get(groupValue);
if (!group) {
group = new Ext.data.Group({
key: groupValue,
store: me
});
groups.add(groupValue, group);
}
group.add(rec);
}
}
},

clearGrouping: function() {
var me = this,
groupers = me.groupers.items,
gLen = groupers.length,
g;
// Trim groupers out of the sorter set
for (g = 0; g < gLen; g++) {
me.sorters.remove(groupers[g]);
}
me.groupers.clear();
if (me.remoteGroup) {
if (me.buffered) {
me.data.clear();
me.loadPage(1, { groupChange: true });
} else {
me.load({
scope: me,
callback: me.fireGroupChange
});
}
} else {
me.groups.clear();
if (me.sorters.length) {
me.sort();
} else {
me.fireEvent('datachanged', me);
me.fireEvent('refresh', me);
}
me.fireGroupChange();
}
},

isGrouped: function() {
return this.groupers.getCount() > 0;
},

fireGroupChange: function() {
this.fireEvent('groupchange', this, this.groupers);
},

getGroups: function(requestGroupString) {
var records = this.data.items,
length = records.length,
groups = [],
pointers = {},
record,
groupStr,
group,
i;
for (i = 0; i < length; i++) {
record = records[i];
groupStr = this.getGroupString(record);
group = pointers[groupStr];
if (group === undefined) {
group = {
name: groupStr,
children: []
};
groups.push(group);
pointers[groupStr] = group;
}
group.children.push(record);
}
return requestGroupString ? pointers[requestGroupString] : groups;
},

getGroupsForGrouper: function(records, grouper) {
var length = records.length,
groups = [],
oldValue,
newValue,
record,
group,
i;
for (i = 0; i < length; i++) {
record = records[i];
newValue = grouper.getGroupString(record);
if (newValue !== oldValue) {
group = {
name: newValue,
grouper: grouper,
records: []
};
groups.push(group);
}
group.records.push(record);
oldValue = newValue;
}
return groups;
},

getGroupsForGrouperIndex: function(records, grouperIndex) {
var me = this,
groupers = me.groupers,
grouper = groupers.getAt(grouperIndex),
groups = me.getGroupsForGrouper(records, grouper),
length = groups.length,
i;
if (grouperIndex + 1 < groupers.length) {
for (i = 0; i < length; i++) {
groups[i].children = me.getGroupsForGrouperIndex(groups[i].records, grouperIndex + 1);
}
}
for (i = 0; i < length; i++) {
groups[i].depth = grouperIndex;
}
return groups;
},

getGroupData: function(sort) {
var me = this;
if (sort !== false) {
me.sort();
}
return me.getGroupsForGrouperIndex(me.data.items, 0);
},

getGroupString: function(instance) {
var group = this.groupers.first();
if (group) {
return group.getGroupString(instance);
}
return '';
},

insert: function(index, records) {
var me = this,
sync = false,
i, len, record,
defaults = me.modelDefaults,
out;
// isIterable allows an argument list of multiple records to be passed unchanged (from add)
if (!Ext.isIterable(records)) {
out = records = [records];
} else {
out = [];
}
len = records.length;
if (len) {
for (i = 0; i < len; i++) {
record = records[i];
if (!record.isModel) {
record = me.createModel(record);
}
out[i] = record;
if (defaults) {
record.set(defaults);
}
record.join(me);
sync = sync || record.phantom === true;
}
// Add records to data in one shot
me.data.insert(index, out);
if (me.snapshot) {
me.snapshot.addAll(out);
}
if (me.requireSort) {
// suspend events so the usual data changed events don't get fired.
me.suspendEvents();
me.sort();
me.resumeEvents();
}
if (me.isGrouped()) {
me.updateGroupsOnAdd(out);
}
me.fireEvent('add', me, out, index);
me.fireEvent('datachanged', me);
if (me.autoSync && sync && !me.autoSyncSuspended) {
me.sync();
}
}
return out;
},
updateGroupsOnAdd: function(records) {
var me = this,
groups = me.groups,
len = records.length,
i, groupName, group, rec;
for (i = 0; i < len; ++i) {
rec = records[i];
groupName = me.getGroupString(rec);
group = groups.getByKey(groupName);
if (!group) {
group = groups.add(new Ext.data.Group({
key: groupName,
store: me
}));
}
group.add(rec);
}
},
updateGroupsOnRemove: function(records) {
var me = this,
groups = me.groups,
len = records.length,
i, groupName, group, rec;
for (i = 0; i < len; ++i) {
rec = records[i];
groupName = me.getGroupString(rec);
group = groups.getByKey(groupName);
if (group) {
group.remove(rec);
if (group.records.length === 0) {
groups.remove(group);
} 
}
}
},
updateGroupsOnUpdate: function(record, modifiedFieldNames){
var me = this,
groupField = me.getGroupField(),
groupName = me.getGroupString(record),
groups = me.groups,
len, i, items, group;
if (modifiedFieldNames && Ext.Array.indexOf(modifiedFieldNames, groupField) !== -1) {
// Sorting is remote for buffered stores, we cannot update a field which is a sort key
if (me.buffered) {
Ext.Error.raise({
msg: 'Cannot move records between groups in a buffered store record'
});
}
// First find the old group and remove the record
items = groups.items;
for (i = 0, len = items.length; i < len; ++i) {
group = items[i];
if (group.contains(record)) {
group.remove(record);
break;
}
}
group = groups.getByKey(groupName);
if (!group) {
group = groups.add(new Ext.data.Group({
key: groupName,
store: me
}));
}
group.add(record);
// At this point we know that we're sorted, so re-insert the record.
// Without adding to the "removed" list or firing events!
me.data.remove(record);
me.data.insert(me.data.findInsertionIndex(record, me.generateComparator()), record);
// Keep subsequent indices up to date
for (i = 0, len = this.getCount(); i < len; i++) {
me.data.items[i].index = i;
}
} else {
// some other field changed, just mark the group as dirty
groups.getByKey(groupName).setDirty(); 
}
},

add: function(arg) {
var me = this,
records,
length, isSorted;
//<debug>
if (me.buffered) {
Ext.Error.raise({
msg: 'add method may not be called on a buffered store'
});
}
//</debug>
// Accept both a single-argument array of records, or any number of record arguments
if (Ext.isArray(arg)) {
records = arg;
} else {
records = arguments;
}
length = records.length;
isSorted = !me.remoteSort && me.sorters && me.sorters.items.length;
// If this Store is sorted, and they only passed one Record (99% or use cases)
// then it's much more efficient to add it sorted than to append and then sort.
if (isSorted && length === 1) {
return [ me.addSorted(me.createModel(records[0])) ];
}
// If this sort is sorted, set the flag used by the insert method to sort
// before firing events.
if (isSorted) {
me.requireSort = true;
}
records = me.insert(me.data.length, records);
delete me.requireSort;
return records;
},

addSorted: function(record) {
var me = this,
index = me.data.findInsertionIndex(record, me.generateComparator());
me.insert(index, record);
return record;
},

createModel: function(record) {
if (!record.isModel) {
record = Ext.ModelManager.create(record, this.model);
}
return record;
},
onUpdate: function(record, type, modifiedFieldNames){
if (this.isGrouped()) {
this.updateGroupsOnUpdate(record, modifiedFieldNames);
}
},

each: function(fn, scope) {
var data = this.data.items,
dLen = data.length,
record, d;
for (d = 0; d < dLen; d++) {
record = data[d];
if (fn.call(scope || record, record, d, dLen) === false) {
break;
}
}
},

remove: function(records, isMove, silent) {

isMove = isMove === true;
var me = this,
sync = false,
snapshot = me.snapshot,
data = me.data,
i = 0,
length,
info = [],
allRecords = [],
indexes = [],
item,
isNotPhantom,
index,
record,
removeRange,
removeCount,
fireRemoveEvent = !silent && me.hasListeners.remove;
// Remove a single record
if (records.isModel) {
records = [records];
length = 1;
}
// Or remove(myRecord)
else if (Ext.isIterable(records)) {
length = records.length;
}
// Allow remove({start:100: end: 110})
// Private API used by removeAt to remove multiple, contiguous records
else if (typeof records === 'object') {
removeRange = true;
i = records.start;
length = records.end + 1;
removeCount = length - i;
}
// Build an array of {record: rec, index: idx} objects to sort into index order.
// Not necessary if we are removing a contiguous range
if (!removeRange) {
for (i = 0; i < length; ++i) {
record = records[i];
// Encountered a record index
if (typeof record == 'number') {
index = record;
record = data.getAt(index);
}
// Removing a record instance
else {
index = me.indexOf(record);
}
// Check record. If number passed, it may not exist.
if (record && index > -1) {
info.push({
record: record,
index: index
});
}
// record guaranteed to be a record now
if (snapshot) {
snapshot.remove(record);
}
}
// Sort records into ascending order so that removalscan be processed in a deterministic order
info = Ext.Array.sort(info, function(o1, o2) {
var index1 = o1.index,
index2 = o2.index;
return index1 === o2.index2 ? 0 : (index1 < index2 ? -1 : 1);
});
// The loop below loops through the info array if not removing contiguous range
i = 0;
length = info.length;
}
// we need to maintain a set of indexes since we're not guaranteed to
// be removing the records in order
// Start value of i is calculated!
for (; i < length; i++) {
if (removeRange) {
record = data.getAt(i);
index = i;
} else {
item = info[i];
record = item.record;
index = item.index;
}
allRecords.push(record);
indexes.push(index);
isNotPhantom = record.phantom !== true;
// don't push phantom records onto removed
if (!isMove && isNotPhantom) {
// Store the index the record was removed from so that rejectChanges can re-insert at the correct place.
// The record's index property won't do, as that is the index in the overall dataset when Store is buffered.
record.removedFrom = index;
me.removed.push(record);
}
record.unjoin(me);
// Remove using the index, but subtract any intervening removed records which would cause the data
// array to shuffle up.
index -= i;
sync = sync || isNotPhantom;
// If we have not been asked to remove a range we must remove individual records
// and fire the individual remove event..
if (!removeRange) {
data.removeAt(index);
// Only fire individual remove events if not silent, and there are listeners.
if (fireRemoveEvent) {
me.fireEvent('remove', me, record, index, !!isMove);
}
}
}
// If there was no listener for the single remove event, remove all records
// from collection in one call
if (removeRange) {
data.removeRange(records.start, removeCount);
}
if (!silent) {
me.fireEvent('bulkremove', me, allRecords, indexes, !!isMove);
me.fireEvent('datachanged', me);
}
if (!isMove && me.autoSync && sync && !me.autoSyncSuspended) {
me.sync();
}
},

removeAt: function(index, count) {
var me = this,
storeCount = me.getCount();
if (index <= storeCount) {
if (arguments.length === 1) {
me.remove([ index ]);
} else if (count) {
me.remove({
start: index,
end: Math.min(index + count, storeCount) - 1
});
}
}
},

removeAll: function(silent) {
var me = this,
snapshot = me.snapshot,
data = me.data;

if (snapshot) {
snapshot.removeAll(data.getRange());
}
if (me.buffered) {
if (data) {
if (silent) {
me.suspendEvent('clear');
}
data.clear();
if (silent) {
me.resumeEvent('clear');
}
} 
}
else {
// Use the remove range interface to remove the entire record set, passing the silent flag to mute the bulkremove event.
// The remove range interface does not fire individual remove events.
me.remove({
start: 0,
end: me.getCount() - 1
}, false, silent);
if (silent !== true) {
me.fireEvent('clear', me);
}
}
},

load: function(options) {
var me = this;
options = options || {};
if (typeof options == 'function') {
options = {
callback: options
};
}
options.groupers = options.groupers || me.groupers.items;
options.page = options.page || me.currentPage;
options.start = (options.start !== undefined) ? options.start : (options.page - 1) * me.pageSize;
options.limit = options.limit || me.pageSize;
options.addRecords = options.addRecords || false;
if (me.buffered) {
options.limit = me.viewSize || me.defaultViewSize;
return me.loadToPrefetch(options);
}
return me.callParent([options]);
},
reload: function(options) {
var me = this,
startIdx,
endIdx,
startPage,
endPage,
i,
waitForReload,
bufferZone,
records,
count = me.getCount();
if (!options) {
options = {};
}
// If buffered, we have to clear the page cache and then
// cache the page range surrounding store's loaded range.
if (me.buffered) {
// So that prefetchPage does not consider the store to be fully loaded if the local count is equal to the total count
delete me.totalCount;
waitForReload = function() {
if (me.rangeCached(startIdx, endIdx)) {
me.loading = false;
me.data.un('pageAdded', waitForReload);
records = me.data.getRange(startIdx, endIdx);
me.fireEvent('load', me, records, true);
}
};
bufferZone = Math.ceil((me.leadingBufferZone + me.trailingBufferZone) / 2);
// Get our record index range in the dataset
startIdx = options.start || (count ? me.getAt(0).index : 0);
endIdx = startIdx + (options.count || (count ? count : me.pageSize)) - 1;
// Calculate a page range which encompasses the Store's loaded range plus both buffer zones
startPage = me.getPageFromRecordIndex(Math.max(startIdx - bufferZone, 0));
endPage = me.getPageFromRecordIndex(endIdx + bufferZone);
// Clear cache (with initial flag so that any listening BufferedRenderer does not reset to page 1).
me.data.clear(true);
if (me.fireEvent('beforeload', me, options) !== false) {
me.loading = true;
// Wait for the requested range to become available in the page map
// Load the range as soon as the whole range is available
me.data.on('pageAdded', waitForReload);
// Recache the page range which encapsulates our visible records
for (i = startPage; i <= endPage; i++) {
me.prefetchPage(i, options);
}
}
} else {
return me.callParent(arguments);
}
},

onProxyLoad: function(operation) {
var me = this,
resultSet = operation.getResultSet(),
records = operation.getRecords(),
successful = operation.wasSuccessful();
if (me.isDestroyed) {
return;
}

if (resultSet) {
me.totalCount = resultSet.total;
}
// Loading should be set to false before loading the records.
// loadRecords doesn't expose any hooks or events until refresh
// and datachanged, so by that time loading should be false
me.loading = false;
if (successful) {
me.loadRecords(records, operation);
}
if (me.hasListeners.load) {
me.fireEvent('load', me, records, successful);
}
//TODO: deprecate this event, it should always have been 'load' instead. 'load' is now documented, 'read' is not.
//People are definitely using this so can't deprecate safely until 2.x
if (me.hasListeners.read) {
me.fireEvent('read', me, records, successful);
}
//this is a callback that would have been passed to the 'read' function and is optional
Ext.callback(operation.callback, operation.scope || me, [records, operation, successful]);
},
//inherit docs
getNewRecords: function() {
return this.data.filterBy(this.filterNew).items;
},
//inherit docs
getUpdatedRecords: function() {
return this.data.filterBy(this.filterUpdated).items;
},

filter: function(filters, value) {
if (Ext.isString(filters)) {
filters = {
property: filters,
value: value
};
}
var me = this,
decoded = me.decodeFilters(filters),
i,
doLocalSort = me.sorters.length && me.sortOnFilter && !me.remoteSort,
length = decoded.length;
// Merge new filters into current filter set.
for (i = 0; i < length; i++) {
me.filters.replace(decoded[i]);
}
filters = me.filters.items;
// If there are filters, filter the data.
// This method can not cut a filter set down to zero, it can only add or replace,
// so if there are no filters, the store is not filtered, and they did not pass a filter.
if (filters.length) {
if (me.remoteFilter) {
// So that prefetchPage does not consider the store to be fully loaded if the local count is equal to the total count
delete me.totalCount;
// For a buffered Store, we have to clear the prefetch cache because the dataset will change upon filtering.
// Then we must prefetch the new page 1, and when that arrives, reload the visible part of the Store
// via the guaranteedrange event
if (me.buffered) {
me.data.clear();
me.loadPage(1);
} else {
// Reset to the first page, the filter is likely to produce a smaller data set
me.currentPage = 1;
//the load function will pick up the new filters and request the filtered data from the proxy
me.load();
}
} else {

me.snapshot = me.snapshot || me.data.clone();
// Filter the unfiltered dataset using the filter set
me.data = me.snapshot.filter(filters);
// Groups will change when filters change
me.constructGroups();
if (doLocalSort) {
me.sort();
} else {
// fire datachanged event if it hasn't already been fired by doSort
me.fireEvent('datachanged', me);
me.fireEvent('refresh', me);
}
}
me.fireEvent('filterchange', me, filters);
}
},

clearFilter: function(suppressEvent) {
var me = this;
me.filters.clear();
if (me.remoteFilter) {
// In a buffered Store, the meaning of suppressEvent is to simply clear the filters collection
if (suppressEvent) {
return;
}
// So that prefetchPage does not consider the store to be fully loaded if the local count is equal to the total count
delete me.totalCount;
// For a buffered Store, we have to clear the prefetch cache because the dataset will change upon filtering.
// Then we must prefetch the new page 1, and when that arrives, reload the visible part of the Store
// via the guaranteedrange event
if (me.buffered) {
me.data.clear();
me.loadPage(1);
} else {
// Reset to the first page, clearing a filter will destroy the context of the current dataset
me.currentPage = 1;
me.load();
}
} else if (me.isFiltered()) {
me.data = me.snapshot;
delete me.snapshot;
// Groups will change when filters change
me.constructGroups();
if (suppressEvent !== true) {
me.fireEvent('datachanged', me);
me.fireEvent('refresh', me);
}
}
me.fireEvent('filterchange', me, me.filters.items);
},

removeFilter: function(toRemove, applyFilters) {
var me = this;
if (!me.remoteFilter && me.isFiltered()) {
if (toRemove instanceof Ext.util.Filter) {
me.filters.remove(toRemove);
} else {
me.filters.removeAtKey(toRemove);
}
if (applyFilters !== false) {
// Not gone down to zero filters - re-filter Store
if (me.filters.length) {
me.filter();
}
// No filters left - let clearFilter do its thing.
else {
me.clearFilter();
}
} else {
me.fireEvent('filterchange', me, me.filters.items);
}
}
},

addFilter: function(filters, applyFilters) {
var me = this,
decoded,
i,
length;
// Decode passed filters and replace/add into the filter set
decoded = me.decodeFilters(filters);
length = decoded.length;
for (i = 0; i < length; i++) {
me.filters.replace(decoded[i]);
}
if (applyFilters !== false && me.filters.length) {
me.filter();
} else {
me.fireEvent('filterchange', me, me.filters.items);
}
},

isFiltered: function() {
var snapshot = this.snapshot;
return !!(snapshot && snapshot !== this.data);
},

filterBy: function(fn, scope) {
var me = this;
me.snapshot = me.snapshot || me.data.clone();
me.data = me.queryBy(fn, scope || me);
me.fireEvent('datachanged', me);
me.fireEvent('refresh', me);
},

queryBy: function(fn, scope) {
var me = this;
return (me.snapshot || me.data).filterBy(fn, scope || me);
},

query: function(property, value, anyMatch, caseSensitive, exactMatch) {
var me = this,
queryFn = me.createFilterFn(property, value, anyMatch, caseSensitive, exactMatch),
results = me.queryBy(queryFn);
//create an empty mixed collection for use if queryBy returns null
if(!results) {
results = new Ext.util.MixedCollection();
}
return results;
},

loadData: function(data, append) {
var length = data.length,
newData = [],
i;
//make sure each data element is an Ext.data.Model instance
for (i = 0; i < length; i++) {
newData.push(this.createModel(data[i]));
}
this.loadRecords(newData, append ? this.addRecordsOptions : undefined);
},

loadRawData : function(data, append) {
var me = this,
result = me.proxy.reader.read(data),
records = result.records;
if (result.success) {
me.totalCount = result.total;
me.loadRecords(records, append ? me.addRecordsOptions : undefined);
}
},

loadRecords: function(records, options) {
var me = this,
i = 0,
length = records.length,
start,
addRecords,
snapshot = me.snapshot;
if (options) {
start = options.start;
addRecords = options.addRecords;
}
if (!addRecords) {
delete me.snapshot;
me.clearData(true);
} else if (snapshot) {
snapshot.addAll(records);
}
me.data.addAll(records);
if (start !== undefined) {
for (; i < length; i++) {
records[i].index = start + i;
records[i].join(me);
}
} else {
for (; i < length; i++) {
records[i].join(me);
}
}

me.suspendEvents();
if (me.filterOnLoad && !me.remoteFilter) {
me.filter();
}
if (me.sortOnLoad && !me.remoteSort) {
me.sort(undefined, undefined, undefined, true);
}
me.resumeEvents();
if (me.isGrouped()) {
me.constructGroups();
}
me.fireEvent('datachanged', me);
me.fireEvent('refresh', me);
},
// PAGING METHODS

loadPage: function(page, options) {
var me = this;
me.currentPage = page;
// Copy options into a new object so as not to mutate passed in objects
options = Ext.apply({
page: page,
start: (page - 1) * me.pageSize,
limit: me.pageSize,
addRecords: !me.clearOnPageLoad
}, options);
if (me.buffered) {
options.limit = me.viewSize || me.defaultViewSize;
return me.loadToPrefetch(options);
}
me.read(options);
},

nextPage: function(options) {
this.loadPage(this.currentPage + 1, options);
},

previousPage: function(options) {
this.loadPage(this.currentPage - 1, options);
},
// private
clearData: function(isLoad) {
var me = this,
records,
i;
// We only have to do the unjoining if not buffered. PageMap will unjoin its records when it clears itself.
// There is a potential for a race condition in stores configured with autoDestroy: true;
// if loading was initiated but didn't complete by the time the store is destroyed,
// the data MC may not have been created yet so we have to check for its existence
// here and below.
if (!me.buffered && me.data) {
records = me.data.items;
i = records.length;
while (i--) {
records[i].unjoin(me);
}
}
// Remove all data from the Collection/PageMap. PageMap will perform unjoining.
if (me.data) {
me.data.clear();
}

if (isLoad !== true || me.clearRemovedOnLoad) {
me.removed.length = 0;
}
},
loadToPrefetch: function(options) {
var me = this,
i,
records,
dataSetSize,
prefetchOptions = options,
// Get the requested record index range in the dataset
startIdx = options.start,
endIdx = options.start + options.limit - 1,
// The end index to load into the store's live record collection
loadEndIdx = Math.min(endIdx, options.start + (me.viewSize || options.limit) - 1),
// Calculate a page range which encompasses the requested range plus both buffer zones.
// The endPage will be adjusted to be in the dataset size range as soon as the first data block returns.
startPage = me.getPageFromRecordIndex(Math.max(startIdx - me.trailingBufferZone, 0)),
endPage = me.getPageFromRecordIndex(endIdx + me.leadingBufferZone),
// Wait for the viewable range to be available
waitForRequestedRange = function() {
if (me.rangeCached(startIdx, loadEndIdx)) {
me.loading = false;
records = me.data.getRange(startIdx, loadEndIdx);
me.data.un('pageAdded', waitForRequestedRange);
// If there is a listener for guranteedrange then fire that event
if (me.hasListeners.guaranteedrange) {
me.guaranteeRange(startIdx, loadEndIdx, options.callback, options.scope);
}
if (options.callback) {
options.callback.call(options.scope||me, records, startIdx, endIdx, options);
}
me.fireEvent('datachanged', me);
me.fireEvent('refresh', me);
me.fireEvent('load', me, records, true);
if (options.groupChange) {
me.fireGroupChange();
}
}
};
if (me.fireEvent('beforeload', me, options) !== false) {
// So that prefetchPage does not consider the store to be fully loaded if the local count is equal to the total count
delete me.totalCount;
me.loading = true;
// Any configured callback is handled in waitForRequestedRange above.
// It should not be processed by onProxyPrefetch.
if (options.callback) {
prefetchOptions = Ext.apply({}, options);
delete prefetchOptions.callback;
}
// Load the first page in the range, which will give us the initial total count.
// Once it is loaded, go ahead and prefetch any subsequent pages, if necessary.
// The prefetchPage has a check to prevent us loading more than the totalCount,
// so we don't want to blindly load up <n> pages where it isn't required. 
me.on('prefetch', function(store, records, successful, operation) {
if (successful) {
// If there is data in the dataset, we can go ahead and add the pageAdded listener which waits for the visible range
// and we can also issue the requests to fill the surrounding buffer zones.
if ((dataSetSize = me.getTotalCount())) {
// Wait for the requested range to become available in the page map
me.data.on('pageAdded', waitForRequestedRange);
// As soon as we have the size of the dataset, ensure we are not waiting for more than can ever arrive,
loadEndIdx = Math.min(loadEndIdx, dataSetSize - 1);
// And make sure we never ask for pages beyond the end of the dataset.
endPage = me.getPageFromRecordIndex(Math.min(loadEndIdx + me.leadingBufferZone, dataSetSize - 1));
for (i = startPage + 1; i <= endPage; ++i) {
me.prefetchPage(i, prefetchOptions);
}
} else {
me.fireEvent('datachanged', me);
me.fireEvent('refresh', me);
me.fireEvent('load', me, records, true);
}
}
// Unsuccessful prefetch: fire a load event with success false.
else {
me.fireEvent('load', me, records, false);
}
}, null, {single: true});
me.prefetchPage(startPage, prefetchOptions);
}
},
// Buffering

prefetch: function(options) {
var me = this,
pageSize = me.pageSize,
proxy,
operation;
// Check pageSize has not been tampered with. That would break page caching
if (pageSize) {
if (me.lastPageSize && pageSize != me.lastPageSize) {
Ext.Error.raise("pageSize cannot be dynamically altered");
}
if (!me.data.pageSize) {
me.data.pageSize = pageSize;
}
}
// Allow first prefetch call to imply the required page size.
else {
me.pageSize = me.data.pageSize = pageSize = options.limit;
}
// So that we can check for tampering next time through
me.lastPageSize = pageSize;
// Always get whole pages.
if (!options.page) {
options.page = me.getPageFromRecordIndex(options.start);
options.start = (options.page - 1) * pageSize;
options.limit = Math.ceil(options.limit / pageSize) * pageSize;
}
// Currently not requesting this page, then request it...
if (!me.pageRequests[options.page]) {
// Copy options into a new object so as not to mutate passed in objects
options = Ext.apply({
action : 'read',
filters: me.filters.items,
sorters: me.sorters.items,
groupers: me.groupers.items,
// Generation # of the page map to which the requested records belong.
// If page map is cleared while this request is in flight, the pageMapGeneration will increment and the payload will be rejected
pageMapGeneration: me.data.pageMapGeneration
}, options);
operation = new Ext.data.Operation(options);
if (me.fireEvent('beforeprefetch', me, operation) !== false) {
proxy = me.proxy;
me.pageRequests[options.page] = proxy.read(operation, me.onProxyPrefetch, me);
if (proxy.isSynchronous) {
delete me.pageRequests[options.page];
}
}
}
return me;
},

onPageMapClear: function() {
var me = this,
loadingFlag = me.wasLoading,
reqs = me.pageRequests,
req,
page;
// If any requests return, we no longer respond to them.
if (me.data.events.pageadded) {
me.data.events.pageadded.clearListeners();
}
// If the page cache gets cleared it's because a full reload is in progress.
// Setting the loading flag prevents linked Views from displaying the empty text
// during a load... we don't know whether ther dataset is empty or not.
me.loading = true;
me.totalCount = 0;
// Cancel all outstanding requests
for (page in reqs) {
if (reqs.hasOwnProperty(page)) {
req = reqs[page];
delete reqs[page];
delete req.callback;
}
}
// This will update any views. 
me.fireEvent('clear', me);
// Restore loading flag. The beforeload event could still veto the process.
// The flag does not get set for real until we pass the beforeload event.
me.loading = loadingFlag;
},

prefetchPage: function(page, options) {
var me = this,
pageSize = me.pageSize || me.defaultPageSize,
start = (page - 1) * me.pageSize,
total = me.totalCount;
// No more data to prefetch.
if (total !== undefined && me.getCount() === total) {
return;
}
// Copy options into a new object so as not to mutate passed in objects
me.prefetch(Ext.applyIf({
page : page,
start : start,
limit : pageSize
}, options));
},

onProxyPrefetch: function(operation) {
var me = this,
resultSet = operation.getResultSet(),
records = operation.getRecords(),
successful = operation.wasSuccessful(),
page = operation.page;
// Only cache the data if the operation was invoked for the current pageMapGeneration.
// If the pageMapGeneration has changed since the request was fired off, it will have been cancelled.
if (operation.pageMapGeneration === me.data.pageMapGeneration) {
if (resultSet) {
me.totalCount = resultSet.total;
me.fireEvent('totalcountchange', me.totalCount);
}
// Remove the loaded page from the outstanding pages hash
if (page !== undefined) {
delete me.pageRequests[page];
}
// Prefetch is broadcast before the page is cached
me.loading = false;
me.fireEvent('prefetch', me, records, successful, operation);
// Add the page into the page map.
// pageAdded event may trigger the onGuaranteedRange
if (successful) {
me.cachePage(records, operation.page);
}
//this is a callback that would have been passed to the 'read' function and is optional
Ext.callback(operation.callback, operation.scope || me, [records, operation, successful]);
}
},

cachePage: function(records, page) {
var me = this,
len = records.length, i;
if (!Ext.isDefined(me.totalCount)) {
me.totalCount = records.length;
me.fireEvent('totalcountchange', me.totalCount);
}
// Add the fetched page into the pageCache
for (i = 0; i < len; i++) {
records[i].join(me);
}
me.data.addPage(page, records);
},

rangeCached: function(start, end) {
return this.data && this.data.hasRange(start, end);
},

pageCached: function(page) {
return this.data && this.data.hasPage(page);
},


pagePending: function(page) {
return !!this.pageRequests[page];
},

rangeSatisfied: function(start, end) {
return this.rangeCached(start, end);
},

getPageFromRecordIndex: function(index) {
return Math.floor(index / this.pageSize) + 1;
},

onGuaranteedRange: function(options) {
var me = this,
totalCount = me.getTotalCount(),
start = options.prefetchStart,
end = (options.prefetchEnd > totalCount - 1) ? totalCount - 1 : options.prefetchEnd,
range;
end = Math.max(0, end);
//<debug>
if (start > end) {
Ext.log({
level: 'warn',
msg: 'Start (' + start + ') was greater than end (' + end +
') for the range of records requested (' + start + '-' +
options.prefetchEnd + ')' + (this.storeId ? ' from store "' + this.storeId + '"' : '')
});
}
//</debug>
range = me.data.getRange(start, end);
if (options.fireEvent !== false) {
me.fireEvent('guaranteedrange', range, start, end, options);
}
if (options.callback) {
options.callback.call(options.scope || me, range, start, end, options);
}
},

guaranteeRange: function(start, end, callback, scope, options) {
options = Ext.apply({
callback: callback,
scope: scope
}, options);
this.getRange(start, end, options)
},

prefetchRange: function(start, end) {
var me = this,
startPage, endPage, page;
if (!me.rangeCached(start, end)) {
startPage = me.getPageFromRecordIndex(start);
endPage = me.getPageFromRecordIndex(end);
// Ensure that the page cache's max size is correct.
// Our purgePageCount is the number of additional pages *outside of the required range* which
// may be kept in the cache. A purgePageCount of zero means unlimited.
me.data.maxSize = me.purgePageCount ? (endPage - startPage + 1) + me.purgePageCount : 0;
// We have the range, but ensure that we have a "buffer" of pages around it.
for (page = startPage; page <= endPage; page++) {
if (!me.pageCached(page)) {
me.prefetchPage(page);
}
}
}
},
primeCache: function(start, end, direction) {
var me = this;
// Scrolling up
if (direction === -1) {
start = Math.max(start - me.leadingBufferZone, 0);
end = Math.min(end + me.trailingBufferZone, me.totalCount - 1);
}
// Scrolling down
else if (direction === 1) {
start = Math.max(Math.min(start - me.trailingBufferZone, me.totalCount - me.pageSize), 0);
end = Math.min(end + me.leadingBufferZone, me.totalCount - 1);
}
// Teleporting
else {
start = Math.min(Math.max(Math.floor(start - ((me.leadingBufferZone + me.trailingBufferZone) / 2)), 0), me.totalCount - me.pageSize);
end = Math.min(Math.max(Math.ceil (end + ((me.leadingBufferZone + me.trailingBufferZone) / 2)), 0), me.totalCount - 1);
}
me.prefetchRange(start, end);
},
// because prefetchData is stored by index
// this invalidates all of the prefetchedData
sort: function() {
var me = this;
if (me.buffered && me.remoteSort) {
me.data.clear();
}
return me.callParent(arguments);
},
// overriden to provide striping of the indexes as sorting occurs.
// this cannot be done inside of sort because datachanged has already
// fired and will trigger a repaint of the bound view.
doSort: function(sorterFn) {
var me = this,
range,
ln,
i;
if (me.remoteSort) {
// For a buffered Store, we have to clear the prefetch cache since it is keyed by the index within the dataset.
// Then we must prefetch the new page 1, and when that arrives, reload the visible part of the Store
// via the guaranteedrange event
if (me.buffered) {
me.data.clear();
me.loadPage(1);
} else {
//the load function will pick up the new sorters and request the sorted data from the proxy
me.load();
}
} else {
//<debug>
if (me.buffered) {
Ext.Error.raise({
msg: 'Local sorting may not be used on a buffered store'
});
}
//</debug>
me.data.sortBy(sorterFn);
if (!me.buffered) {
range = me.getRange();
ln = range.length;
for (i = 0; i < ln; i++) {
range[i].index = i;
}
}
me.fireEvent('datachanged', me);
me.fireEvent('refresh', me);
}
},

find: function(property, value, start, anyMatch, caseSensitive, exactMatch) {
var fn = this.createFilterFn(property, value, anyMatch, caseSensitive, exactMatch);
return fn ? this.data.findIndexBy(fn, null, start) : -1;
},

findRecord: function() {
var me = this,
index = me.find.apply(me, arguments);
return index !== -1 ? me.getAt(index) : null;
},

createFilterFn: function(property, value, anyMatch, caseSensitive, exactMatch) {
if (Ext.isEmpty(value)) {
return false;
}
value = this.data.createValueMatcher(value, anyMatch, caseSensitive, exactMatch);
return function(r) {
return value.test(r.data[property]);
};
},

findExact: function(property, value, start) {
return this.data.findIndexBy(function(rec) {
return rec.isEqual(rec.get(property), value);
},
this, start);
},

findBy: function(fn, scope, start) {
return this.data.findIndexBy(fn, scope, start);
},

collect: function(dataIndex, allowNull, bypassFilter) {
var me = this,
data = (bypassFilter === true && me.snapshot) ? me.snapshot : me.data;
return data.collect(dataIndex, 'data', allowNull);
},

getCount: function() {
return this.data.getCount();
},

getTotalCount: function() {
return this.totalCount || 0;
},

getAt: function(index) {
return this.data.getAt(index);
},

getRange: function(start, end, options) {
//<debug>
if (options && options.cb) {
options.callback = options.cb;
Ext.Error.raise({
msg: 'guaranteeRange options.cb is deprecated, use options.callback'
});
}
//</debug>
var me = this,
requiredStart,
requiredEnd,
maxIndex = me.totalCount - 1,
lastRequestStart = me.lastRequestStart,
pageAddHandler,
result;
options = Ext.apply({
prefetchStart: start,
prefetchEnd: end
}, options);
if (me.buffered) {
// Sanity check end point to be within dataset range
end = (end >= me.totalCount) ? maxIndex : end;
// We must wait for a slightly wider range to be cached.
// This is to allow grouping features to peek at the two surrounding records
// when rendering a *range* of records to see whether the start of the range
// really is a group start and the end of the range really is a group end.
requiredStart = start === 0 ? 0 : start - 1;
requiredEnd = end === maxIndex ? end : end + 1;
// Keep track of range we are being asked for so we can track direction of movement through the dataset
me.lastRequestStart = start;
// If data request can be satisfied from the page cache
if (me.rangeCached(requiredStart, requiredEnd)) {
me.onGuaranteedRange(options);
result = me.data.getRange(start, end);
}
// At least some of the requested range needs loading from server
else {
// Private event used by the LoadMask class to perform masking when the range required for rendering is not found in the cache
me.fireEvent('cachemiss', me, start, end);
// Add a pageAdded listener, and as soon as the requested range is loaded, fire the guaranteedrange event
pageAddHandler = function(page, records) {
if (me.rangeCached(requiredStart, requiredEnd)) {
// Private event used by the LoadMask class to unmask when the range required for rendering has been loaded into the cache
me.fireEvent('cachefilled', me, start, end);
me.data.un('pageAdded', pageAddHandler);
me.onGuaranteedRange(options);
}
};
me.data.on('pageAdded', pageAddHandler);
// Prioritize the request for the *exact range that the UI is asking for*.
// When a page request is in flight, it will not be requested again by checking the me.pageRequests hash,
// so the request after this will only request the *remaining* unrequested pages .
me.prefetchRange(start, end);
}
// Load the pages around the requested range required by the leadingBufferZone and trailingBufferZone.
me.primeCache(start, end, start < lastRequestStart ? -1 : 1);
} else {
result = me.data.getRange(start, end);
// Someone *may* use the callback interface to process their results even if the store is not buffered and always synchronous
if (options.callback) {
options.callback.call(options.scope || me, result, start, end, options)
}
}
return result;
},

getById: function(id) {
var result = (this.snapshot || this.data).findBy(function(record) {
return record.getId() === id;
});
//<debug>
if (this.buffered && !result) {
Ext.Error.raise('getById called for ID that is not present in local cache');
}
//</debug>
return result;
},

indexOf: function(record) {
return this.data.indexOf(record);
},

indexOfTotal: function(record) {
var index = record.index;
if (index || index === 0) {
return index;
}
return this.indexOf(record);
},

indexOfId: function(id) {
return this.indexOf(this.getById(id));
},


first: function(grouped) {
var me = this;
if (grouped && me.isGrouped()) {
return me.aggregate(function(records) {
return records.length ? records[0] : undefined;
}, me, true);
} else {
return me.data.first();
}
},

last: function(grouped) {
var me = this;
if (grouped && me.isGrouped()) {
return me.aggregate(function(records) {
var len = records.length;
return len ? records[len - 1] : undefined;
}, me, true);
} else {
return me.data.last();
}
},

sum: function(field, grouped) {
var me = this;
if (grouped && me.isGrouped()) {
return me.aggregate(me.getSum, me, true, [field]);
} else {
return me.getSum(me.data.items, field);
}
},
// @private, see sum
getSum: function(records, field) {
var total = 0,
i = 0,
len = records.length;
for (; i < len; ++i) {
total += records[i].get(field);
}
return total;
},

count: function(grouped) {
var me = this;
if (grouped && me.isGrouped()) {
return me.aggregate(function(records) {
return records.length;
}, me, true);
} else {
return me.getCount();
}
},

min: function(field, grouped) {
var me = this;
if (grouped && me.isGrouped()) {
return me.aggregate(me.getMin, me, true, [field]);
} else {
return me.getMin(me.data.items, field);
}
},
// @private, see min
getMin: function(records, field) {
var i = 1,
len = records.length,
value, min;
if (len > 0) {
min = records[0].get(field);
}
for (; i < len; ++i) {
value = records[i].get(field);
if (value < min) {
min = value;
}
}
return min;
},

max: function(field, grouped) {
var me = this;
if (grouped && me.isGrouped()) {
return me.aggregate(me.getMax, me, true, [field]);
} else {
return me.getMax(me.data.items, field);
}
},
// @private, see max
getMax: function(records, field) {
var i = 1,
len = records.length,
value,
max;
if (len > 0) {
max = records[0].get(field);
}
for (; i < len; ++i) {
value = records[i].get(field);
if (value > max) {
max = value;
}
}
return max;
},

average: function(field, grouped) {
var me = this;
if (grouped && me.isGrouped()) {
return me.aggregate(me.getAverage, me, true, [field]);
} else {
return me.getAverage(me.data.items, field);
}
},
// @private, see average
getAverage: function(records, field) {
var i = 0,
len = records.length,
sum = 0;
if (records.length > 0) {
for (; i < len; ++i) {
sum += records[i].get(field);
}
return sum / len;
}
return 0;
},

aggregate: function(fn, scope, grouped, args) {
args = args || [];
if (grouped && this.isGrouped()) {
var groups = this.getGroups(),
len = groups.length,
out = {},
group, i;
for (i = 0; i < len; ++i) {
group = groups[i];
out[group.name] = this.getAggregate(fn, scope || this, group.children, args);
}
return out;
} else {
return this.getAggregate(fn, scope, this.data.items, args);
}
},
getAggregate: function(fn, scope, records, args){
args = args || [];
return fn.apply(scope || this, [records].concat(args));
},
onIdChanged: function(rec, oldId, newId, oldInternalId){
var snapshot = this.snapshot;
if (snapshot) {
snapshot.updateKey(oldInternalId, newId);
}
this.data.updateKey(oldInternalId, newId);
this.callParent(arguments);
},

commitChanges : function(){
var me = this,
recs = me.getModifiedRecords(),
len = recs.length,
i = 0;
for (; i < len; i++){
recs[i].commit();
}
// Since removals are cached in a simple array we can simply reset it here.
// Adds and updates are managed in the data MixedCollection and should already be current.
me.removed.length = 0;
},
filterNewOnly: function(item){
return item.phantom === true;
},
// Ideally in the future this will use getModifiedRecords, where there will be a param
// to getNewRecords & getUpdatedRecords to indicate whether to get only the valid
// records or grab all of them
getRejectRecords: function() {
// Return phantom records + updated records
return Ext.Array.push(this.data.filterBy(this.filterNewOnly).items, this.getUpdatedRecords());
},

rejectChanges : function() {
var me = this,
recs = me.getRejectRecords(),
len = recs.length,
i = 0,
rec;
for (; i < len; i++) {
rec = recs[i];
rec.reject();
if (rec.phantom) {
me.remove(rec);
}
}
// Restore removed records back to their original positions
recs = me.removed;
len = recs.length;
for (i = 0; i < len; i++) {
rec = recs[i];
me.insert(rec.removedFrom || 0, rec);
rec.reject();
}
// Since removals are cached in a simple array we can simply reset it here.
// Adds and updates are managed in the data MixedCollection and should already be current.
me.removed.length = 0;
}
}, function() {
// A dummy empty store with a fieldless Model defined in it.
// Just for binding to Views which are instantiated with no Store defined.
// They will be able to run and render fine, and be bound to a generated Store later.
Ext.regStore('ext-empty-store', {fields: [], proxy: 'memory'});
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/data/reader/Array.js */
(function(Ext) {
Ext.define('Ext.data.reader.Array', {
extend: 'Ext.data.reader.Json',
alternateClassName: 'Ext.data.ArrayReader',
alias : 'reader.array',
// For Array Reader, methods in the base which use these properties must not see the defaults
totalProperty: undefined,
successProperty: undefined,

createFieldAccessExpression: function(field, fieldVarName, dataName) {
// In the absence of a mapping property, use the original ordinal position
// at which the Model inserted the field into its collection.
var index = (field.mapping == null) ? field.originalIndex : field.mapping,
result;
if (typeof index === 'function') {
result = fieldVarName + '.mapping(' + dataName + ', this)';
} else {
if (isNaN(index)) {
index = '"' + index + '"';
}
result = dataName + "[" + index + "]";
}
return result;
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/data/ArrayStore.js */
(function(Ext) {
Ext.define('Ext.data.ArrayStore', {
extend: 'Ext.data.Store',
alias: 'store.array',
requires: [
'Ext.data.proxy.Memory',
'Ext.data.reader.Array'
],
constructor: function(config) {
config = Ext.apply({
proxy: {
type: 'memory',
reader: 'array'
}
}, config);
this.callParent([config]);
},
loadData: function(data, append) {
if (this.expandData === true) {
var r = [],
i = 0,
ln = data.length;
for (; i < ln; i++) {
r[r.length] = [data[i]];
}
data = r;
}
this.callParent([data, append]);
}
}, function() {
// backwards compat
Ext.data.SimpleStore = Ext.data.ArrayStore;
// Ext.reg('simplestore', Ext.data.SimpleStore);
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/data/StoreManager.js */
(function(Ext) {
Ext.define('Ext.data.StoreManager', {
extend: 'Ext.util.MixedCollection',
alternateClassName: ['Ext.StoreMgr', 'Ext.data.StoreMgr', 'Ext.StoreManager'],
singleton: true,
uses: ['Ext.data.ArrayStore'],



register : function() {
for (var i = 0, s; (s = arguments[i]); i++) {
this.add(s);
}
},

unregister : function() {
for (var i = 0, s; (s = arguments[i]); i++) {
this.remove(this.lookup(s));
}
},

lookup : function(store) {
// handle the case when we are given an array or an array of arrays.
if (Ext.isArray(store)) {
var fields = ['field1'], 
expand = !Ext.isArray(store[0]),
data = store,
i,
len;

if(expand){
data = [];
for (i = 0, len = store.length; i < len; ++i) {
data.push([store[i]]);
}
} else {
for(i = 2, len = store[0].length; i <= len; ++i){
fields.push('field' + i);
}
}
return new Ext.data.ArrayStore({
data : data,
fields: fields,
autoDestroy: true,
autoCreated: true,
expanded: expand
});
}

if (Ext.isString(store)) {
// store id
return this.get(store);
} else {
// store instance or store config
return Ext.data.AbstractStore.create(store);
}
},
// getKey implementation for MixedCollection
getKey : function(o) {
return o.storeId;
}
}, function() { 

Ext.regStore = function(name, config) {
var store;
if (Ext.isObject(name)) {
config = name;
} else {
config.storeId = name;
}
if (config instanceof Ext.data.Store) {
store = config;
} else {
store = new Ext.data.Store(config);
}
return Ext.data.StoreManager.register(store);
};

Ext.getStore = function(name) {
return Ext.data.StoreManager.lookup(name);
};
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/LoadMask.js */
(function(Ext) {
Ext.define('Ext.LoadMask', {
extend: 'Ext.Component',
alias: 'widget.loadmask',

mixins: {
floating: 'Ext.util.Floating',
bindable: 'Ext.util.Bindable'
},
uses: ['Ext.data.StoreManager'],




//<locale>

msg : 'Loading...',
//</locale>

msgCls : Ext.baseCSSPrefix + 'mask-loading',

maskCls: Ext.baseCSSPrefix + 'mask',

useMsg: true,

useTargetEl: false,
baseCls: Ext.baseCSSPrefix + 'mask-msg',
childEls: [
'msgEl',
'msgTextEl'
],
renderTpl: [
'<div id="{id}-msgEl" class="{[values.$comp.msgCls]} ',
Ext.baseCSSPrefix, 'mask-msg-inner{childElCls}">',
'<div id="{id}-msgTextEl" class="', Ext.baseCSSPrefix ,'mask-msg-text',
'{childElCls}"></div>',
'</div>'
],
// @private Obviously, it's floating.
floating: {
shadow: 'frame'
},
// @private Masks are not focusable
focusOnToFront: false,
// When we put the load mask to the front of it's owner, we generally don't want to also bring the owning
// component to the front.
bringParentToFront: false,

constructor : function(config) {
var me = this,
comp;
if (arguments.length === 2) {
//<debug>
if (Ext.isDefined(Ext.global.console)) {
Ext.global.console.warn('Ext.LoadMask: LoadMask now uses a standard 1 arg constructor: use the target config');
}
//</debug>
comp = config;
config = arguments[1];
} else {
comp = config.target;
}
// Element support to be deprecated
if (!comp.isComponent) {
//<debug>
if (Ext.isDefined(Ext.global.console)) {
Ext.global.console.warn('Ext.LoadMask: LoadMask for elements has been deprecated, use Ext.dom.Element.mask & Ext.dom.Element.unmask');
}
//</debug>
comp = Ext.get(comp);
this.isElement = true;
}
me.ownerCt = comp;
if (!this.isElement) {
me.bindComponent(comp);
}
me.callParent([config]);
if (me.store) {
me.bindStore(me.store, true);
}
},
bindComponent: function(comp) {
var me = this,
listeners = {
scope: this,
resize: me.sizeMask,
added: me.onComponentAdded,
removed: me.onComponentRemoved
};

if (comp.floating) {
listeners.move = me.sizeMask;
me.activeOwner = comp;
} else if (comp.ownerCt) {
me.onComponentAdded(comp.ownerCt);
} else {
// if the target comp is non-floating and under a floating comp don't bring the load mask to the front of the stack
me.preventBringToFront = true;
}
me.mon(comp, listeners);

// subscribe to the observer that manages the hierarchy
me.mon(me.hierarchyEventSource, {
show: me.onContainerShow,
hide: me.onContainerHide,
expand: me.onContainerExpand,
collapse: me.onContainerCollapse,
scope: me
});
},
onComponentAdded: function(owner) {
var me = this;
delete me.activeOwner;
me.floatParent = owner;
if (!owner.floating) {
owner = owner.up('[floating]');
}
if (owner) {
me.activeOwner = owner;
me.mon(owner, 'move', me.sizeMask, me);
} else {
me.preventBringToFront = true;
}
owner = me.floatParent.ownerCt;
if (me.rendered && me.isVisible() && owner) {
me.floatOwner = owner;
me.mon(owner, 'afterlayout', me.sizeMask, me, {single: true});
}
},
onComponentRemoved: function(owner) {
var me = this,
activeOwner = me.activeOwner,
floatOwner = me.floatOwner;
if (activeOwner) {
me.mun(activeOwner, 'move', me.sizeMask, me);
}
if (floatOwner) {
me.mun(floatOwner, 'afterlayout', me.sizeMask, me);
}
delete me.activeOwner;
delete me.floatOwner;
},
afterRender: function() {
this.callParent(arguments);
this.container = this.floatParent.getContentTarget();
},
onContainerShow: function(container) {
if (this.isActiveContainer(container)) {
this.onComponentShow();
}
},
onContainerHide: function(container) {
if (this.isActiveContainer(container)) {
this.onComponentHide();
}
},
onContainerExpand: function(container) {
if (this.isActiveContainer(container)) {
this.onComponentShow();
}
},
onContainerCollapse: function(container) {
if (this.isActiveContainer(container)) {
this.onComponentHide();
}
},
isActiveContainer: function(container) {
return this.isDescendantOf(container);
},
onComponentHide: function() {
var me = this;
if (me.rendered && me.isVisible()) {
me.hide();
me.showNext = true;
}
},
onComponentShow: function() {
if (this.showNext) {
this.show();
}
delete this.showNext;
},

sizeMask: function() {
var me = this,
target;
if (me.rendered && me.isVisible()) {
me.center();
target = me.getMaskTarget();
me.getMaskEl().show().setSize(target.getSize()).alignTo(target, 'tl-tl');
}
},

bindStore : function(store, initial) {
var me = this;
me.mixins.bindable.bindStore.apply(me, arguments);
store = me.store;
if (store && store.isLoading()) {
me.onBeforeLoad();
}
},
getStoreListeners: function(store) {
var load = this.onLoad,
beforeLoad = this.onBeforeLoad,
result = {
// Fired when a range is requested for rendering that is not in the cache
cachemiss: beforeLoad,
// Fired when a range for rendering which was previously missing from the cache is loaded
cachefilled: load
};
// Only need to mask on load if the proxy is asynchronous - ie: Ajax/JsonP
if (!store.proxy.isSynchronous) {
result.beforeLoad = beforeLoad;
result.load = load;
}
return result;
},
onDisable : function() {
this.callParent(arguments);
if (this.loading) {
this.onLoad();
}
},
getOwner: function() {
return this.ownerCt || this.floatParent;
},
getMaskTarget: function() {
var owner = this.getOwner();
return this.useTargetEl ? owner.getTargetEl() : owner.getEl();
},
// @private
onBeforeLoad : function() {
var me = this,
owner = me.getOwner(),
origin;
if (!me.disabled) {
me.loading = true;
// If the owning Component has not been layed out, defer so that the ZIndexManager
// gets to read its layed out size when sizing the modal mask
if (owner.componentLayoutCounter) {
me.maybeShow();
} else {
// The code below is a 'run-once' interceptor.
origin = owner.afterComponentLayout;
owner.afterComponentLayout = function() {
owner.afterComponentLayout = origin;
origin.apply(owner, arguments);
me.maybeShow();
};
}
}
},
maybeShow: function() {
var me = this,
owner = me.getOwner();
if (!owner.isVisible(true)) {
me.showNext = true;
}
else if (me.loading && owner.rendered) {
me.show();
}
},
getMaskEl: function(){
var me = this;
return me.maskEl || (me.maskEl = me.el.insertSibling({
cls: me.maskCls,
style: {
zIndex: me.el.getStyle('zIndex') - 2
}
}, 'before'));
},
onShow: function() {
var me = this,
msgEl = me.msgEl;
me.callParent(arguments);
me.loading = true;
if (me.useMsg) {
msgEl.show();
me.msgTextEl.update(me.msg);
} else {
msgEl.parent().hide();
}
},
hide: function() {
// Element support to be deprecated
if (this.isElement) {
this.ownerCt.unmask();
this.fireEvent('hide', this);
return;
}
delete this.showNext;
return this.callParent(arguments);
},
onHide: function() {
this.callParent();
this.getMaskEl().hide();
},
show: function() {
// Element support to be deprecated
if (this.isElement) {
this.ownerCt.mask(this.useMsg ? this.msg : '', this.msgCls);
this.fireEvent('show', this);
return;
}
return this.callParent(arguments);
},
afterShow: function() {
this.callParent(arguments);
this.sizeMask();
},
setZIndex: function(index) {
var me = this,
owner = me.activeOwner;

if (owner) {
// it seems silly to add 1 to have it subtracted in the call below,
// but this allows the x-mask el to have the correct z-index (same as the component)
// so instead of directly changing the zIndexStack just get the z-index of the owner comp
index = parseInt(owner.el.getStyle('zIndex'), 10) + 1;
}
me.getMaskEl().setStyle('zIndex', index - 1);
return me.mixins.floating.setZIndex.apply(me, arguments);
},
// @private
onLoad : function() {
this.loading = false;
this.hide();
},
onDestroy: function() {
var me = this;
if (me.isElement) {
me.ownerCt.unmask();
}
Ext.destroy(me.maskEl);
me.callParent();
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/ZIndexManager.js */
(function(Ext) {
Ext.define('Ext.ZIndexManager', {
alternateClassName: 'Ext.WindowGroup',
statics: {
zBase : 9000
},
constructor: function(container) {
var me = this;
me.list = {};
me.zIndexStack = [];
me.front = null;
if (container) {
// This is the ZIndexManager for an Ext.container.Container, base its zseed on the zIndex of the Container's element
if (container.isContainer) {
container.on('resize', me._onContainerResize, me);
me.zseed = Ext.Number.from(me.rendered ? container.getEl().getStyle('zIndex') : undefined, me.getNextZSeed());
// The containing element we will be dealing with (eg masking) is the content target
me.targetEl = container.getTargetEl();
me.container = container;
}
// This is the ZIndexManager for a DOM element
else {
Ext.EventManager.onWindowResize(me._onContainerResize, me);
me.zseed = me.getNextZSeed();
me.targetEl = Ext.get(container);
}
}
// No container passed means we are the global WindowManager. Our target is the doc body.
// DOM must be ready to collect that ref.
else {
Ext.EventManager.onWindowResize(me._onContainerResize, me);
me.zseed = me.getNextZSeed();
Ext.onDocumentReady(function() {
me.targetEl = Ext.getBody();
});
}
},
getNextZSeed: function() {
return (Ext.ZIndexManager.zBase += 10000);
},
setBase: function(baseZIndex) {
this.zseed = baseZIndex;
var result = this.assignZIndices();
this._activateLast();
return result;
},
// @private
assignZIndices: function() {
var a = this.zIndexStack,
len = a.length,
i = 0,
zIndex = this.zseed,
comp,
topModal;
for (; i < len; i++) {
comp = a[i];
if (comp && !comp.hidden) {
// Setting the zIndex of a Component returns the topmost zIndex consumed by
// that Component.
// If it's just a plain floating Component such as a BoundList, then the
// return value is the passed value plus 10, ready for the next item.
// If a floating *Container* has its zIndex set, it re-orders its managed
// floating children, starting from that new base, and returns a value 10000 above
// the highest zIndex which it allocates.
zIndex = comp.setZIndex(zIndex);
if (comp.modal) {
topModal = comp;
}
}
}

// If we encountered a modal in our reassigment, ensure our modal mask is just below it.
if (topModal) {
this._showModalMask(topModal)
}
return zIndex;
},
// @private
_setActiveChild: function(comp, oldFront) {
var front = this.front,
oldPreventFocus = comp.preventFocusOnActivate;
if (comp !== front) {
if (front && !front.destroying) {
front.setActive(false, comp);
}
this.front = comp;
if (comp && comp != oldFront) {
// If the previously active comp did not take focus, then do not disturb focus state by focusing the new front
comp.preventFocusOnActivate = comp.preventFocusOnActivate || oldFront && (oldFront.preventFocusOnActivate || !oldFront.focusOnToFront);
comp.setActive(true);

// If the modal mask was utilized by the outgoing front component, reposition it.
if (comp.modal) {
this._showModalMask(comp);
}
// Restore the new front's focusing flag
comp.preventFocusOnActivate = oldPreventFocus;
}
}
},
onComponentHide: function(comp){
this._activateLast();
},
// @private
_activateLast: function() {
var me = this,
stack = me.zIndexStack,
i = stack.length - 1,
comp;
// Go down through the z-index stack.
// Activate the next visible one down.
// If that was modal, then we're done
for (; i >= 0 && stack[i].hidden; --i);
// The loop found a visible floater to activate
if ((comp = stack[i])) {
me._setActiveChild(comp, me.front);
if (comp.modal) {
return;
}
}
// No other floater to activate, just deactivate the current one
else {
if (me.front && !me.front.destroying) {
me.front.setActive(false);
}
me.front = null;
}
// If the new top one was not modal, keep going down to find the next visible
// modal one to shift the modal mask down under
for (; i >= 0; --i) {
comp = stack[i];
// If we find a visible modal further down the zIndex stack, move the mask to just under it.
if (comp.isVisible() && comp.modal) {
me._showModalMask(comp);
return;
}
}
// No visible modal Component was found in the run down the stack.
// So hide the modal mask
me._hideModalMask();
},
_showModalMask: function(comp) {
var me = this,
zIndex = comp.el.getStyle('zIndex') - 4,
maskTarget = comp.floatParent ? comp.floatParent.getTargetEl() : comp.container,
mask = me.mask,
shim = me.maskShim,
viewSize;
if (!mask) {
if (Ext.isIE6) {
shim = me.maskShim = Ext.getBody().createChild({
tag: 'iframe',
cls : Ext.baseCSSPrefix + 'shim ' + Ext.baseCSSPrefix + 'mask-shim'
});
shim.setVisibilityMode(Ext.Element.DISPLAY);
}
// Create the mask at zero size so that it does not affect upcoming target measurements.
mask = me.mask = Ext.getBody().createChild({
cls: Ext.baseCSSPrefix + 'mask',
style: 'height:0;width:0'
});
mask.setVisibilityMode(Ext.Element.DISPLAY);
mask.on('click', me._onMaskClick, me);
}

mask.maskTarget = maskTarget;
viewSize = me.getMaskBox();
if (shim) {
shim.setStyle('zIndex', zIndex);
shim.show();
shim.setBox(viewSize);
}
mask.setStyle('zIndex', zIndex);
// setting mask box before showing it in an IE7 strict iframe within a quirks page
// can cause body scrolling [EXTJSIV-6219]
mask.show();
mask.setBox(viewSize);
},
_hideModalMask: function() {
var mask = this.mask,
maskShim = this.maskShim;
if (mask && mask.isVisible()) {
mask.maskTarget = undefined;
mask.hide();
if (maskShim) {
maskShim.hide();
}
}
},
_onMaskClick: function() {
if (this.front) {
this.front.focus();
}
},

getMaskBox: function(){
var maskTarget = this.mask.maskTarget;
if (maskTarget.dom === document.body) {
return {
height: Math.max(document.body.scrollHeight, Ext.dom.Element.getDocumentHeight()),
width: Math.max(document.body.scrollWidth, document.documentElement.clientWidth),
x: 0,
y: 0
};
} else {
return maskTarget.getBox();
} 
},
_onContainerResize: function() {
var me = this,
mask = me.mask,
maskShim = me.maskShim,
viewSize;
if (mask && mask.isVisible()) {
// At the new container size, the mask might be *causing* the scrollbar, so to find the valid
// client size to mask, we must temporarily unmask the parent node.
mask.hide();
if (maskShim) {
maskShim.hide();
}
viewSize = me.getMaskBox();
if (maskShim) {
maskShim.setSize(viewSize);
maskShim.show();
}
mask.setSize(viewSize);
mask.show();
}
},

register : function(comp) {
var me = this,
compAfterHide = comp.afterHide;

if (comp.zIndexManager) {
comp.zIndexManager.unregister(comp);
}
comp.zIndexManager = me;
me.list[comp.id] = comp;
me.zIndexStack.push(comp);

// Hook into Component's afterHide processing
comp.afterHide = function() {
compAfterHide.apply(comp, arguments);
me.onComponentHide(comp);
};
},

unregister : function(comp) {
var me = this,
list = me.list;

delete comp.zIndexManager;
if (list && list[comp.id]) {
delete list[comp.id];

// Relinquish control of Component's afterHide processing
delete comp.afterHide;
Ext.Array.remove(me.zIndexStack, comp);
// Destruction requires that the topmost visible floater be activated. Same as hiding.
me._activateLast();
}
},

get : function(id) {
return id.isComponent ? id : this.list[id];
},

bringToFront : function(comp, preventFocus) {
var me = this,
result = false,
zIndexStack = me.zIndexStack;

comp = me.get(comp);
if (comp !== me.front) {
Ext.Array.remove(zIndexStack, comp);
if (comp.preventBringToFront) {
// this takes care of cases where a load mask should be displayed under a floated component
zIndexStack.unshift(comp);
} else {
// the default behavior is to push onto the stack
zIndexStack.push(comp);
}
me.assignZIndices();
// Activate new topmost
if (!preventFocus) {
me._activateLast();
}
result = true;
me.front = comp;

// If new topmost is modal, ensure the mask is there
if (comp.modal) {
me._showModalMask(comp);
}
}
return result;
},

sendToBack : function(comp) {
var me = this;

comp = me.get(comp);
Ext.Array.remove(me.zIndexStack, comp);
me.zIndexStack.unshift(comp);
me.assignZIndices();
this._activateLast();
return comp;
},

hideAll : function() {
var list = this.list,
item,
id;

for (id in list) {
if (list.hasOwnProperty(id)) {
item = list[id];
if (item.isComponent && item.isVisible()) {
item.hide();
}
}
}
},

hide: function() {
var i = 0,
stack = this.zIndexStack,
len = stack.length,
comp;
this.tempHidden = [];
for (; i < len; i++) {
comp = stack[i];
if (comp.isVisible()) {
this.tempHidden.push(comp);
comp.el.hide();
comp.hidden = true;
}
}
},

show: function() {
var i = 0,
tempHidden = this.tempHidden,
len = tempHidden ? tempHidden.length : 0,
comp;
for (; i < len; i++) {
comp = tempHidden[i];
comp.el.show();
comp.hidden = false;
comp.setPosition(comp.x, comp.y);
}
delete this.tempHidden;
},

getActive : function() {
return this.front;
},

getBy : function(fn, scope) {
var r = [],
i = 0,
stack = this.zIndexStack,
len = stack.length,
comp;
for (; i < len; i++) {
comp = stack[i];
if (fn.call(scope||comp, comp) !== false) {
r.push(comp);
}
}
return r;
},

each : function(fn, scope) {
var list = this.list,
id,
comp;

for (id in list) {
if (list.hasOwnProperty(id)) {
comp = list[id];
if (comp.isComponent && fn.call(scope || comp, comp) === false) {
return;
}
}
}
},

eachBottomUp: function (fn, scope) {
var stack = this.zIndexStack,
i = 0,
len = stack.length,
comp;
for (; i < len; i++) {
comp = stack[i];
if (comp.isComponent && fn.call(scope || comp, comp) === false) {
return;
}
}
},

eachTopDown: function (fn, scope) {
var stack = this.zIndexStack,
i = stack.length,
comp;
for (; i-- > 0; ) {
comp = stack[i];
if (comp.isComponent && fn.call(scope || comp, comp) === false) {
return;
}
}
},
destroy: function() {
var me = this,
list = me.list,
comp,
id;
for (id in list) {
if (list.hasOwnProperty(id)) {
comp = list[id];
if (comp.isComponent) {
comp.destroy();
}
}
}
delete me.zIndexStack;
delete me.list;
delete me.container;
delete me.targetEl;
}
}, function() {

Ext.WindowManager = Ext.WindowMgr = new this();
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/AbstractComponent.js */
(function(Ext) {
Ext.define('Ext.AbstractComponent', {

requires: [
'Ext.ComponentQuery',
'Ext.ComponentManager',
'Ext.util.ProtoElement',
'Ext.dom.CompositeElement',
'Ext.PluginManager'
],
mixins: {
positionable: 'Ext.util.Positionable',
observable: 'Ext.util.Observable',
animate: 'Ext.util.Animate',
elementCt: 'Ext.util.ElementContainer',
renderable: 'Ext.util.Renderable',
state: 'Ext.state.Stateful'
},
// The "uses" property specifies class which are used in an instantiated AbstractComponent.
// They do *not* have to be loaded before this class may be defined - that is what "requires" is for.
uses: [
'Ext.PluginManager',
'Ext.Element',
'Ext.DomHelper',
'Ext.XTemplate',
'Ext.ComponentLoader',
'Ext.EventManager',
'Ext.layout.Context',
'Ext.layout.Layout',
'Ext.layout.component.Auto',
'Ext.LoadMask',
'Ext.ZIndexManager'
],
statics: {
AUTO_ID: 1000,
pendingLayouts: null,
layoutSuspendCount: 0,

cancelLayout: function(comp, isDestroying) {
var context = this.runningLayoutContext || this.pendingLayouts;
if (context) {
context.cancelComponent(comp, false, isDestroying);
}
},

flushLayouts: function () {
var me = this,
context = me.pendingLayouts;
if (context && context.invalidQueue.length) {
me.pendingLayouts = null;
me.runningLayoutContext = context;
Ext.override(context, {
runComplete: function () {
// we need to release the layout queue before running any of the
// finishedLayout calls because they call afterComponentLayout
// which can re-enter by calling doLayout/doComponentLayout.
me.runningLayoutContext = null;

var result = this.callParent(); // not "me" here!
if (Ext.globalEvents.hasListeners.afterlayout) { 
Ext.globalEvents.fireEvent('afterlayout');
}
return result;
}
});
context.run();
}
},

resumeLayouts: function (flush) {
if (this.layoutSuspendCount && ! --this.layoutSuspendCount) {
if (flush) {
this.flushLayouts();
}
if (Ext.globalEvents.hasListeners.resumelayouts) {
Ext.globalEvents.fireEvent('resumelayouts');
}
}
},

suspendLayouts: function () {
++this.layoutSuspendCount;
},

updateLayout: function (comp, defer) {
var me = this,
running = me.runningLayoutContext,
pending;
if (running) {
running.queueInvalidate(comp);
} else {
pending = me.pendingLayouts || (me.pendingLayouts = new Ext.layout.Context());
pending.queueInvalidate(comp);
if (!defer && !me.layoutSuspendCount && !comp.isLayoutSuspended()) {
me.flushLayouts();
}
}
}
},


isComponent: true,

getAutoId: function() {
this.autoGenId = true;
return ++Ext.AbstractComponent.AUTO_ID;
},
deferLayouts: false,


autoGenId: false,




renderTpl: '{%this.renderContent(out,values)%}',






frameSize: null,





tplWriteMode: 'overwrite',

baseCls: Ext.baseCSSPrefix + 'component',




disabledCls: Ext.baseCSSPrefix + 'item-disabled',

ui: 'default',

uiCls: [],







hidden: false,

disabled: false,


draggable: false,

floating: false,

hideMode: 'display',









autoShow: false,

autoRender: false,
// @private
allowDomMove: true,


rendered: false,

componentLayoutCounter: 0,

shrinkWrap: 2,
weight: 0,

maskOnDisable: true,

_isLayoutRoot: false,

contentPaddingProperty: 'padding',

horizontalPosProp: 'left',
// private
borderBoxCls: Ext.baseCSSPrefix + 'border-box',

constructor : function(config) {
var me = this,
i, len, xhooks;
if (config) {
Ext.apply(me, config);
xhooks = me.xhooks;
if (xhooks) {
delete me.xhooks;
Ext.override(me, xhooks);
}
} else {
config = {};
}
me.initialConfig = config;
me.mixins.elementCt.constructor.call(me);
me.addEvents(

'beforeactivate',

'activate',

'beforedeactivate',

'deactivate',

'added',

'disable',

'enable',

'beforeshow',

'show',

'beforehide',

'hide',

'removed',

'beforerender',

'render',

'afterrender',

'boxready',

'beforedestroy',

'destroy',

'resize',

'move',

'focus',

'blur'
);
me.getId();
me.setupProtoEl();
// initComponent, beforeRender, or event handlers may have set the style or `cls` property since the `protoEl` was set up
// so we must apply styles and classes here too.
if (me.cls) {
me.initialCls = me.cls;
me.protoEl.addCls(me.cls);
}
if (me.style) {
me.initialStyle = me.style;
me.protoEl.setStyle(me.style);
}
me.renderData = me.renderData || {};
me.renderSelectors = me.renderSelectors || {};
if (me.plugins) {
me.plugins = me.constructPlugins();
}
// we need this before we call initComponent
if (!me.hasListeners) {
me.hasListeners = new me.HasListeners();
}
me.initComponent();
// ititComponent gets a chance to change the id property before registering
Ext.ComponentManager.register(me);
// Don't pass the config so that it is not applied to 'this' again
me.mixins.observable.constructor.call(me);
me.mixins.state.constructor.call(me, config);
// Save state on resize.
this.addStateEvents('resize');
// Move this into Observable?
if (me.plugins) {
for (i = 0, len = me.plugins.length; i < len; i++) {
me.plugins[i] = me.initPlugin(me.plugins[i]);
}
}
me.loader = me.getLoader();
if (me.renderTo) {
me.render(me.renderTo);
// EXTJSIV-1935 - should be a way to do afterShow or something, but that
// won't work. Likewise, rendering hidden and then showing (w/autoShow) has
// implications to afterRender so we cannot do that.
}
// Auto show only works unilaterally on *uncontained* Components.
// If contained, then it is the Container's responsibility to do the showing at next layout time.
if (me.autoShow && !me.isContained) {
me.show();
}
//<debug>
if (Ext.isDefined(me.disabledClass)) {
if (Ext.isDefined(Ext.global.console)) {
Ext.global.console.warn('Ext.Component: disabledClass has been deprecated. Please use disabledCls.');
}
me.disabledCls = me.disabledClass;
delete me.disabledClass;
}
//</debug>
},
initComponent: function () {
// This is called again here to allow derived classes to add plugin configs to the
// plugins array before calling down to this, the base initComponent.
this.plugins = this.constructPlugins();
// this will properly (ignore or) constrain the configured width/height to their
// min/max values for consistency.
this.setSize(this.width, this.height);
},

getState: function() {
var me = this,
state = null,
sizeModel = me.getSizeModel();
if (sizeModel.width.configured) {
state = me.addPropertyToState(state, 'width');
}
if (sizeModel.height.configured) {
state = me.addPropertyToState(state, 'height');
}
return state;
},

addPropertyToState: function (state, propName, value) {
var me = this,
len = arguments.length;
// If the property is inherited, it is a default and we don't want to save it to
// the state, however if we explicitly specify a value, always save it
if (len == 3 || me.hasOwnProperty(propName)) {
if (len < 3) {
value = me[propName];
}
// If the property has the same value as was initially configured, again, we
// don't want to save it.
if (value !== me.initialConfig[propName]) {
(state || (state = {}))[propName] = value;
}
}
return state;
},
show: Ext.emptyFn,
animate: function(animObj) {
var me = this,
hasToWidth,
hasToHeight,
toHeight,
toWidth,
to,
clearWidth,
clearHeight,
curWidth, w, curHeight, h, isExpanding,
wasConstrained,
wasConstrainedHeader,
passedCallback,
oldOverflow;
animObj = animObj || {};
to = animObj.to || {};
if (Ext.fx.Manager.hasFxBlock(me.id)) {
return me;
}
hasToWidth = Ext.isDefined(to.width);
if (hasToWidth) {
toWidth = Ext.Number.constrain(to.width, me.minWidth, me.maxWidth);
}
hasToHeight = Ext.isDefined(to.height);
if (hasToHeight) {
toHeight = Ext.Number.constrain(to.height, me.minHeight, me.maxHeight);
}
// Special processing for animating Component dimensions.
if (!animObj.dynamic && (hasToWidth || hasToHeight)) {
curWidth = (animObj.from ? animObj.from.width : undefined) || me.getWidth();
w = curWidth;
curHeight = (animObj.from ? animObj.from.height : undefined) || me.getHeight();
h = curHeight;
isExpanding = false;
if (hasToHeight && toHeight > curHeight) {
h = toHeight;
isExpanding = true;
}
if (hasToWidth && toWidth > curWidth) {
w = toWidth;
isExpanding = true;
}
// During animated sizing, overflow has to be hidden to clip expanded content
if (hasToHeight || hasToWidth) {
oldOverflow = me.el.getStyle('overtflow');
if (oldOverflow !== 'hidden') {
me.el.setStyle('overflow', 'hidden');
}
}
// If any dimensions are being increased, we must resize the internal structure
// of the Component, but then clip it by sizing its encapsulating element back to original dimensions.
// The animation will then progressively reveal the larger content.
if (isExpanding) {
clearWidth = !Ext.isNumber(me.width);
clearHeight = !Ext.isNumber(me.height);
// Lay out this component at the new, larger size to get the internals correctly laid out.
// Then size the encapsulating **Element** back down to size.
// We will then just animate the element to reveal the correctly laid out content.
me.setSize(w, h);
me.el.setSize(curWidth, curHeight);
if (clearWidth) {
delete me.width;
}
if (clearHeight) {
delete me.height;
}
}
if (hasToWidth) {
to.width = toWidth;
}
if (hasToHeight) {
to.height = toHeight;
}
}
// No constraining during the animate - the "to" size has already been calculated with respect to all settings.
// Arrange to reinstate any constraining after the animation has completed
wasConstrained = me.constrain;
wasConstrainedHeader = me.constrainHeader;
if (wasConstrained || wasConstrainedHeader) {
me.constrain = me.constrainHeader = false;
passedCallback = animObj.callback;
animObj.callback = function() {
me.constrain = wasConstrained;
me.constrainHeader = wasConstrainedHeader;
// Call the original callback if any
if (passedCallback) {
passedCallback.call(animObj.scope||me, arguments);
}
if (oldOverflow !== 'hidden') {
me.el.setStyle('overflow', oldOverflow);
}
};
}
return me.mixins.animate.animate.apply(me, arguments);
},

setHiddenState: function(hidden){
var hierarchyState = this.getHierarchyState();

this.hidden = hidden;
if (hidden) {
hierarchyState.hidden = true;
} else {
delete hierarchyState.hidden;
}
},
onHide: function() {
// Only lay out if there is an owning layout which might be affected by the hide
if (this.ownerLayout) {
this.updateLayout({ isRoot: false });
}
},
onShow : function() {
this.updateLayout({ isRoot: false });
},

constructPlugin: function(plugin) {
var me = this;

// ptype only, pass as the defultType
if (typeof plugin == 'string') {
plugin = Ext.PluginManager.create({}, plugin, me);
}
// Object (either config with ptype or an instantiated plugin)
else {
plugin = Ext.PluginManager.create(plugin, null, me);
}
return plugin;
},

constructPlugins: function() {
var me = this,
plugins = me.plugins,
result, i, len;
if (plugins) {
result = [];
if (!Ext.isArray(plugins)) {
plugins = [ plugins ];
}
for (i = 0, len = plugins.length; i < len; i++) {
// this just returns already-constructed plugin instances...
result[i] = me.constructPlugin(plugins[i]);
}
}
me.pluginsInitialized = true;
return result;
},
// @private
initPlugin : function(plugin) {
plugin.init(this);
return plugin;
},
// @private
// Adds a plugin. May be called at any time in the component's lifecycle.
addPlugin: function(plugin) {
var me = this;
plugin = me.constructPlugin(plugin);
if (me.plugins) {
me.plugins.push(plugin);
} else {
me.plugins = [ plugin ];
}
if (me.pluginsInitialized) {
me.initPlugin(plugin);
}
return plugin;
},
removePlugin: function(plugin) {
Ext.Array.remove(this.plugins, plugin);
plugin.destroy();
},

findPlugin: function(ptype) {
var i,
plugins = this.plugins,
ln = plugins && plugins.length;
for (i = 0; i < ln; i++) {
if (plugins[i].ptype === ptype) {
return plugins[i];
}
}
},

getPlugin: function(pluginId) {
var i,
plugins = this.plugins,
ln = plugins && plugins.length;
for (i = 0; i < ln; i++) {
if (plugins[i].pluginId === pluginId) {
return plugins[i];
}
}
},

beforeLayout: Ext.emptyFn,

updateAria: Ext.emptyFn,

registerFloatingItem: function(cmp) {
var me = this;
if (!me.floatingDescendants) {
me.floatingDescendants = new Ext.ZIndexManager(me);
}
me.floatingDescendants.register(cmp);
},
unregisterFloatingItem: function(cmp) {
var me = this;
if (me.floatingDescendants) {
me.floatingDescendants.unregister(cmp);
}
},
layoutSuspendCount: 0,
suspendLayouts: function () {
var me = this;
if (!me.rendered) {
return;
}
if (++me.layoutSuspendCount == 1) {
me.suspendLayout = true;
}
},
resumeLayouts: function (flushOptions) {
var me = this;
if (!me.rendered) {
return;
}
if (! --me.layoutSuspendCount) {
me.suspendLayout = false;
if (flushOptions && !me.isLayoutSuspended()) {
me.updateLayout(flushOptions);
}
}
},
setupProtoEl: function() {
var cls = this.initCls();
this.protoEl = new Ext.util.ProtoElement({
cls: cls.join(' ') // in case any of the parts have multiple classes
});
},
initCls: function() {
var me = this,
cls = [ me.baseCls, me.getComponentLayout().targetCls ];
//<deprecated since=0.99>
if (Ext.isDefined(me.cmpCls)) {
if (Ext.isDefined(Ext.global.console)) {
Ext.global.console.warn('Ext.Component: cmpCls has been deprecated. Please use componentCls.');
}
me.componentCls = me.cmpCls;
delete me.cmpCls;
}
//</deprecated>
if (me.componentCls) {
cls.push(me.componentCls);
} else {
me.componentCls = me.baseCls;
}
return cls;
},

setUI: function(ui) {
var me = this,
uiCls = me.uiCls,
activeUI = me.activeUI,
classes;
if (ui === activeUI) {
// The ui hasn't changed
return;
}
// activeUI will only be set if setUI has been called before. If it hasn't there's no need to remove anything
if (activeUI) {
classes = me.removeClsWithUI(uiCls, true);
if (classes.length) {
me.removeCls(classes);
}
// Remove the UI from the element
me.removeUIFromElement();
}
else {
// We need uiCls to be empty otherwise our call to addClsWithUI won't do anything
me.uiCls = [];
}
// Set the UI
me.ui = ui;
// After the first call to setUI the values ui and activeUI should track each other but initially we need some
// way to tell whether the ui has really been set.
me.activeUI = ui;
// Add the new UI to the element
me.addUIToElement();
classes = me.addClsWithUI(uiCls, true);
if (classes.length) {
me.addCls(classes);
}
// Changing the ui can lead to significant changes to a component's appearance, so the layout needs to be
// updated. Internally most calls to setUI are pre-render. Buttons are a notable exception as setScale changes
// the ui and often requires the layout to be updated.
if (me.rendered) {
me.updateLayout();
}
},

addClsWithUI: function(classes, skip) {
var me = this,
clsArray = [],
i = 0,
uiCls = me.uiCls = Ext.Array.clone(me.uiCls),
activeUI = me.activeUI,
length,
cls;
if (typeof classes === "string") {
classes = (classes.indexOf(' ') < 0) ? [classes] : Ext.String.splitWords(classes);
}
length = classes.length;
for (; i < length; i++) {
cls = classes[i];
if (cls && !me.hasUICls(cls)) {
uiCls.push(cls);
// We can skip this bit if there isn't an activeUI because we'll be called again from setUI
if (activeUI) {
clsArray = clsArray.concat(me.addUIClsToElement(cls));
}
}
}
if (skip !== true && activeUI) {
me.addCls(clsArray);
}
return clsArray;
},

removeClsWithUI: function(classes, skip) {
var me = this,
clsArray = [],
i = 0,
extArray = Ext.Array,
remove = extArray.remove,
uiCls = me.uiCls = extArray.clone(me.uiCls),
activeUI = me.activeUI,
length, cls;
if (typeof classes === "string") {
classes = (classes.indexOf(' ') < 0) ? [classes] : Ext.String.splitWords(classes);
}
length = classes.length;
for (i = 0; i < length; i++) {
cls = classes[i];
if (cls && me.hasUICls(cls)) {
remove(uiCls, cls);
//If there's no activeUI then there's nothing to remove
if (activeUI) {
clsArray = clsArray.concat(me.removeUIClsFromElement(cls));
}
}
}
if (skip !== true && activeUI) {
me.removeCls(clsArray);
}
return clsArray;
},

hasUICls: function(cls) {
var me = this,
uiCls = me.uiCls || [];
return Ext.Array.contains(uiCls, cls);
},
frameElementsArray: ['tl', 'tc', 'tr', 'ml', 'mc', 'mr', 'bl', 'bc', 'br'],

addUIClsToElement: function(cls) {
var me = this,
baseClsUi = me.baseCls + '-' + me.ui + '-' + cls,
result = [Ext.baseCSSPrefix + cls, me.baseCls + '-' + cls, baseClsUi],
frameElementsArray, frameElementsLength, i, el, frameElement;
if (me.rendered && me.frame && !Ext.supports.CSS3BorderRadius) {
// define each element of the frame
frameElementsArray = me.frameElementsArray;
frameElementsLength = frameElementsArray.length;
// loop through each of them, and if they are defined add the ui
for (i = 0; i < frameElementsLength; i++) {
frameElement = frameElementsArray[i];
el = me['frame' + frameElement.toUpperCase()];
if (el) {
el.addCls(baseClsUi + '-' + frameElement);
}
}
}
return result;
},

removeUIClsFromElement: function(cls) {
var me = this,
baseClsUi = me.baseCls + '-' + me.ui + '-' + cls,
result = [Ext.baseCSSPrefix + cls, me.baseCls + '-' + cls, baseClsUi],
frameElementsArray, frameElementsLength, i, el, frameElement;
if (me.rendered && me.frame && !Ext.supports.CSS3BorderRadius) {
// define each element of the frame
frameElementsArray = me.frameElementsArray;
frameElementsLength = frameElementsArray.length;
// loop through each of them, and if they are defined add the ui
for (i = 0; i < frameElementsLength; i++) {
frameElement = frameElementsArray[i];
el = me['frame' + frameElement.toUpperCase()];
if (el) {
el.removeCls(baseClsUi + '-' + frameElement);
}
}
}
return result;
},

addUIToElement: function() {
var me = this,
baseClsUI = me.baseCls + '-' + me.ui,
frameElementsArray, frameElementsLength, i, el, frameElement;
me.addCls(baseClsUI);
if (me.rendered && me.frame && !Ext.supports.CSS3BorderRadius) {
// define each element of the frame
frameElementsArray = me.frameElementsArray;
frameElementsLength = frameElementsArray.length;
// loop through each of them, and if they are defined add the ui
for (i = 0; i < frameElementsLength; i++) {
frameElement = frameElementsArray[i];
el = me['frame' + frameElement.toUpperCase()];
if (el) {
el.addCls(baseClsUI + '-' + frameElement);
}
}
}
},

removeUIFromElement: function() {
var me = this,
baseClsUI = me.baseCls + '-' + me.ui,
frameElementsArray, frameElementsLength, i, el, frameElement;
me.removeCls(baseClsUI);
if (me.rendered && me.frame && !Ext.supports.CSS3BorderRadius) {
// define each element of the frame
frameElementsArray = me.frameElementsArray;
frameElementsLength = frameElementsArray.length;
for (i = 0; i < frameElementsLength; i++) {
frameElement = frameElementsArray[i];
el = me['frame' + frameElement.toUpperCase()];
if (el) {
el.removeCls(baseClsUI + '-' + frameElement);
}
}
}
},

getTpl: function(name) {
return Ext.XTemplate.getTpl(this, name);
},

initStyles: function(targetEl) {
var me = this,
Element = Ext.Element,
margin = me.margin,
border = me.border,
cls = me.cls,
style = me.style,
x = me.x,
y = me.y,
width, height;
me.initPadding(targetEl);
if (margin != null) {
targetEl.setStyle('margin', this.unitizeBox((margin === true) ? 5 : margin));
}
if (border != null) {
me.setBorder(border, targetEl);
}
// initComponent, beforeRender, or event handlers may have set the style or cls property since the protoEl was set up
// so we must apply styles and classes here too.
if (cls && cls != me.initialCls) {
targetEl.addCls(cls);
me.cls = me.initialCls = null;
}
if (style && style != me.initialStyle) {
targetEl.setStyle(style);
me.style = me.initialStyle = null;
}
if (x != null) {
targetEl.setStyle(me.horizontalPosProp, (typeof x == 'number') ? (x + 'px') : x);
}
if (y != null) {
targetEl.setStyle('top', (typeof y == 'number') ? (y + 'px') : y);
}
if (Ext.isBorderBox && (!me.ownerCt || me.floating)) {
targetEl.addCls(me.borderBoxCls);
}
// Framed components need their width/height to apply to the frame, which is
// best handled in layout at present.
if (!me.getFrameInfo()) {
width = me.width;
height = me.height;
// If we're using the content box model, we also cannot assign numeric initial sizes since we do not know the border widths to subtract
if (width != null) {
if (typeof width === 'number') {
if (Ext.isBorderBox) {
targetEl.setStyle('width', width + 'px');
}
} else {
targetEl.setStyle('width', width);
}
}
if (height != null) {
if (typeof height === 'number') {
if (Ext.isBorderBox) {
targetEl.setStyle('height', height + 'px');
}
} else {
targetEl.setStyle('height', height);
}
}
}
},

initPadding: function(targetEl) {
var me = this,
padding = me.padding;
if (padding != null) {
if (me.layout && me.layout.managePadding && me.contentPaddingProperty === 'padding') {
// If the container layout manages padding, the layout will apply the 
// padding to an inner element rather than the target element. The
// assumed intent is for the configured padding to override any padding
// that is applied to the target element via stylesheet rules. It is
// therefore necessary to set the target element's padding to "0".
targetEl.setStyle('padding', 0);
} else {
// Convert the padding, margin and border properties from a space seperated string
// into a proper style string
targetEl.setStyle('padding', this.unitizeBox((padding === true) ? 5 : padding));
}
}
},

parseBox: function(box) {
return Ext.dom.Element.parseBox(box); 
},

unitizeBox: function(box) {
return Ext.dom.Element.unitizeBox(box); 
},


setMargin: function(margin, preventLayout) {
var me = this;

if (me.rendered) {
if (!margin && margin !== 0) {
margin = '';
} else {
if (margin === true) {
margin = 5;
}
margin = this.unitizeBox(margin);
}
me.getTargetEl().setStyle('margin', margin);
if (!preventLayout) {
me.updateLayout();
}
} else {
me.margin = margin;
}
},

initEvents : function() {
var me = this,
afterRenderEvents = me.afterRenderEvents,
afterRenderEvent, el, property, index, len;
if (afterRenderEvents) {
for (property in afterRenderEvents) {
el = me[property];
if (el && el.on) {
afterRenderEvent = afterRenderEvents[property];
for (index = 0, len = afterRenderEvent.length ; index < len ; ++index) {
me.mon(el, afterRenderEvent[index]);
}
}
}
}
// This will add focus/blur listeners to the getFocusEl() element if that is naturally focusable.
// If *not* naturally focusable, then the FocusManager must be enabled to get it to listen for focus so that
// the FocusManager can track and highlight focus.
me.addFocusListener();
},

addFocusListener: function() {
var me = this,
focusEl = me.getFocusEl(),
needsTabIndex;
// All Containers may be focusable, not only "form" type elements, but also
// Panels, Toolbars, Windows etc.
// Usually, the <DIV> element they will return as their focusEl will not be able to receive focus
// However, if the FocusManager is invoked, its non-default navigation handlers (invoked when
// tabbing/arrowing off of certain Components) may explicitly focus a Panel or Container or FieldSet etc.
// Add listeners to the focus and blur events on the focus element
// If this Component returns a focusEl, we might need to add a focus listener to it.
if (focusEl) {
// getFocusEl might return a Component if a Container wishes to delegate focus to a descendant.
// Window can do this via its defaultFocus configuration which can reference a Button.
if (focusEl.isComponent) {
return focusEl.addFocusListener();
}
// If the focusEl is naturally focusable, then we always need a focus listener to drive the Component's
// onFocus handling.
// If *not* naturally focusable, then we only need the focus listener if the FocusManager is enabled.
needsTabIndex = focusEl.needsTabIndex();
if (!me.focusListenerAdded && (!needsTabIndex || Ext.FocusManager.enabled)) {
if (needsTabIndex) {
focusEl.dom.tabIndex = -1;
}
focusEl.on({
focus: me.onFocus,
blur: me.onBlur,
scope: me
});
me.focusListenerAdded = true;
}
}
},

getFocusEl: Ext.emptyFn,
isFocusable: function() {
var me = this,
focusEl;
if ((me.focusable !== false) && (focusEl = me.getFocusEl()) && me.rendered && !me.destroying && !me.isDestroyed && !me.disabled && me.isVisible(true)) {
// getFocusEl might return a Component if a Container wishes to delegate focus to a descendant.
// Window can do this via its defaultFocus configuration which can reference a Button.
// Both Component and Element implement isFocusable, so always ask that.
return focusEl.isFocusable(true);
}
},

beforeFocus: Ext.emptyFn,
// private
onFocus: function(e) {
var me = this,
focusCls = me.focusCls,
focusEl = me.getFocusEl();
if (!me.disabled) {
me.beforeFocus(e);
if (focusCls && focusEl) {
focusEl.addCls(me.addClsWithUI(focusCls, true));
}
if (!me.hasFocus) {
me.hasFocus = true;
me.fireEvent('focus', me, e);
}
}
},

beforeBlur : Ext.emptyFn,
// private
onBlur : function(e) {
var me = this,
focusCls = me.focusCls,
focusEl = me.getFocusEl();
if (me.destroying) {
return;
}
me.beforeBlur(e);
if (focusCls && focusEl) {
focusEl.removeCls(me.removeClsWithUI(focusCls, true));
}
if (me.validateOnBlur) {
me.validate();
}
me.hasFocus = false;
me.fireEvent('blur', me, e);
me.postBlur(e);
},

postBlur : Ext.emptyFn,

is: function(selector) {
return Ext.ComponentQuery.is(this, selector);
},

up: function (selector, limit) {
var result = this.getRefOwner(),
limitSelector = typeof limit === 'string',
limitCount = typeof limit === 'number',
limitComponent = limit && limit.isComponent,
steps = 0;
if (selector) {
for (; result; result = result.getRefOwner()) {
steps++;
if (selector.isComponent) {
if (result === selector) {
return result;
}
} else {
if (Ext.ComponentQuery.is(result, selector)) {
return result;
}
}
// Stop when we hit the limit selector
if (limitSelector && result.is(limit)) {
return;
}
if (limitCount && steps === limit) {
return;
}
if (limitComponent && result === limit) {
return;
}
}
}
return result;
},

nextSibling: function(selector) {
var o = this.ownerCt, it, last, idx, c;
if (o) {
it = o.items;
idx = it.indexOf(this) + 1;
if (idx) {
if (selector) {
for (last = it.getCount(); idx < last; idx++) {
if ((c = it.getAt(idx)).is(selector)) {
return c;
}
}
} else {
if (idx < it.getCount()) {
return it.getAt(idx);
}
}
}
}
return null;
},

previousSibling: function(selector) {
var o = this.ownerCt, it, idx, c;
if (o) {
it = o.items;
idx = it.indexOf(this);
if (idx != -1) {
if (selector) {
for (--idx; idx >= 0; idx--) {
if ((c = it.getAt(idx)).is(selector)) {
return c;
}
}
} else {
if (idx) {
return it.getAt(--idx);
}
}
}
}
return null;
},

previousNode: function(selector, includeSelf) {
var node = this,
ownerCt = node.ownerCt,
result,
it, i, sib;
// If asked to include self, test me
if (includeSelf && node.is(selector)) {
return node;
}
if (ownerCt) {
for (it = ownerCt.items.items, i = Ext.Array.indexOf(it, node) - 1; i > -1; i--) {
sib = it[i];
if (sib.query) {
result = sib.query(selector);
result = result[result.length - 1];
if (result) {
return result;
}
}
if (sib.is(selector)) {
return sib;
}
}
return ownerCt.previousNode(selector, true);
}
return null;
},

nextNode: function(selector, includeSelf) {
var node = this,
ownerCt = node.ownerCt,
result,
it, len, i, sib;
// If asked to include self, test me
if (includeSelf && node.is(selector)) {
return node;
}
if (ownerCt) {
for (it = ownerCt.items.items, i = Ext.Array.indexOf(it, node) + 1, len = it.length; i < len; i++) {
sib = it[i];
if (sib.is(selector)) {
return sib;
}
if (sib.down) {
result = sib.down(selector);
if (result) {
return result;
}
}
}
return ownerCt.nextNode(selector);
}
return null;
},

getId : function() {
return this.id || (this.id = 'ext-comp-' + (this.getAutoId()));
},

getItemId : function() {
return this.itemId || this.id;
},

getEl : function() {
return this.el;
},

getTargetEl: function() {
return this.frameBody || this.el;
},


getOverflowEl: function(){
return this.getTargetEl();
},

getOverflowStyle: function() {
var me = this,
result = null,
ox, oy,
overflowStyle;
// Note to maintainer. To save on waves of testing, setting and defaulting, the code below
// rolls assignent statements into conditional test value expressiona and property object initializers.
// This avoids sprawling code. Maintain with care.
if (typeof me.autoScroll === 'boolean') {
result = {
overflow: overflowStyle = me.autoScroll ? 'auto' : ''
};
me.scrollFlags = {
overflowX: overflowStyle,
overflowY: overflowStyle,
x: true,
y: true,
both: true
};
} else {
ox = me.overflowX;
oy = me.overflowY;
if (ox !== undefined || oy !== undefined) {
result = {
'overflowX': ox = ox || '',
'overflowY': oy = oy || ''
};

me.scrollFlags = {
overflowX: ox,
overflowY: oy,
x: ox = (ox === 'auto' || ox === 'scroll'),
y: oy = (oy === 'auto' || oy === 'scroll'),
both: ox && oy
};
} else {
me.scrollFlags = {
overflowX: '',
overflowY: '',
x: false,
y: false,
both: false
};
}
}
// The scrollable container element must be non-statically positioned or IE6/7 will make
// positioned children stay in place rather than scrolling with the rest of the content
if (result && Ext.isIE7m) {
result.position = 'relative';
}
return result;
},

isXType: function(xtype, shallow) {
if (shallow) {
return this.xtype === xtype;
}
else {
return this.xtypesMap[xtype];
}
},

getXTypes: function() {
var self = this.self,
xtypes, parentPrototype, parentXtypes;
if (!self.xtypes) {
xtypes = [];
parentPrototype = this;
while (parentPrototype) {
parentXtypes = parentPrototype.xtypes;
if (parentXtypes !== undefined) {
xtypes.unshift.apply(xtypes, parentXtypes);
}
parentPrototype = parentPrototype.superclass;
}
self.xtypeChain = xtypes;
self.xtypes = xtypes.join('/');
}
return self.xtypes;
},

update : function(htmlOrData, loadScripts, cb) {
var me = this,
isData = (me.tpl && !Ext.isString(htmlOrData)),
el;
if (isData) {
me.data = htmlOrData;
} else {
me.html = Ext.isObject(htmlOrData) ? Ext.DomHelper.markup(htmlOrData) : htmlOrData;
}
if (me.rendered) {
el = me.isContainer ? me.layout.getRenderTarget() : me.getTargetEl();
if (isData) {
me.tpl[me.tplWriteMode](el, htmlOrData || {});
} else {
el.update(me.html, loadScripts, cb);
}
me.updateLayout();
}
},

setVisible : function(visible) {
return this[visible ? 'show': 'hide']();
},

isVisible: function(deep) {
var me = this,
hidden;
if (me.hidden || !me.rendered || me.isDestroyed) {
hidden = true;
} else if (deep) {
hidden = me.isHierarchicallyHidden();
}
return !hidden;
},
isHierarchicallyHidden: function() {
var child = this,
hidden = false,
parent, parentHierarchyState;
// It is possible for some components to be immune to collapse meaning the immune
// component remains visible when its direct parent is collapsed, e.g. panel header.
// Because of this, we must walk up the component hierarchy to determine the true
// visible state of the component.
for (; (parent = child.ownerCt || child.floatParent); child = parent) {
parentHierarchyState = parent.getHierarchyState();
if (parentHierarchyState.hidden) {
hidden = true;
break;
}
if (child.getHierarchyState().collapseImmune) {
// The child or one of its ancestors is immune to collapse.
if (parent.collapsed && !child.collapseImmune) {
// If the child's direct parent is collapsed, and the child
// itself does not have collapse immunity we know that
// the child is not visible.
hidden = true;
break;
}
} else {
// We have ascended the tree to a point where collapse immunity
// is not in play. This means if any anscestor above this point
// is collapsed, then the component is not visible.
hidden = !!parentHierarchyState.collapsed;
break;
}
}
return hidden;
},
onBoxReady: function(width, height) {
var me = this;
if (me.disableOnBoxReady) {
me.onDisable();
} else if (me.enableOnBoxReady) {
me.onEnable();
}
if (me.resizable) {
me.initResizable(me.resizable);
}
// Draggability must be initialized after resizability
// Because if we have to be wrapped, the resizer wrapper must be dragged as a pseudo-Component
if (me.draggable) {
me.initDraggable();
}

if (me.hasListeners.boxready) {
me.fireEvent('boxready', me, width, height);
}
},

enable: function(silent) {
var me = this;
delete me.disableOnBoxReady;
me.removeCls(me.disabledCls);
if (me.rendered) {
me.onEnable();
} else {
me.enableOnBoxReady = true;
}
me.disabled = false;
delete me.resetDisable;
if (silent !== true) {
me.fireEvent('enable', me);
}
return me;
},

disable: function(silent) {
var me = this;
delete me.enableOnBoxReady;
me.addCls(me.disabledCls);
if (me.rendered) {
me.onDisable();
} else {
me.disableOnBoxReady = true;
}
me.disabled = true;
if (silent !== true) {
delete me.resetDisable;
me.fireEvent('disable', me);
}
return me;
},

onEnable: function() {
if (this.maskOnDisable) {
this.el.dom.disabled = false;
this.unmask();
}
},

onDisable : function() {
var me = this,
focusCls = me.focusCls,
focusEl = me.getFocusEl();

if (focusCls && focusEl) {
focusEl.removeCls(me.removeClsWithUI(focusCls, true));
}

if (me.maskOnDisable) {
me.el.dom.disabled = true;
me.mask();
}
},
mask: function() {
var box = this.lastBox,
target = this.getMaskTarget(),
args = [];
// Pass it the height of our element if we know it.
if (box) {
args[2] = box.height;
}
target.mask.apply(target, args);
},
unmask: function() {
this.getMaskTarget().unmask();
},
getMaskTarget: function(){
return this.el;
},

isDisabled : function() {
return this.disabled;
},

setDisabled : function(disabled) {
return this[disabled ? 'disable': 'enable']();
},

isHidden : function() {
return this.hidden;
},

addCls : function(cls) {
var me = this,
el = me.rendered ? me.el : me.protoEl;
el.addCls.apply(el, arguments);
return me;
},

addClass : function() {
return this.addCls.apply(this, arguments);
},

hasCls: function (cls) {
var me = this,
el = me.rendered ? me.el : me.protoEl;
return el.hasCls.apply(el, arguments);
},

removeCls : function(cls) {
var me = this,
el = me.rendered ? me.el : me.protoEl;
el.removeCls.apply(el, arguments);
return me;
},
//<debug>
// @since 2.3.0
removeClass : function() {
if (Ext.isDefined(Ext.global.console)) {
Ext.global.console.warn('Ext.Component: removeClass has been deprecated. Please use removeCls.');
}
return this.removeCls.apply(this, arguments);
},
//</debug>
addOverCls: function() {
var me = this;
if (!me.disabled) {
me.el.addCls(me.overCls);
}
},
removeOverCls: function() {
this.el.removeCls(this.overCls);
},
addListener : function(element, listeners, scope, options) {
var me = this,
fn,
option;
if (Ext.isString(element) && (Ext.isObject(listeners) || options && options.element)) {
if (options.element) {
fn = listeners;
listeners = {};
listeners[element] = fn;
element = options.element;
if (scope) {
listeners.scope = scope;
}
for (option in options) {
if (options.hasOwnProperty(option)) {
if (me.eventOptionsRe.test(option)) {
listeners[option] = options[option];
}
}
}
}
// At this point we have a variable called element,
// and a listeners object that can be passed to on
if (me[element] && me[element].on) {
me.mon(me[element], listeners);
} else {
me.afterRenderEvents = me.afterRenderEvents || {};
if (!me.afterRenderEvents[element]) {
me.afterRenderEvents[element] = [];
}
me.afterRenderEvents[element].push(listeners);
}
return;
}
return me.mixins.observable.addListener.apply(me, arguments);
},
// inherit docs
removeManagedListenerItem: function(isClear, managedListener, item, ename, fn, scope){
var me = this,
element = managedListener.options ? managedListener.options.element : null;
if (element) {
element = me[element];
if (element && element.un) {
if (isClear || (managedListener.item === item && managedListener.ename === ename && (!fn || managedListener.fn === fn) && (!scope || managedListener.scope === scope))) {
element.un(managedListener.ename, managedListener.fn, managedListener.scope);
if (!isClear) {
Ext.Array.remove(me.managedListeners, managedListener);
}
}
}
} else {
return me.mixins.observable.removeManagedListenerItem.apply(me, arguments);
}
},

getBubbleTarget : function() {
return this.ownerCt;
},

isFloating : function() {
return this.floating;
},

isDraggable : function() {
return !!this.draggable;
},

isDroppable : function() {
return !!this.droppable;
},

onAdded : function(container, pos) {
var me = this;
me.ownerCt = container;
if (me.hierarchyState) {
// if component has a hierarchyState at this point we set an invalid flag in the
// hierarchy state so that descendants of this component know to re-initialize
// their hierarchyState the next time it is requested (see getHierarchyState())
me.hierarchyState.invalid = true;
// We can now delete the old hierarchyState since it is invalid. IMPORTANT:
// the descendants are still linked to the old hierarchy state via the
// prototype chain, and their heirarchyState property will be synced up 
// the next time their getHierarchyState() method is called. For this reason
// hierarchyState should always be accessed using getHierarchyState()
delete me.hierarchyState;
}
if (me.hasListeners.added) {
me.fireEvent('added', me, container, pos);
}
},

onRemoved : function(destroying) {
var me = this;
if (me.hasListeners.removed) {
me.fireEvent('removed', me, me.ownerCt);
}
delete me.ownerCt;
delete me.ownerLayout;
},

beforeDestroy : Ext.emptyFn,

onResize: function(width, height, oldWidth, oldHeight) {
var me = this;
// constrain is a config on Floating
if (me.floating && me.constrain) {
me.doConstrain();
}
if (me.hasListeners.resize) {
me.fireEvent('resize', me, width, height, oldWidth, oldHeight);
}
},

setSize : function(width, height) {
var me = this;
// support for standard size objects
if (width && typeof width == 'object') {
height = width.height;
width = width.width;
}
// Constrain within configured maxima
if (typeof width == 'number') {
me.width = Ext.Number.constrain(width, me.minWidth, me.maxWidth);
} else if (width === null) {
delete me.width;
}

if (typeof height == 'number') {
me.height = Ext.Number.constrain(height, me.minHeight, me.maxHeight);
} else if (height === null) {
delete me.height;
}
// If not rendered, all we need to is set the properties.
// The initial layout will set the size
if (me.rendered && me.isVisible()) {
// If we are changing size, then we are not the root.
me.updateLayout({
isRoot: false
});
}
return me;
},

isLayoutRoot: function() {
var me = this,
ownerLayout = me.ownerLayout;
// Return true if we have been explicitly flagged as the layout root, or if we are floating.
// Sometimes floating Components get an ownerCt ref injected into them which is *not* a true ownerCt, merely
// an upward link for reference purposes. For example a grid column menu is linked to the
// owning header via an ownerCt reference.
if (!ownerLayout || me._isLayoutRoot || me.floating) {
return true;
}
return ownerLayout.isItemLayoutRoot(me);
},

isLayoutSuspended: function () {
var comp = this,
ownerLayout;
while (comp) {
if (comp.layoutSuspendCount || comp.suspendLayout) {
return true;
}
ownerLayout = comp.ownerLayout;
if (!ownerLayout) {
break;
}
// TODO - what about suspending a Layout instance?
// this works better than ownerCt since ownerLayout means "is managed by" in
// the proper sense... some floating components have ownerCt but won't have an
// ownerLayout
comp = ownerLayout.owner;
}
return false;
},

updateLayout: function (options) {
var me = this,
defer,
lastBox = me.lastBox,
isRoot = options && options.isRoot;
if (lastBox) {
// remember that this component's last layout result is invalid and must be
// recalculated
lastBox.invalid = true;
}
if (!me.rendered || me.layoutSuspendCount || me.suspendLayout) {
return;
}
if (me.hidden) {
Ext.AbstractComponent.cancelLayout(me);
} else if (typeof isRoot != 'boolean') {
isRoot = me.isLayoutRoot();
}
// if we aren't the root, see if our ownerLayout will handle it...
if (isRoot || !me.ownerLayout || !me.ownerLayout.onContentChange(me)) {
// either we are the root or our ownerLayout doesn't care
if (!me.isLayoutSuspended()) {
// we aren't suspended (knew that), but neither is any of our ownerCt's...
defer = (options && options.hasOwnProperty('defer')) ? options.defer : me.deferLayouts;
Ext.AbstractComponent.updateLayout(me, defer);
}
}
},

getSizeModel: function (ownerCtSizeModel) {
var me = this,
models = Ext.layout.SizeModel,
ownerContext = me.componentLayout.ownerContext,
width = me.width,
height = me.height,
typeofWidth, typeofHeight,
hasPixelWidth, hasPixelHeight,
heightModel, ownerLayout, policy, shrinkWrap, topLevel, widthModel;
if (ownerContext) {
// If we are in the middle of a running layout, always report the current,
// dynamic size model rather than recompute it. This is not (only) a time
// saving thing, but a correctness thing since we cannot get the right answer
// otherwise.
widthModel = ownerContext.widthModel;
heightModel = ownerContext.heightModel;
}
if (!widthModel || !heightModel) {
hasPixelWidth = ((typeofWidth = typeof width) == 'number');
hasPixelHeight = ((typeofHeight = typeof height) == 'number');
topLevel = me.floating || !(ownerLayout = me.ownerLayout);
// Floating or no owner layout, e.g. rendered using renderTo
if (topLevel) {
policy = Ext.layout.Layout.prototype.autoSizePolicy;
shrinkWrap = me.floating ? 3 : me.shrinkWrap;
if (hasPixelWidth) {
widthModel = models.configured;
}
if (hasPixelHeight) {
heightModel = models.configured;
}
} else {
policy = ownerLayout.getItemSizePolicy(me, ownerCtSizeModel);
shrinkWrap = ownerLayout.isItemShrinkWrap(me);
}
if (ownerContext) {
ownerContext.ownerSizePolicy = policy;
}
shrinkWrap = (shrinkWrap === true) ? 3 : (shrinkWrap || 0); // false->0, true->3
// Now that we have shrinkWrap as a 0-3 value, we need to turn off shrinkWrap
// bits for any dimension that has a configured size not in pixels. These must
// be read from the DOM.
//
if (topLevel && shrinkWrap) {
if (width && typeofWidth == 'string') {
shrinkWrap &= 2; // percentage, "30em" or whatever - not width shrinkWrap
}
if (height && typeofHeight == 'string') {
shrinkWrap &= 1; // percentage, "30em" or whatever - not height shrinkWrap
}
}
if (shrinkWrap !== 3) {
if (!ownerCtSizeModel) {
ownerCtSizeModel = me.ownerCt && me.ownerCt.getSizeModel();
}
if (ownerCtSizeModel) {
shrinkWrap |= (ownerCtSizeModel.width.shrinkWrap ? 1 : 0) | (ownerCtSizeModel.height.shrinkWrap ? 2 : 0);
}
}
if (!widthModel) {
if (!policy.setsWidth) {
if (hasPixelWidth) {
widthModel = models.configured;
} else {
widthModel = (shrinkWrap & 1) ? models.shrinkWrap : models.natural;
}
} else if (policy.readsWidth) {
if (hasPixelWidth) {
widthModel = models.calculatedFromConfigured;
} else {
widthModel = (shrinkWrap & 1) ? models.calculatedFromShrinkWrap :
models.calculatedFromNatural;
}
} else {
widthModel = models.calculated;
}
}
if (!heightModel) {
if (!policy.setsHeight) {
if (hasPixelHeight) {
heightModel = models.configured;
} else {
heightModel = (shrinkWrap & 2) ? models.shrinkWrap : models.natural;
}
} else if (policy.readsHeight) {
if (hasPixelHeight) {
heightModel = models.calculatedFromConfigured;
} else {
heightModel = (shrinkWrap & 2) ? models.calculatedFromShrinkWrap :
models.calculatedFromNatural;
}
} else {
heightModel = models.calculated;
}
}
}
// We return one of the cached objects with the proper "width" and "height" as the
// sizeModels we have determined.
return widthModel.pairsByHeightOrdinal[heightModel.ordinal];
},
isDescendant: function(ancestor) {
if (ancestor.isContainer) {
for (var c = this.ownerCt; c; c = c.ownerCt) {
if (c === ancestor) {
return true;
}
}
}
return false;
},

doComponentLayout : function() {
this.updateLayout();
return this;
},

forceComponentLayout: function () {
this.updateLayout();
},
// @private
setComponentLayout : function(layout) {
var currentLayout = this.componentLayout;
if (currentLayout && currentLayout.isLayout && currentLayout != layout) {
currentLayout.setOwner(null);
}
this.componentLayout = layout;
layout.setOwner(this);
},
getComponentLayout : function() {
var me = this;
if (!me.componentLayout || !me.componentLayout.isLayout) {
me.setComponentLayout(Ext.layout.Layout.create(me.componentLayout, 'autocomponent'));
}
return me.componentLayout;
},

afterComponentLayout: function(width, height, oldWidth, oldHeight) {
var me = this;
if (++me.componentLayoutCounter === 1) {
me.afterFirstLayout(width, height);
}
if (width !== oldWidth || height !== oldHeight) {
me.onResize(width, height, oldWidth, oldHeight);
}
},

beforeComponentLayout: function(width, height) {
return true;
},

setPosition: function(x, y, animate) {
var me = this,
pos = me.beforeSetPosition.apply(me, arguments);
if (pos && me.rendered) {
x = pos.x;
y = pos.y;
if (animate) {
// Proceed only if the new position is different from the current
// one. We only do these DOM reads in the animate case as we don't
// want to incur the penalty of read/write on every call to setPosition
if (x !== me.getLocalX() || y !== me.getLocalY()) {
me.stopAnimation();
me.animate(Ext.apply({
duration: 1000,
listeners: {
afteranimate: Ext.Function.bind(me.afterSetPosition, me, [x, y])
},
to: {
x: x,
y: y
}
}, animate));
}
} else {
me.setLocalXY(x, y);
me.afterSetPosition(x, y);
}
}
return me;
},

beforeSetPosition: function (x, y, animate) {
var pos, x0;
// Decode members of x if x is an array or an object.
// If it is numeric (including zero), we need do nothing.
if (x) {
// Position in first argument as an array of [x, y]
if (Ext.isNumber(x0 = x[0])) {
animate = y;
y = x[1];
x = x0;
}
// Position in first argument as object w/ x & y properties
else if ((x0 = x.x) !== undefined) {
animate = y;
y = x.y;
x = x0;
}
}
if (this.constrain || this.constrainHeader) {
pos = this.calculateConstrainedPosition(null, [x, y], true);
if (pos) {
x = pos[0];
y = pos[1];
}
}
// Set up the return info and store the position in this object
pos = {
x : this.x = x,
y : this.y = y,
anim: animate,
hasX: x !== undefined,
hasY: y !== undefined
};
return (pos.hasX || pos.hasY) ? pos : null;
},

afterSetPosition: function(x, y) {
var me = this;
me.onPosition(x, y);
if (me.hasListeners.move) {
me.fireEvent('move', me, x, y);
}
},

onPosition: Ext.emptyFn,

setWidth : function(width) {
return this.setSize(width);
},

setHeight : function(height) {
return this.setSize(undefined, height);
},

getSize : function() {
return this.el.getSize();
},

getWidth : function() {
return this.el.getWidth();
},

getHeight : function() {
return this.el.getHeight();
},

getLoader: function(){
var me = this,
autoLoad = me.autoLoad ? (Ext.isObject(me.autoLoad) ? me.autoLoad : {url: me.autoLoad}) : null,
loader = me.loader || autoLoad;
if (loader) {
if (!loader.isLoader) {
me.loader = new Ext.ComponentLoader(Ext.apply({
target: me,
autoLoad: autoLoad
}, loader));
} else {
loader.setTarget(me);
}
return me.loader;
}
return null;
},

setDocked : function(dock, layoutParent) {
var me = this;
me.dock = dock;
if (layoutParent && me.ownerCt && me.rendered) {
me.ownerCt.updateLayout();
}
return me;
},

setBorder: function(border, targetEl) {
var me = this,
initial = !!targetEl;
if (me.rendered || initial) {
if (!initial) {
targetEl = me.el;
}
if (!border) {
border = 0;
} else if (border === true) {
border = '1px';
} else {
border = this.unitizeBox(border);
}
targetEl.setStyle('border-width', border);
if (!initial) {
me.updateLayout();
}
}
me.border = border;
},
onDestroy : function() {
var me = this;
if (me.monitorResize && Ext.EventManager.resizeEvent) {
Ext.EventManager.resizeEvent.removeListener(me.setSize, me);
}
// Destroying the floatingItems ZIndexManager will also destroy descendant floating Components
Ext.destroy(
me.componentLayout,
me.loadMask,
me.floatingDescendants
);
},

destroy : function() {
var me = this,
selectors = me.renderSelectors,
selector,
el;
if (!me.isDestroyed) {
if (!me.hasListeners.beforedestroy || me.fireEvent('beforedestroy', me) !== false) {
me.destroying = true;
me.beforeDestroy();
if (me.floating) {
delete me.floatParent;
// A zIndexManager is stamped into a *floating* Component when it is added to a Container.
// If it has no zIndexManager at render time, it is assigned to the global Ext.WindowManager instance.
if (me.zIndexManager) {
me.zIndexManager.unregister(me);
}
} else if (me.ownerCt && me.ownerCt.remove) {
me.ownerCt.remove(me, false);
}
me.stopAnimation();
me.onDestroy();
// Attempt to destroy all plugins
Ext.destroy(me.plugins);
if (me.hasListeners.destroy) {
me.fireEvent('destroy', me);
}
Ext.ComponentManager.unregister(me);
me.mixins.state.destroy.call(me);
me.clearListeners();
// make sure we clean up the element references after removing all events
if (me.rendered) {
if (!me.preserveElOnDestroy) {
me.el.remove();
}
me.mixins.elementCt.destroy.call(me); // removes childEls
if (selectors) {
for (selector in selectors) {
if (selectors.hasOwnProperty(selector)) {
el = me[selector];
if (el) { // in case any other code may have already removed it
delete me[selector];
el.remove();
}
}
}
}
delete me.el;
delete me.frameBody;
delete me.rendered;
}
me.destroying = false;
me.isDestroyed = true;
}
}
},

isDescendantOf: function(container) {
return !!this.findParentBy(function(p){
return p === container;
});
},

getHierarchyState: function (inner) {
var me = this,
hierarchyState = (inner && me.hierarchyStateInner) || me.hierarchyState,
ownerCt = me.ownerCt,
parent, layout, hierarchyStateInner, getInner;

if (!hierarchyState || hierarchyState.invalid) {
// Use upward navigational link, not ownerCt.
// 99% of the time, this will use ownerCt/floatParent.
// Certain floating components do not have an ownerCt, but they are still linked
// into a navigational hierarchy. The getRefOwner method normalizes these differences.
parent = me.getRefOwner();

if (ownerCt) {
// This will only be true if the item is a "child" of its owning container
// For example, a docked item will not get the inner hierarchy state
getInner = me.ownerLayout === ownerCt.layout;
}
me.hierarchyState = hierarchyState =
// chain this component's hierarchyState to that of its parent. If it
// doesn't have a parent, then chain to the rootHierarchyState. This is
// done so that when there is a viewport, all component's will inherit
// from its hierarchyState, even components that are not descendants of
// the viewport.
Ext.Object.chain(parent ? parent.getHierarchyState(getInner)
: Ext.rootHierarchyState);
me.initHierarchyState(hierarchyState);
if ((layout = me.componentLayout).initHierarchyState) {
layout.initHierarchyState(hierarchyState);
}
if (me.isContainer) {
me.hierarchyStateInner = hierarchyStateInner = Ext.Object.chain(hierarchyState);
layout = me.layout;
if (layout && layout.initHierarchyState) {
layout.initHierarchyState(hierarchyStateInner, hierarchyState);
}
if (inner) {
hierarchyState = hierarchyStateInner;
}
}
}
return hierarchyState;
},

initHierarchyState: function(hierarchyState) {
var me = this;
if (me.collapsed) {
hierarchyState.collapsed = true;
}
if (me.hidden) {
hierarchyState.hidden = true;
}
if (me.collapseImmune) {
hierarchyState.collapseImmune = true;
}
},
// **********************************************************************************
// Begin Positionable methods
// **********************************************************************************
getAnchorToXY: function(el, anchor, local, mySize) {
return el.getAnchorXY(anchor, local, mySize);
},
getBorderPadding: function() {
return this.el.getBorderPadding();
},
getLocalX: function() {
return this.el.getLocalX();
},
getLocalXY: function() {
return this.el.getLocalXY();
},
getLocalY: function() {
return this.el.getLocalY();
},
getX: function() {
return this.el.getX();
},
getXY: function() {
return this.el.getXY();
},
getY: function() {
return this.el.getY();
},
setLocalX: function(x) {
this.el.setLocalX(x);
},
setLocalXY: function(x, y) {
this.el.setLocalXY(x, y);
},
setLocalY: function(y) {
this.el.setLocalY(y);
},
setX: function(x, animate) {
this.el.setX(x, animate);
},
setXY: function(xy, animate) {
this.el.setXY(xy, animate);
},
setY: function(y, animate) {
this.el.setY(y, animate);
}
// **********************************************************************************
// End Positionable methods
// **********************************************************************************
}, function() {
var AbstractComponent = this;
AbstractComponent.createAlias({
on: 'addListener',
prev: 'previousSibling',
next: 'nextSibling'
});

Ext.resumeLayouts = function (flush) {
AbstractComponent.resumeLayouts(flush);
};

Ext.suspendLayouts = function () {
AbstractComponent.suspendLayouts();
};

Ext.batchLayouts = function(fn, scope) {
AbstractComponent.suspendLayouts();
// Invoke the function
fn.call(scope);
AbstractComponent.resumeLayouts(true);
};
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/dd/DragTracker.js */
(function(Ext) {
Ext.define('Ext.dd.DragTracker', {
uses: ['Ext.util.Region'],
mixins: {
observable: 'Ext.util.Observable'
},

active: false,


trackOver: false,



tolerance: 5,

autoStart: false,



constructor : function(config){
var me = this;
Ext.apply(me, config);
me.addEvents(

'mouseover',

'mouseout',

'mousedown',

'mouseup',

'mousemove',

'beforedragstart',

'dragstart',

'dragend',

'drag'
);
me.dragRegion = new Ext.util.Region(0,0,0,0);
if (me.el) {
me.initEl(me.el);
}
// Dont pass the config so that it is not applied to 'this' again
me.mixins.observable.constructor.call(me);
if (me.disabled) {
me.disable();
}
},

initEl: function(el) {
var me = this;
me.el = Ext.get(el);
// The delegate option may also be an element on which to listen
me.handle = Ext.get(me.delegate);
// If delegate specified an actual element to listen on, we do not use the delegate listener option
me.delegate = me.handle ? undefined : me.delegate;
if (!me.handle) {
me.handle = me.el;
}
// Add a mousedown listener which reacts only on the elements targeted by the delegate config.
// We process mousedown to begin tracking.
me.handleListeners = {
scope: me,
delegate: me.delegate,
mousedown: me.onMouseDown
};
// If configured to do so, track mouse entry and exit into the target (or delegate).
// The mouseover and mouseout CANNOT be replaced with mouseenter and mouseleave
// because delegate cannot work with those pseudoevents. Entry/exit checking is done in the handler.
if (me.trackOver || me.overCls) {
Ext.apply(me.handleListeners, {
mouseover: me.onMouseOver,
mouseout: me.onMouseOut
});
}
me.mon(me.handle, me.handleListeners);
},
disable: function() {
this.disabled = true;
},
enable: function() {
this.disabled = false;
},
destroy : function() {
var me = this;
if (me.active) {
// endDrag has a mandatory event parameter
me.endDrag({});
}
me.clearListeners();
me.mun(me.handle, me.handleListeners);
me.el = me.handle = null;
},
// When the pointer enters a tracking element, fire a mouseover if the mouse entered from outside.
// This is mouseenter functionality, but we cannot use mouseenter because we are using "delegate" to filter mouse targets
onMouseOver: function(e, target) {
var me = this;
if (!me.disabled) {
if (Ext.EventManager.contains(e) || me.delegate) {
me.mouseIsOut = false;
if (me.overCls) {
me.el.addCls(me.overCls);
}
me.fireEvent('mouseover', me, e, me.delegate ? e.getTarget(me.delegate, target) : me.handle);
}
}
},
// When the pointer exits a tracking element, fire a mouseout.
// This is mouseleave functionality, but we cannot use mouseleave because we are using "delegate" to filter mouse targets
onMouseOut: function(e) {
var me = this;
if (me.mouseIsDown) {
me.mouseIsOut = true;
} else {
if (me.overCls) {
me.el.removeCls(me.overCls);
}
me.fireEvent('mouseout', me, e);
}
},
onMouseDown: function(e, target){
var me = this,
el;
// If this is disabled, or the mousedown has been processed by an upstream DragTracker, return
if (me.disabled ||e.dragTracked) {
return;
}
// This information should be available in mousedown listener and onBeforeStart implementations
me.dragTarget = me.delegate ? target : me.handle.dom;
me.startXY = me.lastXY = e.getXY();
me.startRegion = Ext.fly(me.dragTarget).getRegion();
if (me.fireEvent('mousedown', me, e) === false ||
me.fireEvent('beforedragstart', me, e) === false ||
me.onBeforeStart(e) === false) {
return;
}
// Track when the mouse is down so that mouseouts while the mouse is down are not processed.
// The onMouseOut method will only ever be called after mouseup.
me.mouseIsDown = true;
// Flag for downstream DragTracker instances that the mouse is being tracked.
e.dragTracked = true;
// See Ext.dd.DragDropManager::handleMouseDown
el = me.el.dom;
if (Ext.isIE && el.setCapture) {
el.setCapture();
}
if (me.preventDefault !== false) {
e.preventDefault();
}
Ext.getDoc().on({
scope: me,
mouseup: me.onMouseUp,
mousemove: me.onMouseMove,
selectstart: me.stopSelect
});
if (me.autoStart) {
me.timer = Ext.defer(me.triggerStart, me.autoStart === true ? 1000 : me.autoStart, me, [e]);
}
},
onMouseMove: function(e, target){
var me = this,
xy = e.getXY(),
s = me.startXY;
e.preventDefault();
me.lastXY = xy;
if (!me.active) {
if (Math.max(Math.abs(s[0]-xy[0]), Math.abs(s[1]-xy[1])) > me.tolerance) {
me.triggerStart(e);
} else {
return;
}
}
// Returning false from a mousemove listener deactivates
if (me.fireEvent('mousemove', me, e) === false) {
me.onMouseUp(e);
} else {
me.onDrag(e);
me.fireEvent('drag', me, e);
}
},
onMouseUp: function(e) {
var me = this;
// Clear the flag which ensures onMouseOut fires only after the mouse button
// is lifted if the mouseout happens *during* a drag.
me.mouseIsDown = false;
// If we mouseouted the el *during* the drag, the onMouseOut method will not have fired. Ensure that it gets processed.
if (me.mouseIsOut) {
me.mouseIsOut = false;
me.onMouseOut(e);
}
e.preventDefault();
// See Ext.dd.DragDropManager::handleMouseDown
if (Ext.isIE && document.releaseCapture) {
document.releaseCapture();
}
me.fireEvent('mouseup', me, e);
me.endDrag(e);
},

endDrag: function(e) {
var me = this,
wasActive = me.active;
Ext.getDoc().un({
mousemove: me.onMouseMove,
mouseup: me.onMouseUp,
selectstart: me.stopSelect,
scope: me
});
me.clearStart();
me.active = false;
if (wasActive) {
me.onEnd(e);
me.fireEvent('dragend', me, e);
}
// Private property calculated when first required and only cached during a drag
// Remove flag from event singleton. Using "Ext.EventObject" here since "endDrag" is called directly in some cases without an "e" param
me._constrainRegion = Ext.EventObject.dragTracked = null
},
triggerStart: function(e) {
var me = this;
me.clearStart();
me.active = true;
me.onStart(e);
me.fireEvent('dragstart', me, e);
},
clearStart : function() {
var timer = this.timer;
if (timer) {
clearTimeout(timer);
this.timer = null;
}
},
stopSelect : function(e) {
e.stopEvent();
return false;
},

onBeforeStart : function(e) {
},

onStart : function(xy) {
},

onDrag : function(e) {
},

onEnd : function(e) {
},

getDragTarget : function(){
return this.dragTarget;
},

getDragCt : function(){
return this.el;
},

getConstrainRegion: function() {
var me = this;
if (me.constrainTo) {
if (me.constrainTo instanceof Ext.util.Region) {
return me.constrainTo;
}
if (!me._constrainRegion) {
me._constrainRegion = Ext.fly(me.constrainTo).getViewRegion();
}
} else {
if (!me._constrainRegion) {
me._constrainRegion = me.getDragCt().getViewRegion();
}
}
return me._constrainRegion;
},
getXY : function(constrain){
return constrain ? this.constrainModes[constrain](this, this.lastXY) : this.lastXY;
},

getOffset : function(constrain){
var xy = this.getXY(constrain),
s = this.startXY;
return [xy[0]-s[0], xy[1]-s[1]];
},
constrainModes: {
// Constrain the passed point to within the constrain region
point: function(me, xy) {
var dr = me.dragRegion,
constrainTo = me.getConstrainRegion();
// No constraint
if (!constrainTo) {
return xy;
}
dr.x = dr.left = dr[0] = dr.right = xy[0];
dr.y = dr.top = dr[1] = dr.bottom = xy[1];
dr.constrainTo(constrainTo);
return [dr.left, dr.top];
},
// Constrain the dragTarget to within the constrain region. Return the passed xy adjusted by the same delta.
dragTarget: function(me, xy) {
var s = me.startXY,
dr = me.startRegion.copy(),
constrainTo = me.getConstrainRegion(),
adjust;
// No constraint
if (!constrainTo) {
return xy;
}
// See where the passed XY would put the dragTarget if translated by the unconstrained offset.
// If it overflows, we constrain the passed XY to bring the potential
// region back within the boundary.
dr.translateBy(xy[0]-s[0], xy[1]-s[1]);
// Constrain the X coordinate by however much the dragTarget overflows
if (dr.right > constrainTo.right) {
xy[0] += adjust = (constrainTo.right - dr.right); // overflowed the right
dr.left += adjust;
}
if (dr.left < constrainTo.left) {
xy[0] += (constrainTo.left - dr.left); // overflowed the left
}
// Constrain the Y coordinate by however much the dragTarget overflows
if (dr.bottom > constrainTo.bottom) {
xy[1] += adjust = (constrainTo.bottom - dr.bottom); // overflowed the bottom
dr.top += adjust;
}
if (dr.top < constrainTo.top) {
xy[1] += (constrainTo.top - dr.top); // overflowed the top
}
return xy;
}
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/resizer/ResizeTracker.js */
(function(Ext) {
Ext.define('Ext.resizer.ResizeTracker', {
extend: 'Ext.dd.DragTracker',
dynamic: true,
preserveRatio: false,
// Default to no constraint
constrainTo: null,

proxyCls: Ext.baseCSSPrefix + 'resizable-proxy',
constructor: function(config) {
var me = this,
widthRatio, heightRatio,
throttledResizeFn;
if (!config.el) {
if (config.target.isComponent) {
me.el = config.target.getEl();
} else {
me.el = config.target;
}
}
this.callParent(arguments);
// Ensure that if we are preserving aspect ratio, the largest minimum is honoured
if (me.preserveRatio && me.minWidth && me.minHeight) {
widthRatio = me.minWidth / me.el.getWidth();
heightRatio = me.minHeight / me.el.getHeight();
// largest ratio of minimum:size must be preserved.
// So if a 400x200 pixel image has
// minWidth: 50, maxWidth: 50, the maxWidth will be 400 * (50/200)... that is 100
if (heightRatio > widthRatio) {
me.minWidth = me.el.getWidth() * heightRatio;
} else {
me.minHeight = me.el.getHeight() * widthRatio;
}
}
// If configured as throttled, create an instance version of resize which calls
// a throttled function to perform the resize operation.
if (me.throttle) {
throttledResizeFn = Ext.Function.createThrottled(function() {
Ext.resizer.ResizeTracker.prototype.resize.apply(me, arguments);
}, me.throttle);
me.resize = function(box, direction, atEnd) {
if (atEnd) {
Ext.resizer.ResizeTracker.prototype.resize.apply(me, arguments);
} else {
throttledResizeFn.apply(null, arguments);
}
};
}
},
onBeforeStart: function(e) {
// record the startBox
this.startBox = this.target.getBox();
},

getDynamicTarget: function() {
var me = this,
target = me.target;

if (me.dynamic) {
return target;
} else if (!me.proxy) {
me.proxy = me.createProxy(target);
}
me.proxy.show();
return me.proxy;
},

createProxy: function(target){
var proxy,
cls = this.proxyCls;
if (target.isComponent) {
proxy = target.getProxy().addCls(cls);
} else {
proxy = target.createProxy({
tag: 'div',
cls: cls,
id: target.id + '-rzproxy'
}, Ext.getBody());
}
proxy.removeCls(Ext.baseCSSPrefix + 'proxy-el');
return proxy;
},
onStart: function(e) {
// returns the Ext.ResizeHandle that the user started dragging
this.activeResizeHandle = Ext.get(this.getDragTarget().id);
// If we are using a proxy, ensure it is sized.
if (!this.dynamic) {
this.resize(this.startBox, {
horizontal: 'none',
vertical: 'none'
});
}
},
onDrag: function(e) {
// dynamic resizing, update dimensions during resize
if (this.dynamic || this.proxy) {
this.updateDimensions(e);
}
},
updateDimensions: function(e, atEnd) {
var me = this,
region = me.activeResizeHandle.region,
offset = me.getOffset(me.constrainTo ? 'dragTarget' : null),
box = me.startBox,
ratio,
widthAdjust = 0,
heightAdjust = 0,
snappedWidth,
snappedHeight,
adjustX = 0,
adjustY = 0,
dragRatio,
horizDir = offset[0] < 0 ? 'right' : 'left',
vertDir = offset[1] < 0 ? 'down' : 'up',
oppositeCorner,
axis, // 1 = x, 2 = y, 3 = x and y.
newBox,
newHeight, newWidth;
region = me.convertRegionName(region);
switch (region) {
case 'south':
heightAdjust = offset[1];
axis = 2;
break;
case 'north':
heightAdjust = -offset[1];
adjustY = -heightAdjust;
axis = 2;
break;
case 'east':
widthAdjust = offset[0];
axis = 1;
break;
case 'west':
widthAdjust = -offset[0];
adjustX = -widthAdjust;
axis = 1;
break;
case 'northeast':
heightAdjust = -offset[1];
adjustY = -heightAdjust;
widthAdjust = offset[0];
oppositeCorner = [box.x, box.y + box.height];
axis = 3;
break;
case 'southeast':
heightAdjust = offset[1];
widthAdjust = offset[0];
oppositeCorner = [box.x, box.y];
axis = 3;
break;
case 'southwest':
widthAdjust = -offset[0];
adjustX = -widthAdjust;
heightAdjust = offset[1];
oppositeCorner = [box.x + box.width, box.y];
axis = 3;
break;
case 'northwest':
heightAdjust = -offset[1];
adjustY = -heightAdjust;
widthAdjust = -offset[0];
adjustX = -widthAdjust;
oppositeCorner = [box.x + box.width, box.y + box.height];
axis = 3;
break;
}
newBox = {
width: box.width + widthAdjust,
height: box.height + heightAdjust,
x: box.x + adjustX,
y: box.y + adjustY
};
// Snap value between stops according to configured increments
snappedWidth = Ext.Number.snap(newBox.width, me.widthIncrement);
snappedHeight = Ext.Number.snap(newBox.height, me.heightIncrement);
if (snappedWidth != newBox.width || snappedHeight != newBox.height){
switch (region) {
case 'northeast':
newBox.y -= snappedHeight - newBox.height;
break;
case 'north':
newBox.y -= snappedHeight - newBox.height;
break;
case 'southwest':
newBox.x -= snappedWidth - newBox.width;
break;
case 'west':
newBox.x -= snappedWidth - newBox.width;
break;
case 'northwest':
newBox.x -= snappedWidth - newBox.width;
newBox.y -= snappedHeight - newBox.height;
}
newBox.width = snappedWidth;
newBox.height = snappedHeight;
}
// out of bounds
if (newBox.width < me.minWidth || newBox.width > me.maxWidth) {
newBox.width = Ext.Number.constrain(newBox.width, me.minWidth, me.maxWidth);
// Re-adjust the X position if we were dragging the west side
if (adjustX) {
newBox.x = box.x + (box.width - newBox.width);
}
} else {
me.lastX = newBox.x;
}
if (newBox.height < me.minHeight || newBox.height > me.maxHeight) {
newBox.height = Ext.Number.constrain(newBox.height, me.minHeight, me.maxHeight);
// Re-adjust the Y position if we were dragging the north side
if (adjustY) {
newBox.y = box.y + (box.height - newBox.height);
}
} else {
me.lastY = newBox.y;
}
// If this is configured to preserve the aspect ratio, or they are dragging using the shift key
if (me.preserveRatio || e.shiftKey) {
ratio = me.startBox.width / me.startBox.height;
// Calculate aspect ratio constrained values.
newHeight = Math.min(Math.max(me.minHeight, newBox.width / ratio), me.maxHeight);
newWidth = Math.min(Math.max(me.minWidth, newBox.height * ratio), me.maxWidth);
// X axis: width-only change, height must obey
if (axis == 1) {
newBox.height = newHeight;
}
// Y axis: height-only change, width must obey
else if (axis == 2) {
newBox.width = newWidth;
}
// Corner drag.
else {
// Drag ratio is the ratio of the mouse point from the opposite corner.
// Basically what edge we are dragging, a horizontal edge or a vertical edge.
dragRatio = Math.abs(oppositeCorner[0] - this.lastXY[0]) / Math.abs(oppositeCorner[1] - this.lastXY[1]);
// If drag ratio > aspect ratio then width is dominant and height must obey
if (dragRatio > ratio) {
newBox.height = newHeight;
} else {
newBox.width = newWidth;
}
// Handle dragging start coordinates
if (region == 'northeast') {
newBox.y = box.y - (newBox.height - box.height);
} else if (region == 'northwest') {
newBox.y = box.y - (newBox.height - box.height);
newBox.x = box.x - (newBox.width - box.width);
} else if (region == 'southwest') {
newBox.x = box.x - (newBox.width - box.width);
}
}
}
if (heightAdjust === 0) {
vertDir = 'none';
}
if (widthAdjust === 0) {
horizDir = 'none';
}
me.resize(newBox, {
horizontal: horizDir,
vertical: vertDir
}, atEnd);
},
getResizeTarget: function(atEnd) {
return atEnd ? this.target : this.getDynamicTarget();
},
resize: function(box, direction, atEnd) {
var me = this,
target = me.getResizeTarget(atEnd);
target.setBox(box);
// update the originalTarget if it was wrapped, and the target passed in was the wrap el.
if (me.originalTarget && (me.dynamic || atEnd)) {
me.originalTarget.setBox(box);
}
},
onEnd: function(e) {
this.updateDimensions(e, true);
if (this.proxy) {
this.proxy.hide();
}
},
convertRegionName: function(name) {
return name;
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/resizer/Resizer.js */
(function(Ext) {
Ext.define('Ext.resizer.Resizer', {
mixins: {
observable: 'Ext.util.Observable'
},
uses: ['Ext.resizer.ResizeTracker', 'Ext.Component'],
alternateClassName: 'Ext.Resizable',
handleCls: Ext.baseCSSPrefix + 'resizable-handle',
pinnedCls: Ext.baseCSSPrefix + 'resizable-pinned',
overCls: Ext.baseCSSPrefix + 'resizable-over',
wrapCls: Ext.baseCSSPrefix + 'resizable-wrap',
delimiterRe: /(?:\s*[,;]\s*)|\s+/,

dynamic: true,

handles: 's e se',

height : null,

width : null,

heightIncrement : 0,

widthIncrement : 0,

minHeight : 20,

minWidth : 20,

maxHeight : 10000,

maxWidth : 10000,

pinned: false,

preserveRatio: false,

transparent: false,

possiblePositions: {
n: 'north',
s: 'south',
e: 'east',
w: 'west',
se: 'southeast',
sw: 'southwest',
nw: 'northwest',
ne: 'northeast'
},


constructor: function(config) {
var me = this,
target,
targetEl,
tag,
handles = me.handles,
handleCls,
possibles,
len,
i = 0,
pos, 
handleEls = [],
eastWestStyle, style,
box, targetBaseCls,
unselectableCls = Ext.dom.Element.unselectableCls;
me.addEvents(

'beforeresize',

'resizedrag',

'resize'
);
if (Ext.isString(config) || Ext.isElement(config) || config.dom) {
target = config;
config = arguments[1] || {};
config.target = target;
}
// will apply config to this
me.mixins.observable.constructor.call(me, config);
// If target is a Component, ensure that we pull the element out.
// Resizer must examine the underlying Element.
target = me.target;
if (target) {
if (target.isComponent) {
// Resizable Components get a new UI class on them which makes them overflow:visible
// if the border width is non-zero and therefore the SASS has embedded the handles 
// in the borders using -ve position.
target.addClsWithUI('resizable');
me.el = target.getEl();
if (target.minWidth) {
me.minWidth = target.minWidth;
}
if (target.minHeight) {
me.minHeight = target.minHeight;
}
if (target.maxWidth) {
me.maxWidth = target.maxWidth;
}
if (target.maxHeight) {
me.maxHeight = target.maxHeight;
}
if (target.floating) {
if (!me.hasOwnProperty('handles')) {
me.handles = 'n ne e se s sw w nw';
}
}
} else {
me.el = me.target = Ext.get(target);
}
}
// Backwards compatibility with Ext3.x's Resizable which used el as a config.
else {
me.target = me.el = Ext.get(me.el);
}
// Tags like textarea and img cannot
// have children and therefore must
// be wrapped
tag = me.el.dom.tagName.toUpperCase();
if (tag == 'TEXTAREA' || tag == 'IMG' || tag == 'TABLE') {

me.originalTarget = me.target;
targetEl = me.el;
box = targetEl.getBox();
me.target = me.el = me.el.wrap({
cls: me.wrapCls,
id: me.el.id + '-rzwrap',
style: targetEl.getStyles('margin-top', 'margin-bottom')
});
// Transfer originalTarget's positioning+sizing+margins
me.el.setPositioning(targetEl.getPositioning());
targetEl.clearPositioning();
me.el.setBox(box);
// Position the wrapped element absolute so that it does not stretch the wrapper
targetEl.setStyle('position', 'absolute');
}
// Position the element, this enables us to absolute position
// the handles within this.el
me.el.position();
if (me.pinned) {
me.el.addCls(me.pinnedCls);
}

me.resizeTracker = new Ext.resizer.ResizeTracker({
disabled: me.disabled,
target: me.target,
constrainTo: me.constrainTo,
overCls: me.overCls,
throttle: me.throttle,
originalTarget: me.originalTarget,
delegate: '.' + me.handleCls,
dynamic: me.dynamic,
preserveRatio: me.preserveRatio,
heightIncrement: me.heightIncrement,
widthIncrement: me.widthIncrement,
minHeight: me.minHeight,
maxHeight: me.maxHeight,
minWidth: me.minWidth,
maxWidth: me.maxWidth
});
// Relay the ResizeTracker's superclass events as our own resize events
me.resizeTracker.on({
mousedown: me.onBeforeResize,
drag: me.onResize,
dragend: me.onResizeEnd,
scope: me
});
if (me.handles == 'all') {
me.handles = 'n s e w ne nw se sw';
}
handles = me.handles = me.handles.split(me.delimiterRe);
possibles = me.possiblePositions;
len = handles.length;
handleCls = me.handleCls + ' ' + me.handleCls + '-{0}';
if (me.target.isComponent) {
targetBaseCls = me.target.baseCls
handleCls += ' ' + targetBaseCls + '-handle ' + targetBaseCls + '-handle-{0}';
if (Ext.supports.CSS3BorderRadius) {
handleCls += ' ' + targetBaseCls + '-handle-{0}-br';
}
}
// Needs heighting on IE6!
eastWestStyle = Ext.isIE6 ? ' style="height:' + me.el.getHeight() + 'px"' : '';
for (; i < len; i++){
// if specified and possible, create
if (handles[i] && possibles[handles[i]]) {
pos = possibles[handles[i]];
if (pos === 'east' || pos === 'west') {
style = eastWestStyle;
} else {
style = '';
}
handleEls.push(
'<div id="', me.el.id, '-', pos, '-handle"',
' class="', Ext.String.format(handleCls, pos), ' ', unselectableCls, '"',
' unselectable="on"',
style,
'></div>'
);
}
}
Ext.DomHelper.append(me.el, handleEls.join(''));
// store a reference to each handle element in this.east, this.west, etc
for (i = 0; i < len; i++){
// if specified and possible, create
if (handles[i] && possibles[handles[i]]) {
pos = possibles[handles[i]];
me[pos] = me.el.getById(me.el.id + '-' + pos + '-handle');
me[pos].region = pos;
if (me.transparent) {
me[pos].setOpacity(0);
}
}
}
// Constrain within configured maxima
if (Ext.isNumber(me.width)) {
me.width = Ext.Number.constrain(me.width, me.minWidth, me.maxWidth);
}
if (Ext.isNumber(me.height)) {
me.height = Ext.Number.constrain(me.height, me.minHeight, me.maxHeight);
}
// Size the target (and originalTarget)
if (me.width !== null || me.height !== null) {
if (me.originalTarget) {
me.originalTarget.setWidth(me.width);
me.originalTarget.setHeight(me.height);
}
me.resizeTo(me.width, me.height);
}
me.forceHandlesHeight();
},
disable: function() {
this.resizeTracker.disable();
},
enable: function() {
this.resizeTracker.enable();
},

onBeforeResize: function(tracker, e) {
var box = this.el.getBox();
return this.fireEvent('beforeresize', this, box.width, box.height, e);
},

onResize: function(tracker, e) {
var me = this,
box = me.el.getBox();

me.forceHandlesHeight();
return me.fireEvent('resizedrag', me, box.width, box.height, e);
},

onResizeEnd: function(tracker, e) {
var me = this,
box = me.el.getBox();

me.forceHandlesHeight();
return me.fireEvent('resize', me, box.width, box.height, e);
},

resizeTo : function(width, height) {
var me = this;
me.target.setSize(width, height);
me.fireEvent('resize', me, width, height, null);
},

getEl : function() {
return this.el;
},

getTarget: function() {
return this.target;
},
destroy: function() {
var me = this,
i,
handles = me.handles,
len = handles.length,
positions = me.possiblePositions,
handle;
me.resizeTracker.destroy();
for (i = 0; i < len; i++) {
if (handle = me[positions[handles[i]]]) {
handle.remove();
}
}
},

forceHandlesHeight : function() {
var me = this,
handle;
if (Ext.isIE6) {
handle = me.east;
if (handle) {
handle.setHeight(me.el.getHeight());
}
handle = me.west;
if (handle) {
handle.setHeight(me.el.getHeight());
}
me.el.repaint();
}
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/util/ComponentDragger.js */
(function(Ext) {
Ext.define('Ext.util.ComponentDragger', {
extend: 'Ext.dd.DragTracker',



autoStart: 500,

constructor: function(comp, config) {
this.comp = comp;
this.initialConstrainTo = config.constrainTo;
this.callParent([ config ]);
},
onStart: function(e) {
var me = this,
comp = me.comp;
// Cache the start [X, Y] array
me.startPosition = comp.getXY();
// If client Component has a ghost method to show a lightweight version of itself
// then use that as a drag proxy unless configured to liveDrag.
if (comp.ghost && !comp.liveDrag) {
me.proxy = comp.ghost();
me.dragTarget = me.proxy.header.el;
}
// Set the constrainTo Region before we start dragging.
if (me.constrain || me.constrainDelegate) {
me.constrainTo = me.calculateConstrainRegion();
}
if (comp.beginDrag) {
comp.beginDrag();
}
},
calculateConstrainRegion: function() {
var me = this,
comp = me.comp,
constrainTo = me.initialConstrainTo,
constraintInsets = comp.constraintInsets,
constrainEl,
delegateRegion,
elRegion,
dragEl = me.proxy ? me.proxy.el : comp.el,
shadowSize = (!me.constrainDelegate && dragEl.shadow && comp.constrainShadow && !dragEl.shadowDisabled) ? dragEl.shadow.getShadowSize() : 0;
// The configured constrainTo might be a Region or an element
if (!(constrainTo instanceof Ext.util.Region)) {
constrainEl = Ext.fly(constrainTo);
constrainTo = constrainEl.getViewRegion();
// Do not allow to move into vertical scrollbar
constrainTo.right = constrainTo.left + constrainEl.dom.clientWidth;
} else {
// Create a clone so we don't modify the original
constrainTo = constrainTo.copy();
}
// Apply constraintInsets
if (constraintInsets) {
constraintInsets = Ext.isObject(constraintInsets) ? constraintInsets : Ext.Element.parseBox(constraintInsets);
constrainTo.adjust(constraintInsets.top, constraintInsets.right, constraintInsets.bottom, constraintInsets.length);
}
// Reduce the constrain region to allow for shadow
if (shadowSize) {
constrainTo.adjust(shadowSize[0], -shadowSize[1], -shadowSize[2], shadowSize[3]);
}
// If they only want to constrain the *delegate* to within the constrain region,
// adjust the region to be larger based on the insets of the delegate from the outer
// edges of the Component.
if (!me.constrainDelegate) {
delegateRegion = Ext.fly(me.dragTarget).getRegion();
elRegion = dragEl.getRegion();
constrainTo.adjust(
delegateRegion.top - elRegion.top,
delegateRegion.right - elRegion.right,
delegateRegion.bottom - elRegion.bottom,
delegateRegion.left - elRegion.left
);
}
return constrainTo;
},
// Move either the ghost Component or the target Component to its new position on drag
onDrag: function(e) {
var me = this,
comp = (me.proxy && !me.comp.liveDrag) ? me.proxy : me.comp,
offset = me.getOffset(me.constrain || me.constrainDelegate ? 'dragTarget' : null);
comp.setPagePosition(me.startPosition[0] + offset[0], me.startPosition[1] + offset[1]);
},
onEnd: function(e) {
var comp = this.comp;
if (comp.isDestroyed || comp.destroying) {
return;
}

if (this.proxy && !comp.liveDrag) {
comp.unghost();
}
if (comp.endDrag) {
comp.endDrag();
}
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/Component.js */
(function(Ext) {
Ext.define('Ext.Component', {

alias: ['widget.component', 'widget.box'],
extend: 'Ext.AbstractComponent',
uses: [
'Ext.util.DelayedTask',
'Ext.Layer',
'Ext.resizer.Resizer',
'Ext.util.ComponentDragger'
],
mixins: {
floating: 'Ext.util.Floating'
},
statics: {
// Collapse/expand directions
DIRECTION_TOP: 'top',
DIRECTION_RIGHT: 'right',
DIRECTION_BOTTOM: 'bottom',
DIRECTION_LEFT: 'left',
VERTICAL_DIRECTION_Re: /^(?:top|bottom)$/,
// RegExp whih specifies characters in an xtype which must be translated to '-' when generating auto IDs.
// This includes dot, comma and whitespace
INVALID_ID_CHARS_Re: /[\.,\s]/g
},



resizeHandles: 'all',




floating: false,


defaultAlign: 'tl-bl?',

toFrontOnShow: true,











hideMode: 'display',

offsetsCls: Ext.baseCSSPrefix + 'hide-offsets',
bubbleEvents: [],
defaultComponentLayoutType: 'autocomponent',
//renderTpl: new Ext.XTemplate(
// '<div id="{id}" class="{baseCls} {cls} {cmpCls}<tpl if="typeof ui !== \'undefined\'"> {uiBase}-{ui}</tpl>"<tpl if="typeof style !== \'undefined\'"> style="{style}"</tpl>></div>', {
// compiled: true,
// disableFormats: true
// }
//),

constructor: function(config) {
var me = this;
config = config || {};
if (config.initialConfig) {
// Being initialized from an Ext.Action instance...
if (config.isAction) {
me.baseAction = config;
}
config = config.initialConfig;
// component cloning / action set up
}
else if (config.tagName || config.dom || Ext.isString(config)) {
// element object
config = {
applyTo: config,
id: config.id || config
};
}
me.callParent([config]);
// If we were configured from an instance of Ext.Action, (or configured with a baseAction option),
// register this Component as one of its items
if (me.baseAction){
me.baseAction.addComponent(me);
}
},

initComponent: function() {
var me = this;
me.callParent();
if (me.listeners) {
me.on(me.listeners);
me.listeners = null; //change the value to remove any on prototype
}
me.enableBubble(me.bubbleEvents);
},
afterRender: function() {
var me = this;
me.callParent();
if (!(me.x && me.y) && (me.pageX || me.pageY)) {
me.setPagePosition(me.pageX, me.pageY);
}
},

setAutoScroll : function(scroll) {
var me = this;
me.autoScroll = !!scroll;
// Scrolling styles must be applied to Component's main element.
// Layouts which use an innerCt (Box layout), shrinkwrap the innerCt round overflowing content,
// so the innerCt must be scrolled by the container, it does not scroll content.
if (me.rendered) {
me.getOverflowEl().setStyle(me.getOverflowStyle());
}
me.updateLayout();
return me;
},

setOverflowXY: function(overflowX, overflowY) {
var me = this,
argCount = arguments.length;
if (argCount) {
me.overflowX = overflowX || '';
if (argCount > 1) {
me.overflowY = overflowY || '';
}
}
// Scrolling styles must be applied to Component's main element.
// Layouts which use an innerCt (Box layout), shrinkwrap the innerCt round overflowing content,
// so the innerCt must be scrolled by the container, it does not scroll content.
if (me.rendered) {
me.getOverflowEl().setStyle(me.getOverflowStyle());
}
me.updateLayout();
return me;
},
beforeRender: function () {
var me = this,
floating = me.floating,
cls;
if (floating) {
me.addCls(Ext.baseCSSPrefix + 'layer');
cls = floating.cls;
if (cls) {
me.addCls(cls);
}
}
return me.callParent();
},

beforeLayout: function(){
this.callParent(arguments);
if (this.floating) {
this.onBeforeFloatLayout();
} 
},

afterComponentLayout: function(){
this.callParent(arguments);
if (this.floating) {
this.onAfterFloatLayout();
}
},
// @private
makeFloating : function (dom) {
this.mixins.floating.constructor.call(this, dom);
},
wrapPrimaryEl: function (dom) {
if (this.floating) {
this.makeFloating(dom);
} else {
this.callParent(arguments);
}
},
initResizable: function(resizable) {
var me = this;
resizable = Ext.apply({
target: me,
dynamic: false,
constrainTo: me.constrainTo || (me.floatParent ? me.floatParent.getTargetEl() : null),
handles: me.resizeHandles
}, resizable);
resizable.target = me;
me.resizer = new Ext.resizer.Resizer(resizable);
},
getDragEl: function() {
return this.el;
},
initDraggable: function() {
var me = this,
// If we are resizable, and the resizer had to wrap this Component's el (eg an Img)
// Then we have to create a pseudo-Component out of the resizer to drag that,
// otherwise, we just drag this Component
dragTarget = (me.resizer && me.resizer.el !== me.el) ? me.resizerComponent = new Ext.Component({
el: me.resizer.el,
rendered: true,
container: me.container
}) : me,
ddConfig = Ext.applyIf({
el: dragTarget.getDragEl(),
constrainTo: (me.constrain||me.draggable.constrain) ? (me.constrainTo || (me.floatParent ? me.floatParent.getTargetEl() : me.container)) : undefined
}, me.draggable);
// Add extra configs if Component is specified to be constrained
if (me.constrain || me.constrainDelegate) {
ddConfig.constrain = me.constrain;
ddConfig.constrainDelegate = me.constrainDelegate;
}
me.dd = new Ext.util.ComponentDragger(dragTarget, ddConfig);
},

scrollBy: function(deltaX, deltaY, animate) {
var el;
if ((el = this.getTargetEl()) && el.dom) {
el.scrollBy.apply(el, arguments);
}
},

setLoading : function(load, targetEl) {
var me = this,
config = {
target: me
};
if (me.rendered) {
Ext.destroy(me.loadMask);
me.loadMask = null;
if (load !== false && !me.collapsed) {
if (Ext.isObject(load)) {
Ext.apply(config, load);
} else if (Ext.isString(load)) {
config.msg = load;
}

if (targetEl) {
Ext.applyIf(config, {
useTargetEl: true
});
}
me.loadMask = new Ext.LoadMask(config);
me.loadMask.show();
}
}
return me.loadMask;
},
beforeSetPosition: function () {
var me = this,
pos = me.callParent(arguments), // pass all args on for signature decoding
adj;
if (pos) {
adj = me.adjustPosition(pos.x, pos.y);
pos.x = adj.x;
pos.y = adj.y;
}
return pos || null;
},
afterSetPosition: function(ax, ay) {
this.onPosition(ax, ay);
this.fireEvent('move', this, ax, ay);
},

showAt: function(x, y, animate) {
var me = this;
// Not rendered, then animating to a position is meaningless,
// just set the x,y position and allow show's processing to work.
if (!me.rendered && (me.autoRender || me.floating)) {
me.x = x;
me.y = y;
return me.show();
}
if (me.floating) {
me.setPosition(x, y, animate);
} else {
me.setPagePosition(x, y, animate);
}
me.show();
},


showBy: function(cmp, pos, off) {
var me = this;

//<debug>
if (!me.floating) {
Ext.log.warn('Using showBy on a non-floating component');
return me;
}
//</debug>
if (me.floating && cmp) {
me.show();
// Show may have been vetoed
if (me.rendered && !me.hidden) {
// Align to Component or Element using alignTo because normal show methods
// are container-relative, and we must align to the requested element or
// Component:
me.alignTo(cmp, pos || me.defaultAlign, off);
}
}
return me;
},

setPagePosition: function(x, y, animate) {
var me = this,
p,
floatParentBox;
if (Ext.isArray(x)) {
y = x[1];
x = x[0];
}
me.pageX = x;
me.pageY = y;
if (me.floating) {
// Floating Components which are registered with a Container have to have their x and y properties made relative
if (me.isContainedFloater()) {
floatParentBox = me.floatParent.getTargetEl().getViewRegion();
if (Ext.isNumber(x) && Ext.isNumber(floatParentBox.left)) {
x -= floatParentBox.left;
}
if (Ext.isNumber(y) && Ext.isNumber(floatParentBox.top)) {
y -= floatParentBox.top;
}
} else {
p = me.el.translateXY(x, y);
x = p.x;
y = p.y;
}
me.setPosition(x, y, animate);
} else {
p = me.el.translateXY(x, y);
me.setPosition(p.x, p.y, animate);
}
return me;
},
// Utility method to determine if a Component is floating, and has an owning Container whose coordinate system
// it must be positioned in when using setPosition.
isContainedFloater: function() {
return (this.floating && this.floatParent);
},

updateBox : function(box){
this.setSize(box.width, box.height);
this.setPagePosition(box.x, box.y);
return this;
},
// Include margins
getOuterSize: function() {
var el = this.el;
return {
width: el.getWidth() + el.getMargin('lr'),
height: el.getHeight() + el.getMargin('tb')
};
},
// @private
adjustPosition: function(x, y) {
var me = this,
floatParentBox;
// Floating Components being positioned in their ownerCt have to be made absolute.
if (me.isContainedFloater()) {
floatParentBox = me.floatParent.getTargetEl().getViewRegion();
x += floatParentBox.left;
y += floatParentBox.top;
}
return {
x: x,
y: y
};
},

getPosition: function(local) {
var me = this,
xy,
isContainedFloater = me.isContainedFloater(),
floatParentBox;
// Local position for non-floaters means element's local position
if ((local === true) && !isContainedFloater) {
return [me.getLocalX(), me.getLocalY()];
}
xy = me.getXY();
// Local position for floaters means position relative to the container's target element
if ((local === true) && isContainedFloater) {
floatParentBox = me.floatParent.getTargetEl().getViewRegion();
xy[0] -= floatParentBox.left;
xy[1] -= floatParentBox.top;
}
return xy;
},
getId: function() {
var me = this,
xtype;
if (!me.id) {
xtype = me.getXType();
if (xtype) {
xtype = xtype.replace(Ext.Component.INVALID_ID_CHARS_Re, '-');
} else {
xtype = Ext.name.toLowerCase() + '-comp';
}
me.id = xtype + '-' + me.getAutoId();
}
return me.id;
},

show: function(animateTarget, cb, scope) {
var me = this,
rendered = me.rendered;
if (me.hierarchicallyHidden || (me.floating && !rendered && me.isHierarchicallyHidden())) {
// If this is a hierarchically hidden floating component, we need to stash
// the arguments to this call so that the call can be deferred until the next
// time syncHidden() is called.
if (!rendered) {
// If the component has not yet been rendered it requires special treatment.
// Normally, for rendered components we can just set the pendingShow property
// and syncHidden() listens to events in the hierarchyEventSource and calls
// show() when this component becomes hierarchically visible. However,
// if the component has not yet been rendered the hierarchy event listeners
// have not yet been attached (since Floating is initialized during the
// render phase. This means we have to initialize the hierarchy event
// listeners right now to ensure that the component will show itself when
// it becomes hierarchically visible. 
me.initHierarchyEvents();
}
// defer the show call until next syncHidden(), but ignore animateTarget.
if (arguments.length > 1) {
arguments[0] = null;
me.pendingShow = arguments;
} else {
me.pendingShow = true;
}
} else if (rendered && me.isVisible()) {
if (me.toFrontOnShow && me.floating) {
me.toFront();
}
} else {
if (me.fireEvent('beforeshow', me) !== false) {
me.hidden = false;
delete this.getHierarchyState().hidden;
// Render on first show if there is an autoRender config, or if this
// is a floater (Window, Menu, BoundList etc).

// We suspend layouts here because floaters/autoRenders
// will layout when onShow is called. If the render succeeded,
// the layout will be trigger inside onShow, so we don't flush
// in the first block. If, for some reason we couldn't render, then
// we resume layouts and force a flush because we don't know if something
// will force it.
Ext.suspendLayouts();
if (!rendered && (me.autoRender || me.floating)) {
me.doAutoRender();
rendered = me.rendered;
}

if (rendered) {
me.beforeShow();
Ext.resumeLayouts();
me.onShow.apply(me, arguments);
me.afterShow.apply(me, arguments);
} else {
Ext.resumeLayouts(true);
}
} else {
me.onShowVeto();
}
}
return me;
},

onShowVeto: Ext.emptyFn,

beforeShow: Ext.emptyFn,

onShow: function() {
var me = this;
me.el.show();
me.callParent(arguments);
// Constraining/containing element may have changed size while this Component was hidden
if (me.floating) {
if (me.maximized) {
me.fitContainer();
}
else if (me.constrain) {
me.doConstrain();
}
}
},

getAnimateTarget: function(target){
target = target || this.animateTarget;
if (target) {
target = target.isComponent ? target.getEl() : Ext.get(target);
}
return target || null;
},

afterShow: function(animateTarget, cb, scope) {
var me = this,
myEl = me.el,
fromBox,
toBox,
ghostPanel;
// Default to configured animate target if none passed
animateTarget = me.getAnimateTarget(animateTarget);
// Need to be able to ghost the Component
if (!me.ghost) {
animateTarget = null;
}
// If we're animating, kick of an animation of the ghost from the target to the *Element* current box
if (animateTarget) {
toBox = {
x: myEl.getX(),
y: myEl.getY(),
width: myEl.dom.offsetWidth,
height: myEl.dom.offsetHeight
};
fromBox = {
x: animateTarget.getX(),
y: animateTarget.getY(),
width: animateTarget.dom.offsetWidth,
height: animateTarget.dom.offsetHeight
};
myEl.addCls(me.offsetsCls);
ghostPanel = me.ghost();
ghostPanel.el.stopAnimation();
// Shunting it offscreen immediately, *before* the Animation class grabs it ensure no flicker.
ghostPanel.setX(-10000);
me.ghostBox = toBox;
ghostPanel.el.animate({
from: fromBox,
to: toBox,
listeners: {
afteranimate: function() {
delete ghostPanel.componentLayout.lastComponentSize;
me.unghost();
delete me.ghostBox;
myEl.removeCls(me.offsetsCls);
me.onShowComplete(cb, scope);
}
}
});
}
else {
me.onShowComplete(cb, scope);
}
me.fireHierarchyEvent('show');
},

onShowComplete: function(cb, scope) {
var me = this;
if (me.floating) {
me.toFront();
me.onFloatShow();
}
Ext.callback(cb, scope || me);
me.fireEvent('show', me);
delete me.hiddenByLayout;
},

hide: function(animateTarget, cb, scope) {
var me = this,
continueHide;
if (me.pendingShow) {
// If this is a hierarchically hidden floating component with a pending show
// hide() simply cancels the pending show.
delete me.pendingShow;
} if (!(me.rendered && !me.isVisible())) {
continueHide = (me.fireEvent('beforehide', me) !== false);
if (me.hierarchicallyHidden || continueHide) {
me.hidden = true;
me.getHierarchyState().hidden = true;
if (me.rendered) {
me.onHide.apply(me, arguments);
}
}
}
return me;
},

onHide: function(animateTarget, cb, scope) {
var me = this,
ghostPanel,
fromSize,
toBox;
// Default to configured animate target if none passed
animateTarget = me.getAnimateTarget(animateTarget);
// Need to be able to ghost the Component
if (!me.ghost) {
animateTarget = null;
}
// If we're animating, kick off an animation of the ghost down to the target
if (animateTarget) {
toBox = {
x: animateTarget.getX(),
y: animateTarget.getY(),
width: animateTarget.dom.offsetWidth,
height: animateTarget.dom.offsetHeight
};
ghostPanel = me.ghost();
ghostPanel.el.stopAnimation();
fromSize = me.getSize();
ghostPanel.el.animate({
to: toBox,
listeners: {
afteranimate: function() {
delete ghostPanel.componentLayout.lastComponentSize;
ghostPanel.el.hide();
ghostPanel.el.setSize(fromSize);
me.afterHide(cb, scope);
}
}
});
}
me.el.hide();
if (!animateTarget) {
me.afterHide(cb, scope);
}
},

afterHide: function(cb, scope) {
var me = this,
activeEl = Ext.Element.getActiveElement();
me.hiddenByLayout = null;
// we are the back-end method of onHide at this level, but our call to our parent
// may need to be async... so callParent won't quite work here...
Ext.AbstractComponent.prototype.onHide.call(me);
// If hiding a Component which is focused, or contains focus: blur the focused el. 
if (activeEl === me.el || me.el.contains(activeEl)) {
Ext.fly(activeEl).blur();
}
Ext.callback(cb, scope || me);
me.fireEvent('hide', me);
me.fireHierarchyEvent('hide');
},

onDestroy: function() {
var me = this;
// Ensure that any ancillary components are destroyed.
if (me.rendered) {
Ext.destroy(
me.dd,
me.resizer,
me.proxy,
me.proxyWrap,
me.resizerComponent
);
}
delete me.focusTask;
me.callParent();
},
deleteMembers: function() {
var args = arguments,
len = args.length,
i = 0;
for (; i < len; ++i) {
delete this[args[i]];
}
},

focus: function(selectText, delay, callback, scope) {
var me = this,
focusEl,
focusElDom,
containerScrollTop;
// If delay is wanted, queue a call to this function.
if (delay) {
if (!me.focusTask) {
// One global DelayedTask to assign focus
// So that the last focus call wins.
Ext.Component.prototype.focusTask = new Ext.util.DelayedTask(me.focus);
}
me.focusTask.delay(Ext.isNumber(delay) ? delay : 10, null, me, [selectText, false, callback, scope]);
return me;
}
// An immediate focus call must cancel any outstanding delayed focus calls.
if (me.focusTask) {
me.focusTask.cancel();
}
if (me.rendered && !me.isDestroyed && me.isVisible(true) && (focusEl = me.getFocusEl())) {
// getFocusEl might return a Component if a Container wishes to delegate focus to a descendant.
// Window can do this via its defaultFocus configuration which can reference a Button.
if (focusEl.isComponent) {
return focusEl.focus(selectText, delay);
}
// If it was an Element with a dom property
if ((focusElDom = focusEl.dom)) {
// Not a natural focus holding element, add a tab index to make it programatically focusable.
if (focusEl.needsTabIndex()) {
focusElDom.tabIndex = -1;
}
if (me.floating) {
containerScrollTop = me.container.dom.scrollTop;
}
// Focus the element.
// The focusEl has a DOM focus listener on it which invokes the Component's onFocus method
// to perform Component-specific focus processing
focusEl.focus();
if (selectText === true) {
focusElDom.select();
}
// Call the callback when focus is done
Ext.callback(callback, scope);
}
// Focusing a floating Component brings it to the front of its stack.
// this is performed by its zIndexManager. Pass preventFocus true to avoid recursion.
if (me.floating) {
me.toFront(true);
if (containerScrollTop !== undefined) {
me.container.dom.scrollTop = containerScrollTop;
}
}
}
return me;
},

cancelFocus: function() {
var task = this.focusTask;
if (task) {
task.cancel();
}
},
// @private
blur: function() {
var focusEl;
if (this.rendered && (focusEl = this.getFocusEl())) {
focusEl.blur();
}
return this;
},
getEl: function() {
return this.el;
},
// Deprecate 5.0
getResizeEl: function() {
return this.el;
},
// Deprecate 5.0
getPositionEl: function() {
return this.el;
},
// Deprecate 5.0
getActionEl: function() {
return this.el;
},
// Deprecate 5.0
getVisibilityEl: function() {
return this.el;
},

getRefOwner: function() {
return this.ownerCt || this.floatParent;
},

getBubbleTarget: function() {
return this.getRefOwner();
},
// @private
getContentTarget: function() {
return this.el;
},

cloneConfig: function(overrides) {
overrides = overrides || {};
var id = overrides.id || Ext.id(),
cfg = Ext.applyIf(overrides, this.initialConfig),
self;
cfg.id = id;
self = Ext.getClass(this);
// prevent dup id
return new self(cfg);
},

getXType: function() {
return this.self.xtype;
},

findParentBy: function(fn) {
var p;
// Iterate up the ownerCt chain until there's no ownerCt, or we find an ancestor which matches using the selector function.
for (p = this.getBubbleTarget(); p && !fn(p, this); p = p.getBubbleTarget()) {
// do nothing
}
return p || null;
},

findParentByType: function(xtype) {
return Ext.isFunction(xtype) ?
this.findParentBy(function(p) {
return p.constructor === xtype;
})
:
this.up(xtype);
},

bubble: function(fn, scope, args) {
var p = this;
while (p) {
if (fn.apply(scope || p, args || [p]) === false) {
break;
}
p = p.getBubbleTarget();
}
return this;
},
getProxy: function() {
var me = this,
target;
if (!me.proxy) {
target = Ext.getBody();
me.proxy = me.el.createProxy(Ext.baseCSSPrefix + 'proxy-el', target, true);
}
return me.proxy;
},

fireHierarchyEvent: function (ename) {
this.hierarchyEventSource.fireEvent(ename, this);
},
onAdded: function() {
this.callParent(arguments);
if (this.hierarchyEventSource.hasListeners.added) {
this.fireHierarchyEvent('added');
}
}
}, function () {

this.hierarchyEventSource = this.prototype.hierarchyEventSource = new Ext.util.Observable({ events: {
hide: true,
show: true,
collapse: true,
expand: true,
added: true
}});
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/layout/container/Container.js */
(function(Ext) {
Ext.define('Ext.layout.container.Container', {

alias: ['layout.container'],
extend: 'Ext.layout.Layout',
alternateClassName: 'Ext.layout.ContainerLayout',
mixins: {
elementCt: 'Ext.util.ElementContainer'
},
requires: [
'Ext.XTemplate'
],
type: 'container',



beginCollapse: Ext.emptyFn,

beginExpand: Ext.emptyFn,

animatePolicy: null,
childEls: [

'overflowPadderEl'
],
renderTpl: [
'{%this.renderBody(out,values)%}'
],
usesContainerHeight: true,
usesContainerWidth: true,
usesHeight: true,
usesWidth: true,
constructor: function () {
this.callParent(arguments);
this.mixins.elementCt.constructor.call(this);
},
destroy : function() {
this.callParent();
this.mixins.elementCt.destroy.call(this);
},

beginLayout: function (ownerContext) {
this.callParent(arguments);
ownerContext.targetContext = ownerContext.paddingContext = ownerContext.getEl('getTarget', this);
this.cacheChildItems(ownerContext);
},
beginLayoutCycle: function (ownerContext, firstCycle) {
var me = this;
me.callParent(arguments);
if (firstCycle) {
if (me.usesContainerHeight) {
++ownerContext.consumersContainerHeight;
}
if (me.usesContainerWidth) {
++ownerContext.consumersContainerWidth;
}
}
},
cacheChildItems: function (ownerContext) {
var context = ownerContext.context,
childItems = [],
items = this.getVisibleItems(),
length = items.length,
i;
ownerContext.childItems = childItems;
ownerContext.visibleItems = items;
for (i = 0; i < length; ++i) {
childItems.push(context.getCmp(items[i]));
}
},
cacheElements: function () {
var owner = this.owner;
this.applyChildEls(owner.el, owner.id); // from ElementContainer mixin
},

configureItem: function(item) {
var me = this,
itemCls = me.itemCls,
ownerItemCls = me.owner.itemCls,
addClasses;
// Effectively callParent but without the function overhead
item.ownerLayout = me;
if (itemCls) {
// itemCls can be a single clas or an array
addClasses = typeof itemCls === 'string' ? [itemCls] : itemCls;
}
if (ownerItemCls) {
addClasses = Ext.Array.push(addClasses||[], ownerItemCls);
}
if (addClasses) {
item.addCls(addClasses);
}
},
doRenderBody: function (out, renderData) {
// Careful! This method is bolted on to the renderTpl so all we get for context is
// the renderData! The "this" pointer is the renderTpl instance!
this.renderItems(out, renderData);
this.renderContent(out, renderData);
},
doRenderContainer: function (out, renderData) {
// Careful! This method is bolted on to the renderTpl so all we get for context is
// the renderData! The "this" pointer is the renderTpl instance!
var me = renderData.$comp.layout,
tpl = me.getRenderTpl(),
data = me.getRenderData();
tpl.applyOut(data, out);
},
doRenderItems: function (out, renderData) {
// Careful! This method is bolted on to the renderTpl so all we get for context is
// the renderData! The "this" pointer is the renderTpl instance!
var me = renderData.$layout,
tree = me.getRenderTree();
if (tree) {
Ext.DomHelper.generateMarkup(tree, out);
}
},
finishRender: function () {
var me = this,
target, items;
me.callParent();
me.cacheElements();
target = me.getRenderTarget();
items = me.getLayoutItems();
//<debug>
if (me.targetCls && !me.getTarget().hasCls(me.targetCls)) {
Ext.log.warn('targetCls is missing. This may mean that getTargetEl() is being overridden but not applyTargetCls(). ' + me.owner.id);
}
//</debug>
me.finishRenderItems(target, items);
},

notifyOwner: function() {
this.owner.afterLayout(this);
},

getContainerSize : function(ownerContext, inDom) {
// Subtle But Important:
// 
// We don't want to call getProp/hasProp et.al. unless we in fact need that value
// for our results! If we call it and don't need it, the layout manager will think
// we depend on it and will schedule us again should it change.
var targetContext = ownerContext.targetContext,
frameInfo = targetContext.getFrameInfo(),
padding = ownerContext.paddingContext.getPaddingInfo(),
got = 0,
needed = 0,
gotWidth, gotHeight, width, height;
// In an shrinkWrap width/height case, we must not ask for any of these dimensions
// because they will be determined by contentWidth/Height which is calculated by
// this layout...
// Fit/Card layouts are able to set just the width of children, allowing child's
// resulting height to autosize the Container.
// See examples/tabs/tabs.html for an example of this.
if (!ownerContext.widthModel.shrinkWrap) {
++needed;
width = inDom ? targetContext.getDomProp('width') : targetContext.getProp('width');
gotWidth = (typeof width == 'number');
if (gotWidth) {
++got;
width -= frameInfo.width + padding.width;
if (width < 0) {
width = 0;
}
}
}
if (!ownerContext.heightModel.shrinkWrap) {
++needed;
height = inDom ? targetContext.getDomProp('height') : targetContext.getProp('height');
gotHeight = (typeof height == 'number');
if (gotHeight) {
++got;
height -= frameInfo.height + padding.height;
if (height < 0) {
height = 0;
}
}
}
return {
width: width,
height: height,
needed: needed,
got: got,
gotAll: got == needed,
gotWidth: gotWidth,
gotHeight: gotHeight
};
},

// This method is used to offset the DOM position when checking
// whether the element is a certain child of the target. This is
// required in cases where the extra elements prepended to the target
// before any of the items. An example of this is when using labelAlign: 'top'
// on a field. The label appears first in the DOM before any child items are
// created, so when we check the position we need to add an extra offset.
// Containers that create an innerCt are exempt because this new element
// preserves the order
getPositionOffset: function(position) {
if (!this.createsInnerCt) {
var offset = this.owner.itemNodeOffset;
if (offset) {
position += offset;
}
}
return position;
},

getLayoutItems: function() {
var owner = this.owner,
items = owner && owner.items;
return (items && items.items) || [];
},
getRenderData: function () {
var comp = this.owner;
return {
$comp: comp,
$layout: this,
ownerId: comp.id
};
},

getRenderedItems: function() {
var me = this,
target = me.getRenderTarget(),
items = me.getLayoutItems(),
ln = items.length,
renderedItems = [],
i, item;
for (i = 0; i < ln; i++) {
item = items[i];
if (item.rendered && me.isValidParent(item, target, i)) {
renderedItems.push(item);
}
}
return renderedItems;
},

getRenderTarget: function() {
return this.owner.getTargetEl();
},

getElementTarget: function() {
return this.getRenderTarget();
},
getRenderTpl: function () {
var me = this,
renderTpl = Ext.XTemplate.getTpl(this, 'renderTpl');
// Make sure all standard callout methods for the owner component are placed on the
// XTemplate instance (but only once please):
if (!renderTpl.renderContent) {
me.owner.setupRenderTpl(renderTpl);
}
return renderTpl;
},
getRenderTree: function () {
var result,
items = this.owner.items,
itemsGen,
renderCfgs = {};

do {
itemsGen = items.generation;
result = this.getItemsRenderTree(this.getLayoutItems(), renderCfgs);
} while (items.generation !== itemsGen);
return result;
},

renderChildren: function () {
var me = this,
ownerItems = me.owner.items,
target = me.getRenderTarget(),
itemsGen, items;

// During the render phase, new items may be added. Specifically, a panel will
// create a placeholder component during render if required, so we need to catch
// it here so we can render it.
do {
itemsGen = ownerItems.generation;
items = me.getLayoutItems();
me.renderItems(items, target);
} while (ownerItems.generation !== itemsGen);
},
getScrollbarsNeeded: function (width, height, contentWidth, contentHeight) {
var scrollbarSize = Ext.getScrollbarSize(),
hasWidth = typeof width == 'number',
hasHeight = typeof height == 'number',
needHorz = 0,
needVert = 0;
// No space-consuming scrollbars.
if (!scrollbarSize.width) {
return 0;
}
if (hasHeight && height < contentHeight) {
needVert = 2;
width -= scrollbarSize.width;
}
if (hasWidth && width < contentWidth) {
needHorz = 1;
if (!needVert && hasHeight) {
height -= scrollbarSize.height;
if (height < contentHeight) {
needVert = 2;
}
}
}
return needVert + needHorz;
},

getTarget: function() {
return this.owner.getTargetEl();
},

getVisibleItems: function() {
var target = this.getRenderTarget(),
items = this.getLayoutItems(),
ln = items.length,
visibleItems = [],
i, item;
for (i = 0; i < ln; i++) {
item = items[i];
if (item.rendered && this.isValidParent(item, target, i) && item.hidden !== true) {
visibleItems.push(item);
}
}
return visibleItems;
},
setupRenderTpl: function (renderTpl) {
var me = this;
renderTpl.renderBody = me.doRenderBody;
renderTpl.renderContainer = me.doRenderContainer;
renderTpl.renderItems = me.doRenderItems;
},

getContentTarget: function(){
return this.owner.getDefaultContentTarget();
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/layout/container/Auto.js */
(function(Ext) {
Ext.define('Ext.layout.container.Auto', {

alias: ['layout.auto', 'layout.autocontainer'],
extend: 'Ext.layout.container.Container',

type: 'autocontainer',
childEls: [
'outerCt',
'innerCt',
'clearEl'
],

reserveScrollbar: false,

managePadding: true,

manageOverflow: false,
// Begin with no previous adjustments
lastOverflowAdjust: {
width: 0,
height: 0
},
// Auto layout's renderTpl wraps the content in an outerCt which is used to accomplish
// the following 3 goals:
// 
// 1. When the container has a shrink wrapped width and/or height, the outerCt is used
// to measure the size of the content.
// 2. When the container has overflow some browsers lose the container's right and/or
// bottom padding. To fix this, the padding is rendered to the outerCt instead of
// the container target element. This ensures that the padding is included in the 
// container's scrollWidth/scrollHeight. In Old IE when a table is used, the padding
// is rendered to the innerCt td element.
// 3. The outerCt contains the margins of its children, that is to say, it prevents
// them from collapsing.
renderTpl: [
'{% if (!(Ext.isIEQuirks || Ext.isIE7m)) { %}',
// All browsers that support display:table use this template.
// An outerCt with display:table shrink-wraps contents, and contains child
// margins. The table-cell innerCt is required in order to support percentage
// heights on child elements. Originally the outerCt started out as a div, but
// was changed to a span to work around an obscure firefox 3.6 bug where
// placing a Container inside of a fieldset's legend element causes the legend
// to blow up if the outerCt is a div.
'<span id="{ownerId}-outerCt" style="display:table;">',
// height:100% is required on the innerCt in order for percentage-height
// children to work in IE, firefox, and opera
'<div id="{ownerId}-innerCt" style="display:table-cell;height:100%;',
'vertical-align:top;{%this.renderPadding(out, values)%}" class="{innerCtCls}">',
'{%this.renderBody(out,values)%}',
'</div>',
'</span>',
'{% } else if (values.shrinkWrapWidth) { %}',
// If the containers width is shrink wrapped a table-based outerCt/innerCt
// is required in old IE. See getRenderData() for more details on the criteria
// used to determine if the container has shrink wrapped width.
'<table id="{ownerId}-outerCt" class="' + Ext.plainTableCls + '">',
'<tr>',
'<td id="{ownerId}-innerCt" style="vertical-align:top;padding:0;',
'{%this.renderPadding(out, values)%}" class="{innerCtCls}">',
'{%this.renderBody(out,values)%}',
// clear element to contain the bottom margin of floated last child item
'<div id="{ownerId}-clearEl" class="', Ext.baseCSSPrefix, 'clear"',
'role="presentation"></div>',
'</td>',
'</tr>',
'</table>',
'{% } else { %}',
// If the container's width is not shrink wrapped, old IE can get by with
// divs as the outerCt/innerCt. zoom:1 is required to contain the margins
// of children. The padding is placed on the outerCt instead of the innerCt.
// This is to because if the padding was placed on the innerCt, the top
// margin of the first child item would collapse into the top padding of
// the innerCt.
'<div id="{ownerId}-outerCt" style="zoom:1;{%this.renderPadding(out, values)%}">',
'<div id="{ownerId}-innerCt" style="zoom:1;height:100%;" class="{innerCtCls}">',
'{%this.renderBody(out,values)%}',
// clear element to contain the bottom margin of floated last child item
'<div id="{ownerId}-clearEl" class="', Ext.baseCSSPrefix, 'clear"',
'role="presentation"></div>',
'</div>',
'</div>',
// set a flag that indicates we are not using a "shrink wrap" template
'{% values.$layout.isShrinkWrapTpl = false %}',
'{% } %}'
],
// This template is used for dynamically inserting a table outerCt/innerCt when needed.
// It should be identical to the table template defined in renderTpl except that it
// does not have renderBody or clearEl. It is an empty shell so that the contents
// of an already existing innerCt can be moved into it.
tableTpl: [
'<table id="{ownerId}-outerCt" class="' + Ext.plainTableCls + '">',
'<tr>',
'<td id="{ownerId}-innerCt" style="vertical-align:top;padding:0;',
'{%this.renderPadding(out, values)%}" class="{innerCtCls}">',
'</td>',
'</tr>',
'</table>'
],
isShrinkWrapTpl: true,
beginLayout: function(ownerContext) {
var me = this,
bottomPadding, overflowYStyle, overflowXStyle, needsTable;

me.callParent(arguments);
me.initContextItems(ownerContext);
if (!me.isShrinkWrapTpl) {
// In most cases the determination to use a table based template is made at
// render time; however, if the initial determination was incorrect, we may
// need to dynamically replace the existing outerCt/innerCt with a table
// (see insertTableCt)
if (ownerContext.widthModel.shrinkWrap) {
needsTable = true;
}
// in IE7 strict right padding is lost when there is horizontal overflow
// unless the outerCt is a table.
if (Ext.isStrict && Ext.isIE7) {
overflowXStyle = me.getOverflowXStyle(ownerContext);
if ((overflowXStyle === 'auto' || overflowXStyle === 'scroll') &&
ownerContext.paddingContext.getPaddingInfo().right) {
needsTable = true;
}
}
if (needsTable) {
me.insertTableCt(ownerContext);
}
}
// When using the non-table renderTpl IE7 strict loses bottom padding if there
// is vertical overflow. To adjust for the loss of padding, we add the bottom
// padding to the height of the clearEl
if (!me.isShrinkWrapTpl && Ext.isIE7 && Ext.isStrict && !me.clearElHasPadding) {
bottomPadding = ownerContext.paddingContext.getPaddingInfo().bottom;
overflowYStyle = me.getOverflowYStyle(ownerContext);
if (bottomPadding && (overflowYStyle === 'auto' || overflowYStyle === 'scroll')) {
me.clearEl.setStyle('height', bottomPadding);
me.clearElHasPadding = true;
}
}
},

beforeLayoutCycle: function(ownerContext){
var comp = this.owner,
hierarchyState = comp.hierarchyState,
hierarchyStateInner = comp.hierarchyStateInner;
if (!hierarchyState || hierarchyState.invalid) {
hierarchyState = comp.getHierarchyState(); // fixes both
hierarchyStateInner = comp.hierarchyStateInner;
}
if (ownerContext.widthModel.shrinkWrap && this.isShrinkWrapTpl) {
hierarchyStateInner.inShrinkWrapTable = true;
} else {
delete hierarchyStateInner.inShrinkWrapTable;
}
},
beginLayoutCycle: function(ownerContext) {
var me = this,
outerCt = me.outerCt,
lastOuterCtWidth = me.lastOuterCtWidth || '',
lastOuterCtHeight = me.lastOuterCtHeight || '',
lastOuterCtTableLayout = me.lastOuterCtTableLayout || '',
state = ownerContext.state,
overflowXStyle, overflowYStyle, outerCtWidth, outerCtHeight, outerCtTableLayout,
deferWidth, hierarchyStateInner;
me.callParent(arguments);
// Default to "shrink wrap styles".
outerCtWidth = outerCtHeight = outerCtTableLayout = '';
if (!ownerContext.widthModel.shrinkWrap && me.isShrinkWrapTpl) {
// if we're not shrink wrapping width, but we're using a shrink wrap template
// we need to get the innerCt out of the way to avoid any shrink wrapping
// effect on child items
if (Ext.isIE7m && Ext.isStrict) {
overflowYStyle = me.getOverflowYStyle(ownerContext);
if (overflowYStyle === 'auto' || overflowYStyle === 'scroll') {
// IE6/7 strict will have the outerCt's width set by setCtSizeIfNeeded()
// when the container has potential vertical overflow, so there is
// no need to set the outerCt's width to 100% here
deferWidth = true;
}
}
if (!deferWidth) {
// fill the available width within the container
outerCtWidth = '100%';
}
hierarchyStateInner = me.owner.hierarchyStateInner;
// expand no further than the available width, even if contents are wider
// unless there is a potential for horizontal overflow, then allow
// the outerCt to expand to the width of the contents
overflowXStyle = me.getOverflowXStyle(ownerContext);
outerCtTableLayout = (hierarchyStateInner.inShrinkWrapTable ||
overflowXStyle === 'auto' || 
overflowXStyle === 'scroll') ? '' : 'fixed';
}
if (!ownerContext.heightModel.shrinkWrap && 
!Ext.supports.PercentageHeightOverflowBug) {
// if we're not shrink wrapping height, we need to get the outerCt out of the
// way so that percentage height children will be sized correctly. We do this
// by giving the outerCt a height of '100%' unless the browser is affected by
// the "percentage height overflow bug", in which case the outerCt will get a
// pixel height set during the calculate phase after we know the targetEl size.
outerCtHeight = '100%';
}
// if the outerCt width changed since last time (becuase of a widthModel change)
// or if we set a pixel width on the outerCt last time to work around a browser-
// specific bug, we need to set the width of the outerCt
if ((outerCtWidth !== lastOuterCtWidth) || me.hasOuterCtPxWidth) {
outerCt.setStyle('width', outerCtWidth);
me.lastOuterCtWidth = outerCtWidth;
me.hasOuterCtPxWidth = false;
}
// Set the outerCt table-layout property if different from last time.
if (outerCtTableLayout !== lastOuterCtTableLayout) {
outerCt.setStyle('table-layout', outerCtTableLayout);
me.lastOuterCtTableLayout = outerCtTableLayout;
}
// if the outerCt height changed since last time (becuase of a heightModel change)
// or if we set a pixel height on the outerCt last time to work around a browser-
// specific bug, we need to set the height of the outerCt
if ((outerCtHeight !== lastOuterCtHeight) || me.hasOuterCtPxHeight) {
outerCt.setStyle('height', outerCtHeight);
me.lastOuterCtHeight = outerCtHeight;
me.hasOuterCtPxHeight = false;
}
if (me.hasInnerCtPxHeight) {
me.innerCt.setStyle('height', '');
me.hasInnerCtPxHeight = false;
}
// Begin with the scrollbar adjustment that we used last time - this is more likely
// to be correct than beginning with no adjustment at all, but only if it is not
// already defined - it may have already been set by invalidate()
state.overflowAdjust = state.overflowAdjust || me.lastOverflowAdjust;
},
calculate: function(ownerContext) {
var me = this,
state = ownerContext.state,
containerSize = me.getContainerSize(ownerContext, true),
// If subclass has a calculateItems method, call it and cache the result
calculatedItems = state.calculatedItems ||
(state.calculatedItems = me.calculateItems ?
me.calculateItems(ownerContext, containerSize) : true);
me.setCtSizeIfNeeded(ownerContext, containerSize);
if (calculatedItems && ownerContext.hasDomProp('containerChildrenSizeDone')) {
me.calculateContentSize(ownerContext);
if (containerSize.gotAll) {
if (me.manageOverflow && !ownerContext.state.secondPass && !me.reserveScrollbar) {
me.calculateOverflow(ownerContext, containerSize);
}
return;
}
}

me.done = false;
},
calculateContentSize: function (ownerContext) {
var me = this,
containerDimensions = ((ownerContext.widthModel.shrinkWrap ? 1 : 0) |
(ownerContext.heightModel.shrinkWrap ? 2 : 0)),
calcWidth = (containerDimensions & 1) || undefined,
calcHeight = (containerDimensions & 2) || undefined,
needed = 0,
props = ownerContext.props;
if (calcWidth) {
if (isNaN(props.contentWidth)) {
++needed;
} else {
calcWidth = undefined;
}
}
if (calcHeight) {
if (isNaN(props.contentHeight)) {
++needed;
} else {
calcHeight = undefined;
}
}
if (needed) {
if (calcWidth && !ownerContext.setContentWidth(me.measureContentWidth(ownerContext))) {
me.done = false;
}
if (calcHeight && !ownerContext.setContentHeight(me.measureContentHeight(ownerContext))) {
me.done = false;
}
//if (me.done) {
// var el = ownerContext.targetContext.el.dom;
// Ext.log(this.owner.id, '.contentSize: ', contentWidth, 'x', contentHeight,
// ' => scrollSize: ', el.scrollWidth, 'x', el.scrollHeight);
//}
}
},

calculateOverflow: function (ownerContext) {
var me = this,
width, height, scrollbarSize, scrollbars, xauto, yauto, targetEl;
// Determine the dimensions that have overflow:auto applied. If these come by
// way of component config, this does not require a DOM read:
xauto = (me.getOverflowXStyle(ownerContext) === 'auto');
yauto = (me.getOverflowYStyle(ownerContext) === 'auto');
if (xauto || yauto) {
scrollbarSize = Ext.getScrollbarSize();
targetEl = ownerContext.overflowContext.el.dom;
scrollbars = 0;
if (targetEl.scrollWidth > targetEl.clientWidth) {
// has horizontal scrollbar
scrollbars |= 1;
}
if (targetEl.scrollHeight > targetEl.clientHeight) {
// has vertical scrollbar
scrollbars |= 2;
}
width = (yauto && (scrollbars & 2)) ? scrollbarSize.width : 0;
height = (xauto && (scrollbars & 1)) ? scrollbarSize.height : 0;
if (width !== me.lastOverflowAdjust.width || height !== me.lastOverflowAdjust.height) {
me.done = false;
// we pass overflowAdjust and overflowState in as state for the next
// cycle (these are discarded if one of our ownerCt's invalidates):
ownerContext.invalidate({
state: {
overflowAdjust: {
width: width,
height: height
},
overflowState: scrollbars,
secondPass: true
}
});
}
}
},
completeLayout: function(ownerContext) {
this.lastOverflowAdjust = ownerContext.state.overflowAdjust;
},
doRenderPadding: function(out, renderData) {
// Careful! This method is bolted on to the renderTpl so all we get for context is
// the renderData! The "this" pointer is the renderTpl instance!
var me = renderData.$layout,
owner = renderData.$layout.owner,
padding = owner[owner.contentPaddingProperty];
if (me.managePadding && padding) {
out.push('padding:', owner.unitizeBox(padding));
}
},
finishedLayout: function (ownerContext) {
var innerCt = this.innerCt;
this.callParent(arguments);
if (Ext.isIEQuirks || Ext.isIE8m) {
// IE6/7/quirks need a repaint to fix various rendering issues. TODO: narrow
// down the specific issues that require a repaint.
// IE8 strict needs a repaint to render percentage sized child items.
innerCt.repaint();
}
if (Ext.isOpera) {
// Opera also needs a repaint to render percentage sized child items. but 
// the normal repaint() method doesn't seem to do the trick, but tweaking
// the position property in combination with reading scrollWidth does.
innerCt.setStyle('position', 'relative');
innerCt.dom.scrollWidth;
innerCt.setStyle('position', '');
}
},

getContainerSize : function(ownerContext, inDom) {
// Subtle But Important:
// 
// We don't want to call getProp/hasProp et.al. unless we in fact need that value
// for our results! If we call it and don't need it, the layout manager will think
// we depend on it and will schedule us again should it change.

var size = this.callParent(arguments),
overflowAdjust = ownerContext.state.overflowAdjust;
if (overflowAdjust) {
size.width -= overflowAdjust.width;
size.height -= overflowAdjust.height;
}
return size;
},
getRenderData: function() {
var owner = this.owner,
data = this.callParent();

// The shrinkWrapWidth data property is used by the renderTpl to determine if
// a table-based outerCt/innerCt is required in old IE. There are currently 2
// container configs that turn on the table at render time:
// 
// 1. shrinkWrap:[1/3/true] on the container's initial config. There
// are two reasons one would want to use this config:
// a) If the container's width is initially shrink wrapped.
// b) If the container is not initially shrink wrapped and it is known
// at creation time that it will be shrink wrapped at some point
// after the initial layout cycle, then it is recommended to
// use the shrinkWrap config to initially configure the container
// with shrink wrapped width so that the layout does not have to
// dynamically insert a table after initial render.
// 
// 2. If the container's "floating" config is set to true, and the container
// does not have a configured width, we can be relatively certain at render
// time that the container will be shrink wrapped at layout time, so 
// we go ahead and initially render using a table.
if ((Ext.isIEQuirks || Ext.isIE7m) && // old IE
((owner.shrinkWrap & 1) || // shrink wrap width (handles value of 1, 3, or true)
(owner.floating && !owner.width))) { // floating container with no configured width
data.shrinkWrapWidth = true;
}
return data;
},
// Overridden method from Ext.layout.container.Container.
// Used in the beforeLayout method to render all items into.
getRenderTarget: function() {
return this.innerCt;
},
// Overridden method from Ext.layout.container.Container.
// Used by Container classes to insert special DOM elements which must exist in addition to the child components
getElementTarget: function() {
return this.innerCt;
},

getOverflowXStyle: function(ownerContext) {
return ownerContext.overflowXStyle ||
(ownerContext.overflowXStyle = this.owner.scrollFlags.overflowX || ownerContext.overflowContext.getStyle('overflow-x'));
},

getOverflowYStyle: function(ownerContext) {
return ownerContext.overflowYStyle || 
(ownerContext.overflowYStyle = this.owner.scrollFlags.overflowY || ownerContext.overflowContext.getStyle('overflow-y'));
},
initContextItems: function(ownerContext) {
var me = this,
target = ownerContext.target,
customOverflowEl = me.owner.customOverflowEl;
ownerContext.outerCtContext = ownerContext.getEl('outerCt', me);
ownerContext.innerCtContext = ownerContext.getEl('innerCt', me);

if (customOverflowEl) {
ownerContext.overflowContext = ownerContext.getEl(customOverflowEl); 
} else {
ownerContext.overflowContext = ownerContext.targetContext;
}

if (target[target.contentPaddingProperty] !== undefined) {
// If padding was defined using the contentPaddingProperty, we render the
// the padding to the innerCt or outerCt (depending on the template that is
// being used), so we need to set the paddingContext accordingly.
// Otherwise we leave paddingContext as set by Container layout (defaults to
// the targetContext)
ownerContext.paddingContext = me.isShrinkWrapTpl ?
ownerContext.innerCtContext : ownerContext.outerCtContext;
}
},
initLayout: function() {
var me = this,
scrollbarWidth = Ext.getScrollbarSize().width,
owner = me.owner;
me.callParent();
// Create a default lastOverflowAdjust based upon scrolling configuration.
// If the Container is to overflow, or we *always* reserve space for a scrollbar
// then reserve space for a vertical scrollbar
if (scrollbarWidth && me.manageOverflow && !me.hasOwnProperty('lastOverflowAdjust')) {
if (owner.autoScroll || me.reserveScrollbar) {
me.lastOverflowAdjust = {
width: scrollbarWidth,
height: 0
};
}
}
},

insertTableCt: function(ownerContext) {
var me = this,
owner = me.owner,
i = 0,
renderTpl, fragment, childNodes, childLength, targetEl;
// get the table-based renderTpl
renderTpl = Ext.XTemplate.getTpl(this, 'tableTpl');
renderTpl.renderPadding = me.doRenderPadding
// To avoid unnecessary reflows, remove the innerCt from the dom
// before operating on its children.
me.outerCt.dom.removeChild(me.innerCt.dom);
// create a document fragment to move all the childNodes to, so that
// they can be batch appended to the new innerCt
fragment = document.createDocumentFragment();
childNodes = me.innerCt.dom.childNodes;
childLength = childNodes.length;
// append all the children to the document fragment
for (; i < childLength; i++) {
fragment.appendChild(childNodes[0]);
}
// process the table template and insert it into the target el
targetEl = me.getTarget();
targetEl.dom.innerHTML = renderTpl.apply({
$layout: me,
ownerId: me.owner.id
});
// append the document fragment containing the childNodes to the new innerCt
targetEl.down('td').dom.appendChild(fragment);
// reconfigure childEls to point to the new template's elements
// we need to do this after the childNodes are appended to the new innerCt
// because the clearEl is one of the childNodes
me.applyChildEls(owner.el, owner.id)
// set the flag that indicates we are using a "shrink wrap" template.
// this needs to be done before reinitializeing the context items so that
// the paddingContext will be configured correctly.
me.isShrinkWrapTpl = true;
// since we have new childEls we need to reinitialize the context items
ownerContext.removeEl(me.outerCt);
ownerContext.removeEl(me.innerCt);
me.initContextItems(ownerContext);
},
measureContentHeight: function (ownerContext) {
// contentHeight includes padding, but not border, framing or margins
var contentHeight = this.outerCt.getHeight(),
target = ownerContext.target;
if (this.managePadding && (target[target.contentPaddingProperty] === undefined)) {
// if padding was not configured using the appropriate contentPaddingProperty
// then the padding will not be on the paddingContext, and therfore not included
// in the outerCt measurement, so we need to read the padding from the
// targetContext
contentHeight += ownerContext.targetContext.getPaddingInfo().height;
}
return contentHeight;
},
measureContentWidth: function (ownerContext) {
var dom, style, old, contentWidth, target;

// In the newer Chrome versions, it won't measure the
// width correctly without repainting the inner
// cell in some circumstances.
if (this.chromeCellMeasureBug) {
dom = this.innerCt.dom;
style = dom.style;
old = style.display;

if (old == 'table-cell') {
style.display = '';
dom.offsetWidth;
style.display = old;
} 
}

// contentWidth includes padding, but not border, framing or margins
contentWidth = this.outerCt.getWidth();
target = ownerContext.target;
if (this.managePadding && (target[target.contentPaddingProperty] === undefined)) {
// if padding was not configured using the appropriate contentPaddingProperty
// then the padding will not be on the paddingContext, and therfore not included
// in the outerCt measurement, so we need to read the padding from the
// targetContext
contentWidth += ownerContext.targetContext.getPaddingInfo().width;
}
return contentWidth;
},

setCtSizeIfNeeded: function(ownerContext, containerSize) {
var me = this,
width = containerSize.width,
height = containerSize.height,
padding = ownerContext.paddingContext.getPaddingInfo(),
targetEl = me.getTarget(),
overflowXStyle = me.getOverflowXStyle(ownerContext),
overflowYStyle = me.getOverflowYStyle(ownerContext),
canOverflowX = (overflowXStyle === 'auto' || overflowXStyle === 'scroll'),
canOverflowY = (overflowYStyle === 'auto' || overflowYStyle === 'scroll'),
scrollbarSize = Ext.getScrollbarSize(),
isShrinkWrapTpl = me.isShrinkWrapTpl,
manageOverflow = me.manageOverflow,
overflowStyleName, needsOuterHeight, needsInnerHeight, needsInnerCtPaddingHeight;
if (width && !ownerContext.widthModel.shrinkWrap &&
// shrink wrap outerCt needs pixel width in IE6/7 strict because 100% width
// on the outerCt causes it to overlap the vertical scrollbar
((Ext.isIE7m && Ext.isStrict && isShrinkWrapTpl && canOverflowY) ||
// non shrink wrap tpl outerCt in IE quirks needs pixel width to prevent
// non-breaking text from causing the outerCt to expand beyond the width
// of its container.
(Ext.isIEQuirks && !isShrinkWrapTpl && !canOverflowX))) {
if (!manageOverflow) {
// If we're not managing overflow, the containerSize will not account for
// vertical scrollbar width, so we need to see if there is a vertical
// scrollbar and subtract its width
if (canOverflowY && (targetEl.dom.scrollHeight > targetEl.dom.clientHeight)) {
// has vertical scrollbar
width -= scrollbarSize.width;
}
}
ownerContext.outerCtContext.setProp('width', width + padding.width);
me.hasOuterCtPxWidth = true;
}
if (height && !ownerContext.heightModel.shrinkWrap) {
if (Ext.supports.PercentageHeightOverflowBug) {
// set a pixel height on the outerCt if the browser ignores horizontal
// scrollbar when rendering percentage-height elements
needsOuterHeight = true;
}
if (((Ext.isIE8 && Ext.isStrict) ||
Ext.isIE7m && Ext.isStrict && isShrinkWrapTpl)) {
// When using a shrink wrap template and not shrink wrapping, we set a
// pixel height on the innerCt to support percentage height children in
// IE6/7/8 strict.
needsInnerHeight = true;
// Do not add padding to the innerCt height in IE8 to prevent percentage-
// height children from adding padding height in their height calculation.
needsInnerCtPaddingHeight = !Ext.isIE8;
}
if ((needsOuterHeight || needsInnerHeight) && canOverflowX && 
(targetEl.dom.scrollWidth > targetEl.dom.clientWidth)) {
// adjust the height for scrollbar size since it's not accounted for
// in the containerSize.
// IE8 in what passes for "standards" mode does not tolerate -ve sizes
height = Math.max(height - scrollbarSize.height, 0);
}
if (needsOuterHeight) {
ownerContext.outerCtContext.setProp('height', height + padding.height);
me.hasOuterCtPxHeight = true;
}

if (needsInnerHeight) {
if (needsInnerCtPaddingHeight) {
height += padding.height;
}
ownerContext.innerCtContext.setProp('height', height);
me.hasInnerCtPxHeight = true;
}
}
if (Ext.isIE7 && Ext.isStrict && !isShrinkWrapTpl && (overflowYStyle === 'auto')) {
// IE7 strict has an insane bug where an auto-width element reserves
// space for its parent's vertical scrollbar if the parent has
// overflow-y:auto; even when no scrollbar is present. To workaround
// this issue we can set overflow-y to 'hidden' and then back to 'auto'.
// If we have vertical overflow, however, tweaking overflow-y can cause an
// illegitimate horizontal scrollbar to appear. So we have to tweak overflow-x
// instead if the overflow-x style is "auto"
overflowStyleName = (overflowXStyle === 'auto') ? 'overflow-x' : 'overflow-y';
targetEl.setStyle(overflowStyleName, 'hidden');
targetEl.setStyle(overflowStyleName, 'auto');
}
},
setupRenderTpl: function (renderTpl) {
this.callParent(arguments);
renderTpl.renderPadding = this.doRenderPadding;
},
getContentTarget: function(){
return this.innerCt;
}
}, function(){
this.prototype.chromeCellMeasureBug = Ext.isChrome && Ext.chromeVersion >= 26;
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/Queryable.js */
(function(Ext) {
Ext.define('Ext.Queryable', {

isQueryable: true,


query : function(selector) {
selector = selector || '*';
return Ext.ComponentQuery.query(selector, this);
},


queryBy: function(fn, scope) {
var out = [],
items = this.getRefItems(true),
i = 0,
len = items.length,
item;

for (; i < len; ++i) {
item = items[i];
if (fn.call(scope || item, item) !== false) {
out.push(item);
}
}
return out;
},


queryById: function(id){
return this.down('#' + id);
},

child: function (selector) {
if (selector && selector.isComponent) {
selector = '#' + Ext.escapeId(selector.getItemId());
}
selector = selector || '';
return this.query('> ' + selector)[0] || null;
},


down: function (selector) {
if (selector && selector.isComponent) {
selector = '#' + Ext.escapeId(selector.getItemId());
}
selector = selector || '';
return this.query(selector)[0] || null;
},

getRefItems: function(){
return [];
}

});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/container/AbstractContainer.js */
(function(Ext) {
Ext.define('Ext.container.AbstractContainer', {

extend: 'Ext.Component',
requires: [
'Ext.util.MixedCollection',
'Ext.layout.container.Auto',
'Ext.ZIndexManager'
],

mixins: {
queryable: 'Ext.Queryable'
},

renderTpl: '{%this.renderContainer(out,values)%}',





suspendLayout : false,

autoDestroy : true,

defaultType: 'panel',


detachOnRemove: true,

isContainer : true,

layoutCounter : 0,
baseCls: Ext.baseCSSPrefix + 'container',

defaultLayoutType: 'auto',
// @private
initComponent : function(){
var me = this;
me.addEvents(

'afterlayout',

'beforeadd',

'beforeremove',

'add',

'remove'
);
me.callParent();
me.getLayout();
me.initItems();
},
// @private
initItems : function() {
var me = this,
items = me.items;

me.items = new Ext.util.AbstractMixedCollection(false, me.getComponentId);
me.floatingItems = new Ext.util.MixedCollection(false, me.getComponentId);
if (items) {
if (!Ext.isArray(items)) {
items = [items];
}
me.add(items);
}
},

getFocusEl: function() {
return this.getTargetEl();
},
finishRenderChildren: function () {
this.callParent();
var layout = this.getLayout();
if (layout) {
layout.finishRender();
}
},
beforeRender: function () {
var me = this,
layout = me.getLayout(),
targetCls;
me.callParent();
if (!layout.initialized) {
layout.initLayout();
}
targetCls = layout.targetCls;
if (targetCls) {
me.applyTargetCls(targetCls);
}
},
// The targetCls is a CSS class that the layout needs added to the targetEl. The targetEl is where the container's
// children are rendered and is usually just the main el. Some containers (e.g. panels) use a body instead.
//
// In general, if a class overrides getTargetEl it will also need to override this method. This is necessary to
// avoid a post-render step to add the targetCls.
applyTargetCls: function(targetCls) {
this.addCls(targetCls);
},
afterComponentLayout: function() {
var floaters = this.floatingItems.items,
floaterCount = floaters.length,
i, floater

this.callParent(arguments);
// Contained, unrendered, autoShow items must be shown upon next layout of the Container
for (i = 0; i < floaterCount; i++) {
floater = floaters[i];
if (!floater.rendered && floater.autoShow) {
floater.show();
}
}
},
onPosition: function() {
this.callParent(arguments);
this.repositionFloatingItems();
},
onResize: function() {
this.callParent(arguments);
this.repositionFloatingItems();
},
repositionFloatingItems: function() {
var floaters = this.floatingItems.items,
floaterCount = floaters.length,
i, floater;
// Ensure correct positioning of floated children before calling superclass
for (i = 0; i < floaterCount; i++) {
floater = floaters[i];
if (floater.el && !floater.hidden) {
floater.setPosition(floater.x, floater.y);
}
}
},
setupRenderTpl: function (renderTpl) {
this.callParent(arguments);
this.getLayout().setupRenderTpl(renderTpl);
},

// @private
getDefaultContentTarget: function() {
return this.el;
},

// @private
getContentTarget: function(){
return this.getLayout().getContentTarget();
},
// @private
setLayout : function(layout) {
var currentLayout = this.layout;
if (currentLayout && currentLayout.isLayout && currentLayout != layout) {
currentLayout.setOwner(null);
}
this.layout = layout;
layout.setOwner(this);
},

getLayout : function() {
var me = this;
if (!me.layout || !me.layout.isLayout) {
// Pass any configured in layout property, defaulting to the prototype's layout property, falling back to Auto.
me.setLayout(Ext.layout.Layout.create(me.layout, me.self.prototype.layout || me.defaultLayoutType));
}
return me.layout;
},

doLayout : function() {
this.updateLayout();
return this;
},

afterLayout : function(layout) {
var me = this;
++me.layoutCounter;
if (me.hasListeners.afterlayout) {
me.fireEvent('afterlayout', me, layout);
}
},
// @private
prepareItems : function(items, applyDefaults) {
// Create an Array which does not refer to the passed array.
// The passed array is a reference to a user's config object and MUST NOT be mutated.
if (Ext.isArray(items)) {
items = items.slice();
} else {
items = [items];
}
// Make sure defaults are applied and item is initialized
var me = this,
i = 0,
len = items.length,
item;
for (; i < len; i++) {
item = items[i];
if (item == null) {
Ext.Array.erase(items, i, 1);
--i;
--len;
} else {
if (applyDefaults) {
item = this.applyDefaults(item);
}
// Tell the item we're in a container during construction
item.isContained = me;
items[i] = me.lookupComponent(item);
// need to delete both in case item was a config
delete item.isContained;
delete items[i].isContained;
}
}
return items;
},
// @private
applyDefaults : function(config) {
var defaults = this.defaults;
if (defaults) {
if (Ext.isFunction(defaults)) {
defaults = defaults.call(this, config);
}
if (Ext.isString(config)) {
config = Ext.ComponentManager.get(config);
}
Ext.applyIf(config, defaults);
}
return config;
},
// @private
lookupComponent : function(comp) {
return (typeof comp == 'string') ? Ext.ComponentManager.get(comp)
: Ext.ComponentManager.create(comp, this.defaultType);
},
// @private - used as the key lookup function for the items collection
getComponentId : function(comp) {
return comp.getItemId && comp.getItemId();
},

add : function() {
var me = this,
args = Ext.Array.slice(arguments),
index = (typeof args[0] == 'number') ? args.shift() : -1,
layout = me.getLayout(),
addingArray, items, i, length, item, pos, ret;
if (args.length == 1 && Ext.isArray(args[0])) {
items = args[0];
addingArray = true;
} else {
items = args;
}
if (me.rendered) {
Ext.suspendLayouts(); // suspend layouts while adding items...
}
ret = items = me.prepareItems(items, true);
length = items.length;
if (!addingArray && length == 1) { // an array of 1 should still return an array...
ret = items[0];
}
// loop
for (i = 0; i < length; i++) {
item = items[i];
//<debug>
if (!item) {
Ext.Error.raise("Cannot add null item to Container with itemId/id: " + me.getItemId());
}
//</debug>
pos = (index < 0) ? me.items.length : (index + i);
// Floating Components are not added into the items collection, but to a separate floatingItems collection
if (item.floating) {
me.floatingItems.add(item);
item.onAdded(me, pos);
if (me.hasListeners.add) {
me.fireEvent('add', me, item, pos);
}
} else if ((!me.hasListeners.beforeadd || me.fireEvent('beforeadd', me, item, pos) !== false) && me.onBeforeAdd(item) !== false) {
me.items.insert(pos, item);
item.onAdded(me, pos);
me.onAdd(item, pos);
layout.onAdd(item, pos);
if (me.hasListeners.add) {
me.fireEvent('add', me, item, pos);
}
}
}
// We need to update our layout after adding all passed items
me.updateLayout();
if (me.rendered) {
Ext.resumeLayouts(true);
}
return ret;
},

onAdd : Ext.emptyFn,

onRemove : Ext.emptyFn,

insert : function(index, comp) {
var compIdx;
if (comp && comp.isComponent) {
compIdx = this.items.indexOf(comp);
if (compIdx !== -1) {
return this.move(compIdx, index);
}
}
return this.add(index, comp);
},

move : function(fromIdx, toIdx) {
var items = this.items,
item;

if (fromIdx.isComponent) {
fromIdx = items.indexOf(fromIdx);
}
item = items.removeAt(fromIdx);
if (item === false) {
return false;
}
items.insert(toIdx, item);
this.onMove(item, fromIdx, toIdx);
this.updateLayout();
return item;
},

onMove: Ext.emptyFn,

onBeforeAdd : function(item) {
// Remove from current container if it's not us.
if (item.ownerCt && item.ownerCt !== this) {
item.ownerCt.remove(item, false);
}
},

remove : function(comp, autoDestroy) {
var me = this,
c = me.getComponent(comp);
//<debug>
if (Ext.isDefined(Ext.global.console) && !c) {
Ext.global.console.warn("Attempted to remove a component that does not exist. Ext.container.Container: remove takes an argument of the component to remove. cmp.remove() is incorrect usage.");
}
//</debug>
if (c && (!me.hasListeners.beforeremove || me.fireEvent('beforeremove', me, c) !== false)) {
me.doRemove(c, autoDestroy);
if (me.hasListeners.remove) {
me.fireEvent('remove', me, c);
}
if (!me.destroying && !c.floating) {
me.updateLayout();
}
}
return c;
},
// @private
doRemove : function(component, doDestroy) {
// Ensure the flag is set correctly
doDestroy = doDestroy === true || (doDestroy !== false && this.autoDestroy);
var me = this,
layout = me.layout,
hasLayout = layout && me.rendered,
// isDestroying flag is true if the removal is taking place as part of destruction, OR if removal is intended to *cause* destruction
isDestroying = component.destroying || doDestroy,
floating = component.floating;
if (floating) {
me.floatingItems.remove(component);
} else {
me.items.remove(component);
}
// Inform ownerLayout of removal before deleting the ownerLayout & ownerCt references in the onRemoved call
if (hasLayout && !floating) {
// Removing a component from a running layout has to cancel the layout
if (layout.running) {
Ext.AbstractComponent.cancelLayout(component, isDestroying);
}
layout.onRemove(component, isDestroying);
}
component.onRemoved(isDestroying);
me.onRemove(component, isDestroying);
// Destroy if we were explicitly told to, or we're defaulting to our autoDestroy configuration
if (doDestroy) {
component.destroy();
}
// Only have the layout perform remove postprocessing if the Component is not being destroyed
else {
if (hasLayout && !floating) {
layout.afterRemove(component); 
}
if (me.detachOnRemove && component.rendered) {
me.detachComponent(component);
}
}
},

// Detach a component from the DOM
detachComponent: function(component){
Ext.getDetachedBody().appendChild(component.getEl());
},

removeAll : function(autoDestroy) {
var me = this,
removeItems = me.items.items.slice().concat(me.floatingItems.items),
items = [],
i = 0,
len = removeItems.length,
item;
// Suspend Layouts while we remove multiple items from the container
me.suspendLayouts();
for (; i < len; i++) {
item = removeItems[i];
me.remove(item, autoDestroy);
if (item.ownerCt !== me) {
items.push(item);
}
}
// Resume Layouts now that all items have been removed and do a single layout (if we removed anything!)
me.resumeLayouts(!!len);
return items;
},

getRefItems : function(deep) {
var me = this,
items = me.items.items,
len = items.length,
i = 0,
item,
result = [];
for (; i < len; i++) {
item = items[i];
result[result.length] = item;
if (deep && item.getRefItems) {
result.push.apply(result, item.getRefItems(true));
}
}
// Append floating items to the list.
items = me.floatingItems.items;
len = items.length;
for (i = 0; i < len; i++) {
item = items[i];
result[result.length] = item;
if (deep && item.getRefItems) {
result.push.apply(result, item.getRefItems(true));
}
}
return result;
},

cascade : function(fn, scope, origArgs){
var me = this,
cs = me.items ? me.items.items : [],
len = cs.length,
i = 0,
c,
args = origArgs ? origArgs.concat(me) : [me],
componentIndex = args.length - 1;
if (fn.apply(scope || me, args) !== false) {
for (; i < len; i++){
c = cs[i];
if (c.cascade) {
c.cascade(fn, scope, origArgs);
} else {
args[componentIndex] = c;
fn.apply(scope || cs, args);
}
}
}
return this;
},

isAncestor: function(possibleDescendant) {
while (possibleDescendant) {
if (possibleDescendant.ownerCt === this) {
return true;
}
possibleDescendant = possibleDescendant.ownerCt;
}
},

getComponent : function(comp) {
if (Ext.isObject(comp)) {
comp = comp.getItemId();
}

var c = this.items.get(comp);

// Only allow finding by index on the main items container
if (!c && typeof comp != 'number') {
c = this.floatingItems.get(comp);
}
return c;
},

contains: function(comp, deep) {
var result = false;
if (deep) {
this.cascade(function(c) {
// Only test if the item is a container
if (c.contains && c.contains(comp)) {
result = true;
return false;
}
});
return result;
} else {
return this.items.contains(comp) || this.floatingItems.contains(comp);
}
},
nextChild: function(child, selector) {
var me = this,
result,
childIndex = me.items.indexOf(child);
if (childIndex !== -1) {
result = selector ? Ext.ComponentQuery(selector, me.items.items.slice(childIndex + 1)) : me.items.getAt(childIndex + 1);
if (!result && me.ownerCt) {
result = me.ownerCt.nextChild(me, selector);
}
}
return result;
},
prevChild: function(child, selector) {
var me = this,
result,
childIndex = me.items.indexOf(child);
if (childIndex !== -1) {
result = selector ? Ext.ComponentQuery(selector, me.items.items.slice(childIndex + 1)) : me.items.getAt(childIndex + 1);
if (!result && me.ownerCt) {
result = me.ownerCt.nextChild(me, selector);
}
}
return result;
},
// @private
// Enable all immediate children that was previously disabled
// Override enable because onEnable only gets called when rendered
enable: function() {
this.callParent(arguments);
var itemsToDisable = this.getChildItemsToDisable(),
length = itemsToDisable.length,
item, i;
for (i = 0; i < length; i++) {
item = itemsToDisable[i];
if (item.resetDisable) {
item.enable();
}
}
return this;
},
// Inherit docs
// Disable all immediate children that was previously disabled
// Override disable because onDisable only gets called when rendered
disable: function() {
this.callParent(arguments);
var itemsToDisable = this.getChildItemsToDisable(),
length = itemsToDisable.length,
item, i;
for (i = 0; i < length; i++) {
item = itemsToDisable[i];
if (item.resetDisable !== false && !item.disabled) {
item.disable();
item.resetDisable = true;
}
}
return this;
},


getChildItemsToDisable: function(){
return this.query('[isFormField],button');
},
// @private
// @since 2.3.0
beforeDestroy : function() {
var me = this,
items = me.items,
floatingItems = me.floatingItems,
c;
if (items) {
while ((c = items.first())) {
me.doRemove(c, true);
}
}

if (floatingItems) {
while ((c = floatingItems.first())) {
me.doRemove(c, true);
}
}
Ext.destroy(
me.layout
);
me.callParent();
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/container/Container.js */
(function(Ext) {
Ext.define('Ext.container.Container', {
extend: 'Ext.container.AbstractContainer',
alias: 'widget.container',
alternateClassName: 'Ext.Container',

getChildByElement: function(el, deep) {
var item,
itemEl,
i = 0,
it = this.getRefItems(),
ln = it.length;
el = Ext.getDom(el);
for (; i < ln; i++) {
item = it[i];
itemEl = item.getEl();
if (itemEl && ((itemEl.dom === el) || itemEl.contains(el))) {
return (deep && item.getChildByElement) ? item.getChildByElement(el, deep) : item;
}
}
return null;
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/container/DockingContainer.js */
(function(Ext) {
Ext.define('Ext.container.DockingContainer', {

requires: ['Ext.util.MixedCollection', 'Ext.Element' ],

isDockingContainer: true,





defaultDockWeights: {
top: { render: 1, visual: 1 },
left: { render: 3, visual: 5 },
right: { render: 5, visual: 7 },
bottom: { render: 7, visual: 3 }
},
// @private
// Values to decide which side of the body element docked items must go
// This overides any weight. A left/top will *always* sort before a right/bottom
// regardless of any weight value. Weights sort at either side of the "body" dividing point.
dockOrder: {
top: -1,
left: -1,
right: 1,
bottom: 1
},

horizontalDocks: 0,

addDocked : function(items, pos) {
var me = this,
i = 0,
item, length;
items = me.prepareItems(items);
length = items.length;
for (; i < length; i++) {
item = items[i];
item.dock = item.dock || 'top';
if (item.dock === 'left' || item.dock === 'right') {
me.horizontalDocks++;
}
if (pos !== undefined) {
i += pos;
me.dockedItems.insert(i, item);
} else {
me.dockedItems.add(item);
}

item.onAdded(me, i);
if (me.hasListeners.dockedadd) {
me.fireEvent('dockedadd', me, item, i);
}
if (me.onDockedAdd !== Ext.emptyFn) {
me.onDockedAdd(item);
}
}
if (me.rendered && !me.suspendLayout) {
me.updateLayout();
}
return items;
},
destroyDockedItems: function(){
var dockedItems = this.dockedItems,
c;
if (dockedItems) {
while ((c = dockedItems.first())) {
this.removeDocked(c, true);
}
}
},
doRenderDockedItems: function (out, renderData, after) {
// Careful! This method is bolted on to the frameTpl and renderTpl so all we get for
// context is the renderData! The "this" pointer is either the frameTpl or the
// renderTpl instance!
// Due to framing, we will be called in two different ways: in the frameTpl or in
// the renderTpl. The frameTpl version enters via doRenderFramingDockedItems which
// sets "$skipDockedItems" on the renderTpl's renderData.
//
var me = renderData.$comp,
layout = me.componentLayout,
items,
tree;
if (layout.getDockedItems && !renderData.$skipDockedItems) {
items = layout.getDockedItems('render', !after);
tree = items && layout.getItemsRenderTree(items);
if (tree) {
Ext.DomHelper.generateMarkup(tree, out);
}
}
},

getDockedComponent: function(comp) {
if (Ext.isObject(comp)) {
comp = comp.getItemId();
}
return this.dockedItems.get(comp);
},

getDockedItems : function(selector, beforeBody) {
var dockedItems = this.getComponentLayout().getDockedItems('render', beforeBody);
if (selector && dockedItems.length) {
dockedItems = Ext.ComponentQuery.query(selector, dockedItems);
}
return dockedItems;
},
getDockingRefItems: function(deep, containerItems) {
// deep fetches the docked items and their descendants using '*' and then '* *'
var selector = deep && '*,* *',
// start with only the top/left docked items (and maybe their children)
dockedItems = this.getDockedItems(selector, true),
items;
// push container items (and maybe their children) after top/left docked items:
dockedItems.push.apply(dockedItems, containerItems);
// push right/bottom docked items (and maybe their children) after container items:
items = this.getDockedItems(selector, false);
dockedItems.push.apply(dockedItems, items);
return dockedItems;
},
initDockingItems: function() {
var me = this,
items = me.dockedItems;
me.dockedItems = new Ext.util.AbstractMixedCollection(false, me.getComponentId);
if (items) {
me.addDocked(items);
}
},

insertDocked : function(pos, items) {
this.addDocked(items, pos);
},
// Placeholder empty functions

onDockedAdd : Ext.emptyFn,

onDockedRemove : Ext.emptyFn,

removeDocked : function(item, autoDestroy) {
var me = this,
layout,
hasLayout;
autoDestroy = autoDestroy === true || (autoDestroy !== false && me.autoDestroy);
if (!me.dockedItems.contains(item)) {
return item;
}
if (item.dock === 'left' || item.dock === 'right') {
me.horizontalDocks--;
}
layout = me.componentLayout;
hasLayout = layout && me.rendered;
if (hasLayout) {
layout.onRemove(item);
}
me.dockedItems.remove(item);
// destroying flag is true if the removal is taking place as part of destruction, OR if removal is intended to *cause* destruction
item.onRemoved(item.destroying || autoDestroy);
me.onDockedRemove(item);
if (autoDestroy) {
item.destroy();
} else if (hasLayout) {
// not destroying, make any layout related removals
layout.afterRemove(item);
}

if (me.hasListeners.dockedremove) {
me.fireEvent('dockedremove', me, item);
}
if (!me.destroying && !me.suspendLayout) {
me.updateLayout();
}
return item;
},
setupDockingRenderTpl: function (renderTpl) {
renderTpl.renderDockedItems = this.doRenderDockedItems;
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/toolbar/Fill.js */
(function(Ext) {
Ext.define('Ext.toolbar.Fill', {
extend: 'Ext.Component',
alias: 'widget.tbfill',
alternateClassName: 'Ext.Toolbar.Fill',

isFill : true,
flex: 1
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/layout/container/boxOverflow/None.js */
(function(Ext) {
Ext.define('Ext.layout.container.boxOverflow.None', {
alternateClassName: 'Ext.layout.boxOverflow.None',

constructor: function(layout, config) {
this.layout = layout;
Ext.apply(this, config);
},
handleOverflow: Ext.emptyFn,
clearOverflow: Ext.emptyFn,
beginLayout: Ext.emptyFn,
beginLayoutCycle: Ext.emptyFn,
calculate: function(ownerContext) {
var me = this,
plan = ownerContext.state.boxPlan,
overflow;
if (plan && plan.tooNarrow) {
overflow = me.handleOverflow(ownerContext);
if (overflow) {
if (overflow.reservedSpace) {
me.layout.publishInnerCtSize(ownerContext, overflow.reservedSpace);
}
// TODO: If we need to use the code below then we will need to pass along
// the new targetSize as state and use it calculate somehow...
//
//if (overflow.recalculate) {
// ownerContext.invalidate({
// state: {
// overflow: overflow
// }
// });
//}
}
} else {
me.clearOverflow();
}
},
completeLayout: Ext.emptyFn,
finishedLayout: function (ownerContext) {
var me = this,
owner = me.layout.owner,
hiddens,
hiddenCount;
// Only count hidden children if someone is interested when the overflow state changes
if (owner.hasListeners.overflowchange) {
hiddens = owner.query('>[hidden]');
hiddenCount = hiddens.length;
if (hiddenCount !== me.lastHiddenCount) {
owner.fireEvent('overflowchange', me.lastHiddenCount, hiddenCount, hiddens);
me.lastHiddenCount = hiddenCount;
}
}
},
onRemove: Ext.emptyFn,

getItem: function(item) {
return this.layout.owner.getComponent(item);
},

getOwnerType: function(owner){
var type;
if (owner.isToolbar) {
type = 'toolbar';
} else if (owner.isTabBar) {
type = 'tabbar';
} else if (owner.isMenu) {
type = 'menu';
} else {
type = owner.getXType();
}

return type;
},
getPrefixConfig: Ext.emptyFn,
getSuffixConfig: Ext.emptyFn,
getOverflowCls: function() {
return '';
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/toolbar/Item.js */
(function(Ext) {
Ext.define('Ext.toolbar.Item', {
extend: 'Ext.Component',
alias: 'widget.tbitem',
alternateClassName: 'Ext.Toolbar.Item',
enable:Ext.emptyFn,
disable:Ext.emptyFn,
focus:Ext.emptyFn

});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/toolbar/Separator.js */
(function(Ext) {
Ext.define('Ext.toolbar.Separator', {
extend: 'Ext.toolbar.Item',
alias: 'widget.tbseparator',
alternateClassName: 'Ext.Toolbar.Separator',
baseCls: Ext.baseCSSPrefix + 'toolbar-separator',
focusable: false
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/button/Manager.js */
(function(Ext) {
Ext.define('Ext.button.Manager', {
singleton: true,
alternateClassName: 'Ext.ButtonToggleManager',
groups: {},
pressedButton: null,
buttonSelector: '.' + Ext.baseCSSPrefix + 'btn',
init: function() {
var me = this;
if (!me.initialized) {
Ext.getDoc().on({
keydown: me.onDocumentKeyDown,
mouseup: me.onDocumentMouseUp,
scope: me
});
me.initialized = true;
}
},
// Buttons must react to SPACE and ENTER to trigger the click handler.
// Now that they are `<a>` elements, we use a keydown listener.
onDocumentKeyDown: function(e) {
var k = e.getKey(),
btn;
// SPACE and ENTER trigger a click
if (k === e.SPACE || k === e.ENTER) {
// Look for a Button's encapsulating element
btn = e.getTarget(this.buttonSelector);
// If found, fire the Button's onClick
if (btn) {
Ext.getCmp(btn.id).onClick(e);
}
}
},
// Called by buton instances.
// Track the button which was mousedowned upon so that the next *document* mouseup can be delivered to it
// in case mouse is moved outside of button element.
onButtonMousedown: function(button, e) {
var pressed = this.pressedButton;
if (pressed) {
pressed.onMouseUp(e);
}
this.pressedButton = button;
},
onDocumentMouseUp: function(e) {
var pressed = this.pressedButton;

if (pressed) {
pressed.onMouseUp(e);
this.pressedButton = null;
}
},
toggleGroup: function(btn, state) {
if (state) {
var g = this.groups[btn.toggleGroup],
length = g.length,
i;
for (i = 0; i < length; i++) {
if (g[i] !== btn) {
g[i].toggle(false);
}
}
}
},
register: function(btn) {
var me = this,
groups = this.groups,
group = groups[btn.toggleGroup];
me.init();
if (!btn.toggleGroup) {
return;
}
if (!group) {
group = groups[btn.toggleGroup] = [];
}
group.push(btn);
btn.on('toggle', me.toggleGroup, me);
},
unregister: function(btn) {
if (!btn.toggleGroup) {
return;
}
var me = this,
group = me.groups[btn.toggleGroup];
if (group) {
Ext.Array.remove(group, btn);
btn.un('toggle', me.toggleGroup, me);
}
},
// Gets the pressed button in the passed group or null
// @param {String} group
// @return {Ext.button.Button}
getPressed: function(group) {
var g = this.groups[group],
i = 0,
len;
if (g) {
for (len = g.length; i < len; i++) {
if (g[i].pressed === true) {
return g[i];
}
}
}
return null;
} 
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/util/KeyMap.js */
(function(Ext) {
Ext.define('Ext.util.KeyMap', {
alternateClassName: 'Ext.KeyMap',





eventName: 'keydown',
constructor: function(config) {
var me = this;
// Handle legacy arg list in which the first argument is the target.
// TODO: Deprecate in V5
if ((arguments.length !== 1) || (typeof config === 'string') || config.dom || config.tagName || config === document || config.isComponent) {
me.legacyConstructor.apply(me, arguments);
return;
}
Ext.apply(me, config);
me.bindings = [];
if (!me.target.isComponent) {
me.target = Ext.get(me.target);
}
if (me.binding) {
me.addBinding(me.binding);
} else if (config.key) {
me.addBinding(config);
}
me.enable();
},

legacyConstructor: function(el, binding, eventName){
var me = this;
Ext.apply(me, {
target: Ext.get(el),
eventName: eventName || me.eventName,
bindings: []
});
if (binding) {
me.addBinding(binding);
}
me.enable();
},

addBinding : function(binding){
var me = this,
keyCode = binding.key,
i,
len;
if (me.processing) {
me.bindings = bindings.slice(0);
}

if (Ext.isArray(binding)) {
for (i = 0, len = binding.length; i < len; i++) {
me.addBinding(binding[i]);
}
return;
}
me.bindings.push(Ext.apply({
keyCode: me.processKeys(keyCode)
}, binding));
},


removeBinding: function(binding){
var me = this,
bindings = me.bindings,
len = bindings.length,
i, item, keys;

if (me.processing) {
me.bindings = bindings.slice(0);
}

keys = me.processKeys(binding.key);
for (i = 0; i < len; ++i) {
item = bindings[i];
if (item.fn === binding.fn && item.scope === binding.scope) {
if (binding.alt == item.alt && binding.crtl == item.crtl && binding.shift == item.shift) {
if (Ext.Array.equals(item.keyCode, keys)) {
Ext.Array.erase(me.bindings, i, 1);
return;
}
}
}
}
},

processKeys: function(keyCode){
var processed = false,
key, keys, keyString, len, i;

if (Ext.isString(keyCode)) {
keys = [];
keyString = keyCode.toUpperCase();
for (i = 0, len = keyString.length; i < len; ++i){
keys.push(keyString.charCodeAt(i));
}
keyCode = keys;
processed = true;
}
if (!Ext.isArray(keyCode)) {
keyCode = [keyCode];
}
if (!processed) {
for (i = 0, len = keyCode.length; i < len; ++i) {
key = keyCode[i];
if (Ext.isString(key)) {
keyCode[i] = key.toUpperCase().charCodeAt(0);
}
}
}
return keyCode;
},

handleTargetEvent: (function() {
var tagRe = /input|textarea/i;
return function(event) {
var me = this,
bindings, i, len,
target, contentEditable;
if (me.enabled) { //just in case
bindings = me.bindings;
i = 0;
len = bindings.length;
// Process the event
event = me.processEvent.apply(me||me.processEventScope, arguments);
// Ignore events from input fields if configured to do so
if (me.ignoreInputFields) {
target = event.target;
contentEditable = target.contentEditable;
// contentEditable will default to inherit if not specified, only check if the
// attribute has been set or explicitly set to true
// http://html5doctor.com/the-contenteditable-attribute/
if (tagRe.test(target.tagName) || (contentEditable === '' || contentEditable === 'true')) {
return;
}
}
// If the processor does not return a keyEvent, we can't process it.
// Allow them to return false to cancel processing of the event
if (!event.getKey) {
return event;
}
me.processing = true;
for(; i < len; ++i){
me.processBinding(bindings[i], event);
}
me.processing = false;
}
}
}()),

processEvent: Ext.identityFn,

processBinding: function(binding, event){
if (this.checkModifiers(binding, event)) {
var key = event.getKey(),
handler = binding.fn || binding.handler,
scope = binding.scope || this,
keyCode = binding.keyCode,
defaultEventAction = binding.defaultEventAction,
i,
len,
keydownEvent = new Ext.EventObjectImpl(event);
for (i = 0, len = keyCode.length; i < len; ++i) {
if (key === keyCode[i]) {
if (handler.call(scope, key, event) !== true && defaultEventAction) {
keydownEvent[defaultEventAction]();
}
break;
}
}
}
},

checkModifiers: function(binding, e) {
var keys = ['shift', 'ctrl', 'alt'],
i = 0,
len = keys.length,
val, key;
for (; i < len; ++i){
key = keys[i];
val = binding[key];
if (!(val === undefined || (val === e[key + 'Key']))) {
return false;
}
}
return true;
},

on: function(key, fn, scope) {
var keyCode, shift, ctrl, alt;
if (Ext.isObject(key) && !Ext.isArray(key)) {
keyCode = key.key;
shift = key.shift;
ctrl = key.ctrl;
alt = key.alt;
} else {
keyCode = key;
}
this.addBinding({
key: keyCode,
shift: shift,
ctrl: ctrl,
alt: alt,
fn: fn,
scope: scope
});
},


un: function(key, fn, scope) {
var keyCode, shift, ctrl, alt;
if (Ext.isObject(key) && !Ext.isArray(key)) {
keyCode = key.key;
shift = key.shift;
ctrl = key.ctrl;
alt = key.alt;
} else {
keyCode = key;
}
this.removeBinding({
key: keyCode,
shift: shift,
ctrl: ctrl,
alt: alt,
fn: fn,
scope: scope
});
},

isEnabled : function() {
return this.enabled;
},

enable: function() {
var me = this;

if (!me.enabled) {
me.target.on(me.eventName, me.handleTargetEvent, me);
me.enabled = true;
}
},

disable: function() {
var me = this;

if (me.enabled) {
me.target.removeListener(me.eventName, me.handleTargetEvent, me);
me.enabled = false;
}
},

setDisabled : function(disabled) {
if (disabled) {
this.disable();
} else {
this.enable();
}
},

destroy: function(removeTarget) {
var me = this,
target = me.target;
me.bindings = [];
me.disable();
if (removeTarget === true) {
if (target.isComponent) {
target.destroy();
} else {
target.remove();
}
}
delete me.target;
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/layout/container/Fit.js */
(function(Ext) {
Ext.define('Ext.layout.container.Fit', {

extend: 'Ext.layout.container.Container',
alternateClassName: 'Ext.layout.FitLayout',
alias: 'layout.fit',

itemCls: Ext.baseCSSPrefix + 'fit-item',
targetCls: Ext.baseCSSPrefix + 'layout-fit',
type: 'fit',


defaultMargins: {
top: 0,
right: 0,
bottom: 0,
left: 0
},
manageMargins: true,
sizePolicies: {
0: { readsWidth: 1, readsHeight: 1, setsWidth: 0, setsHeight: 0 },
1: { readsWidth: 0, readsHeight: 1, setsWidth: 1, setsHeight: 0 },
2: { readsWidth: 1, readsHeight: 0, setsWidth: 0, setsHeight: 1 },
3: { readsWidth: 0, readsHeight: 0, setsWidth: 1, setsHeight: 1 }
},
getItemSizePolicy: function (item, ownerSizeModel) {
// this layout's sizePolicy is derived from its owner's sizeModel:
var sizeModel = ownerSizeModel || this.owner.getSizeModel(),
mode = (sizeModel.width.shrinkWrap ? 0 : 1) |
(sizeModel.height.shrinkWrap ? 0 : 2);
return this.sizePolicies[mode];
},
beginLayoutCycle: function (ownerContext, firstCycle) {
var me = this,
// determine these before the lastSizeModels get updated:
resetHeight = me.lastHeightModel && me.lastHeightModel.calculated,
resetWidth = me.lastWidthModel && me.lastWidthModel.calculated,
resetSizes = resetWidth || resetHeight,
maxChildMinHeight = 0, maxChildMinWidth = 0,
c, childItems, i, item, length, margins, minHeight, minWidth, style, undef;
me.callParent(arguments);
// Clear any dimensions which we set before calculation, in case the current
// settings affect the available size. This particularly effects self-sizing
// containers such as fields, in which the target element is naturally sized,
// and should not be stretched by a sized child item.
if (resetSizes && ownerContext.targetContext.el.dom.tagName.toUpperCase() != 'TD') {
resetSizes = resetWidth = resetHeight = false;
}
childItems = ownerContext.childItems;
length = childItems.length;
for (i = 0; i < length; ++i) {
item = childItems[i];
// On the firstCycle, we determine the max of the minWidth/Height of the items
// since these can cause the container to grow scrollbars despite our attempts
// to fit the child to the container.
if (firstCycle) {
c = item.target;
minHeight = c.minHeight;
minWidth = c.minWidth;
if (minWidth || minHeight) {
margins = item.marginInfo || item.getMarginInfo();
// if the child item has undefined minWidth/Height, these will become
// NaN by adding the margins...
minHeight += margins.height;
minWidth += margins.height;
// if the child item has undefined minWidth/Height, these comparisons
// will evaluate to false... that is, "0 < NaN" == false...
if (maxChildMinHeight < minHeight) {
maxChildMinHeight = minHeight;
}
if (maxChildMinWidth < minWidth) {
maxChildMinWidth = minWidth;
}
}
}
if (resetSizes) {
style = item.el.dom.style;
if (resetHeight) {
style.height = '';
}
if (resetWidth) {
style.width = '';
}
}
}
if (firstCycle) {
ownerContext.maxChildMinHeight = maxChildMinHeight;
ownerContext.maxChildMinWidth = maxChildMinWidth;
}
// Cache the overflowX/Y flags, but make them false in shrinkWrap mode (since we
// won't be triggering overflow in that case) and false if we have no minSize (so
// no child to trigger an overflow).
c = ownerContext.target;
ownerContext.overflowX = (!ownerContext.widthModel.shrinkWrap && 
ownerContext.maxChildMinWidth &&
c.scrollFlags.x) || undef;
ownerContext.overflowY = (!ownerContext.heightModel.shrinkWrap &&
ownerContext.maxChildMinHeight &&
c.scrollFlags.y) || undef;
},
calculate : function (ownerContext) {
var me = this,
childItems = ownerContext.childItems,
length = childItems.length,
containerSize = me.getContainerSize(ownerContext),
info = {
length: length,
ownerContext: ownerContext,
targetSize: containerSize
},
shrinkWrapWidth = ownerContext.widthModel.shrinkWrap,
shrinkWrapHeight = ownerContext.heightModel.shrinkWrap,
overflowX = ownerContext.overflowX,
overflowY = ownerContext.overflowY,
scrollbars, scrollbarSize, padding, i, contentWidth, contentHeight;
if (overflowX || overflowY) {
// If we have children that have minHeight/Width, we may be forced to overflow
// and gain scrollbars. If so, we want to remove their space from the other
// axis so that we fit things inside the scrollbars rather than under them.
scrollbars = me.getScrollbarsNeeded(
overflowX && containerSize.width, overflowY && containerSize.height,
ownerContext.maxChildMinWidth, ownerContext.maxChildMinHeight);
if (scrollbars) {
scrollbarSize = Ext.getScrollbarSize();
if (scrollbars & 1) { // if we need the hscrollbar, remove its height
containerSize.height -= scrollbarSize.height;
}
if (scrollbars & 2) { // if we need the vscrollbar, remove its width
containerSize.width -= scrollbarSize.width;
}
}
}
// Size the child items to the container (if non-shrinkWrap):
for (i = 0; i < length; ++i) {
info.index = i;
me.fitItem(childItems[i], info);
}

if (shrinkWrapHeight || shrinkWrapWidth) {
padding = ownerContext.targetContext.getPaddingInfo();

if (shrinkWrapWidth) {
if (overflowY && !containerSize.gotHeight) {
// if we might overflow vertically and don't have the container height,
// we don't know if we will need a vscrollbar or not, so we must wait
// for that height so that we can determine the contentWidth...
me.done = false;
} else {
contentWidth = info.contentWidth + padding.width;
// the scrollbar flag (if set) will indicate that an overflow exists on
// the horz(1) or vert(2) axis... if not set, then there could never be
// an overflow...
if (scrollbars & 2) { // if we need the vscrollbar, add its width
contentWidth += scrollbarSize.width;
}
if (!ownerContext.setContentWidth(contentWidth)) {
me.done = false;
}
}
}
if (shrinkWrapHeight) {
if (overflowX && !containerSize.gotWidth) {
// if we might overflow horizontally and don't have the container width,
// we don't know if we will need a hscrollbar or not, so we must wait
// for that width so that we can determine the contentHeight...
me.done = false;
} else {
contentHeight = info.contentHeight + padding.height;
// the scrollbar flag (if set) will indicate that an overflow exists on
// the horz(1) or vert(2) axis... if not set, then there could never be
// an overflow...
if (scrollbars & 1) { // if we need the hscrollbar, add its height
contentHeight += scrollbarSize.height;
}
if (!ownerContext.setContentHeight(contentHeight)) {
me.done = false;
}
}
}
}
},
fitItem: function (itemContext, info) {
var me = this;
if (itemContext.invalid) {
me.done = false;
return;
}
info.margins = itemContext.getMarginInfo();
info.needed = info.got = 0;
me.fitItemWidth(itemContext, info);
me.fitItemHeight(itemContext, info);
// If not all required dimensions have been satisfied, we're not done.
if (info.got != info.needed) {
me.done = false;
}
},
fitItemWidth: function (itemContext, info) {
var contentWidth, width;
// Attempt to set only dimensions that are being controlled, not shrinkWrap dimensions
if (info.ownerContext.widthModel.shrinkWrap) {
// contentWidth must include the margins to be consistent with setItemWidth
width = itemContext.getProp('width') + info.margins.width;
// because we add margins, width will be NaN or a number (not undefined)
contentWidth = info.contentWidth;
if (contentWidth === undefined) {
info.contentWidth = width;
} else {
info.contentWidth = Math.max(contentWidth, width);
}
} else if (itemContext.widthModel.calculated) {
++info.needed;
if (info.targetSize.gotWidth) {
++info.got;
this.setItemWidth(itemContext, info);
}
}
this.positionItemX(itemContext, info);
},
fitItemHeight: function (itemContext, info) {
var contentHeight, height;
if (info.ownerContext.heightModel.shrinkWrap) {
// contentHeight must include the margins to be consistent with setItemHeight
height = itemContext.getProp('height') + info.margins.height;
// because we add margins, height will be NaN or a number (not undefined)
contentHeight = info.contentHeight;
if (contentHeight === undefined) {
info.contentHeight = height;
} else {
info.contentHeight = Math.max(contentHeight, height);
}
} else if (itemContext.heightModel.calculated) {
++info.needed;
if (info.targetSize.gotHeight) {
++info.got;
this.setItemHeight(itemContext, info);
}
}
this.positionItemY(itemContext, info);
},
positionItemX: function (itemContext, info) {
var margins = info.margins;
// Adjust position to account for configured margins or if we have multiple items
// (all items should overlap):
if (info.index || margins.left) {
itemContext.setProp('x', margins.left);
}
if (margins.width) {
// Need the margins for shrink-wrapping but old IE sometimes collapses the left margin into the padding
itemContext.setProp('margin-right', margins.width);
}
},
positionItemY: function (itemContext, info) {
var margins = info.margins;
if (info.index || margins.top) {
itemContext.setProp('y', margins.top);
}
if (margins.height) {
// Need the margins for shrink-wrapping but old IE sometimes collapses the top margin into the padding
itemContext.setProp('margin-bottom', margins.height);
}
},
setItemHeight: function (itemContext, info) {
itemContext.setHeight(info.targetSize.height - info.margins.height);
},
setItemWidth: function (itemContext, info) {
itemContext.setWidth(info.targetSize.width - info.margins.width);
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/layout/container/VBox.js */
(function(Ext) {
Ext.define('Ext.layout.container.VBox', {

alias: ['layout.vbox'],
extend: 'Ext.layout.container.Box',
alternateClassName: 'Ext.layout.VBoxLayout',


align : 'left', // left, center, stretch, strechmax



constrainAlign: false,
type: 'vbox',
direction: 'vertical',
horizontal: false,
names: {
// parallel
beforeX: 'top',
beforeScrollX: 'top',
beforeScrollerSuffix: '-before-scroller',
afterScrollerSuffix: '-after-scroller',
leftCap: 'Top',
afterX: 'bottom',
width: 'height',
contentWidth: 'contentHeight',
minWidth: 'minHeight',
maxWidth: 'maxHeight',
widthCap: 'Height',
widthModel: 'heightModel',
widthIndex: 1,
x: 'y',
scrollLeft: 'scrollTop',
overflowX: 'overflowY',
hasOverflowX: 'hasOverflowY',
invalidateScrollX: 'invalidateScrollY',
parallelMargins: 'tb',
// perpendicular
center: 'center',
beforeY: 'left',
afterY: 'right',
height: 'width',
contentHeight: 'contentWidth',
minHeight: 'minWidth',
maxHeight: 'maxWidth',
heightCap: 'Width',
heightModel: 'widthModel',
heightIndex: 0,
y: 'x',
overflowY: 'overflowX',
hasOverflowY: 'hasOverflowX',
invalidateScrollY: 'invalidateScrollX',
perpendicularMargins: 'lr',
// Methods
getWidth: 'getHeight',
getHeight: 'getWidth',
setWidth: 'setHeight',
setHeight: 'setWidth',
gotWidth: 'gotHeight',
gotHeight: 'gotWidth',
setContentWidth: 'setContentHeight',
setContentHeight: 'setContentWidth',
setWidthInDom: 'setHeightInDom',
setHeightInDom: 'setWidthInDom',
getScrollLeft: 'getScrollTop',
setScrollLeft: 'setScrollTop',
scrollTo: 'scrollTo'
},
sizePolicy: {
flex: {
'': {
readsWidth : 1,
readsHeight: 0,
setsWidth : 0,
setsHeight : 1
},
stretch: {
readsWidth : 0,
readsHeight: 0,
setsWidth : 1,
setsHeight : 1
},
stretchmax: {
readsWidth : 1,
readsHeight: 0,
setsWidth : 1,
setsHeight : 1
}
},
'': {
readsWidth : 1,
readsHeight: 1,
setsWidth : 0,
setsHeight : 0
},
stretch: {
readsWidth : 0,
readsHeight: 1,
setsWidth : 1,
setsHeight : 0
},
stretchmax: {
readsWidth : 1,
readsHeight: 1,
setsWidth : 1,
setsHeight : 0
}
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/menu/Item.js */
(function(Ext) {
Ext.define('Ext.menu.Item', {
extend: 'Ext.Component',
alias: 'widget.menuitem',
alternateClassName: 'Ext.menu.TextItem',

mixins: {
queryable: 'Ext.Queryable'
},



activeCls: Ext.baseCSSPrefix + 'menu-item-active',

ariaRole: 'menuitem',

canActivate: true,

clickHideDelay: 0,

destroyMenu: true,

disabledCls: Ext.baseCSSPrefix + 'menu-item-disabled',



hideOnClick: true,



isMenuItem: true,



menuAlign: 'tl-tr?',

menuExpandDelay: 200,

menuHideDelay: 200,



tooltipType: 'qtip',
arrowCls: Ext.baseCSSPrefix + 'menu-item-arrow',
childEls: [
'itemEl', 'iconEl', 'textEl', 'arrowEl'
],
renderTpl: [
'<tpl if="plain">',
'{text}',
'<tpl else>',
'<a id="{id}-itemEl"',
' class="' + Ext.baseCSSPrefix + 'menu-item-link{childElCls}"',
' href="{href}"',
'<tpl if="hrefTarget"> target="{hrefTarget}"</tpl>',
' hidefocus="true"',
// For most browsers the text is already unselectable but Opera needs an explicit unselectable="on".
' unselectable="on"',
'<tpl if="tabIndex">',
' tabIndex="{tabIndex}"',
'</tpl>',
'>',
'<div role="img" id="{id}-iconEl" class="' + Ext.baseCSSPrefix + 'menu-item-icon {iconCls}',
'{childElCls} {glyphCls}" style="<tpl if="icon">background-image:url({icon});</tpl>',
'<tpl if="glyph && glyphFontFamily">font-family:{glyphFontFamily};</tpl>">',
'<tpl if="glyph">&#{glyph};</tpl>',
'</div>',
'<span id="{id}-textEl" class="' + Ext.baseCSSPrefix + 'menu-item-text" unselectable="on">{text}</span>',
'<img id="{id}-arrowEl" src="{blank}" class="{arrowCls}',
'{childElCls}"/>',
'</a>',
'</tpl>'
],
maskOnDisable: false,


activate: function() {
var me = this;
if (!me.activated && me.canActivate && me.rendered && !me.isDisabled() && me.isVisible()) {
me.el.addCls(me.activeCls);
me.focus();
me.activated = true;
me.fireEvent('activate', me);
}
},
getFocusEl: function() {
return this.itemEl;
},
deactivate: function() {
var me = this;
if (me.activated) {
me.el.removeCls(me.activeCls);
me.blur();
me.hideMenu();
me.activated = false;
me.fireEvent('deactivate', me);
}
},
deferHideMenu: function() {
if (this.menu.isVisible()) {
this.menu.hide();
}
},

cancelDeferHide: function(){
clearTimeout(this.hideMenuTimer);
},
deferHideParentMenus: function() {
var ancestor;
Ext.menu.Manager.hideAll();
if (!Ext.Element.getActiveElement()) {
// If we have just hidden all Menus, and there is no currently focused element in the dom, transfer focus to the first visible ancestor if any.
ancestor = this.up(':not([hidden])');
if (ancestor) {
ancestor.focus();
}
}
},
expandMenu: function(delay) {
var me = this;
if (me.menu) {
me.cancelDeferHide();
if (delay === 0) {
me.doExpandMenu();
} else {
clearTimeout(me.expandMenuTimer);
me.expandMenuTimer = Ext.defer(me.doExpandMenu, Ext.isNumber(delay) ? delay : me.menuExpandDelay, me);
}
}
},
doExpandMenu: function() {
var me = this,
menu = me.menu;
if (me.activated && (!menu.rendered || !menu.isVisible())) {
me.parentMenu.activeChild = menu;
menu.parentItem = me;
menu.parentMenu = me.parentMenu;
menu.showBy(me, me.menuAlign);
}
},
getRefItems: function(deep) {
var menu = this.menu,
items;
if (menu) {
items = menu.getRefItems(deep);
items.unshift(menu);
}
return items || [];
},
hideMenu: function(delay) {
var me = this;
if (me.menu) {
clearTimeout(me.expandMenuTimer);
me.hideMenuTimer = Ext.defer(me.deferHideMenu, Ext.isNumber(delay) ? delay : me.menuHideDelay, me);
}
},
initComponent: function() {
var me = this,
prefix = Ext.baseCSSPrefix,
cls = [prefix + 'menu-item'],
menu;
me.addEvents(

'activate',

'click',

'deactivate',

'textchange',

'iconchange'
);
if (me.plain) {
cls.push(prefix + 'menu-item-plain');
}
if (me.cls) {
cls.push(me.cls);
}
me.cls = cls.join(' ');
if (me.menu) {
menu = me.menu;
delete me.menu;
me.setMenu(menu);
}
me.callParent(arguments);
},
onClick: function(e) {
var me = this,
clickHideDelay = me.clickHideDelay;
if (!me.href) {
e.stopEvent();
}
if (me.disabled) {
return;
}
if (me.hideOnClick) {
if (!clickHideDelay) {
me.deferHideParentMenus();
} else {
me.deferHideParentMenusTimer = Ext.defer(me.deferHideParentMenus, clickHideDelay, me);
}
}
Ext.callback(me.handler, me.scope || me, [me, e]);
me.fireEvent('click', me, e);
if (!me.hideOnClick) {
me.focus();
}
},
onRemoved: function() {
var me = this;
// Removing the active item, must deactivate it.
if (me.activated && me.parentMenu.activeItem === me) {
me.parentMenu.deactivateActiveItem();
}
me.callParent(arguments);
me.parentMenu = me.ownerButton = null;
},
// @private
beforeDestroy: function() {
var me = this;
if (me.rendered) {
me.clearTip();
}
me.callParent();
},
onDestroy: function() {
var me = this;
clearTimeout(me.expandMenuTimer);
me.cancelDeferHide();
clearTimeout(me.deferHideParentMenusTimer);
me.setMenu(null);
me.callParent(arguments);
},
beforeRender: function() {
var me = this,
blank = Ext.BLANK_IMAGE_URL,
glyph = me.glyph,
glyphFontFamily = Ext._glyphFontFamily,
glyphParts, iconCls, arrowCls;
me.callParent();
if (me.iconAlign === 'right') {
iconCls = me.checkChangeDisabled ? me.disabledCls : '';
arrowCls = Ext.baseCSSPrefix + 'menu-item-icon-right ' + me.iconCls;
} else {
iconCls = (me.iconCls || '') + (me.checkChangeDisabled ? ' ' + me.disabledCls : '');
arrowCls = me.menu ? me.arrowCls : '';
}
if (typeof glyph === 'string') {
glyphParts = glyph.split('@');
glyph = glyphParts[0];
glyphFontFamily = glyphParts[1];
}
Ext.applyIf(me.renderData, {
href: me.href || '#',
hrefTarget: me.hrefTarget,
icon: me.icon,
iconCls: iconCls,
glyph: glyph,
glyphCls: glyph ? Ext.baseCSSPrefix + 'menu-item-glyph' : undefined,
glyphFontFamily: glyphFontFamily,
hasIcon: !!(me.icon || me.iconCls || glyph),
iconAlign: me.iconAlign,
plain: me.plain,
text: me.text,
arrowCls: arrowCls,
blank: blank,
tabIndex: me.tabIndex
});
},
onRender: function() {
var me = this;
me.callParent(arguments);
if (me.tooltip) {
me.setTooltip(me.tooltip, true);
}
},


setMenu: function(menu, destroyMenu) {
var me = this,
oldMenu = me.menu,
arrowEl = me.arrowEl;

if (oldMenu) {
delete oldMenu.parentItem;
delete oldMenu.parentMenu;
delete oldMenu.ownerItem;

if (destroyMenu === true || (destroyMenu !== false && me.destroyMenu)) {
Ext.destroy(oldMenu);
}
}
if (menu) {
me.menu = Ext.menu.Manager.get(menu);
me.menu.ownerItem = me;
} else {
me.menu = null;
}

if (me.rendered && !me.destroying && arrowEl) {
arrowEl[me.menu ? 'addCls' : 'removeCls'](me.arrowCls);
}
},

setHandler: function(fn, scope) {
this.handler = fn || null;
this.scope = scope;
},

setIcon: function(icon){
var iconEl = this.iconEl,
oldIcon = this.icon;
if (iconEl) {
iconEl.src = icon || Ext.BLANK_IMAGE_URL;
}
this.icon = icon;
this.fireEvent('iconchange', this, oldIcon, icon);
},

setIconCls: function(iconCls) {
var me = this,
iconEl = me.iconEl,
oldCls = me.iconCls;
if (iconEl) {
if (me.iconCls) {
iconEl.removeCls(me.iconCls);
}
if (iconCls) {
iconEl.addCls(iconCls);
}
}
me.iconCls = iconCls;
me.fireEvent('iconchange', me, oldCls, iconCls);
},

setText: function(text) {
var me = this,
el = me.textEl || me.el,
oldText = me.text;
me.text = text;
if (me.rendered) {
el.update(text || '');
// cannot just call layout on the component due to stretchmax
me.ownerCt.updateLayout();
}
me.fireEvent('textchange', me, oldText, text);
},
getTipAttr: function(){
return this.tooltipType == 'qtip' ? 'data-qtip' : 'title';
},
//private
clearTip: function() {
if (Ext.quickTipsActive && Ext.isObject(this.tooltip)) {
Ext.tip.QuickTipManager.unregister(this.itemEl);
}
},

setTooltip: function(tooltip, initial) {
var me = this;
if (me.rendered) {
if (!initial) {
me.clearTip();
}
if (Ext.quickTipsActive && Ext.isObject(tooltip)) {
Ext.tip.QuickTipManager.register(Ext.apply({
target: me.itemEl.id
},
tooltip));
me.tooltip = tooltip;
} else {
me.itemEl.dom.setAttribute(me.getTipAttr(), tooltip);
}
} else {
me.tooltip = tooltip;
}
return me;
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/menu/CheckItem.js */
(function(Ext) {
Ext.define('Ext.menu.CheckItem', {
extend: 'Ext.menu.Item',
alias: 'widget.menucheckitem',








checkedCls: Ext.baseCSSPrefix + 'menu-item-checked',

uncheckedCls: Ext.baseCSSPrefix + 'menu-item-unchecked',

groupCls: Ext.baseCSSPrefix + 'menu-group-icon',

hideOnClick: false,


checkChangeDisabled: false,
childEls: [
'itemEl', 'iconEl', 'textEl', 'checkEl'
],

showCheckbox: true,
renderTpl: [
'<tpl if="plain">',
'{text}',
'<tpl else>',
'{%var showCheckbox = values.showCheckbox,',
' rightCheckbox = showCheckbox && values.hasIcon && (values.iconAlign !== "left"), textCls = rightCheckbox ? "' + Ext.baseCSSPrefix + 'right-check-item-text" : "";%}',
'<a id="{id}-itemEl" class="' + Ext.baseCSSPrefix + 'menu-item-link{childElCls}" href="{href}" <tpl if="hrefTarget">target="{hrefTarget}"</tpl> hidefocus="true" unselectable="on"',
'<tpl if="tabIndex">',
' tabIndex="{tabIndex}"',
'</tpl>',
'>',
'{%if (values.hasIcon && (values.iconAlign !== "left")) {%}',
'<div role="img" id="{id}-iconEl" class="' + Ext.baseCSSPrefix + 'menu-item-icon {iconCls}',
'{childElCls} {glyphCls}" style="<tpl if="icon">background-image:url({icon});</tpl>',
'<tpl if="glyph && glyphFontFamily">font-family:{glyphFontFamily};</tpl>">',
'<tpl if="glyph">&#{glyph};</tpl>',
'</div>',
'{%} else if (showCheckbox){%}',
'<img id="{id}-checkEl" src="{blank}" class="' + Ext.baseCSSPrefix + 'menu-item-icon{childElCls}" />',
'{%}%}',
'<span id="{id}-textEl" class="' + Ext.baseCSSPrefix + 'menu-item-text {[textCls]}{childElCls}" <tpl if="arrowCls">style="margin-right: 17px;"</tpl> >{text}</span>',
// CheckItem with an icon puts the icon on the right unless iconAlign=='left'
'{%if (rightCheckbox) {%}',
'<img id="{id}-checkEl" src="{blank}" class="' + Ext.baseCSSPrefix + 'menu-item-icon-right{childElCls}" />',
'{%} else if (values.arrowCls) {%}',
'<img id="{id}-arrowEl" src="{blank}" class="{arrowCls}{childElCls}"/>',
'{%}%}',
'</a>',
'</tpl>'
],
initComponent: function() {
var me = this;

// coerce to bool straight away
me.checked = !!me.checked;
me.addEvents(

'beforecheckchange',

'checkchange'
);
me.callParent(arguments);
Ext.menu.Manager.registerCheckable(me);
if (me.group) {
me.showCheckbox = false
if (!(me.iconCls || me.icon || me.glyph)) {
me.iconCls = me.groupCls;
}
if (me.initialConfig.hideOnClick !== false) {
me.hideOnClick = true;
}
}
},

beforeRender: function() {
this.callParent();
this.renderData.showCheckbox = this.showCheckbox;
},

afterRender: function() {
var me = this;
me.callParent();
me.checked = !me.checked;
me.setChecked(!me.checked, true);
if (me.checkChangeDisabled) {
me.disableCheckChange();
}
},


disableCheckChange: function() {
var me = this,
checkEl = me.checkEl;
if (checkEl) {
checkEl.addCls(me.disabledCls);
}
// In some cases the checkbox will disappear until repainted
// Happens in everything except IE9 strict, see: EXTJSIV-6412
if (!(Ext.isIE10p || (Ext.isIE9 && Ext.isStrict)) && me.rendered) {
me.el.repaint();
}
me.checkChangeDisabled = true;
},

enableCheckChange: function() {
var me = this,
checkEl = me.checkEl;

if (checkEl) {
checkEl.removeCls(me.disabledCls);
}
me.checkChangeDisabled = false;
},
onClick: function(e) {
var me = this;
if(!me.disabled && !me.checkChangeDisabled && !(me.checked && me.group)) {
me.setChecked(!me.checked);
}
this.callParent([e]);
},
onDestroy: function() {
Ext.menu.Manager.unregisterCheckable(this);
this.callParent(arguments);
},

setChecked: function(checked, suppressEvents) {
var me = this;
if (me.checked !== checked && (suppressEvents || me.fireEvent('beforecheckchange', me, checked) !== false)) {
if (me.el) {
me.el[checked ? 'addCls' : 'removeCls'](me.checkedCls)[!checked ? 'addCls' : 'removeCls'](me.uncheckedCls);
}
me.checked = checked;
Ext.menu.Manager.onCheckChange(me, checked);
if (!suppressEvents) {
Ext.callback(me.checkHandler, me.scope, [me, checked]);
me.fireEvent('checkchange', me, checked);
}
}
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/util/KeyNav.js */
(function(Ext) {
Ext.define('Ext.util.KeyNav', {
alternateClassName: 'Ext.KeyNav',
requires: ['Ext.util.KeyMap'],
statics: {
keyOptions: {
left: 37,
right: 39,
up: 38,
down: 40,
space: 32,
pageUp: 33,
pageDown: 34,
del: 46,
backspace: 8,
home: 36,
end: 35,
enter: 13,
esc: 27,
tab: 9
}
},
constructor: function(config) {
var me = this;
if (arguments.length === 2) {
me.legacyConstructor.apply(me, arguments);
return;
}
me.setConfig(config);
},

legacyConstructor: function(el, config) {
this.setConfig(Ext.apply({
target: el
}, config));
},

setConfig: function(config) {
var me = this,
keymapCfg = {
target: config.target,
ignoreInputFields: config.ignoreInputFields,
eventName: me.getKeyEvent('forceKeyDown' in config ? config.forceKeyDown : me.forceKeyDown, config.eventName)
},
map, keyCodes, defaultScope, keyName, binding;
if (me.map) {
me.map.destroy();
}
if (config.processEvent) {
keymapCfg.processEvent = config.processEvent;
keymapCfg.processEventScope = config.processEventScope||me;
}
// If they specified a KeyMap to use, use it
if (config.keyMap) {
map = me.map = config.keyMap;
}
// Otherwise, create one, and remember to destroy it on destroy
else {
map = me.map = new Ext.util.KeyMap(keymapCfg);
me.destroyKeyMap = true;
}
keyCodes = Ext.util.KeyNav.keyOptions;
defaultScope = config.scope || me;
for (keyName in keyCodes) {
if (keyCodes.hasOwnProperty(keyName)) {
// There is a property named after a key name.
// It may be a function or an binding spec containing handler, scope and defaultAction configs
if (binding = config[keyName]) {
if (typeof binding === 'function') {
binding = {
handler: binding,
defaultEventAction: (config.defaultEventAction !== undefined) ? config.defaultEventAction : me.defaultEventAction
};
}
map.addBinding({
key: keyCodes[keyName],
handler: Ext.Function.bind(me.handleEvent, binding.scope||defaultScope, binding.handler||binding.fn, true),
defaultEventAction: (binding.defaultEventAction !== undefined) ? binding.defaultEventAction : me.defaultEventAction
});
}
}
}
map.disable();
if (!config.disabled) {
map.enable();
}
},

handleEvent: function(keyCode, event, handler){
return handler.call(this, event);
},

disabled: false,

defaultEventAction: "stopEvent",

forceKeyDown: false,


eventName: 'keypress',





destroy: function(removeEl) {
if (this.destroyKeyMap) {
this.map.destroy(removeEl);
}
delete this.map;
},

enable: function() {
// this.map will be removed if destroyed
if (this.map) {
this.map.enable();
this.disabled = false;
}
},

disable: function() {
// this.map will be removed if destroyed
if (this.map) {
this.map.disable();
}
this.disabled = true;
},

setDisabled : function(disabled) {
this.map.setDisabled(disabled);
this.disabled = disabled;
},

getKeyEvent: function(forceKeyDown, configuredEventName) {
if (forceKeyDown || (Ext.EventManager.useKeyDown && !configuredEventName)) {
return 'keydown';
} else {
return configuredEventName||this.eventName;
}
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/FocusManager.js */
(function(Ext) {
Ext.define('Ext.FocusManager', {
singleton: true,
alternateClassName: ['Ext.FocusMgr' ],
mixins: {
observable: 'Ext.util.Observable'
},
requires: [
'Ext.AbstractComponent',
'Ext.Component',
'Ext.ComponentManager',
'Ext.ComponentQuery',
'Ext.util.HashMap',
'Ext.util.KeyNav'
],

enabled: false,

focusElementCls: Ext.baseCSSPrefix + 'focus-element',
focusFrameCls: Ext.baseCSSPrefix + 'focus-frame',

whitelist: [
'textfield'
],
constructor: function(config) {
var me = this,
CQ = Ext.ComponentQuery;
me.mixins.observable.constructor.call(me, config);
me.addEvents(

'beforecomponentfocus',

'componentfocus',

'disable',

'enable'
);
me.focusTask = new Ext.util.DelayedTask(me.handleComponentFocus, me);
// Gain control on Component focus, blur, hide and destroy
Ext.override(Ext.AbstractComponent, {
onFocus: function() {
this.callParent(arguments);
if (me.enabled && this.hasFocus) {
Array.prototype.unshift.call(arguments, this);
me.onComponentFocus.apply(me, arguments);
}
},
onBlur: function() {
this.callParent(arguments);
if (me.enabled && !this.hasFocus) {
Array.prototype.unshift.call(arguments, this);
me.onComponentBlur.apply(me, arguments);
}
},
onDestroy: function() {
this.callParent(arguments);
if (me.enabled) {
Array.prototype.unshift.call(arguments, this);
me.onComponentDestroy.apply(me, arguments);
}
}
});
Ext.override(Ext.Component, {
afterHide: function() {
this.callParent(arguments);
if (me.enabled) {
Array.prototype.unshift.call(arguments, this);
me.onComponentHide.apply(me, arguments);
}
}
});
// Setup KeyNav that's bound to document to catch all
// unhandled/bubbled key events for navigation
me.keyNav = new Ext.util.KeyNav(Ext.getDoc(), {
disabled: true,
scope: me,
backspace: me.focusLast,
enter: me.navigateIn,
esc: me.navigateOut,
tab: me.navigateSiblings,
space: me.navigateIn,
del: me.focusLast,
left: me.navigateSiblings,
right: me.navigateSiblings,
down: me.navigateSiblings,
up: me.navigateSiblings
});
me.focusData = {};
me.subscribers = new Ext.util.HashMap();
me.focusChain = {};
// Setup some ComponentQuery pseudos
Ext.apply(CQ.pseudos, {
// Return the single next focusable sibling from the current idx in either direction (step -1 or 1)
nextFocus: function(cmps, idx, step) {
step = step || 1;
idx = parseInt(idx, 10);
var len = cmps.length,
i = idx, c;
for (;;) {
// Increment index, and loop round if off either end
if ((i += step) >= len) {
i = 0;
} else if (i < 0) {
i = len - 1;
}
// As soon as we loop back to the starting index, give up, there are no focusable siblings.
if (i === idx) {
return [];
}
// If we have found a focusable sibling, return it
if ((c = cmps[i]).isFocusable()) {
return [c];
}
}
return [];
},
prevFocus: function(cmps, idx) {
return this.nextFocus(cmps, idx, -1);
},
root: function(cmps) {
var len = cmps.length,
results = [],
i = 0,
c;
for (; i < len; i++) {
c = cmps[i];
if (!c.ownerCt) {
results.push(c);
}
}
return results;
}
});
},

addXTypeToWhitelist: function(xtype) {
var me = this;
if (Ext.isArray(xtype)) {
Ext.Array.forEach(xtype, me.addXTypeToWhitelist, me);
return;
}
if (!Ext.Array.contains(me.whitelist, xtype)) {
me.whitelist.push(xtype);
}
},
clearComponent: function(cmp) {
clearTimeout(this.cmpFocusDelay);
if (!cmp.isDestroyed) {
cmp.blur();
}
},

disable: function() {
var me = this;
if (!me.enabled) {
return;
}
delete me.options;
me.enabled = false;
me.removeDOM();
// Stop handling key navigation
me.keyNav.disable();
me.fireEvent('disable', me);
},

enable: function(options) {
var me = this;
if (options === true) {
options = { focusFrame: true };
}
me.options = options = options || {};
if (me.enabled) {
return;
}
// When calling addFocusListener on Containers, the FocusManager must be enabled, otherwise it won't do it.
me.enabled = true;
me.initDOM(options);
// Start handling key navigation
me.keyNav.enable();
// Finally, let's focus our global focus el so we start fresh
me.focusEl.focus();
delete me.focusedCmp;
me.fireEvent('enable', me);
},
focusLast: function(e) {
var me = this;
if (me.isWhitelisted(me.focusedCmp)) {
return true;
}
// Go back to last focused item
if (me.previousFocusedCmp) {
me.previousFocusedCmp.focus();
}
},
getRootComponents: function() {
var CQ = Ext.ComponentQuery,
inline = CQ.query(':focusable:root:not([floating])'),
floating = CQ.query(':focusable:root[floating]');
// Floating items should go to the top of our root stack, and be ordered
// by their z-index (highest first)
floating.sort(function(a, b) {
return a.el.getZIndex() > b.el.getZIndex();
});
return floating.concat(inline);
},
initDOM: function(options) {
var me = this,
cls = me.focusFrameCls,
needListeners = Ext.ComponentQuery.query('{getFocusEl()}:not([focusListenerAdded])'),
i = 0, len = needListeners.length;
if (!Ext.isReady) {
return Ext.onReady(me.initDOM, me);
}
// When we are enabled, we must ensure that all Components which return a focusEl that is *not naturally focusable*
// have focus/blur listeners enabled to then trigger onFocus/onBlur handling so that we get to know about their focus action.
// These listeners are not added at initialization unless the FocusManager is enabled at that time.
for (; i < len; i++) {
needListeners[i].addFocusListener();
}
// Make the document body the global focus element
if (!me.focusEl) {
me.focusEl = Ext.getBody();
me.focusEl.dom.tabIndex = -1;
}
// Create global focus frame
if (!me.focusFrame && options.focusFrame) {
me.focusFrame = Ext.getBody().createChild({
cls: cls,
children: [
{ cls: cls + '-top' },
{ cls: cls + '-bottom' },
{ cls: cls + '-left' },
{ cls: cls + '-right' }
],
style: 'top: -100px; left: -100px;'
});
me.focusFrame.setVisibilityMode(Ext.Element.DISPLAY);
me.focusFrame.hide().setLocalXY(0, 0);
}
},
isWhitelisted: function(cmp) {
return cmp && Ext.Array.some(this.whitelist, function(x) {
return cmp.isXType(x);
});
},
navigateIn: function(e) {
var me = this,
focusedCmp = me.focusedCmp,
defaultRoot,
firstChild;
if (me.isWhitelisted(focusedCmp)) {
return true;
}
if (!focusedCmp) {
// No focus yet, so focus the first root cmp on the page
defaultRoot = me.getRootComponents()[0];
if (defaultRoot) {
// If the default root is based upon the body, then it will already be focused, and will not fire a focus event to
// trigger its own onFocus processing, so we have to programatically blur it first.
if (defaultRoot.getFocusEl() === me.focusEl) {
me.focusEl.blur();
}
defaultRoot.focus();
}
} else {
// Drill into child ref items of the focused cmp, if applicable.
// This works for any Component with a getRefItems implementation.
firstChild = focusedCmp.hasFocus ? Ext.ComponentQuery.query('>:focusable', focusedCmp)[0] : focusedCmp;
if (firstChild) {
firstChild.focus();
} else {
// Let's try to fire a click event, as if it came from the mouse
if (Ext.isFunction(focusedCmp.onClick)) {
e.button = 0;
focusedCmp.onClick(e);
if (focusedCmp.isVisible(true)) {
focusedCmp.focus();
} else {
me.navigateOut();
}
}
}
}
},
navigateOut: function(e) {
var me = this,
parent;
if (!me.focusedCmp || !(parent = me.focusedCmp.up(':focusable'))) {
me.focusEl.focus();
} else {
parent.focus();
}
// In some browsers (Chrome) FocusManager can handle this before other
// handlers. Ext Windows have their own Esc key handling, so we need to
// return true here to allow the event to bubble.
return true;
},
navigateSiblings: function(e, source, parent) {
var me = this,
src = source || me,
key = e.getKey(),
EO = Ext.EventObject,
goBack = e.shiftKey || key == EO.LEFT || key == EO.UP,
checkWhitelist = key == EO.LEFT || key == EO.RIGHT || key == EO.UP || key == EO.DOWN,
nextSelector = goBack ? 'prev' : 'next',
idx, next, focusedCmp, siblings;
focusedCmp = (src.focusedCmp && src.focusedCmp.comp) || src.focusedCmp;
if (!focusedCmp && !parent) {
return true;
}
if (checkWhitelist && me.isWhitelisted(focusedCmp)) {
return true;
}
// If no focused Component, or a root level one was focused, then siblings are root components.
if (!focusedCmp || focusedCmp.is(':root')) {
siblings = me.getRootComponents();
} else {
// Else if the focused component has a parent, get siblings from there
parent = parent || focusedCmp.up();
if (parent) {
siblings = parent.getRefItems();
}
}
// Navigate if we have found siblings.
if (siblings) {
idx = focusedCmp ? Ext.Array.indexOf(siblings, focusedCmp) : -1;
next = Ext.ComponentQuery.query(':' + nextSelector + 'Focus(' + idx + ')', siblings)[0];
if (next && focusedCmp !== next) {
next.focus();
return next;
}
}
},
onComponentBlur: function(cmp, e) {
var me = this;
if (me.focusedCmp === cmp) {
me.previousFocusedCmp = cmp;
delete me.focusedCmp;
}
if (me.focusFrame) {
me.focusFrame.hide();
}
},
onComponentFocus: function(cmp, e) {
var me = this,
chain = me.focusChain,
parent;
if (!cmp.isFocusable()) {
me.clearComponent(cmp);
// Check our focus chain, so we don't run into a never ending recursion
// If we've attempted (unsuccessfully) to focus this component before,
// then we're caught in a loop of child->parent->...->child and we
// need to cut the loop off rather than feed into it.
if (chain[cmp.id]) {
return;
}
// Try to focus the parent instead
parent = cmp.up();
if (parent) {
// Add component to our focus chain to detect infinite focus loop
// before we fire off an attempt to focus our parent.
// See the comments above.
chain[cmp.id] = true;
parent.focus();
}
return;
}
// Clear our focus chain when we have a focusable component
me.focusChain = {};
// Capture the focusEl to frame now.
// Button returns its encapsulating element during the focus phase
// So that element gets styled and framed.
me.focusTask.delay(10, null, null, [cmp, cmp.getFocusEl()]);
},
handleComponentFocus: function(cmp, focusEl) {
var me = this,
cls,
ff,
box,
bt,
bl,
bw,
bh,
ft,
fb,
fl,
fr;
if (me.fireEvent('beforecomponentfocus', me, cmp, me.previousFocusedCmp) === false) {
me.clearComponent(cmp);
return;
}
me.focusedCmp = cmp;
// If we have a focus frame, show it around the focused component
if (me.shouldShowFocusFrame(cmp)) {
cls = '.' + me.focusFrameCls + '-';
ff = me.focusFrame;

// focusEl may in fact be a descendant component to which to delegate focus
box = (focusEl.dom ? focusEl : focusEl.el).getBox();
// Size the focus frame's t/b/l/r according to the box
// This leaves a hole in the middle of the frame so user
// interaction w/ the mouse can continue
bt = box.top;
bl = box.left;
bw = box.width;
bh = box.height;
ft = ff.child(cls + 'top');
fb = ff.child(cls + 'bottom');
fl = ff.child(cls + 'left');
fr = ff.child(cls + 'right');
ft.setWidth(bw).setLocalXY(bl, bt);
fb.setWidth(bw).setLocalXY(bl, bt + bh - 2);
fl.setHeight(bh - 2).setLocalXY(bl, bt + 2);
fr.setHeight(bh - 2).setLocalXY(bl + bw - 2, bt + 2);
ff.show();
}
me.fireEvent('componentfocus', me, cmp, me.previousFocusedCmp);
},
onComponentHide: function(cmp) {
var me = this,
cmpHadFocus = false,
focusedCmp = me.focusedCmp,
parent;
if (focusedCmp) {
// See if the Component being hidden was the focused Component, or owns the focused Component
// In these cases, focus needs to be removed from the focused Component to the nearest focusable ancestor
cmpHadFocus = cmp.hasFocus || (cmp.isContainer && cmp.isAncestor(me.focusedCmp));
}
me.clearComponent(cmp);
// Move focus onto the nearest focusable ancestor, or this is there is none
if (cmpHadFocus && (parent = cmp.up(':focusable'))) {
parent.focus();
} else {
me.focusEl.focus();
}
},
onComponentDestroy: function() {
},
removeDOM: function() {
var me = this;
// If we are still enabled globally, or there are still subscribers
// then we will halt here, since our DOM stuff is still being used
if (me.enabled || me.subscribers.length) {
return;
}
Ext.destroy(
me.focusFrame
);
delete me.focusEl;
delete me.focusFrame;
},

removeXTypeFromWhitelist: function(xtype) {
var me = this;
if (Ext.isArray(xtype)) {
Ext.Array.forEach(xtype, me.removeXTypeFromWhitelist, me);
return;
}
Ext.Array.remove(me.whitelist, xtype);
},
setupSubscriberKeys: function(container, keys) {
var me = this,
el = container.getFocusEl(),
scope = keys.scope,
handlers = {
backspace: me.focusLast,
enter: me.navigateIn,
esc: me.navigateOut,
scope: me
},
navSiblings = function(e) {
if (me.focusedCmp === container) {
// Root the sibling navigation to this container, so that we
// can automatically dive into the container, rather than forcing
// the user to hit the enter key to dive in.
return me.navigateSiblings(e, me, container);
} else {
return me.navigateSiblings(e);
}
};
Ext.iterate(keys, function(key, cb) {
handlers[key] = function(e) {
var ret = navSiblings(e);
if (Ext.isFunction(cb) && cb.call(scope || container, e, ret) === true) {
return true;
}
return ret;
};
}, me);
return new Ext.util.KeyNav(el, handlers);
},
shouldShowFocusFrame: function(cmp) {
var me = this,
opts = me.options || {};
// Do not show a focus frame if
// 1. We are configured not to.
// 2. No Component was passed
if (!me.focusFrame || !cmp) {
return false;
}
// Global trumps
if (opts.focusFrame) {
return true;
}
if (me.focusData[cmp.id].focusFrame) {
return true;
}
return false;
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/menu/KeyNav.js */
(function(Ext) {
Ext.define('Ext.menu.KeyNav', {
extend: 'Ext.util.KeyNav',
requires: ['Ext.FocusManager'],

constructor: function(config) {
var me = this;
me.menu = config.target;
me.callParent([Ext.apply({
down: me.down,
enter: me.enter,
esc: me.escape,
left: me.left,
right: me.right,
space: me.enter,
tab: me.tab,
up: me.up
}, config)]);
},
down: function(e) {
var me = this,
fi = me.menu.focusedItem;
if (fi && e.getKey() == Ext.EventObject.DOWN && me.isWhitelisted(fi)) {
return true;
}
me.focusNextItem(1);
},
enter: function(e) {
var menu = this.menu,
focused = menu.focusedItem;

if (menu.activeItem) {
menu.onClick(e);
} else if (focused && focused.isFormField) {
// prevent stopEvent being called
return true;
}
},
escape: function(e) {
Ext.menu.Manager.hideAll();
},
focusNextItem: function(step) {
var menu = this.menu,
items = menu.items,
focusedItem = menu.focusedItem,
startIdx = focusedItem ? items.indexOf(focusedItem) : -1,
idx = startIdx + step,
len = items.length,
count = 0,
item;
// Limit the count, since we might not be able to find something to focus
while (count < len && idx !== startIdx) {
if (idx < 0) {
idx = len - 1;
} else if (idx >= len) {
idx = 0;
}
item = items.getAt(idx);
if (menu.canActivateItem(item)) {
menu.setActiveItem(item);
break;
}
idx += step;
++count;
}
},
isWhitelisted: function(item) {
return Ext.FocusManager.isWhitelisted(item);
},
left: function(e) {
var menu = this.menu,
fi = menu.focusedItem;
if (fi && this.isWhitelisted(fi)) {
return true;
}
menu.hide();
if (menu.parentMenu) {
menu.parentMenu.focus();
}
},
right: function(e) {
var menu = this.menu,
fi = menu.focusedItem,
ai = menu.activeItem,
am;
if (fi && this.isWhitelisted(fi)) {
return true;
}
if (ai) {
am = menu.activeItem.menu;
if (am) {
ai.expandMenu(0);
am.setActiveItem(am.child(':focusable'));
}
}
},
tab: function(e) {
var me = this;
if (e.shiftKey) {
me.up(e);
} else {
me.down(e);
}
},
up: function(e) {
var me = this,
fi = me.menu.focusedItem;
if (fi && e.getKey() == Ext.EventObject.UP && me.isWhitelisted(fi)) {
return true;
}
me.focusNextItem(-1);
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/menu/Separator.js */
(function(Ext) {
Ext.define('Ext.menu.Separator', {
extend: 'Ext.menu.Item',
alias: 'widget.menuseparator',


canActivate: false,



focusable: false,



hideOnClick: false,







plain: true,

separatorCls: Ext.baseCSSPrefix + 'menu-item-separator',

text: '&#160;',
beforeRender: function(ct, pos) {
var me = this;
me.callParent();
me.addCls(me.separatorCls);
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/menu/Menu.js */
(function(Ext) {
Ext.define('Ext.menu.Menu', {
extend: 'Ext.panel.Panel',
alias: 'widget.menu',
requires: [
'Ext.layout.container.Fit',
'Ext.layout.container.VBox',
'Ext.menu.CheckItem',
'Ext.menu.Item',
'Ext.menu.KeyNav',
'Ext.menu.Manager',
'Ext.menu.Separator'
],



enableKeyNav: true,

allowOtherMenus: false,

ariaRole: 'menu',


floating: true,

constrain: true,

hidden: true,
hideMode: 'visibility',

ignoreParentClicks: false,

isMenu: true,


showSeparator : true,

minWidth: undefined,
defaultMinWidth: 120,

initComponent: function() {
var me = this,
prefix = Ext.baseCSSPrefix,
cls = [prefix + 'menu'],
bodyCls = me.bodyCls ? [me.bodyCls] : [],
isFloating = me.floating !== false;
me.addEvents(

'click',

'mouseenter',

'mouseleave',

'mouseover'
);
Ext.menu.Manager.register(me);
// Menu classes
if (me.plain) {
cls.push(prefix + 'menu-plain');
}
me.cls = cls.join(' ');
// Menu body classes
bodyCls.push(prefix + 'menu-body', Ext.dom.Element.unselectableCls);
me.bodyCls = bodyCls.join(' ');
// Internal vbox layout, with scrolling overflow
// Placed in initComponent (rather than prototype) in order to support dynamic layout/scroller
// options if we wish to allow for such configurations on the Menu.
// e.g., scrolling speed, vbox align stretch, etc.
if (!me.layout) {
me.layout = {
type: 'vbox',
align: 'stretchmax',
overflowHandler: 'Scroller'
};
}
if (isFloating) {
// only apply the minWidth when we're floating & one hasn't already been set
if (me.minWidth === undefined) {
me.minWidth = me.defaultMinWidth;
}
} else {
// hidden defaults to false if floating is configured as false
me.hidden = !!me.initialConfig.hidden;
me.constrain = false;
}
me.callParent(arguments);
},
// Private implementation for Menus. They are a special case.
// They are always global floaters, never contained.
registerWithOwnerCt: function() {
if (this.floating) {
this.ownerCt = null;
Ext.WindowManager.register(this);
}
},
// Menus do not have owning containers on which they depend for visibility. They stand outside
// any container hierarchy.
initHierarchyEvents: Ext.emptyFn,
// Menus are never contained, and must not ascertain their visibility from the ancestor hierarchy
isVisible: function() {
return this.callParent();
},
// As menus are never contained, a Menu's visibility only ever depends upon its own hidden state.
// Ignore hiddenness from the ancestor hierarchy, override it with local hidden state.
getHierarchyState: function() {
var result = this.callParent();
result.hidden = this.hidden;
return result;
},
beforeRender: function() {
this.callParent(arguments);
// Menus are usually floating: true, which means they shrink wrap their items.
// However, when they are contained, and not auto sized, we must stretch the items.
if (!this.getSizeModel().width.shrinkWrap) {
this.layout.align = 'stretch';
}
},
onBoxReady: function() {
var me = this;
me.callParent(arguments);
// TODO: Move this to a subTemplate When we support them in the future
if (me.showSeparator) {
me.iconSepEl = me.layout.getElementTarget().insertFirst({
cls: Ext.baseCSSPrefix + 'menu-icon-separator',
html: '&#160;'
});
}
me.mon(me.el, {
click: me.onClick,
mouseover: me.onMouseOver,
scope: me
});
me.mouseMonitor = me.el.monitorMouseLeave(100, me.onMouseLeave, me);
// A Menu is a Panel. The KeyNav can use the Panel's KeyMap
if (me.enableKeyNav) {
me.keyNav = new Ext.menu.KeyNav({
target: me,
keyMap: me.getKeyMap()
});
}
},
getRefOwner: function() {
// If a submenu, this will have a parentMenu property
// If a menu of a Button, it will have an ownerButton property
// Else use the default method.
return this.parentMenu || this.ownerButton || this.callParent(arguments);
},

canActivateItem: function(item) {
return item && !item.isDisabled() && item.isVisible() && (item.canActivate || item.getXTypes().indexOf('menuitem') < 0);
},

deactivateActiveItem: function(andBlurFocusedItem) {
var me = this,
activeItem = me.activeItem,
focusedItem = me.focusedItem;
if (activeItem) {
activeItem.deactivate();
if (!activeItem.activated) {
delete me.activeItem;
}
}
// Blur the focused item if we are being asked to do that too
// Only needed if we are being hidden - mouseout does not blur.
if (focusedItem && andBlurFocusedItem) {
focusedItem.blur();
delete me.focusedItem;
}
},
// @inheritdoc
getFocusEl: function() {
return this.focusedItem || this.el;
},
// @inheritdoc
hide: function() {
this.deactivateActiveItem(true);
this.callParent(arguments);
},
// @private
getItemFromEvent: function(e) {
return this.getChildByElement(e.getTarget());
},
lookupComponent: function(cmp) {
var me = this;
if (typeof cmp == 'string') {
cmp = me.lookupItemFromString(cmp);
} else if (Ext.isObject(cmp)) {
cmp = me.lookupItemFromObject(cmp);
}
// Apply our minWidth to all of our child components so it's accounted
// for in our VBox layout
cmp.minWidth = cmp.minWidth || me.minWidth;
return cmp;
},
// @private
lookupItemFromObject: function(cmp) {
var me = this,
prefix = Ext.baseCSSPrefix,
cls;
if (!cmp.isComponent) {
if (!cmp.xtype) {
cmp = Ext.create('Ext.menu.' + (Ext.isBoolean(cmp.checked) ? 'Check': '') + 'Item', cmp);
} else {
cmp = Ext.ComponentManager.create(cmp, cmp.xtype);
}
}
if (cmp.isMenuItem) {
cmp.parentMenu = me;
}
if (!cmp.isMenuItem && !cmp.dock) {
cls = [prefix + 'menu-item-cmp'];
// The "plain" setting means that the menu does not look so much like a menu. It's more like a grey Panel.
// So it has no vertical separator.
// Plain menus also will not indent non MenuItem components; there is nothing to indent them to the right of.
if (!me.plain && (cmp.indent !== false || cmp.iconCls === 'no-icon')) {
cls.push(prefix + 'menu-item-indent');
}
if (cmp.rendered) {
cmp.el.addCls(cls);
} else {
cmp.cls = (cmp.cls || '') + ' ' + cls.join(' ');
}
}
return cmp;
},
// @private
lookupItemFromString: function(cmp) {
return (cmp == 'separator' || cmp == '-') ?
new Ext.menu.Separator()
: new Ext.menu.Item({
canActivate: false,
hideOnClick: false,
plain: true,
text: cmp
});
},
onClick: function(e) {
var me = this,
item;
if (me.disabled) {
e.stopEvent();
return;
}
item = (e.type === 'click') ? me.getItemFromEvent(e) : me.activeItem;
if (item && item.isMenuItem) {
if (!item.menu || !me.ignoreParentClicks) {
item.onClick(e);
} else {
e.stopEvent();
}
}
// Click event may be fired without an item, so we need a second check
if (!item || item.disabled) {
item = undefined;
}
me.fireEvent('click', me, item, e);
},
onDestroy: function() {
var me = this;
Ext.menu.Manager.unregister(me);
me.parentMenu = me.ownerButton = null;
if (me.rendered) {
me.el.un(me.mouseMonitor);
Ext.destroy(me.keyNav);
me.keyNav = null;
}
me.callParent(arguments);
},
onMouseLeave: function(e) {
var me = this;
me.deactivateActiveItem();
if (me.disabled) {
return;
}
me.fireEvent('mouseleave', me, e);
},
onMouseOver: function(e) {
var me = this,
fromEl = e.getRelatedTarget(),
mouseEnter = !me.el.contains(fromEl),
item = me.getItemFromEvent(e),
parentMenu = me.parentMenu,
parentItem = me.parentItem;
if (mouseEnter && parentMenu) {
parentMenu.setActiveItem(parentItem);
parentItem.cancelDeferHide();
parentMenu.mouseMonitor.mouseenter();
}
if (me.disabled) {
return;
}
// Do not activate the item if the mouseover was within the item, and it's already active
if (item && !item.activated) {
me.setActiveItem(item);
if (item.activated && item.expandMenu) {
item.expandMenu();
}
}
if (mouseEnter) {
me.fireEvent('mouseenter', me, e);
}
me.fireEvent('mouseover', me, item, e);
},
setActiveItem: function(item) {
var me = this;
if (item && (item != me.activeItem)) {
me.deactivateActiveItem();
if (me.canActivateItem(item)) {
if (item.activate) {
item.activate();
if (item.activated) {
me.activeItem = item;
me.focusedItem = item;
me.focus();
}
} else {
item.focus();
me.focusedItem = item;
}
}
item.el.scrollIntoView(me.layout.getRenderTarget());
}
},
showBy: function(cmp, pos, off) {
var me = this;
me.callParent(arguments);
if (!me.hidden) {
// show may have been vetoed
me.setVerticalPosition();
}
return me;
},
beforeShow: function() {
var me = this,
viewHeight;
// Constrain the height to the containing element's viewable area
if (me.floating) {
me.savedMaxHeight = me.maxHeight;
viewHeight = me.container.getViewSize().height;
me.maxHeight = Math.min(me.maxHeight || viewHeight, viewHeight);
}
me.callParent(arguments);
},
afterShow: function() {
var me = this;
me.callParent(arguments);
// Restore configured maxHeight
if (me.floating) {
me.maxHeight = me.savedMaxHeight;
}
},
// @private
// adjust the vertical position of the menu if the height of the
// menu is equal (or greater than) the viewport size
setVerticalPosition: function() {
var me = this,
max,
y = me.getY(),
returnY = y,
height = me.getHeight(),
viewportHeight = Ext.Element.getViewportHeight().height,
parentEl = me.el.parent(),
viewHeight = parentEl.getViewSize().height,
normalY = y - parentEl.getScroll().top; // factor in scrollTop of parent
parentEl = null;
if (me.floating) {
max = me.maxHeight ? me.maxHeight : viewHeight - normalY;
if (height > viewHeight) {
returnY = y - normalY;
} else if (max < height) {
returnY = y - (height - max);
} else if((y + height) > viewportHeight){ // keep the document from scrolling
returnY = viewportHeight - height;
}
}
me.setY(returnY);
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/menu/Manager.js */
(function(Ext) {
Ext.define('Ext.menu.Manager', {
singleton: true,
requires: [
'Ext.util.MixedCollection',
'Ext.util.KeyMap'
],
alternateClassName: 'Ext.menu.MenuMgr',
uses: ['Ext.menu.Menu'],

menuSelector: '.' + Ext.baseCSSPrefix + 'menu',
menus: {},
groups: {},
attached: false,
lastShow: new Date(),
init: function() {
var me = this;

me.active = new Ext.util.MixedCollection();
Ext.getDoc().addKeyListener(27, function() {
if (me.active.length > 0) {
me.hideAll();
}
}, me);
},

hideAll: function() {
var active = this.active,
menus, m, mLen;
if (active && active.length > 0) {
menus = Ext.Array.slice(active.items);
mLen = menus.length;
for (m = 0; m < mLen; m++) {
menus[m].hide();
}
return true;
}
return false;
},
onHide: function(m) {
var me = this,
active = me.active;
active.remove(m);
if (active.length < 1) {
Ext.getDoc().un('mousedown', me.onMouseDown, me);
me.attached = false;
}
},
onShow: function(m) {
var me = this,
active = me.active,
attached = me.attached;
me.lastShow = new Date();
active.add(m);
if (!attached) {
Ext.getDoc().on('mousedown', me.onMouseDown, me, {
// On IE we have issues with the menu stealing focus at certain points
// during the head, so give it a short buffer
buffer: Ext.isIE9m ? 10 : undefined
});
me.attached = true;
}
m.toFront();
},
onBeforeHide: function(m) {
if (m.activeChild) {
m.activeChild.hide();
}
if (m.autoHideTimer) {
clearTimeout(m.autoHideTimer);
delete m.autoHideTimer;
}
},
onBeforeShow: function(m) {
var active = this.active,
parentMenu = m.parentMenu;

active.remove(m);
if (!parentMenu && !m.allowOtherMenus) {
this.hideAll();
}
else if (parentMenu && parentMenu.activeChild && m != parentMenu.activeChild) {
parentMenu.activeChild.hide();
}
},
// @private
onMouseDown: function(e) {
var me = this,
active = me.active,
lastShow = me.lastShow,
doHide = true;
if (Ext.Date.getElapsed(lastShow) > 50 && active.length > 0 && !e.getTarget(me.menuSelector)) {
// Because we use a buffer in IE, the target may have been removed from the
// DOM by the time we get here, so the selector will never find the menu. In this
// case, it's safer to not hide than menus than to do so
if (Ext.isIE9m && !Ext.getDoc().contains(e.target)) {
doHide = false;
}
if (doHide) {
me.hideAll();
}
}
},
// @private
register: function(menu) {
var me = this;
if (!me.active) {
me.init();
}
if (menu.floating) {
me.menus[menu.id] = menu;
menu.on({
beforehide: me.onBeforeHide,
hide: me.onHide,
beforeshow: me.onBeforeShow,
show: me.onShow,
scope: me
});
}
},

get: function(menu) {
var menus = this.menus;

if (typeof menu == 'string') { // menu id
if (!menus) { // not initialized, no menus to return
return null;
}
return menus[menu];
} else if (menu.isMenu) { // menu instance
return menu;
} else if (Ext.isArray(menu)) { // array of menu items
return new Ext.menu.Menu({items:menu});
} else { // otherwise, must be a config
return Ext.ComponentManager.create(menu, 'menu');
}
},
// @private
unregister: function(menu) {
var me = this,
menus = me.menus,
active = me.active;
delete menus[menu.id];
active.remove(menu);
menu.un({
beforehide: me.onBeforeHide,
hide: me.onHide,
beforeshow: me.onBeforeShow,
show: me.onShow,
scope: me
});
},
// @private
registerCheckable: function(menuItem) {
var groups = this.groups,
groupId = menuItem.group;
if (groupId) {
if (!groups[groupId]) {
groups[groupId] = [];
}
groups[groupId].push(menuItem);
}
},
// @private
unregisterCheckable: function(menuItem) {
var groups = this.groups,
groupId = menuItem.group;
if (groupId) {
Ext.Array.remove(groups[groupId], menuItem);
}
},
onCheckChange: function(menuItem, state) {
var groups = this.groups,
groupId = menuItem.group,
i = 0,
group, ln, curr;
if (groupId && state) {
group = groups[groupId];
ln = group.length;
for (; i < ln; i++) {
curr = group[i];
if (curr != menuItem) {
curr.setChecked(false);
}
}
}
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/util/ClickRepeater.js */
(function(Ext) {
Ext.define('Ext.util.ClickRepeater', {
extend: 'Ext.util.Observable',

constructor : function(el, config){
var me = this;
me.el = Ext.get(el);
me.el.unselectable();
Ext.apply(me, config);
me.callParent();
me.addEvents(

"mousedown",

"click",

"mouseup"
);
if(!me.disabled){
me.disabled = true;
me.enable();
}
// allow inline handler
if(me.handler){
me.on("click", me.handler, me.scope || me);
}
},




interval : 20,

delay: 250,

preventDefault : true,

stopDefault : false,
timer : 0,

enable: function(){
if(this.disabled){
this.el.on('mousedown', this.handleMouseDown, this);
// IE versions will detect clicks as in sequence as dblclicks
// if they happen in quick succession
if (Ext.isIE && !(Ext.isIE10p || (Ext.isStrict && Ext.isIE9))){
this.el.on('dblclick', this.handleDblClick, this);
}
if(this.preventDefault || this.stopDefault){
this.el.on('click', this.eventOptions, this);
}
}
this.disabled = false;
},

disable: function( force){
if(force || !this.disabled){
clearTimeout(this.timer);
if(this.pressedCls){
this.el.removeCls(this.pressedCls);
}
Ext.getDoc().un('mouseup', this.handleMouseUp, this);
this.el.removeAllListeners();
}
this.disabled = true;
},

setDisabled: function(disabled){
this[disabled ? 'disable' : 'enable']();
},
eventOptions: function(e){
if(this.preventDefault){
e.preventDefault();
}
if(this.stopDefault){
e.stopEvent();
}
},
// @private
destroy : function() {
this.disable(true);
Ext.destroy(this.el);
this.clearListeners();
},
handleDblClick : function(e){
clearTimeout(this.timer);
this.el.blur();
this.fireEvent("mousedown", this, e);
this.fireEvent("click", this, e);
},
// @private
handleMouseDown : function(e){
clearTimeout(this.timer);
this.el.blur();
if(this.pressedCls){
this.el.addCls(this.pressedCls);
}
this.mousedownTime = new Date();
Ext.getDoc().on("mouseup", this.handleMouseUp, this);
this.el.on("mouseout", this.handleMouseOut, this);
this.fireEvent("mousedown", this, e);
this.fireEvent("click", this, e);
// Do not honor delay or interval if acceleration wanted.
if (this.accelerate) {
this.delay = 400;
}
// Re-wrap the event object in a non-shared object, so it doesn't lose its context if
// the global shared EventObject gets a new Event put into it before the timer fires.
e = new Ext.EventObjectImpl(e);
this.timer = Ext.defer(this.click, this.delay || this.interval, this, [e]);
},
// @private
click : function(e){
this.fireEvent("click", this, e);
this.timer = Ext.defer(this.click, this.accelerate ?
this.easeOutExpo(Ext.Date.getElapsed(this.mousedownTime),
400,
-390,
12000) :
this.interval, this, [e]);
},
easeOutExpo : function (t, b, c, d) {
return (t==d) ? b+c : c * (-Math.pow(2, -10 * t/d) + 1) + b;
},
// @private
handleMouseOut : function(){
clearTimeout(this.timer);
if(this.pressedCls){
this.el.removeCls(this.pressedCls);
}
this.el.on("mouseover", this.handleMouseReturn, this);
},
// @private
handleMouseReturn : function(){
this.el.un("mouseover", this.handleMouseReturn, this);
if(this.pressedCls){
this.el.addCls(this.pressedCls);
}
this.click();
},
// @private
handleMouseUp : function(e){
clearTimeout(this.timer);
this.el.un("mouseover", this.handleMouseReturn, this);
this.el.un("mouseout", this.handleMouseOut, this);
Ext.getDoc().un("mouseup", this.handleMouseUp, this);
if(this.pressedCls){
this.el.removeCls(this.pressedCls);
}
this.fireEvent("mouseup", this, e);
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/layout/component/Button.js */
(function(Ext) {
Ext.define('Ext.layout.component.Button', {

alias: ['layout.button'],
extend: 'Ext.layout.component.Auto',

type: 'button',
htmlRE: /<.*>/,
beginLayout: function(ownerContext) {
var me = this,
owner = me.owner,
text = owner.text;
me.callParent(arguments);
ownerContext.btnWrapContext = ownerContext.getEl('btnWrap');
ownerContext.btnElContext = ownerContext.getEl('btnEl');
ownerContext.btnInnerElContext = ownerContext.getEl('btnInnerEl');
ownerContext.btnIconElContext = ownerContext.getEl('btnIconEl');
if (text && me.htmlRE.test(text)) {
ownerContext.isHtmlText = true;
// If the text contains HTML tag(s) we need to account for the possibility
// of multi-line-text. We have to remove the default line-height set by the
// stylesheet so that we can allow the browser to measure the natural
// height of the html content.
owner.btnInnerEl.setStyle('line-height', 'normal');
owner.btnInnerEl.setStyle('padding-top', '');
}
},
beginLayoutCycle: function(ownerContext) {
var owner = this.owner,
lastWidthModel = this.lastWidthModel;
this.callParent(arguments);
if (lastWidthModel && !this.lastWidthModel.shrinkWrap &&
ownerContext.widthModel.shrinkWrap) {
// clear any heights we set last time around if needed
owner.btnWrap.setStyle('height', '');
owner.btnEl.setStyle('height', '');
owner.btnInnerEl.setStyle('line-height', '');
}
},
calculate: function(ownerContext) {
var me = this,
owner = me.owner,
btnElContext = ownerContext.btnElContext,
btnInnerElContext = ownerContext.btnInnerElContext,
btnWrapContext = ownerContext.btnWrapContext,
mmax = Math.max,
ownerHeight, contentHeight, btnElHeight, innerElHeight;
me.callParent(arguments);
if (ownerContext.heightModel.shrinkWrap) {
// Buttons that have a shrink-wrapped height usually do not need any layout
// adjustments beause their layout is handled in CSS. An exception is made
// for buttons that contain html tags in their "text". These buttons need
// special handling to vertically center the inner element inside the button.
// measure the btnEl (the anchor element) to determine the available
// height for centering the inner element.
btnElHeight = owner.btnEl.getHeight();
if (ownerContext.isHtmlText) {
me.centerInnerEl(
ownerContext,
btnElHeight
);
me.ieCenterIcon(ownerContext, btnElHeight);
}
} else {
// Buttons with configured or calculated heights may need to stretch their
// inner elements to fit.
ownerHeight = ownerContext.getProp('height');
// If height is 0, skip out all this
if (ownerHeight) {
// contentHeight is the total available height inside the button's padding
// and framing
contentHeight = ownerHeight - ownerContext.getFrameInfo().height - ownerContext.getPaddingInfo().height;
// The btnElHeight is the total available height to be shared by the button's
// icon and text. For standard buttons this is the same as the contentHeight
// but must be adjusted for arrow height if the button has an arrow.
btnElHeight = contentHeight;
if ((owner.menu || owner.split) && owner.arrowAlign === 'bottom') {
// If the button has an arrow, subtract its size from the btnElHeight
// padding to account for the possibility of an arrow
btnElHeight -= btnWrapContext.getPaddingInfo().bottom;
}
// The innerElHeight is the total vertical space available for vertically
// centering the button text. By default this is the same as btnElHeight
// but it must be adjusted by the icon size if the button has a top
// or bottom icon.
innerElHeight = btnElHeight;
if ((owner.icon || owner.iconCls || owner.glyph) &&
(owner.iconAlign === 'top' || owner.iconAlign === 'bottom')) {
innerElHeight -= btnInnerElContext.getPaddingInfo().height;
}
btnWrapContext.setProp('height', mmax(0, contentHeight));
btnElContext.setProp('height', mmax(0, btnElHeight));
// ensure the button's text is vertically centered
if (ownerContext.isHtmlText) {
// if the button text contains html it must be vertically centered
// by measuring it and adding top padding.
me.centerInnerEl(ownerContext, btnElHeight);
} else {
// if the button text does not contain html we can just center it
// using line-height to avoid the extra measurement that happens
// inside of centerInnerEl() since multi-line text is not a possiblity
btnInnerElContext.setProp('line-height', mmax(0, innerElHeight) + 'px');
}
me.ieCenterIcon(ownerContext, btnElHeight);
} else if (ownerHeight !== 0) {
// Only fail if height was undefined, since it could be 0
me.done = false;
}
}
},
centerInnerEl: function(ownerContext, btnElHeight) {
var me = this,
btnInnerElContext = ownerContext.btnInnerElContext,
innerElHeight = me.owner.btnInnerEl.getHeight();
if (ownerContext.heightModel.shrinkWrap && (btnElHeight < innerElHeight)) {
// if the natural height of the html content is greater than the height
// of the button element (the anchor el), then expand the button element
// to fit
ownerContext.btnElContext.setHeight(innerElHeight);
} else if (btnElHeight > innerElHeight) {
// if the natural height of the html content is smaller than the height
// of the button element then we need to pad the top of the btnInnerEl
// so that it is vertically centered within the btnEl
btnInnerElContext.setProp(
'padding-top', 
Math.round((btnElHeight - innerElHeight) / 2) +
// if the inner element already has top padding, as is the case
// when the button has a top-aligned icon, then add the existing
// padding to the padding adjustment.
btnInnerElContext.getPaddingInfo().top 
);
}
},
ieCenterIcon: function(ownerContext, btnElHeight) {
var iconAlign = this.owner.iconAlign;
if ((Ext.isIEQuirks || Ext.isIE6) &&
(iconAlign === 'left' || iconAlign === 'right')) {
// Normally right/left aligned icon elements are vertically stretched using
// top:0, bottom:0, and the icon is vertically centered inside this element
// using background-position. This technique for vertical centering does not
// work in IE6 and IE quirks, so the stylesheet sets a fixed height on the
// icon element in these browsers. If the layout changes the height of the
// button the height of the icon element must also be modified.
ownerContext.btnIconElContext.setHeight(btnElHeight);
}
},
publishInnerWidth: function(ownerContext, width) {
if (this.owner.getFrameInfo().table) {
// if the framing template uses a table, we need to set the width of the
// inner element. Otherwise long text may stretch the element past its
// allowable width in IE.
ownerContext.btnInnerElContext.setWidth(
width -
// the inner el must be sized inside the owner's framing and padding
ownerContext.getFrameInfo().width - ownerContext.getPaddingInfo().width -
// There may also be padding on the btnWrap el, e.g. tab with close icon
// or button with arrow. This reduces the inner el size even further.
ownerContext.btnWrapContext.getPaddingInfo().width
);
}
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/util/TextMetrics.js */
(function(Ext) {
Ext.define('Ext.util.TextMetrics', {
statics: {
shared: null,

measure: function(el, text, fixedWidth){
var me = this,
shared = me.shared;

if(!shared){
shared = me.shared = new me(el, fixedWidth);
}
shared.bind(el);
shared.setFixedWidth(fixedWidth || 'auto');
return shared.getSize(text);
},


destroy: function(){
var me = this;
Ext.destroy(me.shared);
me.shared = null;
}
},


constructor: function(bindTo, fixedWidth){
var me = this,
measure = Ext.getBody().createChild({
cls: Ext.baseCSSPrefix + 'textmetrics'
});

me.measure = measure; 
if (bindTo) {
me.bind(bindTo);
}

measure.position('absolute');
measure.setLocalXY(-1000, -1000);
measure.hide();
if (fixedWidth) {
measure.setWidth(fixedWidth);
}
},


getSize: function(text){
var measure = this.measure,
size;

measure.update(text);
size = measure.getSize();
measure.update('');
return size;
},


bind: function(el){
var me = this;

me.el = Ext.get(el);
me.measure.setStyle(
me.el.getStyles('font-size','font-style', 'font-weight', 'font-family','line-height', 'text-transform', 'letter-spacing')
);
},


setFixedWidth : function(width){
this.measure.setWidth(width);
},


getWidth : function(text){
this.measure.dom.style.width = 'auto';
return this.getSize(text).width;
},


getHeight : function(text){
return this.getSize(text).height;
},


destroy: function(){
var me = this;
me.measure.remove();
delete me.el;
delete me.measure;
}
}, function(){
Ext.Element.addMethods({

getTextWidth : function(text, min, max){
return Ext.Number.constrain(Ext.util.TextMetrics.measure(this.dom, Ext.value(text, this.dom.innerHTML, true)).width, min || 0, max || 1000000);
}
});
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/button/Button.js */
(function(Ext) {
Ext.define('Ext.button.Button', {

alias: 'widget.button',
extend: 'Ext.Component',
requires: [
'Ext.button.Manager',
'Ext.menu.Manager',
'Ext.util.ClickRepeater',
'Ext.layout.component.Button',
'Ext.util.TextMetrics',
'Ext.util.KeyMap'
],

mixins: {
queryable: 'Ext.Queryable'
},
alternateClassName: 'Ext.Button',


isButton: true,
componentLayout: 'button',

hidden: false,

disabled: false,

pressed: false,











tabIndex: 0,


enableToggle: false,



menuAlign: 'tl-bl?',

showEmptyMenu: false,

textAlign: 'center',




clickEvent: 'click',

preventDefault: true,

handleMouseEvents: true,

tooltipType: 'qtip',

baseCls: Ext.baseCSSPrefix + 'btn',

pressedCls: 'pressed',

overCls: 'over',

focusCls: 'focus',

menuActiveCls: 'menu-active',


hrefTarget: '_blank',



childEls: [
'btnEl', 'btnWrap', 'btnInnerEl', 'btnIconEl'
],
// We have to keep "unselectable" attribute on all elements because it's not inheritable.
// Without it, clicking anywhere on a button disrupts current selection and cursor position
// in HtmlEditor.
renderTpl: [
'<span id="{id}-btnWrap" class="{baseCls}-wrap',
'<tpl if="splitCls"> {splitCls}</tpl>',
'{childElCls}" unselectable="on">',
'<span id="{id}-btnEl" class="{baseCls}-button">',
'<span id="{id}-btnInnerEl" class="{baseCls}-inner {innerCls}',
'{childElCls}" unselectable="on">',
'{text}',
'</span>',
'<span role="img" id="{id}-btnIconEl" class="{baseCls}-icon-el {iconCls}',
'{childElCls} {glyphCls}" unselectable="on" style="',
'<tpl if="iconUrl">background-image:url({iconUrl});</tpl>',
'<tpl if="glyph && glyphFontFamily">font-family:{glyphFontFamily};</tpl>">',
'<tpl if="glyph">&#{glyph};</tpl><tpl if="iconCls || iconUrl">&#160;</tpl>',
'</span>',
'</span>',
'</span>',
// if "closable" (tab) add a close element icon
'<tpl if="closable">',
'<span id="{id}-closeEl" class="{baseCls}-close-btn" title="{closeText}" tabIndex="0"></span>',
'</tpl>'
],

scale: 'small',

allowedScales: ['small', 'medium', 'large'],


iconAlign: 'left',

arrowAlign: 'right',

arrowCls: 'arrow',



maskOnDisable: false,
shrinkWrap: 3,
frame: true,
// A reusable object used by getTriggerRegion to avoid excessive object creation.
_triggerRegion: {},
// inherit docs
initComponent: function() {
var me = this;
// the autoEl object can't be on the prototype because we add tabIndex and href
// properties to it conditionally.
me.autoEl = {
tag: 'a',
role: 'button',
hidefocus: 'on',
unselectable: 'on'
};
// Ensure no selection happens
me.addCls('x-unselectable');
me.callParent(arguments);
me.addEvents(

'click',

'toggle',

'mouseover',

'mouseout',

'menushow',

'menuhide',

'menutriggerover',

'menutriggerout',

'textchange',

'iconchange',

'glyphchange'
);
if (me.menu) {
// Flag that we'll have a splitCls
me.split = true;
// retrieve menu by id or instantiate instance if needed
me.menu = Ext.menu.Manager.get(me.menu);
// Use ownerButton as the upward link. Menus *must have no ownerCt* - they are global floaters.
// Upward navigation is done using the up() method.
me.menu.ownerButton = me;
}
// Accept url as a synonym for href
if (me.url) {
me.href = me.url;
}
// preventDefault defaults to false for links
if (me.href && !me.hasOwnProperty('preventDefault')) {
me.preventDefault = false;
}
if (Ext.isString(me.toggleGroup) && me.toggleGroup !== '') {
me.enableToggle = true;
}
if (me.html && !me.text) {
me.text = me.html;
delete me.html;
}
me.glyphCls = me.baseCls + '-glyph';
},
// inherit docs
getActionEl: function() {
return this.el;
},
// inherit docs
getFocusEl: function() {
return this.el;
},
// See comments in onFocus
onDisable: function(){
this.callParent(arguments);
},
// @private
setComponentCls: function() {
var me = this,
cls = me.getComponentCls();
if (!Ext.isEmpty(me.oldCls)) {
me.removeClsWithUI(me.oldCls);
me.removeClsWithUI(me.pressedCls);
}
me.oldCls = cls;
me.addClsWithUI(cls);
},
getComponentCls: function() {
var me = this,
cls;
// Check whether the button has an icon or not, and if it has an icon, what is the alignment
if (me.iconCls || me.icon || me.glyph) {
cls = [me.text ? 'icon-text-' + me.iconAlign : 'icon'];
} else if (me.text) {
cls = ['noicon'];
} else {
cls = [];
}
if (me.pressed) {
cls[cls.length] = me.pressedCls;
}
return cls;
},
beforeRender: function () {
var me = this,
autoEl = me.autoEl,
href = me.getHref(),
hrefTarget = me.hrefTarget;
if (!me.disabled) {
autoEl.tabIndex = me.tabIndex;
}
if (href) {
autoEl.href = href;
if (hrefTarget) {
autoEl.target = hrefTarget;
}
}
me.callParent();
// Add all needed classes to the protoElement.
me.oldCls = me.getComponentCls();
me.addClsWithUI(me.oldCls);
// Apply the renderData to the template args
Ext.applyIf(me.renderData, me.getTemplateArgs());
},
// @private
onRender: function() {
var me = this,
addOnclick,
btn,
btnListeners;
me.doc = Ext.getDoc();
me.callParent(arguments);
// Set btn as a local variable for easy access
btn = me.el;
if (me.tooltip) {
me.setTooltip(me.tooltip, true);
}
// Add the mouse events to the button
if (me.handleMouseEvents) {
btnListeners = {
scope: me,
mouseover: me.onMouseOver,
mouseout: me.onMouseOut,
mousedown: me.onMouseDown
};
if (me.split) {
btnListeners.mousemove = me.onMouseMove;
}
} else {
btnListeners = {
scope: me
};
}
// Check if the button has a menu
if (me.menu) {
me.mon(me.menu, {
scope: me,
show: me.onMenuShow,
hide: me.onMenuHide
});
me.keyMap = new Ext.util.KeyMap({
target: me.el,
key: Ext.EventObject.DOWN,
handler: me.onDownKey,
scope: me
});
}
// Check if it is a repeat button
if (me.repeat) {
me.mon(new Ext.util.ClickRepeater(btn, Ext.isObject(me.repeat) ? me.repeat: {}), 'click', me.onRepeatClick, me);
} else {
// If the activation event already has a handler, make a note to add the handler later
if (btnListeners[me.clickEvent]) {
addOnclick = true;
} else {
btnListeners[me.clickEvent] = me.onClick;
}
}
// Add whatever button listeners we need
me.mon(btn, btnListeners);
// If the listeners object had an entry for our clickEvent, add a listener now
if (addOnclick) {
me.mon(btn, me.clickEvent, me.onClick, me);
}
Ext.button.Manager.register(me);
},

getTemplateArgs: function() {
var me = this,
glyph = me.glyph,
glyphFontFamily = Ext._glyphFontFamily,
glyphParts;
if (typeof glyph === 'string') {
glyphParts = glyph.split('@');
glyph = glyphParts[0];
glyphFontFamily = glyphParts[1];
}
return {
innerCls : me.getInnerCls(),
splitCls : me.getSplitCls(),
iconUrl : me.icon,
iconCls : me.iconCls,
glyph: glyph,
glyphCls: glyph ? me.glyphCls : '', 
glyphFontFamily: glyphFontFamily,
text : me.text || '&#160;'
};
},

setHref: function(href) {
this.href = href;
this.el.dom.href = this.getHref();
},

getHref: function() {
var me = this,
href = me.href;
return href ? Ext.urlAppend(href, Ext.Object.toQueryString(Ext.apply({}, me.params, me.baseParams))) : false;
},

setParams: function(params) {
this.params = params;
this.el.dom.href = this.getHref();
},
getSplitCls: function() {
var me = this;
return me.split ? (me.baseCls + '-' + me.arrowCls) + ' ' + (me.baseCls + '-' + me.arrowCls + '-' + me.arrowAlign) : '';
},
getInnerCls: function() {
return this.textAlign ? this.baseCls + '-inner-' + this.textAlign : '';
},

setIcon: function(icon) {
icon = icon || '';
var me = this,
btnIconEl = me.btnIconEl,
oldIcon = me.icon || '';
me.icon = icon;
if (icon != oldIcon) {
if (btnIconEl) {
btnIconEl.setStyle('background-image', icon ? 'url(' + icon + ')': '');
me.setComponentCls();
if (me.didIconStateChange(oldIcon, icon)) {
me.updateLayout();
}
}
me.fireEvent('iconchange', me, oldIcon, icon);
}
return me;
},

setIconCls: function(cls) {
cls = cls || '';
var me = this,
btnIconEl = me.btnIconEl,
oldCls = me.iconCls || '';
me.iconCls = cls;
if (oldCls != cls) {
if (btnIconEl) {
// Remove the previous iconCls from the button
btnIconEl.removeCls(oldCls);
btnIconEl.addCls(cls);
me.setComponentCls();
if (me.didIconStateChange(oldCls, cls)) {
me.updateLayout();
}
}
me.fireEvent('iconchange', me, oldCls, cls);
}
return me;
},

setGlyph: function(glyph) {
glyph = glyph || 0;
var me = this,
btnIconEl = me.btnIconEl,
oldGlyph = me.glyph,
fontFamily, glyphParts;
me.glyph = glyph;
if (btnIconEl) {
if (typeof glyph === 'string') {
glyphParts = glyph.split('@');
glyph = glyphParts[0];
fontFamily = glyphParts[1] || Ext._glyphFontFamily;
}
if (!glyph) {
btnIconEl.dom.innerHTML = '';
} else if (oldGlyph != glyph) {
btnIconEl.dom.innerHTML = '&#' + glyph + ';';
}
if (fontFamily) {
btnIconEl.setStyle('font-family', fontFamily);
}
}
me.fireEvent('glyphchange', me, me.glyph, oldGlyph);
return me;
},

setTooltip: function(tooltip, initial) {
var me = this;
if (me.rendered) {
if (!initial || !tooltip) {
me.clearTip();
}
if (tooltip) {
if (Ext.quickTipsActive && Ext.isObject(tooltip)) {
Ext.tip.QuickTipManager.register(Ext.apply({
target: me.el.id
},
tooltip));
me.tooltip = tooltip;
} else {
me.el.dom.setAttribute(me.getTipAttr(), tooltip);
}
}
} else {
me.tooltip = tooltip;
}
return me;
},

setTextAlign: function(align) {
var me = this,
btnEl = me.btnEl;
if (btnEl) {
btnEl.removeCls(me.baseCls + '-inner-' + me.textAlign);
btnEl.addCls(me.baseCls + '-inner-' + align);
}
me.textAlign = align;
return me;
},
getTipAttr: function(){
return this.tooltipType == 'qtip' ? 'data-qtip' : 'title';
},
// @private
getRefItems: function(deep){
var menu = this.menu,
items;
if (menu) {
items = menu.getRefItems(deep);
items.unshift(menu);
}
return items || [];
},
// @private
clearTip: function() {
var me = this,
el = me.el;
if (Ext.quickTipsActive && Ext.isObject(me.tooltip)) {
Ext.tip.QuickTipManager.unregister(el);
} else {
el.dom.removeAttribute(me.getTipAttr());
}
},
// @private
beforeDestroy: function() {
var me = this;
if (me.rendered) {
me.clearTip();
}
if (me.menu && me.destroyMenu !== false) {
Ext.destroy(me.menu);
}
Ext.destroy(me.btnInnerEl, me.repeater);
me.callParent();
},
// @private
onDestroy: function() {
var me = this;
if (me.rendered) {
me.doc.un('mouseover', me.monitorMouseOver, me);
delete me.doc;
Ext.destroy(me.keyMap);
delete me.keyMap;
}
Ext.button.Manager.unregister(me);
me.callParent();
},

setHandler: function(handler, scope) {
this.handler = handler;
this.scope = scope;
return this;
},

setText: function(text) {
text = text || '';
var me = this,
oldText = me.text || '';
if (text != oldText) {
me.text = text;
if (me.rendered) {
me.btnInnerEl.update(text || '&#160;');
me.setComponentCls();
if (Ext.isStrict && Ext.isIE8) {
// weird repaint issue causes it to not resize
me.el.repaint();
}
me.updateLayout();
}
me.fireEvent('textchange', me, oldText, text);
}
return me;
},

didIconStateChange: function(old, current) {
var currentEmpty = Ext.isEmpty(current);
return Ext.isEmpty(old) ? !currentEmpty : currentEmpty;
},

getText: function() {
return this.text;
},

toggle: function(state, suppressEvent) {
var me = this;
state = state === undefined ? !me.pressed: !!state;
if (state !== me.pressed) {
if (me.rendered) {
me[state ? 'addClsWithUI': 'removeClsWithUI'](me.pressedCls);
}
me.pressed = state;
if (!suppressEvent) {
me.fireEvent('toggle', me, state);
Ext.callback(me.toggleHandler, me.scope || me, [me, state]);
}
}
return me;
},
maybeShowMenu: function(){
var me = this;
if (me.menu && !me.hasVisibleMenu() && !me.ignoreNextClick) {
me.showMenu(true);
}
},

showMenu: function( fromEvent) {
var me = this,
menu = me.menu;
if (me.rendered) {
if (me.tooltip && Ext.quickTipsActive && me.getTipAttr() != 'title') {
Ext.tip.QuickTipManager.getQuickTip().cancelShow(me.el);
}
if (menu.isVisible()) {
menu.hide();
}
if (!fromEvent || me.showEmptyMenu || menu.items.getCount() > 0) {
menu.showBy(me.el, me.menuAlign);
}
}
return me;
},

hideMenu: function() {
if (this.hasVisibleMenu()) {
this.menu.hide();
}
return this;
},

hasVisibleMenu: function() {
var menu = this.menu;
return menu && menu.rendered && menu.isVisible();
},
// @private
onRepeatClick: function(repeat, e) {
this.onClick(e);
},
// @private
onClick: function(e) {
var me = this;
if (me.preventDefault || (me.disabled && me.getHref()) && e) {
e.preventDefault();
}
// Can be triggered by ENTER or SPACE keydown events which set the button property.
// Only veto event handling if it's a mouse event with an alternative button.
if (e.type !== 'keydown' && e.button !== 0) {
return;
}
if (!me.disabled) {
me.doToggle();
me.maybeShowMenu();
me.fireHandler(e);
}
},
fireHandler: function(e) {
var me = this,
handler = me.handler;
if (me.fireEvent('click', me, e) !== false) {
if (handler) {
handler.call(me.scope || me, me, e);
}
}
},
doToggle: function() {
var me = this; 
if (me.enableToggle && (me.allowDepress !== false || !me.pressed)) {
me.toggle();
}
},

onMouseOver: function(e) {
var me = this;
if (!me.disabled && !e.within(me.el, true, true)) {
me.onMouseEnter(e);
}
},

onMouseOut: function(e) {
var me = this;
if (!e.within(me.el, true, true)) {
if (me.overMenuTrigger) {
me.onMenuTriggerOut(e);
}
me.onMouseLeave(e);
}
},

onMouseMove: function(e) {
var me = this,
el = me.el,
over = me.overMenuTrigger,
overPosition, triggerRegion;
if (me.split) {
overPosition = (me.arrowAlign === 'right') ?
e.getX() - me.getX() : e.getY() - el.getY();
triggerRegion = me.getTriggerRegion();
if (overPosition > triggerRegion.begin && overPosition < triggerRegion.end) {
if (!over) {
me.onMenuTriggerOver(e);
}
} else {
if (over) {
me.onMenuTriggerOut(e);
}
}
}
},

getTriggerRegion: function() {
var me = this,
region = me._triggerRegion,
triggerSize = me.getTriggerSize(),
btnSize = me.arrowAlign === 'right' ? me.getWidth() : me.getHeight();
region.begin = btnSize - triggerSize;
region.end = btnSize;
return region;
},

getTriggerSize: function() {
var me = this,
size = me.triggerSize,
side, sideFirstLetter;
if (size == null) { // Same as (size === null || size === undefined)
side = me.arrowAlign;
sideFirstLetter = side.charAt(0);
size = me.triggerSize = me.el.getFrameWidth(sideFirstLetter) + me.getBtnWrapFrameWidth(sideFirstLetter)
if (me.frameSize) {
size = me.triggerSize += me.frameSize[side];
}
}
return size;
},

getBtnWrapFrameWidth: function(side) {
return this.btnWrap.getFrameWidth(side);
},
addOverCls: function() {
if (!this.disabled) {
this.addClsWithUI(this.overCls);
}
},
removeOverCls: function() {
this.removeClsWithUI(this.overCls);
},

onMouseEnter: function(e) {
// overCls is handled by AbstractComponent
this.fireEvent('mouseover', this, e);
},

onMouseLeave: function(e) {
// overCls is handled by AbstractComponent
this.fireEvent('mouseout', this, e);
},

onMenuTriggerOver: function(e) {
var me = this,
arrowTip = me.arrowTooltip;
me.overMenuTrigger = true;
// We don't have a separate arrow element, so we only add the tip attribute if
// we're over that part of the button
if (me.split && arrowTip) {
me.btnWrap.dom.setAttribute(me.getTipAttr(), arrowTip);
}
me.fireEvent('menutriggerover', me, me.menu, e);
},

onMenuTriggerOut: function(e) {
var me = this;
delete me.overMenuTrigger;
// See onMenuTriggerOver
if (me.split && me.arrowTooltip) {
me.btnWrap.dom.setAttribute(me.getTipAttr(), '');
}
me.fireEvent('menutriggerout', me, me.menu, e);
},
// inherit docs
enable: function(silent) {
var me = this;
me.callParent(arguments);
me.removeClsWithUI('disabled');
if (me.rendered) {
me.el.dom.setAttribute('tabIndex', me.tabIndex);
}
return me;
},
// inherit docs
disable: function(silent) {
var me = this;
me.callParent(arguments);
me.addClsWithUI('disabled');
me.removeClsWithUI(me.overCls);
if (me.rendered) {
me.el.dom.removeAttribute('tabIndex');
}
// IE renders disabled text by layering gray text on top of white text, offset by 1 pixel. Normally this is fine
// but in some circumstances (such as using formBind) it gets confused and renders them side by side instead.
if (me.btnInnerEl && Ext.isIE7m) {
me.btnInnerEl.repaint();
}
return me;
},

setScale: function(scale) {
var me = this,
ui = me.ui.replace('-' + me.scale, '');
//check if it is an allowed scale
if (!Ext.Array.contains(me.allowedScales, scale)) {
throw('#setScale: scale must be an allowed scale (' + me.allowedScales.join(', ') + ')');
}
me.scale = scale;
me.setUI(ui);
},
// inherit docs
setUI: function(ui) {
var me = this;
//we need to append the scale to the UI, if not already done
if (me.scale && !ui.match(me.scale)) {
ui = ui + '-' + me.scale;
}
me.callParent([ui]);
// Set all the state classNames, as they need to include the UI
// me.disabledCls += ' ' + me.baseCls + '-' + me.ui + '-disabled';
},
// @private
onMouseDown: function(e) {
var me = this;
if (Ext.isIE) {
// In IE the use of unselectable on the button's elements causes the element
// to not receive focus, even when it is directly clicked.
me.getFocusEl().focus();
}
if (!me.disabled && e.button === 0) {
Ext.button.Manager.onButtonMousedown(me, e);
me.addClsWithUI(me.pressedCls);
}
},
// @private
onMouseUp: function(e) {
var me = this;
if (e.button === 0) {
if (!me.pressed) {
me.removeClsWithUI(me.pressedCls);
}
}
},
// @private
onMenuShow: function(e) {
var me = this;
me.ignoreNextClick = 0;
me.addClsWithUI(me.menuActiveCls);
me.fireEvent('menushow', me, me.menu);
},
// @private
onMenuHide: function(e) {
var me = this;
me.removeClsWithUI(me.menuActiveCls);
me.ignoreNextClick = Ext.defer(me.restoreClick, 250, me);
me.fireEvent('menuhide', me, me.menu);
me.focus();
},
// @private
restoreClick: function() {
this.ignoreNextClick = 0;
},
// @private
onDownKey: function(k, e) {
var me = this;
if (me.menu && !me.disabled) {
me.showMenu();
e.stopEvent();
return false;
}
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/layout/container/boxOverflow/Menu.js */
(function(Ext) {
Ext.define('Ext.layout.container.boxOverflow.Menu', {

extend: 'Ext.layout.container.boxOverflow.None',
requires: ['Ext.toolbar.Separator', 'Ext.button.Button'],
alternateClassName: 'Ext.layout.boxOverflow.Menu',




noItemsMenuText : '<div class="' + Ext.baseCSSPrefix + 'toolbar-no-items">(None)</div>',
constructor: function(layout) {
var me = this;
me.callParent(arguments);
me.triggerButtonCls = me.triggerButtonCls || Ext.baseCSSPrefix + 'box-menu-after';

me.menuItems = [];
},
beginLayout: function (ownerContext) {
this.callParent(arguments);
// Before layout, we need to re-show all items which we may have hidden due to a
// previous overflow...
this.clearOverflow(ownerContext);
},
beginLayoutCycle: function (ownerContext, firstCycle) {
this.callParent(arguments);
if (!firstCycle) {
// if we are being re-run, we need to clear any overflow from the last run and
// recache the childItems collection
this.clearOverflow(ownerContext);
this.layout.cacheChildItems(ownerContext);
}
},
onRemove: function(comp){
Ext.Array.remove(this.menuItems, comp);
},
// We don't define a prefix in menu overflow.
getSuffixConfig: function() {
var me = this,
layout = me.layout,
owner = layout.owner,
oid = owner.id;

me.menu = new Ext.menu.Menu({
listeners: {
scope: me,
beforeshow: me.beforeMenuShow
}
});

me.menuTrigger = new Ext.button.Button({
id: oid + '-menu-trigger',
cls: Ext.layout.container.Box.prototype.innerCls + ' ' + me.triggerButtonCls + ' ' + Ext.baseCSSPrefix + 'toolbar-item',
plain: owner.usePlainButtons,
ownerCt: owner, // To enable the Menu to ascertain a valid zIndexManager owner in the same tree
ownerLayout: layout,
iconCls: Ext.baseCSSPrefix + me.getOwnerType(owner) + '-more-icon',
ui: owner instanceof Ext.toolbar.Toolbar ? 'default-toolbar' : 'default',
menu: me.menu,
// Menu will be empty when we're showing it because we populate items after
showEmptyMenu: true,
getSplitCls: function() { return '';}
});
return me.menuTrigger.getRenderTree();
},

getOverflowCls: function() {
return Ext.baseCSSPrefix + this.layout.direction + '-box-overflow-body';
},
handleOverflow: function(ownerContext) {
var me = this,
layout = me.layout,
names = layout.names,
plan = ownerContext.state.boxPlan,
posArgs = [null, null];
me.showTrigger(ownerContext);
// Center the menuTrigger button only if we are not vertical.
// TODO: Should we emulate align: 'middle' like this, or should we 'stretchmax' the menuTrigger?
if (me.layout.direction !== 'vertical') {
posArgs[names.heightIndex] = (plan.maxSize - me.menuTrigger[names.getHeight]()) / 2;
me.menuTrigger.setPosition.apply(me.menuTrigger, posArgs);
}
return {
reservedSpace: me.triggerTotalWidth
};
},

captureChildElements: function() {
var me = this,
menuTrigger = me.menuTrigger,
names = me.layout.names;
// The rendering flag is set when getRenderTree is called which we do when returning markup string for the owning layout's "suffix"
if (menuTrigger.rendering) {
menuTrigger.finishRender();
me.triggerTotalWidth = menuTrigger[names.getWidth]() + menuTrigger.el.getMargin(names.parallelMargins);
}
},
_asLayoutRoot: { isRoot: true },

clearOverflow: function(ownerContext) {
var me = this,
items = me.menuItems,
item,
i = 0,
length = items.length,
owner = me.layout.owner,
asLayoutRoot = me._asLayoutRoot;
owner.suspendLayouts();
me.captureChildElements();
me.hideTrigger();
owner.resumeLayouts();
for (; i < length; i++) {
item = items[i];
// What we are doing here is preventing the layout bubble from invalidating our
// owner component. We need just the button to be added to the layout run.
item.suspendLayouts();
item.show();
item.resumeLayouts(asLayoutRoot);
}
items.length = 0;
},

showTrigger: function(ownerContext) {
var me = this,
layout = me.layout,
owner = layout.owner,
names = layout.names,
startProp = names.x,
sizeProp = names.width,
plan = ownerContext.state.boxPlan,
available = plan.targetSize[sizeProp],
childItems = ownerContext.childItems,
len = childItems.length,
menuTrigger = me.menuTrigger,
childContext,
comp, i, props;
// We don't want the menuTrigger.show to cause owner's layout to be invalidated, so
// we force just the button to be invalidated and added to the current run.
menuTrigger.suspendLayouts();
menuTrigger.show();
menuTrigger.resumeLayouts(me._asLayoutRoot);
available -= me.triggerTotalWidth;
owner.suspendLayouts();
// Hide all items which are off the end, and store them to allow them to be restored
// before each layout operation.
me.menuItems.length = 0;
for (i = 0; i < len; i++) {
childContext = childItems[i];
props = childContext.props;
if (props[startProp] + props[sizeProp] > available) {
comp = childContext.target;
me.menuItems.push(comp);
comp.hide();
}
}
owner.resumeLayouts();
},

hideTrigger: function() {
var menuTrigger = this.menuTrigger;
if (menuTrigger) {
menuTrigger.hide();
}
},

beforeMenuShow: function(menu) {
var me = this,
items = me.menuItems,
i = 0,
len = items.length,
item,
prev,
needsSep = function(group, prev){
return group.isXType('buttongroup') && !(prev instanceof Ext.toolbar.Separator);
};
menu.suspendLayouts();
me.clearMenu();
menu.removeAll();
for (; i < len; i++) {
item = items[i];
// Do not show a separator as a first item
if (!i && (item instanceof Ext.toolbar.Separator)) {
continue;
}
if (prev && (needsSep(item, prev) || needsSep(prev, item))) {
menu.add('-');
}
me.addComponentToMenu(menu, item);
prev = item;
}
// put something so the menu isn't empty if no compatible items found
if (menu.items.length < 1) {
menu.add(me.noItemsMenuText);
}
menu.resumeLayouts();
},


createMenuConfig : function(component, hideOnClick) {
var me = this,
config = Ext.apply({}, component.initialConfig),
group = component.toggleGroup;
Ext.copyTo(config, component, [
'iconCls', 'icon', 'itemId', 'disabled', 'handler', 'scope', 'menu', 'tabIndex'
]);
Ext.apply(config, {
text : component.overflowText || component.text,
hideOnClick: hideOnClick,
destroyMenu: false,
listeners : {}
});
// Clone must have same value, and must sync original's value on change
if (component.isFormField) {
config.value = component.getValue();
// Sync the original component's value when the clone changes value.
// This intentionally overwrites any developer-configured change listener on the clone.
// That's because we monitor the clone's change event, and sync the
// original field by calling setValue, so the original field's change
// event will still fire.
config.listeners.change = function(c, newVal, oldVal) { 
component.setValue(newVal);
}
}
// ToggleButtons become CheckItems
else if (group || component.enableToggle) {
Ext.apply(config, {
hideOnClick: false,
group : group,
checked: component.pressed,
handler: function(item, e) {
component.onClick(e);
}
});
}
// Buttons may have their text or icon changed - this must be propagated to the clone in the overflow menu
if (component.isButton && !component.changeListenersAdded) {
component.on({
textchange: me.onButtonAttrChange,
iconchange: me.onButtonAttrChange,
toggle: me.onButtonToggle
});
component.changeListenersAdded = true;
}
// Typically margins are used to separate items in a toolbar
// but don't really make a lot of sense in a menu, so we strip
// them out here.
delete config.margin;
delete config.ownerCt;
delete config.xtype;
delete config.id;
delete config.itemId;
return config;
},
onButtonAttrChange: function(btn) {
var clone = btn.overflowClone;
clone.suspendLayouts();
clone.setText(btn.text);
clone.setIcon(btn.icon);
clone.setIconCls(btn.iconCls);
clone.resumeLayouts(true);
},
onButtonToggle: function(btn, state) {
// Keep the clone in sync with the original if necessary
if (btn.overflowClone.checked !== state) {
btn.overflowClone.setChecked(state);
}
},

addComponentToMenu : function(menu, component) {
var me = this,
i, items, iLen;
if (component instanceof Ext.toolbar.Separator) {
menu.add('-');
} else if (component.isComponent) {
if (component.isXType('splitbutton')) {
component.overflowClone = menu.add(me.createMenuConfig(component, true));
} else if (component.isXType('button')) {
component.overflowClone = menu.add(me.createMenuConfig(component, !component.menu));
} else if (component.isXType('buttongroup')) {
items = component.items.items;
iLen = items.length;
for (i = 0; i < iLen; i++) {
me.addComponentToMenu(menu, items[i]);
}
} else {
component.overflowClone = menu.add(Ext.create(Ext.getClassName(component), me.createMenuConfig(component)));
}
}
},

clearMenu : function() {
var menu = this.menu,
items, i, iLen, item;

if (menu && menu.items) {
items = menu.items.items;
iLen = items.length;

for (i = 0; i < iLen; i++) {
item = items[i];
if (item.setMenu) {
item.setMenu(null);
}
}
}
},

destroy: function() {
var trigger = this.menuTrigger;

if (trigger && !this.layout.owner.items.contains(trigger)) {
// Ensure we delete the ownerCt if it's not in the items
// so we don't get spurious container remove warnings.
delete trigger.ownerCt;
}
Ext.destroy(this.menu, trigger);
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/layout/container/boxOverflow/Scroller.js */
(function(Ext) {
Ext.define('Ext.layout.container.boxOverflow.Scroller', {

extend: 'Ext.layout.container.boxOverflow.None',
requires: ['Ext.util.ClickRepeater', 'Ext.Element'],
alternateClassName: 'Ext.layout.boxOverflow.Scroller',
mixins: {
observable: 'Ext.util.Observable'
},



animateScroll: false,

scrollIncrement: 20,

wheelIncrement: 10,

scrollRepeatInterval: 60,

scrollDuration: 400,



scrollerCls: Ext.baseCSSPrefix + 'box-scroller',


constructor: function(layout, config) {
var me = this;
me.layout = layout;
Ext.apply(me, config || {});
// Dont pass the config so that it is not applied to 'this' again
me.mixins.observable.constructor.call(me);
me.addEvents(

'scroll'
);
me.scrollPosition = 0;
me.scrollSize = 0;
},
getPrefixConfig: function() {
var me = this,
layout = me.layout,
owner = layout.owner,
cls;
me.initCSSClasses();
cls = Ext.layout.container.Box.prototype.innerCls + ' ' + me.beforeCtCls;
if (owner.plain) {
// Add plain class for components that need separate "plain" styling (e.g. tab bar)
cls += ' ' + me.scrollerCls + '-plain';
}
return {
cls: cls,
cn : {
id : owner.id + layout.names.beforeScrollerSuffix,
cls: me.scrollerCls + ' ' + me.beforeScrollerCls,
style: 'display:none'
}
};
},
getSuffixConfig: function() {
var me = this,
layout = me.layout,
owner = layout.owner,
cls = Ext.layout.container.Box.prototype.innerCls + ' ' + me.afterCtCls;
if (owner.plain) {
// Add plain class for components that need separate "plain" styling (e.g. tab bar)
cls += ' ' + me.scrollerCls + '-plain';
}
return {
cls: cls,
cn : {
id : owner.id + layout.names.afterScrollerSuffix,
cls: me.scrollerCls + ' ' + me.afterScrollerCls,
style: 'display:none'
}
};
},
getOverflowCls: function() {
return Ext.baseCSSPrefix + this.layout.direction + '-box-overflow-body';
},
initCSSClasses: function() {
var me = this,
prefix = Ext.baseCSSPrefix,
layout = me.layout,
names = layout.names,
beforeXName = names.beforeX,
afterXName = names.afterX,
type = me.getOwnerType(layout.owner);
me.beforeCtCls = me.beforeCtCls || prefix + 'box-scroller-' + beforeXName;
me.afterCtCls = me.afterCtCls || prefix + 'box-scroller-' + afterXName;

me.beforeScrollerCls = me.beforeScrollerCls || prefix + type + '-scroll-' + beforeXName;
me.afterScrollerCls = me.afterScrollerCls || prefix + type + '-scroll-' + afterXName;
},
beginLayout: function (ownerContext) {
var layout = this.layout;
ownerContext.innerCtScrollPos = this.getScrollPosition();
this.callParent(arguments);
},
completeLayout: function(ownerContext) {
var me = this,
plan = ownerContext.state.boxPlan,
names = me.layout.names,
last;
// If there is overflow...
if (plan && plan.tooNarrow) {
last = ownerContext.childItems[ownerContext.childItems.length - 1];
// capture this before callParent since it calls handle/clearOverflow:
me.scrollSize = last.props[names.x] + last.props[names.width];
me.updateScrollButtons();
}
this.callParent(arguments);
},
finishedLayout: function(ownerContext) {
var me = this,
layout = me.layout,
scrollPos = Math.min(me.getMaxScrollPosition(), ownerContext.innerCtScrollPos);
layout.innerCt[layout.names.setScrollLeft](scrollPos);
},
handleOverflow: function(ownerContext) {
var me = this,
methodName = me.layout.names.getWidth;
me.showScrollers();
return {
reservedSpace: me.beforeCt[methodName]() + me.afterCt[methodName]()
};
},

captureChildElements: function() {
var me = this,
el = me.layout.owner.el,
before, after, hoverCls, pressedSuffix, pressedCls, hoverSuffix;
// Grab the scroll click receiving elements
if (!me.beforeCt) {
hoverSuffix = '-hover';
pressedSuffix = '-pressed';
hoverCls = me.scrollerCls + hoverSuffix;
pressedCls = me.scrollerCls + pressedSuffix;
before = me.beforeScroller = el.getById(me.layout.owner.id + '-before-scroller');
after = me.afterScroller = el.getById(me.layout.owner.id + '-after-scroller');
me.beforeCt = before.up('');
me.afterCt = after.up('');
me.createWheelListener();
before.addClsOnOver(hoverCls);
before.addClsOnOver(me.beforeScrollerCls + hoverSuffix);
before.addClsOnClick(pressedCls);
before.addClsOnClick(me.beforeScrollerCls + pressedSuffix);
after.addClsOnOver(hoverCls);
after.addClsOnOver(me.afterScrollerCls + hoverSuffix);
after.addClsOnClick(pressedCls);
after.addClsOnClick(me.afterScrollerCls + pressedSuffix);
before.setVisibilityMode(Ext.Element.DISPLAY);
after.setVisibilityMode(Ext.Element.DISPLAY);
me.beforeRepeater = new Ext.util.ClickRepeater(before, {
interval: me.scrollRepeatInterval,
handler : me.scrollLeft,
scope : me
});
me.afterRepeater = new Ext.util.ClickRepeater(after, {
interval: me.scrollRepeatInterval,
handler : me.scrollRight,
scope : me
});
}
},

createWheelListener: function() {
var me = this;
me.layout.innerCt.on({
mousewheel: function(e) {
me.scrollBy(me.getWheelDelta(e) * me.wheelIncrement * -1, false);
},
stopEvent: true
});
},
getWheelDelta: function (e) {
return e.getWheelDelta();
},

clearOverflow: function () {
this.hideScrollers();
},

showScrollers: function() {
var me = this;
me.captureChildElements();
me.beforeScroller.show();
me.afterScroller.show();
me.layout.owner.addClsWithUI(me.layout.direction === 'vertical' ? 'vertical-scroller' : 'scroller');
// TODO - this may invalidates data in the ContextItem's styleCache
},

hideScrollers: function() {
var me = this;
if (me.beforeScroller !== undefined) {
me.beforeScroller.hide();
me.afterScroller.hide();
me.layout.owner.removeClsWithUI(me.layout.direction === 'vertical' ? 'vertical-scroller' : 'scroller');
// TODO - this may invalidates data in the ContextItem's styleCache
}
},

destroy: function() {
var me = this;
Ext.destroy(me.beforeRepeater, me.afterRepeater, me.beforeScroller, me.afterScroller, me.beforeCt, me.afterCt);
},

scrollBy: function(delta, animate) {
this.scrollTo(this.getScrollPosition() + delta, animate);
},

getScrollAnim: function() {
return {
duration: this.scrollDuration, 
callback: this.updateScrollButtons, 
scope : this
};
},

updateScrollButtons: function() {
var me = this,
beforeMeth,
afterMeth,
beforeCls,
afterCls,
disabledCls,
suffix = '-disabled';

if (me.beforeScroller == null || me.afterScroller == null) {
return;
}
beforeMeth = me.atExtremeBefore() ? 'addCls' : 'removeCls';
afterMeth = me.atExtremeAfter() ? 'addCls' : 'removeCls';
disabledCls = me.scrollerCls + suffix;
beforeCls = [disabledCls, me.beforeScrollerCls + suffix];
afterCls = [disabledCls, me.afterScrollerCls + suffix];
me.beforeScroller[beforeMeth](beforeCls);
me.afterScroller[afterMeth](afterCls);
me.scrolling = false;
},

scrollLeft: function() {
this.scrollBy(-this.scrollIncrement, false);
},

scrollRight: function() {
this.scrollBy(this.scrollIncrement, false);
},

getScrollPosition: function(){
var me = this,
layout = me.layout,
result;
// Until we actually scroll, the scroll[Top|Left] is stored as zero to avoid DOM
// hits, after that it's NaN.
if (isNaN(me.scrollPosition)) {
result = layout.innerCt[layout.names.getScrollLeft]();
} else {
result = me.scrollPosition;
}
return result;
},

getMaxScrollPosition: function() {
var me = this,
layout = me.layout,
maxScrollPos = me.scrollSize - layout.innerCt[layout.names.getWidth]();
return (maxScrollPos < 0) ? 0 : maxScrollPos;
},

atExtremeBefore: function() {
return !this.getScrollPosition();
},

atExtremeAfter: function() {
return this.getScrollPosition() >= this.getMaxScrollPosition();
},

scrollTo: function(position, animate) {
var me = this,
layout = me.layout,
names = layout.names,
oldPosition = me.getScrollPosition(),
newPosition = Ext.Number.constrain(position, 0, me.getMaxScrollPosition());
if (newPosition != oldPosition && !me.scrolling) {
me.scrollPosition = NaN;
if (animate === undefined) {
animate = me.animateScroll;
}
layout.innerCt[names.scrollTo](names.beforeScrollX, newPosition, animate ? me.getScrollAnim() : false);
if (animate) {
me.scrolling = true;
} else {
me.updateScrollButtons();
}
me.fireEvent('scroll', me, newPosition, animate ? me.getScrollAnim() : false);
}
},

scrollToItem: function(item, animate) {
var me = this,
layout = me.layout,
owner = layout.owner,
names = layout.names,
visibility,
box,
newPos;
item = me.getItem(item);
if (item !== undefined) {
if (item == owner.items.first()) {
newPos = 0
} else if (item === owner.items.last()) {
newPos = me.getMaxScrollPosition();
} else {
visibility = me.getItemVisibility(item);
if (!visibility.fullyVisible) {
box = item.getBox(false, true);
newPos = box[names.x];
if (visibility.hiddenEnd) {
newPos -= (me.layout.innerCt[names.getWidth]() - box[names.width]);
}
}
}
if (newPos !== undefined) {
me.scrollTo(newPos, animate);
}
}
},

getItemVisibility: function(item) {
var me = this,
box = me.getItem(item).getBox(true, true),
layout = me.layout,
names = layout.names,
itemStart = box[names.x],
itemEnd = itemStart + box[names.width],
scrollStart = me.getScrollPosition(),
scrollEnd = scrollStart + layout.innerCt[names.getWidth]();
return {
hiddenStart : itemStart < scrollStart,
hiddenEnd : itemEnd > scrollEnd,
fullyVisible: itemStart > scrollStart && itemEnd < scrollEnd
};
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/tip/Tip.js */
(function(Ext) {
Ext.define('Ext.tip.Tip', {
extend: 'Ext.panel.Panel',
alternateClassName: 'Ext.Tip',





minWidth : 40,

maxWidth : 500,

shadow : "sides",

defaultAlign : "tl-bl?",

constrainPosition : true,
// private panel overrides
autoRender: true,
hidden: true,
baseCls: Ext.baseCSSPrefix + 'tip',
floating: {
shadow: true,
shim: true
},
focusOnToFront: false,

closeAction: 'hide',
ariaRole: 'tooltip',
// Flag to Renderable to always look up the framing styles for this Component
alwaysFramed: true,
frameHeader: false,
initComponent: function() {
var me = this;
me.floating = Ext.apply( {}, {
shadow: me.shadow,
constrain: me.constrainPosition
}, me.self.prototype.floating);
me.callParent(arguments);
// Or in the deprecated config. Floating.doConstrain only constrains if the constrain property is truthy.
me.constrain = me.constrain || me.constrainPosition;
},

showAt : function(xy){
var me = this;
this.callParent(arguments);
// Show may have been vetoed.
if (me.isVisible()) {
me.setPagePosition(xy[0], xy[1]);
if (me.constrainPosition || me.constrain) {
me.doConstrain();
}
me.toFront(true);
}
},

initDraggable : function(){
var me = this;
me.draggable = {
el: me.getDragEl(),
delegate: me.header.el,
constrain: me,
constrainTo: me.el.dom.parentNode
};
// Important: Bypass Panel's initDraggable. Call direct to Component's implementation.
Ext.Component.prototype.initDraggable.call(me);
},
// Tip does not ghost. Drag is "live"
ghost: undefined,
unghost: undefined
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/tip/ToolTip.js */
(function(Ext) {
Ext.define('Ext.tip.ToolTip', {
extend: 'Ext.tip.Tip',
alias: 'widget.tooltip',
alternateClassName: 'Ext.ToolTip',



autoHide: true,


showDelay: 500,

hideDelay: 200,

dismissDelay: 5000,


trackMouse: false,


anchorToTarget: true,

anchorOffset: 0,

// @private
targetCounter: 0,
quickShowInterval: 250,
// @private
initComponent: function() {
var me = this;
me.callParent(arguments);
me.lastActive = new Date();
me.setTarget(me.target);
me.origAnchor = me.anchor;
},
// @private
onRender: function(ct, position) {
var me = this;
me.callParent(arguments);
me.anchorCls = Ext.baseCSSPrefix + 'tip-anchor-' + me.getAnchorPosition();
me.anchorEl = me.el.createChild({
cls: Ext.baseCSSPrefix + 'tip-anchor ' + me.anchorCls
});
},

setTarget: function(target) {
var me = this,
t = Ext.get(target),
tg;
if (me.target) {
tg = Ext.get(me.target);
me.mun(tg, 'mouseover', me.onTargetOver, me);
me.mun(tg, 'mouseout', me.onTargetOut, me);
me.mun(tg, 'mousemove', me.onMouseMove, me);
}
me.target = t;
if (t) {
me.mon(t, {
// TODO - investigate why IE6/7 seem to fire recursive resize in e.getXY
// breaking QuickTip#onTargetOver (EXTJSIV-1608)
freezeEvent: true,
mouseover: me.onTargetOver,
mouseout: me.onTargetOut,
mousemove: me.onMouseMove,
scope: me
});
}
if (me.anchor) {
me.anchorTarget = me.target;
}
},
// @private
onMouseMove: function(e) {
var me = this,
t = me.delegate ? e.getTarget(me.delegate) : me.triggerElement = true,
xy;
if (t) {
me.targetXY = e.getXY();
if (t === me.triggerElement) {
if (!me.hidden && me.trackMouse) {
xy = me.getTargetXY();
if (me.constrainPosition) {
xy = me.el.adjustForConstraints(xy, me.el.parent());
}
me.setPagePosition(xy);
}
} else {
me.hide();
me.lastActive = new Date(0);
me.onTargetOver(e);
}
} else if ((!me.closable && me.isVisible()) && me.autoHide !== false) {
me.hide();
}
},
// @private
getTargetXY: function() {
var me = this,
mouseOffset,
offsets, xy, dw, dh, de, bd, scrollX, scrollY, axy, sz, constrainPosition;
if (me.delegate) {
me.anchorTarget = me.triggerElement;
}
if (me.anchor) {
me.targetCounter++;
offsets = me.getOffsets();
xy = (me.anchorToTarget && !me.trackMouse) ? me.getAlignToXY(me.anchorTarget, me.getAnchorAlign()) : me.targetXY;
dw = Ext.Element.getViewWidth() - 5;
dh = Ext.Element.getViewHeight() - 5;
de = document.documentElement;
bd = document.body;
scrollX = (de.scrollLeft || bd.scrollLeft || 0) + 5;
scrollY = (de.scrollTop || bd.scrollTop || 0) + 5;
axy = [xy[0] + offsets[0], xy[1] + offsets[1]];
sz = me.getSize();
constrainPosition = me.constrainPosition;
me.anchorEl.removeCls(me.anchorCls);
if (me.targetCounter < 2 && constrainPosition) {
if (axy[0] < scrollX) {
if (me.anchorToTarget) {
me.defaultAlign = 'l-r';
if (me.mouseOffset) {
me.mouseOffset[0] *= -1;
}
}
me.anchor = 'left';
return me.getTargetXY();
}
if (axy[0] + sz.width > dw) {
if (me.anchorToTarget) {
me.defaultAlign = 'r-l';
if (me.mouseOffset) {
me.mouseOffset[0] *= -1;
}
}
me.anchor = 'right';
return me.getTargetXY();
}
if (axy[1] < scrollY) {
if (me.anchorToTarget) {
me.defaultAlign = 't-b';
if (me.mouseOffset) {
me.mouseOffset[1] *= -1;
}
}
me.anchor = 'top';
return me.getTargetXY();
}
if (axy[1] + sz.height > dh) {
if (me.anchorToTarget) {
me.defaultAlign = 'b-t';
if (me.mouseOffset) {
me.mouseOffset[1] *= -1;
}
}
me.anchor = 'bottom';
return me.getTargetXY();
}
}
me.anchorCls = Ext.baseCSSPrefix + 'tip-anchor-' + me.getAnchorPosition();
me.anchorEl.addCls(me.anchorCls);
me.targetCounter = 0;
return axy;
} else {
mouseOffset = me.getMouseOffset();
return (me.targetXY) ? [me.targetXY[0] + mouseOffset[0], me.targetXY[1] + mouseOffset[1]] : mouseOffset;
}
},
getMouseOffset: function() {
var me = this,
offset = me.anchor ? [0, 0] : [15, 18];
if (me.mouseOffset) {
offset[0] += me.mouseOffset[0];
offset[1] += me.mouseOffset[1];
}
return offset;
},
// @private
getAnchorPosition: function() {
var me = this,
m;
if (me.anchor) {
me.tipAnchor = me.anchor.charAt(0);
} else {
m = me.defaultAlign.match(/^([a-z]+)-([a-z]+)(\?)?$/);
//<debug>
if (!m) {
Ext.Error.raise('The AnchorTip.defaultAlign value "' + me.defaultAlign + '" is invalid.');
}
//</debug>
me.tipAnchor = m[1].charAt(0);
}
switch (me.tipAnchor) {
case 't':
return 'top';
case 'b':
return 'bottom';
case 'r':
return 'right';
}
return 'left';
},
// @private
getAnchorAlign: function() {
switch (this.anchor) {
case 'top':
return 'tl-bl';
case 'left':
return 'tl-tr';
case 'right':
return 'tr-tl';
default:
return 'bl-tl';
}
},
// @private
getOffsets: function() {
var me = this,
mouseOffset,
offsets,
ap = me.getAnchorPosition().charAt(0);
if (me.anchorToTarget && !me.trackMouse) {
switch (ap) {
case 't':
offsets = [0, 9];
break;
case 'b':
offsets = [0, -13];
break;
case 'r':
offsets = [ - 13, 0];
break;
default:
offsets = [9, 0];
break;
}
} else {
switch (ap) {
case 't':
offsets = [ - 15 - me.anchorOffset, 30];
break;
case 'b':
offsets = [ - 19 - me.anchorOffset, -13 - me.el.dom.offsetHeight];
break;
case 'r':
offsets = [ - 15 - me.el.dom.offsetWidth, -13 - me.anchorOffset];
break;
default:
offsets = [25, -13 - me.anchorOffset];
break;
}
}
mouseOffset = me.getMouseOffset();
offsets[0] += mouseOffset[0];
offsets[1] += mouseOffset[1];
return offsets;
},
// @private
onTargetOver: function(e) {
var me = this,
delegate = me.delegate,
t;
if (me.disabled || e.within(me.target.dom, true)) {
return;
}
t = delegate ? e.getTarget(delegate) : true;
if (t) {
me.triggerElement = t;
me.triggerEvent = e;
me.clearTimer('hide');
me.targetXY = e.getXY();
me.delayShow();
}
},
// @private
delayShow: function() {
var me = this;
if (me.hidden && !me.showTimer) {
if (Ext.Date.getElapsed(me.lastActive) < me.quickShowInterval) {
me.show();
} else {
me.showTimer = Ext.defer(me.showFromDelay, me.showDelay, me);
}
}
else if (!me.hidden && me.autoHide !== false) {
me.show();
}
},

showFromDelay: function(){
this.fromDelayShow = true;
this.show();
delete this.fromDelayShow;
},

onShowVeto: function(){
this.callParent();
delete this.triggerElement;
this.clearTimer('show');
},
// @private
onTargetOut: function(e) {
var me = this,
triggerEl = me.triggerElement,
// If we don't have a delegate, then the target is set
// to true, so set it to the main target.
target = triggerEl === true ? me.target : triggerEl;
// If disabled, moving within the current target, ignore the mouseout
// EventObject.within is the only correct way to determine this.
if (me.disabled || !triggerEl || e.within(target, true)) {
return;
}
if (me.showTimer) {
me.clearTimer('show');
me.triggerElement = null;
}
if (me.autoHide !== false) {
me.delayHide();
}
},
// @private
delayHide: function() {
var me = this;
if (!me.hidden && !me.hideTimer) {
me.hideTimer = Ext.defer(me.hide, me.hideDelay, me);
}
},

hide: function() {
var me = this;
me.clearTimer('dismiss');
me.lastActive = new Date();
if (me.anchorEl) {
me.anchorEl.hide();
}
me.callParent(arguments);
delete me.triggerElement;
},

show: function() {
var me = this;
// Show this Component first, so that sizing can be calculated
// pre-show it off screen so that the el will have dimensions
this.callParent();
if (this.hidden === false) {
me.setPagePosition(-10000, -10000);
if (me.anchor) {
me.anchor = me.origAnchor;
}

if (!me.calledFromShowAt) {
me.showAt(me.getTargetXY());
}
if (me.anchor) {
me.syncAnchor();
me.anchorEl.show();
} else {
me.anchorEl.hide();
}
}
},
// @inheritdoc
showAt: function(xy) {
var me = this;
me.lastActive = new Date();
me.clearTimers();
me.calledFromShowAt = true;
// Only call if this is hidden. May have been called from show above.
if (!me.isVisible()) {
this.callParent(arguments);
}
// Show may have been vetoed.
if (me.isVisible()) {
me.setPagePosition(xy[0], xy[1]);
if (me.constrainPosition || me.constrain) {
me.doConstrain();
}
me.toFront(true);
me.el.sync(true);
if (me.dismissDelay && me.autoHide !== false) {
me.dismissTimer = Ext.defer(me.hide, me.dismissDelay, me);
}
if (me.anchor) {
me.syncAnchor();
if (!me.anchorEl.isVisible()) {
me.anchorEl.show();
}
} else {
me.anchorEl.hide();
}
}
delete me.calledFromShowAt;
},
// @private
syncAnchor: function() {
var me = this,
anchorPos,
targetPos,
offset;
switch (me.tipAnchor.charAt(0)) {
case 't':
anchorPos = 'b';
targetPos = 'tl';
offset = [20 + me.anchorOffset, 1];
break;
case 'r':
anchorPos = 'l';
targetPos = 'tr';
offset = [ - 1, 12 + me.anchorOffset];
break;
case 'b':
anchorPos = 't';
targetPos = 'bl';
offset = [20 + me.anchorOffset, -1];
break;
default:
anchorPos = 'r';
targetPos = 'tl';
offset = [1, 12 + me.anchorOffset];
break;
}
me.anchorEl.alignTo(me.el, anchorPos + '-' + targetPos, offset);
me.anchorEl.setStyle('z-index', parseInt(me.el.getZIndex(), 10) || 0 + 1).setVisibilityMode(Ext.Element.DISPLAY);
},
// @private
setPagePosition: function(x, y) {
var me = this;
me.callParent(arguments);
if (me.anchor) {
me.syncAnchor();
}
},
_timerNames: {},
// @private
clearTimer: function (name) {
var me = this,
names = me._timerNames,
propName = names[name] || (names[name] = name + 'Timer'),
timer = me[propName];
if (timer) {
clearTimeout(timer);
me[propName] = null;
}
},
// @private
clearTimers: function() {
var me = this;
me.clearTimer('show');
me.clearTimer('dismiss');
me.clearTimer('hide');
},
// @private
onShow: function() {
var me = this;
me.callParent();
me.mon(Ext.getDoc(), 'mousedown', me.onDocMouseDown, me);
},
// @private
onHide: function() {
var me = this;
me.callParent();
me.mun(Ext.getDoc(), 'mousedown', me.onDocMouseDown, me);
},
// @private
onDocMouseDown: function(e) {
var me = this;
if (!me.closable && !e.within(me.el.dom)) {
me.disable();
Ext.defer(me.doEnable, 100, me);
}
},
// @private
doEnable: function() {
if (!this.isDestroyed) {
this.enable();
}
},
// @private
onDisable: function() {
this.callParent();
this.clearTimers();
this.hide();
},
beforeDestroy: function() {
var me = this;
me.clearTimers();
Ext.destroy(me.anchorEl);
delete me.anchorEl;
delete me.target;
delete me.anchorTarget;
delete me.triggerElement;
me.callParent();
},
// @private
onDestroy: function() {
Ext.getDoc().un('mousedown', this.onDocMouseDown, this);
this.callParent();
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/tip/QuickTip.js */
(function(Ext) {
Ext.define('Ext.tip.QuickTip', {
extend: 'Ext.tip.ToolTip',
alias: 'widget.quicktip',
alternateClassName: 'Ext.QuickTip',


interceptTitles : false,
// Force creation of header Component
title: '&#160;',
// @private
tagConfig : {
namespace : 'data-',
attribute : 'qtip',
width : 'qwidth',
target : 'target',
title : 'qtitle',
hide : 'hide',
cls : 'qclass',
align : 'qalign',
anchor : 'anchor',
showDelay: 'qshowDelay'
},
// @private
initComponent : function(){
var me = this;
me.target = me.target || Ext.getDoc();
me.targets = me.targets || {};
me.callParent();
},

register : function(config){
var configs = Ext.isArray(config) ? config : arguments,
i = 0,
len = configs.length,
target, j, targetLen;
for (; i < len; i++) {
config = configs[i];
target = config.target;
if (target) {
if (Ext.isArray(target)) {
for (j = 0, targetLen = target.length; j < targetLen; j++) {
this.targets[Ext.id(target[j])] = config;
}
} else{
this.targets[Ext.id(target)] = config;
}
}
}
},

unregister : function(el){
delete this.targets[Ext.id(el)];
},

cancelShow: function(el){
var me = this,
activeTarget = me.activeTarget;
el = Ext.get(el).dom;
if (me.isVisible()) {
if (activeTarget && activeTarget.el == el) {
me.hide();
}
} else if (activeTarget && activeTarget.el == el) {
me.clearTimer('show');
}
},

getTipCfg: function(e) {
var t = e.getTarget(),
titleText = t.title,
cfg;
if (this.interceptTitles && titleText && Ext.isString(titleText)) {
t.qtip = titleText;
t.removeAttribute("title");
e.preventDefault();
return {
text: titleText
};
}
else {
cfg = this.tagConfig;
t = e.getTarget('[' + cfg.namespace + cfg.attribute + ']');
if (t) {
return {
target: t,
text: t.getAttribute(cfg.namespace + cfg.attribute)
};
}
}
},
// @private
onTargetOver : function(e){
var me = this,
target = e.getTarget(me.delegate),
hasShowDelay,
delay,
elTarget,
cfg,
ns,
tipConfig,
autoHide,
targets, targetEl, value, key;
if (me.disabled) {
return;
}
// TODO - this causes "e" to be recycled in IE6/7 (EXTJSIV-1608) so ToolTip#setTarget
// was changed to include freezeEvent. The issue seems to be a nested 'resize' event
// that smashed Ext.EventObject.
me.targetXY = e.getXY();
// If the over target was filtered out by the delegate selector, or is not an HTMLElement, or is the <html> or the <body>, then return
if(!target || target.nodeType !== 1 || target == document.documentElement || target == document.body){
return;
}
if (me.activeTarget && ((target == me.activeTarget.el) || Ext.fly(me.activeTarget.el).contains(target))) {
// We may have started a delayed show where we have an active target.
// If the timer is yet to be fired, but the mouse moves, it will try to
// show it immediately. If the attribute has been removed from the element,
// we want to cancel the show.
if (me.targetTextEmpty()) {
me.onShowVeto();
delete me.activeTarget;
} else {
me.clearTimer('hide');
me.show();
}
return;
}
if (target) {
targets = me.targets;
for (key in targets) {
if (targets.hasOwnProperty(key)) {
value = targets[key];
targetEl = Ext.fly(value.target);
if (targetEl && (targetEl.dom === target || targetEl.contains(target))) {
elTarget = targetEl.dom;
break;
}
}
}
if (elTarget) {
me.activeTarget = me.targets[elTarget.id];
me.activeTarget.el = target;
me.anchor = me.activeTarget.anchor;
if (me.anchor) {
me.anchorTarget = target;
}
hasShowDelay = parseInt(me.activeTarget.showDelay, 10);
if (hasShowDelay) {
delay = me.showDelay;
me.showDelay = hasShowDelay;
}
me.delayShow();
if (hasShowDelay) {
me.showDelay = delay;
}
return;
}
}
// Should be a fly.
elTarget = Ext.fly(target, '_quicktip-target');
cfg = me.tagConfig;
ns = cfg.namespace;
tipConfig = me.getTipCfg(e);
if (tipConfig) {
// getTipCfg may look up the parentNode axis for a tip text attribute and will return the new target node.
// Change our target element to match that from which the tip text attribute was read.
if (tipConfig.target) {
target = tipConfig.target;
elTarget = Ext.fly(target, '_quicktip-target');
}
autoHide = elTarget.getAttribute(ns + cfg.hide);
me.activeTarget = {
el: target,
text: tipConfig.text,
width: +elTarget.getAttribute(ns + cfg.width) || null,
autoHide: autoHide != "user" && autoHide !== 'false',
title: elTarget.getAttribute(ns + cfg.title),
cls: elTarget.getAttribute(ns + cfg.cls),
align: elTarget.getAttribute(ns + cfg.align),
showDelay: parseInt(elTarget.getAttribute(ns + cfg.showDelay), 10)
};
me.anchor = elTarget.getAttribute(ns + cfg.anchor);
if (me.anchor) {
me.anchorTarget = target;
}
hasShowDelay = parseInt(me.activeTarget.showDelay, 10);
if (hasShowDelay) {
delay = me.showDelay;
me.showDelay = hasShowDelay;
}
me.delayShow();
if (hasShowDelay) {
me.showDelay = delay;
}
}
},
// @private
onTargetOut : function(e){
var me = this,
active = me.activeTarget,
hasHideDelay,
delay;
// If moving within the current target, and it does not have a new tip, ignore the mouseout
// EventObject.within is the only correct way to determine this.
if (active && e.within(me.activeTarget.el) && !me.getTipCfg(e)) {
return;
}
me.clearTimer('show');
delete me.activeTarget;
if (me.autoHide !== false) {
hasHideDelay = active && parseInt(active.hideDelay, 10);
if (hasHideDelay) {
delay = me.hideDelay;
me.hideDelay = hasHideDelay;
}
me.delayHide();
if (hasHideDelay) {
me.hideDelay = delay;
}
}
},

targetTextEmpty: function(){
var me = this,
target = me.activeTarget,
cfg = me.tagConfig,
el, text;

if (target) {
el = target.el;
if (el) {
text = el.getAttribute(cfg.namespace + cfg.attribute);
// Note that the quicktip could also have been registered with the QuickTipManager.
// If this was the case, then we don't want to veto showing it.
// Simply do a lookup in the registered targets collection.
if (!text && !me.targets[target.target]) {
return true;
}
}
}
return false;
},

show: function(){
var me = this,
fromDelay = me.fromDelayShow;

// We're coming from a delayed show, so check whether
// the attribute has been removed before we show it 
if (fromDelay && me.targetTextEmpty()) {
me.onShowVeto();
delete me.activeTarget;
return;
}
me.callParent(arguments); 
},
// @inheritdoc
showAt : function(xy){
var me = this,
target = me.activeTarget,
header = me.header,
cls;
if (target) {
if (!me.rendered) {
me.render(Ext.getBody());
me.activeTarget = target;
}
me.suspendLayouts();
if (target.title) {
me.setTitle(target.title);
header.show();
} else if (header) {
header.hide();
}
me.update(target.text);
me.autoHide = target.autoHide;
me.dismissDelay = target.dismissDelay || me.dismissDelay;
if (target.mouseOffset) {
xy[0] += target.mouseOffset[0];
xy[1] += target.mouseOffset[1];
}
cls = me.lastCls;
if (cls) {
me.removeCls(cls);
delete me.lastCls;
}
cls = target.cls;
if (cls) {
me.addCls(cls);
me.lastCls = cls;
}
me.setWidth(target.width);
if (me.anchor) {
me.constrainPosition = false;
} else if (target.align) { // TODO: this doesn't seem to work consistently
xy = me.getAlignToXY(target.el, target.align);
me.constrainPosition = false;
}else{
me.constrainPosition = true;
}
me.resumeLayouts(true);
}
me.callParent([xy]);
},
// @inheritdoc
hide: function(){
delete this.activeTarget;
this.callParent();
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/tip/QuickTipManager.js */
(function(Ext) {
Ext.define('Ext.tip.QuickTipManager', {
requires: ['Ext.tip.QuickTip'],
singleton: true,
alternateClassName: 'Ext.QuickTips',
disabled: false,

init : function (autoRender, config) {
var me = this;
if (!me.tip) {
if (!Ext.isReady) {
Ext.onReady(function(){
Ext.tip.QuickTipManager.init(autoRender, config);
});
return;
}
var tipConfig = Ext.apply({ disabled: me.disabled, id: 'ext-quicktips-tip' }, config),
className = tipConfig.className,
xtype = tipConfig.xtype;
if (className) {
delete tipConfig.className;
} else if (xtype) {
className = 'widget.' + xtype;
delete tipConfig.xtype;
}
if (autoRender !== false) {
tipConfig.renderTo = document.body;
//<debug>
if (tipConfig.renderTo.tagName.toUpperCase() != 'BODY') { // e.g., == 'FRAMESET'
Ext.Error.raise({
sourceClass: 'Ext.tip.QuickTipManager',
sourceMethod: 'init',
msg: 'Cannot init QuickTipManager: no document body'
});
}
//</debug>
}
me.tip = Ext.create(className || 'Ext.tip.QuickTip', tipConfig);
// private.
// Need a globally accessble way of testing whether QuickTipsManager is both loaded AND initialized.
Ext.quickTipsActive = true;
}
},

destroy: function() {
Ext.destroy(this.tip);
this.tip = undefined;
},
// Protected method called by the dd classes
ddDisable : function() {
var me = this,
tip = me.tip;
// don't disable it if we don't need to
if (tip && !me.disabled) {
tip.disable();
}
},
// Protected method called by the dd classes
ddEnable : function() {
var me = this,
tip = me.tip;
// only enable it if it hasn't been disabled
if (tip && !me.disabled) {
tip.enable();
}
},

enable : function(){
var me = this,
tip = me.tip;
if (tip) {
tip.enable();
}
me.disabled = false;
},

disable : function(){
var me = this,
tip = me.tip;
if(tip){
tip.disable();
}
me.disabled = true;
},

isEnabled : function(){
var tip = this.tip;
return tip !== undefined && !tip.disabled;
},

getQuickTip : function(){
return this.tip;
},

register : function(){
var tip = this.tip;
tip.register.apply(tip, arguments);
},

unregister : function(){
var tip = this.tip;
tip.unregister.apply(tip, arguments);
},

tips : function(){
var tip = this.tip;
tip.register.apply(tip, arguments);
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/dd/DragDropManager.js */
(function(Ext) {
Ext.define('Ext.dd.DragDropManager', {
singleton: true,
requires: ['Ext.util.Region'],
uses: ['Ext.tip.QuickTipManager'],
// shorter ClassName, to save bytes and use internally
alternateClassName: ['Ext.dd.DragDropMgr', 'Ext.dd.DDM'],

ids: {},

handleIds: {},

dragCurrent: null,

dragOvers: {},

deltaX: 0,

deltaY: 0,

preventDefault: true,

stopPropagation: true,

initialized: false,

locked: false,

init: function() {
this.initialized = true;
},

POINT: 0,

INTERSECT: 1,

mode: 0,

notifyOccluded: false,

dragCls: Ext.baseCSSPrefix + 'dd-drag-current',

_execOnAll: function(sMethod, args) {
var i, j, oDD;
for (i in this.ids) {
for (j in this.ids[i]) {
oDD = this.ids[i][j];
if (! this.isTypeOfDD(oDD)) {
continue;
}
oDD[sMethod].apply(oDD, args);
}
}
},

_onLoad: function() {
this.init();
var Event = Ext.EventManager;
Event.on(document, "mouseup", this.handleMouseUp, this, true);
Event.on(document, "mousemove", this.handleMouseMove, this, true);
Event.on(window, "unload", this._onUnload, this, true);
Event.on(window, "resize", this._onResize, this, true);
// Event.on(window, "mouseout", this._test);
},

_onResize: function(e) {
this._execOnAll("resetConstraints", []);
},

lock: function() { this.locked = true; },

unlock: function() { this.locked = false; },

isLocked: function() { return this.locked; },

locationCache: {},

useCache: true,

clickPixelThresh: 3,

clickTimeThresh: 350,

dragThreshMet: false,

clickTimeout: null,

startX: 0,

startY: 0,

regDragDrop: function(oDD, sGroup) {
if (!this.initialized) { this.init(); }
if (!this.ids[sGroup]) {
this.ids[sGroup] = {};
}
this.ids[sGroup][oDD.id] = oDD;
},

removeDDFromGroup: function(oDD, sGroup) {
if (!this.ids[sGroup]) {
this.ids[sGroup] = {};
}
var obj = this.ids[sGroup];
if (obj && obj[oDD.id]) {
delete obj[oDD.id];
}
},

_remove: function(oDD) {
for (var g in oDD.groups) {
if (g && this.ids[g] && this.ids[g][oDD.id]) {
delete this.ids[g][oDD.id];
}
}
delete this.handleIds[oDD.id];
},

regHandle: function(sDDId, sHandleId) {
if (!this.handleIds[sDDId]) {
this.handleIds[sDDId] = {};
}
this.handleIds[sDDId][sHandleId] = sHandleId;
},

isDragDrop: function(id) {
return ( this.getDDById(id) ) ? true : false;
},

getRelated: function(p_oDD, bTargetsOnly) {
var oDDs = [],
i, j, dd;
for (i in p_oDD.groups) {
for (j in this.ids[i]) {
dd = this.ids[i][j];
if (! this.isTypeOfDD(dd)) {
continue;
}
if (!bTargetsOnly || dd.isTarget) {
oDDs[oDDs.length] = dd;
}
}
}
return oDDs;
},

isLegalTarget: function (oDD, oTargetDD) {
var targets = this.getRelated(oDD, true),
i, len;
for (i=0, len=targets.length;i<len;++i) {
if (targets[i].id == oTargetDD.id) {
return true;
}
}
return false;
},

isTypeOfDD: function (oDD) {
return (oDD && oDD.__ygDragDrop);
},

isHandle: function(sDDId, sHandleId) {
return ( this.handleIds[sDDId] &&
this.handleIds[sDDId][sHandleId] );
},

getDDById: function(id) {
var i, dd;
for (i in this.ids) {
dd = this.ids[i][id];
if (dd instanceof Ext.dd.DDTarget) {
return dd;
}
}
return null;
},

handleMouseDown: function(e, oDD) {
var me = this,
el;
if (Ext.quickTipsActive){
Ext.tip.QuickTipManager.ddDisable();
}
if (me.dragCurrent){
// the original browser mouseup wasn't handled (e.g. outside FF browser window)
// so clean up first to avoid breaking the next drag
me.handleMouseUp(e);
}
me.currentTarget = e.getTarget();
me.dragCurrent = oDD;
el = oDD.getEl();
// We use this to handle an issue where a mouseup will not be detected 
// if the mouseup event happens outside of the browser window. When the 
// mouse comes back, any drag will still be active
// http://msdn.microsoft.com/en-us/library/ms537630(VS.85).aspx
if (Ext.isIE9m && el.setCapture) {
el.setCapture();
}
// track start position
me.startX = e.getPageX();
me.startY = e.getPageY();
me.deltaX = me.startX - el.offsetLeft;
me.deltaY = me.startY - el.offsetTop;
me.dragThreshMet = false;
me.clickTimeout = setTimeout(
function() {
me.startDrag(me.startX, me.startY);
},
me.clickTimeThresh
);
},

startDrag: function(x, y) {
var me = this,
current = me.dragCurrent,
dragEl;
clearTimeout(me.clickTimeout);
if (current) {
current.b4StartDrag(x, y);
current.startDrag(x, y);
dragEl = current.getDragEl();
// Add current drag class to dragged element
if (dragEl) {
Ext.fly(dragEl).addCls(me.dragCls);
}
}
me.dragThreshMet = true;
},

handleMouseUp: function(e) {
var me = this;
if (Ext.quickTipsActive){
Ext.tip.QuickTipManager.ddEnable();
}
if (!me.dragCurrent) {
return;
}
// See setCapture call in handleMouseDown
if (Ext.isIE && document.releaseCapture) {
document.releaseCapture();
}
clearTimeout(me.clickTimeout);
if (me.dragThreshMet) {
me.fireEvents(e, true);
}
me.stopDrag(e);
me.stopEvent(e);
},

stopEvent: function(e) {
if (this.stopPropagation) {
e.stopPropagation();
}
if (this.preventDefault) {
e.preventDefault();
}
},

stopDrag: function(e) {
var me = this,
current = me.dragCurrent,
dragEl;
// Fire the drag end event for the item that was dragged
if (current) {
if (me.dragThreshMet) {
// Remove current drag class from dragged element
dragEl = current.getDragEl();
if (dragEl) {
Ext.fly(dragEl).removeCls(me.dragCls);
}
current.b4EndDrag(e);
current.endDrag(e);
}
me.dragCurrent.onMouseUp(e);
}
me.dragCurrent = null;
me.dragOvers = {};
},

handleMouseMove: function(e) {
var me = this,
current = me.dragCurrent,
diffX,
diffY;
if (!current) {
return true;
}
if (!me.dragThreshMet) {
diffX = Math.abs(me.startX - e.getPageX());
diffY = Math.abs(me.startY - e.getPageY());
if (diffX > me.clickPixelThresh || diffY > me.clickPixelThresh) {
me.startDrag(me.startX, me.startY);
}
}
if (me.dragThreshMet) {
current.b4Drag(e);
current.onDrag(e);
if (!current.moveOnly) {
me.fireEvents(e, false);
}
}
me.stopEvent(e);
return true;
},

fireEvents: function(e, isDrop) {
var me = this,
dragCurrent = me.dragCurrent,
dragEl,
oldDragElTop,
mousePoint = e.getPoint(),
overTarget,
overTargetEl,
allTargets = [],
oldOvers = [], // cache the previous dragOver array
outEvts = [],
overEvts = [],
dropEvts = [],
enterEvts = [],
xy,
needsSort,
i,
len,
sGroup;
// If the user did the mouse up outside of the window, we could
// get here even though we have ended the drag.
if (!dragCurrent || dragCurrent.isLocked()) {
return;
}
// If we need to use the current mousemove target to find the over el,
// but pointer-events is not supported, AND the delta position does not place the mouse outside of the dragEl,
// temporarily move the dragEl away, and fake the mousemove target by using document.elementFromPoint
// while it's out of the way.
// The pointer events implementation is bugged in IE9/10 and opera, so fallback even if they report that they support it.
// IE8m do not support it so they will auto fall back
if (!me.notifyOccluded && (!Ext.supports.PointerEvents || Ext.isIE10m || Ext.isOpera) && !(dragCurrent.deltaX < 0 || dragCurrent.deltaY < 0)) {
dragEl = dragCurrent.getDragEl();
oldDragElTop = dragEl.style.top;
dragEl.style.top = '-10000px';
xy = e.getXY();
e.target = document.elementFromPoint(xy[0], xy[1]);
dragEl.style.top = oldDragElTop;
}
// Check to see if the object(s) we were hovering over is no longer
// being hovered over so we can fire the onDragOut event
for (i in me.dragOvers) {
overTarget = me.dragOvers[i];
if (!me.isTypeOfDD(overTarget)) {
continue;
}
// If notifyOccluded set, we use mouse position
if (me.notifyOccluded) {
if (!this.isOverTarget(mousePoint, overTarget, me.mode)) {
outEvts.push(overTarget);
}
}
// Otherwise we use event source of the mousemove event
else {
if (!e.within(overTarget.getEl())) {
outEvts.push(overTarget);
}
}
oldOvers[i] = true;
delete me.dragOvers[i];
}
// Collect all targets which are members of the same ddGoups that the dragCurrent is a member of, and which may recieve mouseover and drop notifications.
// This is preparatory to seeing which one(s) we are currently over
// Begin by iterating through the ddGroups of which the dragCurrent is a member
for (sGroup in dragCurrent.groups) {
if ("string" != typeof sGroup) {
continue;
}
// Loop over the registered members of each group, testing each as a potential target
for (i in me.ids[sGroup]) {
overTarget = me.ids[sGroup][i];
// The target is valid if it is a DD type
// And it's got a DOM element
// And it's configured to be a drop target
// And it's not locked
// And the DOM element is fully visible with no hidden ancestors
// And it's either not the dragCurrent, or, if it is, tha dragCurrent is configured to not ignore itself.
if (me.isTypeOfDD(overTarget) &&
(overTargetEl = overTarget.getEl()) &&
(overTarget.isTarget) &&
(!overTarget.isLocked()) &&
(Ext.fly(overTargetEl).isVisible(true)) &&
((overTarget != dragCurrent) || (dragCurrent.ignoreSelf === false))) {
// If notifyOccluded set, we use mouse position
if (me.notifyOccluded) {
// Only sort by zIndex if there were some which had a floating zIndex value
if ((overTarget.zIndex = me.getZIndex(overTargetEl)) !== -1) {
needsSort = true;
}
allTargets.push(overTarget);
}
// Otherwise we use event source of the mousemove event
else {
if (e.within(overTarget.getEl())) {
allTargets.push(overTarget);
break;
}
}
}
}
}
// If there were floating targets, sort the highest zIndex to the top
if (needsSort) {
Ext.Array.sort(allTargets, me.byZIndex);
}
// Loop through possible targets, notifying the one(s) we are over.
// Usually we only deliver events to the topmost.
for (i = 0, len = allTargets.length; i < len; i++) {
overTarget = allTargets[i];
// If we are over the overTarget, queue it up to recieve an event of whatever type we are handling
if (me.isOverTarget(mousePoint, overTarget, me.mode)) {
// look for drop interactions
if (isDrop) {
dropEvts.push( overTarget );
// look for drag enter and drag over interactions
} else {
// initial drag over: dragEnter fires
if (!oldOvers[overTarget.id]) {
enterEvts.push( overTarget );
// subsequent drag overs: dragOver fires
} else {
overEvts.push( overTarget );
}
me.dragOvers[overTarget.id] = overTarget;
}
// Unless this DragDropManager has been explicitly configured to deliver events to multiple targets, then we are done.
if (!me.notifyOccluded) {
break;
}
}
}
if (me.mode) {
if (outEvts.length) {
dragCurrent.b4DragOut(e, outEvts);
dragCurrent.onDragOut(e, outEvts);
}
if (enterEvts.length) {
dragCurrent.onDragEnter(e, enterEvts);
}
if (overEvts.length) {
dragCurrent.b4DragOver(e, overEvts);
dragCurrent.onDragOver(e, overEvts);
}
if (dropEvts.length) {
dragCurrent.b4DragDrop(e, dropEvts);
dragCurrent.onDragDrop(e, dropEvts);
}
} else {
// fire dragout events
for (i=0, len=outEvts.length; i<len; ++i) {
dragCurrent.b4DragOut(e, outEvts[i].id);
dragCurrent.onDragOut(e, outEvts[i].id);
}
// fire enter events
for (i=0,len=enterEvts.length; i<len; ++i) {
// dc.b4DragEnter(e, oDD.id);
dragCurrent.onDragEnter(e, enterEvts[i].id);
}
// fire over events
for (i=0,len=overEvts.length; i<len; ++i) {
dragCurrent.b4DragOver(e, overEvts[i].id);
dragCurrent.onDragOver(e, overEvts[i].id);
}
// fire drop events
for (i=0, len=dropEvts.length; i<len; ++i) {
dragCurrent.b4DragDrop(e, dropEvts[i].id);
dragCurrent.onDragDrop(e, dropEvts[i].id);
}
}
// notify about a drop that did not find a target
if (isDrop && !dropEvts.length) {
dragCurrent.onInvalidDrop(e);
}
},

getZIndex: function(element) {
var body = document.body,
z,
zIndex = -1;
element = Ext.getDom(element);
while (element !== body) {
if (!isNaN(z = Number(Ext.fly(element).getStyle('zIndex')))) {
zIndex = z;
}
element = element.parentNode;
}
return zIndex;
},

byZIndex: function(d1, d2) {
return d1.zIndex < d2.zIndex;
},

getBestMatch: function(dds) {
var winner = null,
len = dds.length,
i, dd;
// Return null if the input is not what we expect
//if (!dds || !dds.length || dds.length == 0) {
// winner = null;
// If there is only one item, it wins
//} else if (dds.length == 1) {
if (len == 1) {
winner = dds[0];
} else {
// Loop through the targeted items
for (i=0; i<len; ++i) {
dd = dds[i];
// If the cursor is over the object, it wins. If the
// cursor is over multiple matches, the first one we come
// to wins.
if (dd.cursorIsOver) {
winner = dd;
break;
// Otherwise the object with the most overlap wins
} else {
if (!winner ||
winner.overlap.getArea() < dd.overlap.getArea()) {
winner = dd;
}
}
}
}
return winner;
},

refreshCache: function(groups) {
var sGroup, i, oDD, loc;
for (sGroup in groups) {
if ("string" != typeof sGroup) {
continue;
}
for (i in this.ids[sGroup]) {
oDD = this.ids[sGroup][i];
if (this.isTypeOfDD(oDD)) {
// if (this.isTypeOfDD(oDD) && oDD.isTarget) {
loc = this.getLocation(oDD);
if (loc) {
this.locationCache[oDD.id] = loc;
} else {
delete this.locationCache[oDD.id];
// this will unregister the drag and drop object if
// the element is not in a usable state
// oDD.unreg();
}
}
}
}
},

verifyEl: function(el) {
if (el) {
var parent;
if(Ext.isIE){
try{
parent = el.offsetParent;
}catch(e){}
}else{
parent = el.offsetParent;
}
if (parent) {
return true;
}
}
return false;
},

getLocation: function(oDD) {
if (! this.isTypeOfDD(oDD)) {
return null;
}
//delegate getLocation method to the
//drag and drop target.
if (oDD.getRegion) {
return oDD.getRegion();
}
var el = oDD.getEl(), pos, x1, x2, y1, y2, t, r, b, l;
try {
pos= Ext.Element.getXY(el);
} catch (e) { }
if (!pos) {
return null;
}
x1 = pos[0];
x2 = x1 + el.offsetWidth;
y1 = pos[1];
y2 = y1 + el.offsetHeight;
t = y1 - oDD.padding[0];
r = x2 + oDD.padding[1];
b = y2 + oDD.padding[2];
l = x1 - oDD.padding[3];
return new Ext.util.Region(t, r, b, l);
},

isOverTarget: function(pt, oTarget, intersect) {
// use cache if available
var loc = this.locationCache[oTarget.id],
dc,
pos,
el,
curRegion,
overlap;
if (!loc || !this.useCache) {
loc = this.getLocation(oTarget);
this.locationCache[oTarget.id] = loc;
}
if (!loc) {
return false;
}
oTarget.cursorIsOver = loc.contains( pt );
// DragDrop is using this as a sanity check for the initial mousedown
// in this case we are done. In POINT mode, if the drag obj has no
// contraints, we are also done. Otherwise we need to evaluate the
// location of the target as related to the actual location of the
// dragged element.
dc = this.dragCurrent;
if (!dc || !dc.getTargetCoord ||
(!intersect && !dc.constrainX && !dc.constrainY)) {
return oTarget.cursorIsOver;
}
oTarget.overlap = null;
// Get the current location of the drag element, this is the
// location of the mouse event less the delta that represents
// where the original mousedown happened on the element. We
// need to consider constraints and ticks as well.
pos = dc.getTargetCoord(pt.x, pt.y);
el = dc.getDragEl();
curRegion = new Ext.util.Region(pos.y,
pos.x + el.offsetWidth,
pos.y + el.offsetHeight,
pos.x
);
overlap = curRegion.intersect(loc);
if (overlap) {
oTarget.overlap = overlap;
return (intersect) ? true : oTarget.cursorIsOver;
} else {
return false;
}
},

_onUnload: function(e, me) {
Ext.dd.DragDropManager.unregAll();
},

unregAll: function() {
if (this.dragCurrent) {
this.stopDrag();
this.dragCurrent = null;
}
this._execOnAll("unreg", []);
for (var i in this.elementCache) {
delete this.elementCache[i];
}
this.elementCache = {};
this.ids = {};
},

elementCache: {},

getElWrapper: function(id) {
var oWrapper = this.elementCache[id];
if (!oWrapper || !oWrapper.el) {
oWrapper = this.elementCache[id] =
new this.ElementWrapper(Ext.getDom(id));
}
return oWrapper;
},

getElement: function(id) {
return Ext.getDom(id);
},

getCss: function(id) {
var el = Ext.getDom(id);
return (el) ? el.style : null;
},

ElementWrapper: function(el) {

this.el = el || null;

this.id = this.el && el.id;

this.css = this.el && el.style;
},
// Continue class docs


getPosX: function(el) {
return Ext.Element.getX(el);
},

getPosY: function(el) {
return Ext.Element.getY(el);
},

swapNode: function(n1, n2) {
if (n1.swapNode) {
n1.swapNode(n2);
} else {
var p = n2.parentNode,
s = n2.nextSibling;
if (s == n1) {
p.insertBefore(n1, n2);
} else if (n2 == n1.nextSibling) {
p.insertBefore(n2, n1);
} else {
n1.parentNode.replaceChild(n2, n1);
p.insertBefore(n1, s);
}
}
},

getScroll: function () {
var doc = window.document,
docEl = doc.documentElement,
body = doc.body,
top = 0,
left = 0;
if (Ext.isGecko4) {
top = window.scrollYOffset;
left = window.scrollXOffset;
} else {
if (docEl && (docEl.scrollTop || docEl.scrollLeft)) {
top = docEl.scrollTop;
left = docEl.scrollLeft;
} else if (body) {
top = body.scrollTop;
left = body.scrollLeft;
}
}
return {
top: top,
left: left
};
},

getStyle: function(el, styleProp) {
return Ext.fly(el).getStyle(styleProp);
},

getScrollTop: function () {
return this.getScroll().top;
},

getScrollLeft: function () {
return this.getScroll().left;
},

moveToEl: function (moveEl, targetEl) {
var aCoord = Ext.Element.getXY(targetEl);
Ext.Element.setXY(moveEl, aCoord);
},

numericSort: function(a, b) {
return (a - b);
},

_timeoutCount: 0,

_addListeners: function() {
if ( document ) {
this._onLoad();
} else {
if (this._timeoutCount <= 2000) {
setTimeout(this._addListeners, 10);
if (document && document.body) {
this._timeoutCount += 1;
}
}
}
},

handleWasClicked: function(node, id) {
if (this.isHandle(id, node.id)) {
return true;
} else {
// check to see if this is a text node child of the one we want
var p = node.parentNode;
while (p) {
if (this.isHandle(id, p.id)) {
return true;
} else {
p = p.parentNode;
}
}
}
return false;
}
}, function() {
this._addListeners();
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/layout/container/Box.js */
(function(Ext) {
Ext.define('Ext.layout.container.Box', {

alias: ['layout.box'],
extend: 'Ext.layout.container.Container',
alternateClassName: 'Ext.layout.BoxLayout',
requires: [
'Ext.layout.container.boxOverflow.None',
'Ext.layout.container.boxOverflow.Menu',
'Ext.layout.container.boxOverflow.Scroller',
'Ext.util.Format',
'Ext.dd.DragDropManager'
],


defaultMargins: {
top: 0,
right: 0,
bottom: 0,
left: 0
},

padding: 0,

pack: 'start',

flex: undefined,

stretchMaxPartner: undefined,
alignRoundingMethod: 'round',
type: 'box',
scrollOffset: 0,
itemCls: Ext.baseCSSPrefix + 'box-item',
targetCls: Ext.baseCSSPrefix + 'box-layout-ct',
targetElCls: Ext.baseCSSPrefix + 'box-target',
innerCls: Ext.baseCSSPrefix + 'box-inner',
// availableSpaceOffset is used to adjust the availableWidth, typically used
// to reserve space for a scrollbar
availableSpaceOffset: 0,
// whether or not to reserve the availableSpaceOffset in layout calculations
reserveOffset: true,
manageMargins: true,

createsInnerCt: true,
childEls: [
'innerCt',
'targetEl'
],
renderTpl: [
'{%var oc,l=values.$comp.layout,oh=l.overflowHandler;',
'if (oh.getPrefixConfig!==Ext.emptyFn) {',
'if(oc=oh.getPrefixConfig())dh.generateMarkup(oc, out)',
'}%}',
'<div id="{ownerId}-innerCt" class="{[l.innerCls]} {[oh.getOverflowCls()]}" role="presentation">',
'<div id="{ownerId}-targetEl" class="{targetElCls}">',
'{%this.renderBody(out, values)%}',
'</div>',
'</div>',
'{%if (oh.getSuffixConfig!==Ext.emptyFn) {',
'if(oc=oh.getSuffixConfig())dh.generateMarkup(oc, out)',
'}%}',
{
disableFormats: true,
definitions: 'var dh=Ext.DomHelper;'
}
],
constructor: function(config) {
var me = this,
type;
me.callParent(arguments);
// The sort function needs access to properties in this, so must be bound.
me.flexSortFn = Ext.Function.bind(me.flexSort, me);
me.initOverflowHandler();
type = typeof me.padding;
if (type == 'string' || type == 'number') {
me.padding = Ext.util.Format.parseBox(me.padding);
me.padding.height = me.padding.top + me.padding.bottom;
me.padding.width = me.padding.left + me.padding.right;
}
},
// Matches: `<spaces>digits[.digits]<spaces>%<spaces>`
// Captures: `digits[.digits]`
_percentageRe: /^\s*(\d+(?:\.\d*)?)\s*[%]\s*$/,
getItemSizePolicy: function (item, ownerSizeModel) {
var me = this,
policy = me.sizePolicy,
align = me.align,
flex = item.flex,
key = align,
names = me.names,
width = item[names.width],
height = item[names.height],
percentageRe = me._percentageRe,
percentageWidth = percentageRe.test(width),
isStretch = (align == 'stretch'),
isStretchMax = (align == 'stretchmax'),
constrain = me.constrainAlign;

// Getting the size model is expensive, so we only want to do so if we really need it
if (!ownerSizeModel && (isStretch || flex || percentageWidth || (constrain && !isStretchMax))) {
ownerSizeModel = me.owner.getSizeModel();
}
if (isStretch) {
// If we are height.shrinkWrap, we behave as if we were stretchmax (for more
// details, see beginLayoutCycle)...
if (!percentageRe.test(height) && ownerSizeModel[names.height].shrinkWrap) {
key = 'stretchmax';
// We leave %age height as stretch since it will not participate in the
// stretchmax size calculation. This avoid running such a child in its
// shrinkWrap mode prior to supplying the calculated size.
}
} else if (!isStretchMax) {
if (percentageRe.test(height)) {
// Height %ages are calculated based on container size, so they are the
// same as align=stretch for this purpose...
key = 'stretch';
} else if (constrain && !ownerSizeModel[names.height].shrinkWrap) {
// Same functionality as stretchmax, only the max is going to be the size
// of the container, not the largest item
key = 'stretchmax';
} else {
key = '';
}
}
if (flex || percentageWidth) {
// If we are width.shrinkWrap, we won't be flexing since that requires a
// container width...
if (!ownerSizeModel[names.width].shrinkWrap) {
policy = policy.flex; // both flex and %age width are calculated
}
}
return policy[key];
},
flexSort: function (a, b) {
// We need to sort the flexed items to ensure that we have
// the items with max/min width first since when we set the
// values we may have the value constrained, so we need to
// react accordingly. Precedence is given from the largest
// value through to the smallest value
var maxWidthName = this.names.maxWidth,
minWidthName = this.names.minWidth,
infiniteValue = Infinity,
aTarget = a.target,
bTarget = b.target,
result = 0,
aMin, bMin, aMax, bMax,
hasMin, hasMax;
aMax = aTarget[maxWidthName] || infiniteValue;
bMax = bTarget[maxWidthName] || infiniteValue;
aMin = aTarget[minWidthName] || 0;
bMin = bTarget[minWidthName] || 0;

hasMin = isFinite(aMin) || isFinite(bMin);
hasMax = isFinite(aMax) || isFinite(bMax);
if (hasMin || hasMax) {
if (hasMax) {
result = aMax - bMax;
}

// If the result is 0, it means either
// a) hasMax was false
// b) The max values were the same
if (result === 0 && hasMin) {
result = bMin - aMin;
}
}
return result;
},
isItemBoxParent: function (itemContext) {
return true;
},
isItemShrinkWrap: function (item) {
return true;
},
roundFlex: function(width) {
return Math.ceil(width);
},

beginCollapse: function(child) {
var me = this;
if (me.direction === 'vertical' && child.collapsedVertical()) {
child.collapseMemento.capture(['flex']);
delete child.flex;
} else if (me.direction === 'horizontal' && child.collapsedHorizontal()) {
child.collapseMemento.capture(['flex']);
delete child.flex;
}
},

beginExpand: function(child) {
// Restores the flex if we used to be flexed before
child.collapseMemento.restore(['flex']);
},
beginLayout: function (ownerContext) {
var me = this,
owner = me.owner,
smp = owner.stretchMaxPartner,
style = me.innerCt.dom.style,
names = me.names;
ownerContext.boxNames = names;
// this must happen before callParent to allow the overflow handler to do its work
// that can effect the childItems collection...
me.overflowHandler.beginLayout(ownerContext);
// get the contextItem for our stretchMax buddy:
if (typeof smp === 'string') {
smp = Ext.getCmp(smp) || owner.query(smp)[0];
}
ownerContext.stretchMaxPartner = smp && ownerContext.context.getCmp(smp);
me.callParent(arguments);
ownerContext.innerCtContext = ownerContext.getEl('innerCt', me);
// Capture whether the owning Container is scrolling in the parallel direction
me.scrollParallel = owner.scrollFlags[names.x];
// Capture whether the owning Container is scrolling in the perpendicular direction
me.scrollPerpendicular = owner.scrollFlags[names.y];
// If we *are* scrolling parallel, capture the scroll position of the encapsulating element
if (me.scrollParallel) {
me.scrollPos = owner.getTargetEl().dom[names.scrollLeft];
}
// Don't allow sizes burned on to the innerCt to influence measurements.
style.width = '';
style.height = '';
},
beginLayoutCycle: function (ownerContext, firstCycle) {
var me = this,
align = me.align,
names = ownerContext.boxNames,
pack = me.pack,
heightModelName = names.heightModel;
// this must happen before callParent to allow the overflow handler to do its work
// that can effect the childItems collection...
me.overflowHandler.beginLayoutCycle(ownerContext, firstCycle);
me.callParent(arguments);
// Cache several of our string concat/compare results (since width/heightModel can
// change if we are invalidated, we cannot do this in beginLayout)
ownerContext.parallelSizeModel = ownerContext[names.widthModel];
ownerContext.perpendicularSizeModel = ownerContext[heightModelName];
ownerContext.boxOptions = {
align: align = {
stretch: align == 'stretch',
stretchmax: align == 'stretchmax',
center: align == names.center,
bottom: align == names.afterY
},
pack: pack = {
center: pack == 'center',
end: pack == 'end'
}
};
// Consider an hbox w/stretch which means "assign all items the container's height".
// The spirit of this request is make all items the same height, but when shrinkWrap
// height is also requested, the height of the tallest item determines the height.
// This is exactly what the stretchmax option does, so we jiggle the flags here to
// act as if stretchmax were requested.
if (align.stretch && ownerContext.perpendicularSizeModel.shrinkWrap) {
align.stretchmax = true;
align.stretch = false;
}
// This is handy for knowing that we might need to apply height %ages
align.nostretch = !(align.stretch || align.stretchmax);
// In our example hbox, packing items to the right (end) or center can only work if
// there is a container width. So, if we are shrinkWrap, we just turn off the pack
// options for the run.
if (ownerContext.parallelSizeModel.shrinkWrap) {
pack.center = pack.end = false;
}
me.cacheFlexes(ownerContext);
// We set the width of the target el equal to the width of the innerCt
// when the layout cycle is finished, so we need to clear the width here
// to prevent the children from being crushed.
// IE needs it because of its scrollIntoView bug: https://sencha.jira.com/browse/EXTJSIV-6520
// Webkit needs it because of its mouse drag bug: https://sencha.jira.com/browse/EXTJSIV-5962
// FF needs it because of a vertical tab bug: https://sencha.jira.com/browse/EXTJSIV-8614
me.targetEl.setWidth(20000);
},

cacheFlexes: function (ownerContext) {
var me = this,
names = ownerContext.boxNames,
widthModelName = names.widthModel,
heightModelName = names.heightModel,
nostretch = ownerContext.boxOptions.align.nostretch,
totalFlex = 0,
childItems = ownerContext.childItems,
i = childItems.length,
flexedItems = [],
minWidth = 0,
minWidthName = names.minWidth,
percentageRe = me._percentageRe,
percentageWidths = 0,
percentageHeights = 0,
child, childContext, flex, match;
while (i--) {
childContext = childItems[i];
child = childContext.target;
// check widthModel to see if we are the sizing layout. If so, copy the flex
// from the item to the contextItem and add it to totalFlex
//
if (childContext[widthModelName].calculated) {
childContext.flex = flex = child.flex;
if (flex) {
totalFlex += flex;
flexedItems.push(childContext);
minWidth += child[minWidthName] || 0;
} else { // a %age width...
match = percentageRe.exec(child[names.width]);
childContext.percentageParallel = parseFloat(match[1]) / 100;
++percentageWidths;
}
}
// the above means that "childContext.flex" is properly truthy/falsy, which is
// often times quite convenient...
if (nostretch && childContext[heightModelName].calculated) {
// the only reason we would be calculated height in this case is due to a
// height %age...
match = percentageRe.exec(child[names.height]);
childContext.percentagePerpendicular = parseFloat(match[1]) / 100;
++percentageHeights;
}
}
ownerContext.flexedItems = flexedItems;
ownerContext.flexedMinSize = minWidth;
ownerContext.totalFlex = totalFlex;
ownerContext.percentageWidths = percentageWidths;
ownerContext.percentageHeights = percentageHeights;
// The flexed boxes need to be sorted in ascending order of maxSize to work properly
// so that unallocated space caused by maxWidth being less than flexed width can be
// reallocated to subsequent flexed boxes.
Ext.Array.sort(flexedItems, me.flexSortFn);
},
calculate: function(ownerContext) {
var me = this,
targetSize = me.getContainerSize(ownerContext),
names = ownerContext.boxNames,
state = ownerContext.state,
plan = state.boxPlan || (state.boxPlan = {}),
targetContext = ownerContext.targetContext;
plan.targetSize = targetSize;
// If we are not widthModel.shrinkWrap, we need the width before we can lay out boxes:
if (!ownerContext.parallelSizeModel.shrinkWrap && !targetSize[names.gotWidth]) {
me.done = false;
return;
}
if (!state.parallelDone) {
state.parallelDone = me.calculateParallel(ownerContext, names, plan);
}
if (!state.perpendicularDone) {
state.perpendicularDone = me.calculatePerpendicular(ownerContext, names, plan);
}
if (state.parallelDone && state.perpendicularDone) {
// Fix for left and right docked Components in a dock component layout. This is for docked Headers and docked Toolbars.
// Older Microsoft browsers do not size a position:absolute element's width to match its content.
// So in this case, in the publishInnerCtSize method we may need to adjust the size of the owning Container's element explicitly based upon
// the discovered max width. So here we put a calculatedWidth property in the metadata to facilitate this.
if (me.owner.dock && (Ext.isIE7m || Ext.isIEQuirks) && !me.owner.width && !me.horizontal) {
plan.isIEVerticalDock = true;
plan.calculatedWidth = plan.maxSize + ownerContext.getPaddingInfo().width + ownerContext.getFrameInfo().width;
if (targetContext !== ownerContext) {
// targetContext can have additional padding, e.g. vertically
// oriented toolbar body element has a few px of left or right padding
// to make room for the tab strip.
plan.calculatedWidth += targetContext.getPaddingInfo().width;
}
}
me.publishInnerCtSize(ownerContext, me.reserveOffset ? me.availableSpaceOffset : 0);
// Calculate stretchmax only if there is >1 child item, or there is a stretchMaxPartner wanting the info
if (me.done && (ownerContext.childItems.length > 1 || ownerContext.stretchMaxPartner) && ownerContext.boxOptions.align.stretchmax && !state.stretchMaxDone) {
me.calculateStretchMax(ownerContext, names, plan);
state.stretchMaxDone = true;
}
me.overflowHandler.calculate(ownerContext);
} else {
me.done = false;
}
},
calculateParallel: function(ownerContext, names, plan) {
var me = this,
widthName = names.width,
childItems = ownerContext.childItems,
beforeXName = names.beforeX,
afterXName = names.afterX,
setWidthName = names.setWidth,
childItemsLength = childItems.length,
flexedItems = ownerContext.flexedItems,
flexedItemsLength = flexedItems.length,
pack = ownerContext.boxOptions.pack,
padding = me.padding,
containerWidth = plan.targetSize[widthName],
totalMargin = 0,
left = padding[beforeXName],
nonFlexWidth = left + padding[afterXName] + me.scrollOffset +
(me.reserveOffset ? me.availableSpaceOffset : 0),
scrollbarWidth = Ext.getScrollbarSize()[names.width],
i, childMargins, remainingWidth, remainingFlex, childContext, flex, flexedWidth,
contentWidth, mayNeedScrollbarAdjust, childWidth, percentageSpace;
// We may need to add scrollbar size to parallel size if
// Scrollbars take up space
// and we are scrolling in the perpendicular direction
// and shrinkWrapping in the parallel direction,
// and NOT stretching perpendicular dimensions to fit
// and NOT shrinkWrapping in the perpendicular direction
if (scrollbarWidth &&
me.scrollPerpendicular &&
ownerContext.parallelSizeModel.shrinkWrap &&
!ownerContext.boxOptions.align.stretch &&
!ownerContext.perpendicularSizeModel.shrinkWrap) {
// If its possible that we may need to add scrollbar size to the parallel size
// then we need to wait until the perpendicular size has been determined,
// so that we know if there is a scrollbar.
if (!ownerContext.state.perpendicularDone) {
return false;
}
mayNeedScrollbarAdjust = true;
}
// Gather the total size taken up by non-flexed items:
for (i = 0; i < childItemsLength; ++i) {
childContext = childItems[i];
childMargins = childContext.marginInfo || childContext.getMarginInfo();
totalMargin += childMargins[widthName];
if (!childContext[names.widthModel].calculated) {
childWidth = childContext.getProp(widthName);
nonFlexWidth += childWidth; // min/maxWidth safe
if (isNaN(nonFlexWidth)) {
return false;
}
}
}
nonFlexWidth += totalMargin;
if (ownerContext.percentageWidths) {
percentageSpace = containerWidth - totalMargin;
if (isNaN(percentageSpace)) {
return false;
}
for (i = 0; i < childItemsLength; ++i) {
childContext = childItems[i];
if (childContext.percentageParallel) {
childWidth = Math.ceil(percentageSpace * childContext.percentageParallel);
childWidth = childContext.setWidth(childWidth);
nonFlexWidth += childWidth;
}
}
}
// if we get here, we have all the childWidths for non-flexed items...
if (ownerContext.parallelSizeModel.shrinkWrap) {
plan.availableSpace = 0;
plan.tooNarrow = false;
} else {
plan.availableSpace = containerWidth - nonFlexWidth;
// If we're going to need space for a parallel scrollbar, then we need to redo the perpendicular measurements
plan.tooNarrow = plan.availableSpace < ownerContext.flexedMinSize;
if (plan.tooNarrow && Ext.getScrollbarSize()[names.height] && me.scrollParallel && ownerContext.state.perpendicularDone) {
ownerContext.state.perpendicularDone = false;
for (i = 0; i < childItemsLength; ++i) {
childItems[i].invalidate();
}
}
}
contentWidth = nonFlexWidth;
remainingWidth = plan.availableSpace;
remainingFlex = ownerContext.totalFlex;
// Calculate flexed item sizes:
for (i = 0; i < flexedItemsLength; i++) {
childContext = flexedItems[i];
flex = childContext.flex;
flexedWidth = me.roundFlex((flex / remainingFlex) * remainingWidth);
flexedWidth = childContext[setWidthName](flexedWidth); // constrained
// due to minWidth constraints, it may be that flexedWidth > remainingWidth
contentWidth += flexedWidth;
// Remaining space has already had margins subtracted, so just subtract size
remainingWidth = Math.max(0, remainingWidth - flexedWidth); // no negatives!
remainingFlex -= flex;
}
if (pack.center) {
left += remainingWidth / 2;
// If content is too wide to pack to center, do not allow the centering calculation to place it off the left edge.
if (left < 0) {
left = 0;
}
} else if (pack.end) {
left += remainingWidth;
}
// Assign parallel position for the boxes:
for (i = 0; i < childItemsLength; ++i) {
childContext = childItems[i];
childMargins = childContext.marginInfo; // already cached by first loop
left += childMargins[beforeXName];
childContext.setProp(names.x, left);
// We can read directly from "props.width" because we have already properly
// requested it in the calculation of nonFlexedWidths or we calculated it.
// We cannot call getProp because that would be inappropriate for flexed items
// and we don't need any extra function call overhead:
left += childMargins[afterXName] + childContext.props[widthName];
}
contentWidth += ownerContext.targetContext.getPaddingInfo()[widthName];
// Stash the contentWidth on the state so that it can always be accessed later in the calculation
ownerContext.state.contentWidth = contentWidth; 
// if there is perpendicular overflow, the published parallel content size includes
// the size of the perpendicular scrollbar.
if (mayNeedScrollbarAdjust &&
(ownerContext.peek(names.contentHeight) > plan.targetSize[names.height])) {
contentWidth += scrollbarWidth;
ownerContext[names.hasOverflowY] = true;
// tell the component layout to set the parallel size in the dom
ownerContext.target.componentLayout[names.setWidthInDom] = true;
// IE8 in what passes for "strict" mode will not create a scrollbar if 
// there is just the *exactly correct* spare space created for it. We
// have to force that to happen once all the styles have been flushed
// to the DOM (see completeLayout):
ownerContext[names.invalidateScrollY] = Ext.isStrict && Ext.isIE8;
}
ownerContext[names.setContentWidth](contentWidth);
return true;
},
calculatePerpendicular: function(ownerContext, names, plan) {
var me = this,
heightShrinkWrap = ownerContext.perpendicularSizeModel.shrinkWrap,
targetSize = plan.targetSize,
childItems = ownerContext.childItems,
childItemsLength = childItems.length,
mmax = Math.max,
heightName = names.height,
setHeightName = names.setHeight,
beforeYName = names.beforeY,
topPositionName = names.y,
padding = me.padding,
top = padding[beforeYName],
availHeight = targetSize[heightName] - top - padding[names.afterY],
align = ownerContext.boxOptions.align,
isStretch = align.stretch, // never true if heightShrinkWrap (see beginLayoutCycle)
isStretchMax = align.stretchmax,
isCenter = align.center,
isBottom = align.bottom,
constrain = me.constrainAlign,
maxHeight = 0,
hasPercentageSizes = 0,
onBeforeInvalidateChild = me.onBeforeConstrainInvalidateChild,
onAfterInvalidateChild = me.onAfterConstrainInvalidateChild,
scrollbarHeight = Ext.getScrollbarSize().height,
childTop, i, childHeight, childMargins, diff, height, childContext,
stretchMaxPartner, stretchMaxChildren, shrinkWrapParallelOverflow, 
percentagePerpendicular;
if (isStretch || ((isCenter || isBottom) && !heightShrinkWrap)) {
if (isNaN(availHeight)) {
return false;
}
}
// If the intention is to horizontally scroll child components, but the container is too narrow,
// then:
// if we are shrinkwrapping height:
// Set a flag because we are going to expand the height taken by the perpendicular dimension to accommodate the scrollbar
// else
// We must allow for the parallel scrollbar to intrude into the height
if (me.scrollParallel && plan.tooNarrow) {
if (heightShrinkWrap) {
shrinkWrapParallelOverflow = true;
} else {
availHeight -= scrollbarHeight;
plan.targetSize[heightName] -= scrollbarHeight;
}
}
if (isStretch) {
height = availHeight; // never heightShrinkWrap...
} else {
for (i = 0; i < childItemsLength; i++) {
childContext = childItems[i];
childMargins = (childContext.marginInfo || childContext.getMarginInfo())[heightName];
if (!(percentagePerpendicular = childContext.percentagePerpendicular)) {
childHeight = childContext.getProp(heightName);
} else {
++hasPercentageSizes;
if (heightShrinkWrap) {
// height %age items cannot contribute to maxHeight... they are going
// to be a %age of that maxHeight!
continue;
} else {
childHeight = percentagePerpendicular * availHeight - childMargins;
childHeight = childContext[names.setHeight](childHeight);
}
}

// Summary:
// 1) Not shrink wrapping height, so the height is not determined by the children
// 2) Constrain is set
// 3) The child item is shrink wrapping
// 4) It execeeds the max
if (!heightShrinkWrap && constrain && childContext[names.heightModel].shrinkWrap && childHeight > availHeight) {
childContext.invalidate({
before: onBeforeInvalidateChild,
after: onAfterInvalidateChild,
layout: me,
childHeight: availHeight,
names: names
});

// By invalidating the height, it could mean the width can change, so we need
// to recalculate in the parallel direction.
ownerContext.state.parallelDone = false; 
}
// Max perpendicular measurement (used for stretchmax) must take the min perpendicular size of each child into account in case any fall short.
if (isNaN(maxHeight = mmax(maxHeight, childHeight + childMargins,
childContext.target[names.minHeight] || 0))) {
return false; // heightShrinkWrap || isCenter || isStretchMax ??
}
}
// If there is going to be a parallel scrollbar maxHeight must include it to the outside world.
// ie: a stretchmaxPartner, and the setContentHeight
if (shrinkWrapParallelOverflow) {
maxHeight += scrollbarHeight;
ownerContext[names.hasOverflowX] = true;
// tell the component layout to set the perpendicular size in the dom
ownerContext.target.componentLayout[names.setHeightInDom] = true;
// IE8 in what passes for "strict" mode will not create a scrollbar if 
// there is just the *exactly correct* spare space created for it. We
// have to force that to happen once all the styles have been flushed
// to the DOM (see completeLayout):
ownerContext[names.invalidateScrollX] = Ext.isStrict && Ext.isIE8;
}
// If we are associated with another box layout, grab its maxChildHeight
// This must happen before we calculate and publish our contentHeight
stretchMaxPartner = ownerContext.stretchMaxPartner;
if (stretchMaxPartner) {
// Publish maxChildHeight as soon as it has been calculated for our partner:
ownerContext.setProp('maxChildHeight', maxHeight);
stretchMaxChildren = stretchMaxPartner.childItems;
// Only wait for maxChildHeight if our partner has visible items:
if (stretchMaxChildren && stretchMaxChildren.length) {
maxHeight = mmax(maxHeight, stretchMaxPartner.getProp('maxChildHeight'));
if (isNaN(maxHeight)) {
return false;
}
}
}
ownerContext[names.setContentHeight](maxHeight + me.padding[heightName] +
ownerContext.targetContext.getPaddingInfo()[heightName]);
// We have to publish the contentHeight with the additional scrollbarHeight
// to encourage our container to accomodate it, but we must remove the height
// of the scrollbar as we go to sizing or centering the children.
if (shrinkWrapParallelOverflow) {
maxHeight -= scrollbarHeight;
}
plan.maxSize = maxHeight;
if (isStretchMax) {
height = maxHeight;
} else if (isCenter || isBottom || hasPercentageSizes) {
if (constrain) {
height = heightShrinkWrap ? maxHeight : availHeight;
} else {
height = heightShrinkWrap ? maxHeight : mmax(availHeight, maxHeight);
}
// When calculating a centered position within the content box of the innerCt,
// the width of the borders must be subtracted from the size to yield the
// space available to center within. The publishInnerCtSize method explicitly
// adds the border widths to the set size of the innerCt.
height -= ownerContext.innerCtContext.getBorderInfo()[heightName];
}
}
for (i = 0; i < childItemsLength; i++) {
childContext = childItems[i];
childMargins = childContext.marginInfo || childContext.getMarginInfo();
childTop = top + childMargins[beforeYName];
if (isStretch) {
childContext[setHeightName](height - childMargins[heightName]);
} else {
percentagePerpendicular = childContext.percentagePerpendicular;
if (heightShrinkWrap && percentagePerpendicular) {
childMargins = childContext.marginInfo || childContext.getMarginInfo();
childHeight = percentagePerpendicular * height - childMargins[heightName];
childHeight = childContext.setHeight(childHeight);
}
if (isCenter) {
diff = height - childContext.props[heightName];
if (diff > 0) {
childTop = top + Math[me.alignRoundingMethod](diff / 2);
}
} else if (isBottom) {
childTop = mmax(0, height - childTop - childContext.props[heightName]);
}
}
childContext.setProp(topPositionName, childTop);
}
return true;
},

onBeforeConstrainInvalidateChild: function(childContext, options){
// NOTE: No "this" pointer in here...
var heightModelName = options.names.heightModel;
if (!childContext[heightModelName].constrainedMin) {
// if the child hit a min constraint, it needs to be at its configured size, so
// we leave the sizeModel alone
childContext[heightModelName] = Ext.layout.SizeModel.calculated;
}
},

onAfterConstrainInvalidateChild: function(childContext, options){
// NOTE: No "this" pointer in here...
var names = options.names;
// We use 0 here because we know the size exceeds the available size.
// This was chosen on purpose, even for align: 'bottom', because it doesn't
// make practical sense to place the item at the bottom and then have it overflow
// over the top of the container, since it's not possible to scroll to it. As such,
// we always put the component at the top to follow normal document flow.
childContext.setProp(names.beforeY, 0);
if (childContext[names.heightModel].calculated) {
childContext[names.setHeight](options.childHeight);
}
},
calculateStretchMax: function (ownerContext, names, plan) {
var me = this,
heightName = names.height,
widthName = names.width,
childItems = ownerContext.childItems,
length = childItems.length,
height = plan.maxSize,
onBeforeStretchMaxInvalidateChild = me.onBeforeStretchMaxInvalidateChild,
onAfterStretchMaxInvalidateChild = me.onAfterStretchMaxInvalidateChild,
childContext, props, i, childHeight;
for (i = 0; i < length; ++i) {
childContext = childItems[i];
props = childContext.props;
childHeight = height - childContext.getMarginInfo()[heightName];
if (childHeight != props[heightName] || // if (wrong height ...
childContext[names.heightModel].constrained) { // ...or needs invalidation)
// When we invalidate a child, since we won't be around to size or position
// it, we include an after callback that will be run after the invalidate
// that will (re)do that work. The good news here is that we can read the
// results of all that from the childContext props.
//
// We also include a before callback to change the sizeModel to calculated
// prior to the layout being invoked.
childContext.invalidate({
before: onBeforeStretchMaxInvalidateChild,
after: onAfterStretchMaxInvalidateChild,
layout: me,
// passing this data avoids a 'scope' and its Function.bind
childWidth: props[widthName],
// subtract margins from the maximum value
childHeight: childHeight,
childX: props.x,
childY: props.y,
names: names
});
}
}
},

onBeforeStretchMaxInvalidateChild: function (childContext, options) {
// NOTE: No "this" pointer in here...
var heightModelName = options.names.heightModel;
// Change the childItem to calculated (i.e., "set by ownerCt"). The component layout
// of the child can course-correct (like dock layout does for a collapsed panel),
// so we must make these changes here before that layout's beginLayoutCycle is
// called.
if (!childContext[heightModelName].constrainedMax) {
// if the child hit a max constraint, it needs to be at its configured size, so
// we leave the sizeModel alone...
childContext[heightModelName] = Ext.layout.SizeModel.calculated;
}
},
onAfterStretchMaxInvalidateChild: function (childContext, options) {
// NOTE: No "this" pointer in here...
var names = options.names,
childHeight = options.childHeight,
childWidth = options.childWidth;
childContext.setProp('x', options.childX);
childContext.setProp('y', options.childY);
if (childContext[names.heightModel].calculated) {
// We need to respect a child that is still not calculated (such as a collapsed
// panel)...
childContext[names.setHeight](childHeight);
}
if (childContext[names.widthModel].calculated) {
childContext[names.setWidth](childWidth);
}
},
completeLayout: function(ownerContext) {
var me = this,
names = ownerContext.boxNames,
invalidateScrollX = ownerContext.invalidateScrollX,
invalidateScrollY = ownerContext.invalidateScrollY,
dom, el, overflowX, overflowY, styles;
me.overflowHandler.completeLayout(ownerContext);
if (invalidateScrollX || invalidateScrollY) {
el = me.getTarget();
dom = el.dom;
styles = dom.style;
if (invalidateScrollX) {
// get computed style to see if we are 'auto'
overflowX = el.getStyle('overflowX');
if (overflowX == 'auto') {
// capture the inline style (if any) so we can restore it later:
overflowX = styles.overflowX;
styles.overflowX = 'scroll'; // force the scrollbar to appear
} else {
invalidateScrollX = false; // no work really since not 'auto'
}
}
if (invalidateScrollY) {
// get computed style to see if we are 'auto'
overflowY = el.getStyle('overflowY');
if (overflowY == 'auto') {
// capture the inline style (if any) so we can restore it later:
overflowY = styles.overflowY;
styles.overflowY = 'scroll'; // force the scrollbar to appear
} else {
invalidateScrollY = false; // no work really since not 'auto'
}
}
if (invalidateScrollX || invalidateScrollY) { // if (some form of 'auto' in play)
// force a reflow...
dom.scrollWidth;
if (invalidateScrollX) {
styles.overflowX = overflowX; // restore inline style
}
if (invalidateScrollY) {
styles.overflowY = overflowY; // restore inline style
}
}
}
// If we are scrolling parallel, restore the saved scroll position
if (me.scrollParallel) {
me.owner.getTargetEl().dom[names.scrollLeft] = me.scrollPos;
}
},
finishedLayout: function(ownerContext) {
this.overflowHandler.finishedLayout(ownerContext);
this.callParent(arguments);
// Fix for an obscure webkit bug (EXTJSIV-5962) caused by the targetEl's 20000px
// width. We set a very large width on the targetEl at the beginning of the 
// layout cycle to prevent any "crushing" effect on the child items, however
// in some cases the very large width makes it possible to scroll the innerCt
// by dragging on certain child elements. To prevent this from happening we ensure
// that the targetEl's width is the same as the innerCt.
// IE needs it because of its scrollIntoView bug: https://sencha.jira.com/browse/EXTJSIV-6520
// Webkit needs it because of its mouse drag bug: https://sencha.jira.com/browse/EXTJSIV-5962
// FF needs it because of a vertical tab bug: https://sencha.jira.com/browse/EXTJSIV-8614
this.targetEl.setWidth(ownerContext.innerCtContext.props.width);
},
publishInnerCtSize: function(ownerContext, reservedSpace) {
var me = this,
names = ownerContext.boxNames,
heightName = names.height,
widthName = names.width,
align = ownerContext.boxOptions.align,
dock = me.owner.dock,
padding = me.padding,
plan = ownerContext.state.boxPlan,
targetSize = plan.targetSize,
height = targetSize[heightName],
innerCtContext = ownerContext.innerCtContext,
innerCtWidth = (ownerContext.parallelSizeModel.shrinkWrap || (plan.tooNarrow && me.scrollParallel)
? ownerContext.state.contentWidth - ownerContext.targetContext.getPaddingInfo()[widthName]
: targetSize[widthName]) - (reservedSpace || 0),
innerCtHeight;
if (align.stretch) {
innerCtHeight = height;
} else {
innerCtHeight = plan.maxSize + padding[names.beforeY] + padding[names.afterY] + innerCtContext.getBorderInfo()[heightName];
if (!ownerContext.perpendicularSizeModel.shrinkWrap && (align.center || align.bottom)) {
innerCtHeight = Math.max(height, innerCtHeight);
}
}
innerCtContext[names.setWidth](innerCtWidth);
innerCtContext[names.setHeight](innerCtHeight);
// If unable to publish both dimensions, this layout needs to run again
if (isNaN(innerCtWidth + innerCtHeight)) {
me.done = false;
}
// If a calculated width has been found (this only happens for widthModel.shrinkWrap
// vertical docked Components in old Microsoft browsers) then, if the Component has
// not assumed the size of its content, set it to do so.
//
// We MUST pass the dirty flag to get that into the DOM, and because we are a Container
// layout, and not really supposed to perform sizing, we must also use the force flag.
if (plan.calculatedWidth && (dock == 'left' || dock == 'right')) {
// TODO: setting the owner size should be the job of the component layout.
ownerContext.setWidth(plan.calculatedWidth, true, true);
}
},
onRemove: function(comp){
var me = this;
me.callParent(arguments);
if (me.overflowHandler) {
me.overflowHandler.onRemove(comp);
}
if (comp.layoutMarginCap == me.id) {
delete comp.layoutMarginCap;
}
},

initOverflowHandler: function() {
var me = this,
handler = me.overflowHandler,
handlerType,
constructor;
if (typeof handler == 'string') {
handler = {
type: handler
};
}
handlerType = 'None';
if (handler && handler.type !== undefined) {
handlerType = handler.type;
}
constructor = Ext.layout.container.boxOverflow[handlerType];
if (constructor[me.type]) {
constructor = constructor[me.type];
}
me.overflowHandler = Ext.create('Ext.layout.container.boxOverflow.' + handlerType, me, handler);
},
// Overridden method from Ext.layout.container.Container.
// Used in the beforeLayout method to render all items into.
getRenderTarget: function() {
return this.targetEl;
},
// Overridden method from Ext.layout.container.Container.
// Used by Container classes to insert special DOM elements which must exist in addition to the child components
getElementTarget: function() {
return this.innerCt;
},
//<debug>
calculateChildBox: Ext.deprecated(),
calculateChildBoxes: Ext.deprecated(),
updateChildBoxes: Ext.deprecated(),
//</debug>

destroy: function() {
Ext.destroy(this.innerCt, this.overflowHandler);
this.callParent(arguments);
},
getRenderData: function() {
var data = this.callParent();
data.targetElCls = this.targetElCls;
return data;
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/layout/container/HBox.js */
(function(Ext) {
Ext.define('Ext.layout.container.HBox', {

alias: ['layout.hbox'],
extend: 'Ext.layout.container.Box',
alternateClassName: 'Ext.layout.HBoxLayout',


align: 'top', // top, middle, stretch, strechmax



constrainAlign: false,
type : 'hbox',
direction: 'horizontal',
horizontal: true,
names: {
// parallel
beforeX: 'left',
beforeScrollX: 'left',
beforeScrollerSuffix: '-before-scroller',
afterScrollerSuffix: '-after-scroller',
leftCap: 'Left',
afterX: 'right',
width: 'width',
contentWidth: 'contentWidth',
minWidth: 'minWidth',
maxWidth: 'maxWidth',
widthCap: 'Width',
widthModel: 'widthModel',
widthIndex: 0,
x: 'x',
scrollLeft: 'scrollLeft',
overflowX: 'overflowX',
hasOverflowX: 'hasOverflowX',
invalidateScrollX: 'invalidateScrollX',
parallelMargins: 'lr',
// perpendicular
center: 'middle',
beforeY: 'top',
afterY: 'bottom',
height: 'height',
contentHeight: 'contentHeight',
minHeight: 'minHeight',
maxHeight: 'maxHeight',
heightCap: 'Height',
heightModel: 'heightModel',
heightIndex: 1,
y: 'y',
overflowY: 'overflowY',
hasOverflowY: 'hasOverflowY',
invalidateScrollY: 'invalidateScrollY',
perpendicularMargins: 'tb',
// Methods
getWidth: 'getWidth',
getHeight: 'getHeight',
setWidth: 'setWidth',
setHeight: 'setHeight',
gotWidth: 'gotWidth',
gotHeight: 'gotHeight',
setContentWidth: 'setContentWidth',
setContentHeight: 'setContentHeight',
setWidthInDom: 'setWidthInDom',
setHeightInDom: 'setHeightInDom',
getScrollLeft: 'getScrollLeft',
setScrollLeft: 'setScrollLeft',
scrollTo: 'scrollTo'
},
sizePolicy: {
flex: {
'': {
readsWidth : 0,
readsHeight: 1,
setsWidth : 1,
setsHeight : 0
},
stretch: {
readsWidth : 0,
readsHeight: 0,
setsWidth : 1,
setsHeight : 1
},
stretchmax: {
readsWidth : 0,
readsHeight: 1,
setsWidth : 1,
setsHeight : 1
}
},
'': {
readsWidth : 1,
readsHeight: 1,
setsWidth : 0,
setsHeight : 0
},
stretch: {
readsWidth : 1,
readsHeight: 0,
setsWidth : 0,
setsHeight : 1
},
stretchmax: {
readsWidth : 1,
readsHeight: 1,
setsWidth : 0,
setsHeight : 1
}
} 
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/toolbar/Toolbar.js */
(function(Ext) {
Ext.define('Ext.toolbar.Toolbar', {
extend: 'Ext.container.Container',
requires: [
'Ext.toolbar.Fill',
'Ext.layout.container.HBox',
'Ext.layout.container.VBox'
],
uses: [
'Ext.toolbar.Separator'
],
alias: 'widget.toolbar',
alternateClassName: 'Ext.Toolbar',

isToolbar: true,
baseCls : Ext.baseCSSPrefix + 'toolbar',
ariaRole : 'toolbar',
defaultType: 'button',

vertical: false,


enableOverflow: false,

menuTriggerCls: Ext.baseCSSPrefix + 'toolbar-more-icon',


// @private
trackMenus: true,
itemCls: Ext.baseCSSPrefix + 'toolbar-item',
statics: {
shortcuts: {
'-' : 'tbseparator',
' ' : 'tbspacer'
},
shortcutsHV: {
// horizontal
0: {
'->': { xtype: 'tbfill', height: 0 }
},
// vertical
1: {
'->': { xtype: 'tbfill', width: 0 }
}
}
},
initComponent: function() {
var me = this;
// check for simplified (old-style) overflow config:
if (!me.layout && me.enableOverflow) {
me.layout = { overflowHandler: 'Menu' };
}
if (me.dock === 'right' || me.dock === 'left') {
me.vertical = true;
}
me.layout = Ext.applyIf(Ext.isString(me.layout) ? {
type: me.layout
} : me.layout || {}, {
type: me.vertical ? 'vbox' : 'hbox',
align: me.vertical ? 'stretchmax' : 'middle'
});
if (me.vertical) {
me.addClsWithUI('vertical');
}
// @TODO: remove this hack and implement a more general solution
if (me.ui === 'footer') {
me.ignoreBorderManagement = true;
}
me.callParent();

me.addEvents('overflowchange');
},
getRefItems: function(deep) {
var me = this,
items = me.callParent(arguments),
layout = me.layout,
handler;
if (deep && me.enableOverflow) {
handler = layout.overflowHandler;
if (handler && handler.menu) {
items = items.concat(handler.menu.getRefItems(deep));
}
}
return items;
},



// @private
lookupComponent: function(c) {
var args = arguments;
if (typeof c == 'string') {
var T = Ext.toolbar.Toolbar,
shortcut = T.shortcutsHV[this.vertical ? 1 : 0][c] || T.shortcuts[c];
if (typeof shortcut == 'string') {
c = {
xtype: shortcut
};
} else if (shortcut) {
c = Ext.apply({}, shortcut);
} else {
c = {
xtype: 'tbtext',
text: c
};
}
this.applyDefaults(c);

// See: EXTJSIV-7578
args = [c];
}
return this.callParent(args);
},
// @private
applyDefaults: function(c) {
if (!Ext.isString(c)) {
c = this.callParent(arguments);
}
return c;
},
// @private
trackMenu: function(item, remove) {
if (this.trackMenus && item.menu) {
var method = remove ? 'mun' : 'mon',
me = this;
me[method](item, 'mouseover', me.onButtonOver, me);
me[method](item, 'menushow', me.onButtonMenuShow, me);
me[method](item, 'menuhide', me.onButtonMenuHide, me);
}
},
// @private
onBeforeAdd: function(component) {
var me = this,
isButton = component.isButton;
if (isButton && me.defaultButtonUI && component.ui === 'default' &&
!component.hasOwnProperty('ui')) {
component.ui = me.defaultButtonUI;
} else if ((isButton || component.isFormField) && me.ui !== 'footer') {
component.ui = component.ui + '-toolbar';
component.addCls(component.baseCls + '-toolbar');
}
// Any separators needs to know if is vertical or not
if (component instanceof Ext.toolbar.Separator) {
component.setUI((me.vertical) ? 'vertical' : 'horizontal');
}
me.callParent(arguments);
},
// @private
onAdd: function(component) {
this.callParent(arguments);
this.trackMenu(component);
},

// @private
onRemove: function(c) {
this.callParent(arguments);
this.trackMenu(c, true);
},

getChildItemsToDisable: function() {
return this.items.getRange(); 
},
// @private
onButtonOver: function(btn){
if (this.activeMenuBtn && this.activeMenuBtn != btn) {
this.activeMenuBtn.hideMenu();
btn.showMenu();
this.activeMenuBtn = btn;
}
},
// @private
onButtonMenuShow: function(btn) {
this.activeMenuBtn = btn;
},
// @private
onButtonMenuHide: function(btn) {
delete this.activeMenuBtn;
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/panel/AbstractPanel.js */
(function(Ext) {
Ext.define('Ext.panel.AbstractPanel', {

extend: 'Ext.container.Container',
mixins: {
docking: 'Ext.container.DockingContainer'
},
requires: ['Ext.util.MixedCollection', 'Ext.Element', 'Ext.toolbar.Toolbar'],


baseCls : Ext.baseCSSPrefix + 'panel',





isPanel: true,



contentPaddingProperty: 'bodyPadding',


shrinkWrapDock: false,
componentLayout: 'dock',
childEls: [
'body'
],
renderTpl: [
// If this Panel is framed, the framing template renders the docked items round the frame
'{% this.renderDockedItems(out,values,0); %}',
// This empty div solves an IE6/7/Quirks problem where the margin-top on the bodyEl
// is ignored. Best we can figure, this is triggered by the previousSibling being
// position absolute (a docked item). The goal is to use margins to position the
// bodyEl rather than left/top since that allows us to avoid writing a height on the
// panel and the body. This in turn allows CSS height to expand or contract the
// panel during things like portlet dragging where we want to avoid running a ton
// of layouts during the drag operation.
// This empty div also has to be relatively positioned, otherwise it crashes IE6-9 Quirks
// when panel is rendered in a table-based layout.
(Ext.isIE7m || Ext.isIEQuirks) ? '<div style="position:relative"></div>' : '',
'<div id="{id}-body" class="{baseCls}-body<tpl if="bodyCls"> {bodyCls}</tpl>',
' {baseCls}-body-{ui}<tpl if="uiCls">',
'<tpl for="uiCls"> {parent.baseCls}-body-{parent.ui}-{.}</tpl>',
'</tpl>{childElCls}"',
'<tpl if="bodyStyle"> style="{bodyStyle}"</tpl>>',
'{%this.renderContainer(out,values);%}',
'</div>',
'{% this.renderDockedItems(out,values,1); %}'
],
bodyPosProps: {
x: 'x',
y: 'y'
},
// TODO: Move code examples into product-specific files. The code snippet below is Touch only.

// @since 2.3.0
border: true,

emptyArray: [],
initComponent : function() {
this.initBorderProps();
this.callParent();
},
initBorderProps: function() {
var me = this;
if (me.frame && me.border && me.bodyBorder === undefined) {
me.bodyBorder = false;
}
if (me.frame && me.border && (me.bodyBorder === false || me.bodyBorder === 0)) {
me.manageBodyBorders = true;
}
},
beforeDestroy: function(){
this.destroyDockedItems();
this.callParent();
},
// @private
initItems : function() {
this.callParent();
this.initDockingItems();
},

initRenderData: function() {
var me = this,
data = me.callParent();
me.initBodyStyles();
me.protoBody.writeTo(data);
delete me.protoBody;
return data;
},

getComponent: function(comp) {
var component = this.callParent(arguments);
if (component === undefined && !Ext.isNumber(comp)) {
// If the arg is a numeric index skip docked items
component = this.getDockedComponent(comp);
}
return component;
},
getProtoBody: function () {
var me = this,
body = me.protoBody;
if (!body) {
me.protoBody = body = new Ext.util.ProtoElement({
cls: me.bodyCls,
style: me.bodyStyle,
clsProp: 'bodyCls',
styleProp: 'bodyStyle',
styleIsText: true
});
}
return body;
},

initBodyStyles: function() {
var me = this,
body = me.getProtoBody();
if (me.bodyPadding !== undefined) {
if (me.layout.managePadding) {
// If the container layout manages padding, the layout will apply the 
// padding to an inner element rather than the body element. The
// assumed intent is for the configured padding to override any padding
// that is applied to the body element via stylesheet rules. It is
// therefore necessary to set the body element's padding to "0".
body.setStyle('padding', 0);
} else {
body.setStyle('padding', this.unitizeBox((me.bodyPadding === true) ? 5 : me.bodyPadding));
}
}
me.initBodyBorder();
},
initBodyBorder: function() {
var me = this;
if (me.frame && me.bodyBorder) {
if (!Ext.isNumber(me.bodyBorder)) {
me.bodyBorder = 1;
}
me.getProtoBody().setStyle('border-width', this.unitizeBox(me.bodyBorder));
}
},
getCollapsedDockedItems: function () {
var me = this;
return me.header === false || me.collapseMode == 'placeholder' ? me.emptyArray : [ me.getReExpander() ];
},

setBodyStyle: function(style, value) {
var me = this,
body = me.rendered ? me.body : me.getProtoBody();
if (Ext.isFunction(style)) {
style = style();
}
if (arguments.length == 1) {
if (Ext.isString(style)) {
style = Ext.Element.parseStyles(style); 
}
body.setStyle(style);
} else {
body.setStyle(style, value);
}
return me;
},

addBodyCls: function(cls) {
var me = this,
body = me.rendered ? me.body : me.getProtoBody();
body.addCls(cls);
return me;
},

removeBodyCls: function(cls) {
var me = this,
body = me.rendered ? me.body : me.getProtoBody();
body.removeCls(cls);
return me;
},
// inherit docs
addUIClsToElement: function(cls) {
var me = this,
result = me.callParent(arguments);
me.addBodyCls([Ext.baseCSSPrefix + cls, me.baseCls + '-body-' + cls, me.baseCls + '-body-' + me.ui + '-' + cls]);
return result;
},
// inherit docs
removeUIClsFromElement: function(cls) {
var me = this,
result = me.callParent(arguments);
me.removeBodyCls([Ext.baseCSSPrefix + cls, me.baseCls + '-body-' + cls, me.baseCls + '-body-' + me.ui + '-' + cls]);
return result;
},
// inherit docs
addUIToElement: function() {
var me = this;
me.callParent(arguments);
me.addBodyCls(me.baseCls + '-body-' + me.ui);
},
// inherit docs
removeUIFromElement: function() {
var me = this;
me.callParent(arguments);
me.removeBodyCls(me.baseCls + '-body-' + me.ui);
},
// @private
getTargetEl : function() {
return this.body;
},
applyTargetCls: function(targetCls) {
this.getProtoBody().addCls(targetCls);
},
getRefItems: function(deep) {
var items = this.callParent(arguments);
return this.getDockingRefItems(deep, items);
},
setupRenderTpl: function (renderTpl) {
this.callParent(arguments);
this.setupDockingRenderTpl(renderTpl);
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/panel/Tool.js */
(function(Ext) {
Ext.define('Ext.panel.Tool', {
extend: 'Ext.Component',
requires: ['Ext.tip.QuickTipManager'],
alias: 'widget.tool',

isTool: true,
baseCls: Ext.baseCSSPrefix + 'tool',
disabledCls: Ext.baseCSSPrefix + 'tool-disabled',


toolPressedCls: Ext.baseCSSPrefix + 'tool-pressed',

toolOverCls: Ext.baseCSSPrefix + 'tool-over',
ariaRole: 'button',
childEls: [
'toolEl'
],
renderTpl: [
'<img role="presentation" id="{id}-toolEl" src="{blank}" class="{baseCls}-img {baseCls}-{type}' +
'{childElCls}" role="presentation"/>'
],

toolOwner: null,






tooltipType: 'qtip',

stopEvent: true,
// Tool size is fixed so that Box layout can avoid measurements.
height: 15,
width: 15,
//<debug>
_toolTypes: {
close:1,
collapse:1,
down:1,
expand:1,
gear:1,
help:1,
left:1,
maximize:1,
minimize:1,
minus:1,
//move:1,
next:1,
pin:1,
plus:1,
prev:1,
print:1,
refresh:1,
//resize:1,
restore:1,
right:1,
save:1,
search:1,
toggle:1,
unpin:1,
up:1
},
//</debug>
initComponent: function() {
var me = this;
me.addEvents(

'click'
);
//<debug>
if (me.id && me._toolTypes[me.id] && Ext.global.console) {
Ext.global.console.warn('When specifying a tool you should use the type option, the id can conflict now that tool is a Component');
}
//</debug>
me.type = me.type || me.id;
Ext.applyIf(me.renderData, {
baseCls: me.baseCls,
blank: Ext.BLANK_IMAGE_URL,
type: me.type
});
// alias qtip, should use tooltip since it's what we have in the docs
me.tooltip = me.tooltip || me.qtip;
me.callParent();
},
// inherit docs
afterRender: function() {
var me = this,
attr;
me.callParent(arguments);
me.el.on({
click: me.onClick,
mousedown: me.onMouseDown,
mouseover: me.onMouseOver,
mouseout: me.onMouseOut,
scope: me
});
if (me.tooltip) {
if (Ext.quickTipsActive && Ext.isObject(me.tooltip)) {
Ext.tip.QuickTipManager.register(Ext.apply({
target: me.id
}, me.tooltip));
}
else {
attr = me.tooltipType == 'qtip' ? 'data-qtip' : 'title';
me.el.dom.setAttribute(attr, me.tooltip);
}
}
},
getFocusEl: function() {
return this.el;
},

setType: function(type) {
var me = this,
oldType = me.type;
me.type = type;
if (me.rendered) {
if (oldType) {
me.toolEl.removeCls(me.baseCls + '-' + oldType);
}
me.toolEl.addCls(me.baseCls + '-' + type);
} else {
me.renderData.type = type;
}
return me;
},

onClick: function(e, target) {
var me = this;
if (me.disabled) {
return false;
}
//remove the pressed + over class
me.el.removeCls(me.toolPressedCls);
me.el.removeCls(me.toolOverCls);
if (me.stopEvent !== false) {
e.stopEvent();
}
if (me.handler) {
Ext.callback(me.handler, me.scope || me, [e, target, me.ownerCt, me]);
} else if (me.callback) {
Ext.callback(me.callback, me.scope || me, [me.toolOwner || me.ownerCt, me, e]);
}
me.fireEvent('click', me, e);
return true;
},
// inherit docs
onDestroy: function(){
if (Ext.quickTipsActive && Ext.isObject(this.tooltip)) {
Ext.tip.QuickTipManager.unregister(this.id);
}
this.callParent();
},

onMouseDown: function() {
if (this.disabled) {
return false;
}
this.el.addCls(this.toolPressedCls);
},

onMouseOver: function() {
if (this.disabled) {
return false;
}
this.el.addCls(this.toolOverCls);
},

onMouseOut: function() {
this.el.removeCls(this.toolOverCls);
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/util/CSS.js */
(function(Ext) {
Ext.define('Ext.util.CSS', function() {
var CSS,
rules = null,
doc = document,
camelRe = /(-[a-z])/gi,
camelFn = function(m, a){ return a.charAt(1).toUpperCase(); };
return {
singleton: true,
rules: rules,
initialized: false,
constructor: function() {
// Cache a reference to the singleton
CSS = this;
},

createStyleSheet : function(cssText, id) {
var ss,
head = doc.getElementsByTagName("head")[0],
styleEl = doc.createElement("style");
styleEl.setAttribute("type", "text/css");
if (id) {
styleEl.setAttribute("id", id);
}
if (Ext.isIE) {
head.appendChild(styleEl);
ss = styleEl.styleSheet;
ss.cssText = cssText;
} else {
try{
styleEl.appendChild(doc.createTextNode(cssText));
} catch(e) {
styleEl.cssText = cssText;
}
head.appendChild(styleEl);
ss = styleEl.styleSheet ? styleEl.styleSheet : (styleEl.sheet || doc.styleSheets[doc.styleSheets.length-1]);
}
CSS.cacheStyleSheet(ss);
return ss;
},

removeStyleSheet : function(id) {
var existing = doc.getElementById(id);
if (existing) {
existing.parentNode.removeChild(existing);
}
},

swapStyleSheet : function(id, url) {
var ss;
CSS.removeStyleSheet(id);
ss = doc.createElement("link");
ss.setAttribute("rel", "stylesheet");
ss.setAttribute("type", "text/css");
ss.setAttribute("id", id);
ss.setAttribute("href", url);
doc.getElementsByTagName("head")[0].appendChild(ss);
},

refreshCache : function() {
return CSS.getRules(true);
},
// @private
cacheStyleSheet : function(ss) {
if (!rules) {
rules = CSS.rules = {};
}
try {// try catch for cross domain access issue
var ssRules = ss.cssRules || ss.rules,
i = ssRules.length - 1,
imports = ss.imports,
len = imports ? imports.length : 0,
rule, j;

// Old IE has a different way of handling imports
for (j = 0; j < len; ++j) {
CSS.cacheStyleSheet(imports[j]);
}
for (; i >= 0; --i) {
rule = ssRules[i];
// If it's an @import rule, import its stylesheet
if (rule.styleSheet) {
CSS.cacheStyleSheet(rule.styleSheet);
}
CSS.cacheRule(rule, ss);
}
} catch(e) {}
},
cacheRule: function(cssRule, styleSheet) {
// If it's an @import rule, import its stylesheet
if (cssRule.styleSheet) {
return CSS.cacheStyleSheet(cssRule.styleSheet);
}
var selectorText = cssRule.selectorText,
selectorCount, j;
if (selectorText) {
// Split in case there are multiple, comma-delimited selectors
selectorText = selectorText.split(',');
selectorCount = selectorText.length;
for (j = 0; j < selectorCount; j++) {
// IE<8 does not keep a reference to parentStyleSheet in the rule, so we
// must cache an object like this until IE<8 is deprecated.
rules[Ext.String.trim(selectorText[j]).toLowerCase()] = {
parentStyleSheet: styleSheet,
cssRule: cssRule
};
};
}
},

getRules : function(refreshCache) {
var result = {},
selector;
if (rules === null || refreshCache) {
CSS.refreshCache();
}
for (selector in rules) {
result[selector] = rules[selector].cssRule;
}
return result;
},

refreshCache: function() {
var ds = doc.styleSheets,
i = 0,
len = ds.length;
rules = CSS.rules = {}
for (; i < len; i++) {
try {
if (!ds[i].disabled) {
CSS.cacheStyleSheet(ds[i]);
}
} catch(e) {}
}
},

getRule: function(selector, refreshCache, rawCache) {
var i, result;
if (!rules || refreshCache) {
CSS.refreshCache();
}
if (!Ext.isArray(selector)) {
result = rules[selector.toLowerCase()]
if (result && !rawCache) {
result = result.cssRule;
}
return result || null;
}
for (i = 0; i < selector.length; i++) {
if (rules[selector[i]]) {
return rawCache ? rules[selector[i].toLowerCase()] : rules[selector[i].toLowerCase()].cssRule;
}
}
return null;
},

createRule: function(styleSheet, selector, cssText) {
var result,
ruleSet = styleSheet.cssRules || styleSheet.rules,
index = ruleSet.length;
if (styleSheet.insertRule) {
styleSheet.insertRule(selector + '{' + cssText + '}', index);
} else {
styleSheet.addRule(selector, cssText||' ');
}
CSS.cacheRule(result = ruleSet[index], styleSheet);
return result;
},

updateRule : function(selector, property, value) {
var rule, i, styles;
if (!Ext.isArray(selector)) {
rule = CSS.getRule(selector);
if (rule) {
// 2 arg form means cssText sent, so parse it and update each style
if (arguments.length == 2) {
styles = Ext.Element.parseStyles(property);
for (property in styles) {
rule.style[property.replace(camelRe, camelFn)] = styles[property];
}
} else {
rule.style[property.replace(camelRe, camelFn)] = value;
}
return true;
}
} else {
for (i = 0; i < selector.length; i++) {
if (CSS.updateRule(selector[i], property, value)) {
return true;
}
}
}
return false;
},
deleteRule: function(selector) {
var rule = CSS.getRule(selector, false, true),
styleSheet, index;
if (rule) {
styleSheet = rule.parentStyleSheet;
index = Ext.Array.indexOf(styleSheet.cssRules || styleSheet.rules, rule.cssRule);
if (styleSheet.deleteRule) {
styleSheet.deleteRule(index);
} else {
styleSheet.removeRule(index);
}
delete rules[selector];
}
}
};
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/layout/component/Body.js */
(function(Ext) {
Ext.define('Ext.layout.component.Body', {

alias: ['layout.body'],
extend: 'Ext.layout.component.Auto',

type: 'body',
beginLayout: function (ownerContext) {
this.callParent(arguments);
ownerContext.bodyContext = ownerContext.getEl('body');
},
beginLayoutCycle: function(ownerContext, firstCycle){
var me = this,
lastWidthModel = me.lastWidthModel,
lastHeightModel = me.lastHeightModel,
body = me.owner.body;
me.callParent(arguments);
if (lastWidthModel && lastWidthModel.fixed && ownerContext.widthModel.shrinkWrap) {
body.setWidth(null);
}
if (lastHeightModel && lastHeightModel.fixed && ownerContext.heightModel.shrinkWrap) {
body.setHeight(null);
}
},
// Padding is exciting here because we have 2 el's: owner.el and owner.body. Content
// size always includes the padding of the targetEl, which should be owner.body. But
// it is common to have padding on owner.el also (such as a panel header), so we need
// to do some more padding work if targetContext is not owner.el. The base class has
// already handled the ownerContext's frameInfo (border+framing) so all that is left
// is padding.
calculateOwnerHeightFromContentHeight: function (ownerContext, contentHeight) {
var height = this.callParent(arguments);
if (ownerContext.targetContext != ownerContext) {
height += ownerContext.getPaddingInfo().height;
}
return height;
},
calculateOwnerWidthFromContentWidth: function (ownerContext, contentWidth) {
var width = this.callParent(arguments);
if (ownerContext.targetContext != ownerContext) {
width += ownerContext.getPaddingInfo().width;
}
return width;
},
measureContentWidth: function (ownerContext) {
return ownerContext.bodyContext.setWidth(ownerContext.bodyContext.el.dom.offsetWidth, false);
},
measureContentHeight: function (ownerContext) {
return ownerContext.bodyContext.setHeight(ownerContext.bodyContext.el.dom.offsetHeight, false);
},
publishInnerHeight: function (ownerContext, height) {
var innerHeight = height - ownerContext.getFrameInfo().height,
targetContext = ownerContext.targetContext;
if (targetContext != ownerContext) {
innerHeight -= ownerContext.getPaddingInfo().height;
}
// return the value here, it may get used in a subclass
return ownerContext.bodyContext.setHeight(innerHeight, !ownerContext.heightModel.natural);
},
publishInnerWidth: function (ownerContext, width) {
var innerWidth = width - ownerContext.getFrameInfo().width,
targetContext = ownerContext.targetContext;
if (targetContext != ownerContext) {
innerWidth -= ownerContext.getPaddingInfo().width;
}
ownerContext.bodyContext.setWidth(innerWidth, !ownerContext.widthModel.natural);
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/Img.js */
(function(Ext) {
Ext.define('Ext.Img', {
extend: 'Ext.Component',
alias: ['widget.image', 'widget.imagecomponent'],
autoEl: 'img',
baseCls: Ext.baseCSSPrefix + 'img',

src: '',

alt: '',

title: '',

imgCls: '',

initComponent: function() {
if (this.glyph) {
this.autoEl = 'div';
}
this.callParent();
},
getElConfig: function() {
var me = this,
config = me.callParent(),
glyphFontFamily = Ext._glyphFontFamily,
glyph = me.glyph,
img, glyphParts;
// It is sometimes helpful (like in a panel header icon) to have the img wrapped
// by a div. If our autoEl is not 'img' then we just add an img child to the el.
if (me.autoEl == 'img') {
img = config;
} else if (me.glyph) {
if (typeof glyph === 'string') {
glyphParts = glyph.split('@');
glyph = glyphParts[0];
glyphFontFamily = glyphParts[1];
}
config.html = '&#' + glyph + ';';
if (glyphFontFamily) {
config.style = 'font-family:' + glyphFontFamily;
}
} else {
config.cn = [img = {
tag: 'img',
id: me.id + '-img'
}];
}
if (img) {
if (me.imgCls) {
img.cls = (img.cls ? img.cls + ' ' : '') + me.imgCls;
}
img.src = me.src || Ext.BLANK_IMAGE_URL;
}
if (me.alt) {
(img || config).alt = me.alt;
}
if (me.title) {
(img || config).title = me.title;
}
return config;
},
onRender: function () {
var me = this,
el;
me.callParent(arguments);
el = me.el;
me.imgEl = (me.autoEl == 'img') ? el : el.getById(me.id + '-img');
},
onDestroy: function () {
Ext.destroy(this.imgEl);
this.imgEl = null;
this.callParent();
},

setSrc: function(src) {
var me = this,
imgEl = me.imgEl;
me.src = src;
if (imgEl) {
imgEl.dom.src = src || Ext.BLANK_IMAGE_URL;
}
},
setGlyph: function(glyph) {
var me = this,
glyphFontFamily = Ext._glyphFontFamily,
glyphParts, dom;
if (glyph != me.glyph) {
if (typeof glyph === 'string') {
glyphParts = glyph.split('@');
glyph = glyphParts[0];
glyphFontFamily = glyphParts[1];
}
dom = me.el.dom;
dom.innerHTML = '&#' + glyph + ';';
if (glyphFontFamily) {
dom.style = 'font-family:' + glyphFontFamily;
}
}
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/panel/Header.js */
(function(Ext) {
Ext.define('Ext.panel.Header', {
extend: 'Ext.container.Container',
uses: ['Ext.panel.Tool', 'Ext.util.CSS', 'Ext.layout.component.Body', 'Ext.Img'],
alias: 'widget.header',

isHeader : true,
defaultType : 'tool',
indicateDrag : false,
weight : -1,
componentLayout: 'body',

childEls: [
'body'
],
renderTpl: [
'<div id="{id}-body" class="{headerCls}-body {baseCls}-body {bodyCls} {bodyTargetCls}',
'<tpl for="uiCls"> {parent.baseCls}-body-{parent.ui}-{.}</tpl>"',
'<tpl if="bodyStyle"> style="{bodyStyle}"</tpl>>',
'{%this.renderContainer(out,values)%}',
'</div>'
],
headingTpl: [
// unselectable="on" is required for Opera, other browsers inherit unselectability from the header
'<span id="{id}-textEl" class="{headerCls}-text {cls}-text {cls}-text-{ui}" unselectable="on">{title}</span>'
],
shrinkWrap: 3,


titlePosition: 0,



// a class for styling that is shared between panel and window headers
headerCls: Ext.baseCSSPrefix + 'header',
initComponent: function() {
var me = this,
hasPosition = me.hasOwnProperty('titlePosition'),
items = me.items,
titlePosition = hasPosition ? me.titlePosition : (items ? items.length : 0),
uiClasses = [me.orientation, me.getDockName()],
ownerCt = me.ownerCt;
me.addEvents(

'click',

'dblclick'
);
me.indicateDragCls = me.headerCls + '-draggable';
me.title = me.title || '&#160;';
me.tools = me.tools || [];
items = me.items = (items ? Ext.Array.slice(items) : []);
me.orientation = me.orientation || 'horizontal';
me.dock = (me.dock) ? me.dock : (me.orientation == 'horizontal') ? 'top' : 'left';
if (ownerCt ? (!ownerCt.border && !ownerCt.frame) : !me.border) {
uiClasses.push(me.orientation + '-noborder');
}
me.addClsWithUI(uiClasses);
me.addCls([me.headerCls, me.headerCls + '-' + me.orientation]);
if (me.indicateDrag) {
me.addCls(me.indicateDragCls);
}
// Add Icon
if (me.iconCls || me.icon || me.glyph) {
me.initIconCmp();
// If we didn't provide a position or items, the icon should
// appear before the title
if (!hasPosition && !items.length) {
++titlePosition;
}
items.push(me.iconCmp);
}
// Add Title
me.titleCmp = new Ext.Component({
ariaRole : 'heading',
focusable : false,
noWrap : true,
flex : 1,
rtl : me.rtl,
id : me.id + '_hd',
style : me.titleAlign ? ('text-align:' + me.titleAlign) : '',
cls : me.headerCls + '-text-container ' +
me.baseCls + '-text-container ' +
me.baseCls + '-text-container-' + me.ui,
renderTpl : me.getTpl('headingTpl'),
renderData: {
title: me.title,
cls : me.baseCls,
headerCls: me.headerCls,
ui : me.ui
},
childEls : ['textEl'],
autoEl: {
// Required for Opera
unselectable: 'on'
},
listeners: {
render: me.onTitleRender,
scope: me
}
});
me.layout = (me.orientation == 'vertical') ? {
type : 'vbox',
align: 'center',
alignRoundingMethod: 'ceil'
} : {
type : 'hbox',
align: 'middle',
alignRoundingMethod: 'floor'
};
// Add Tools
Ext.Array.push(items, me.tools);
// Clear the tools so we can have only the instances. Intentional mutation of passed in array
// Owning code in Panel uses this array as its pubic tools property.
me.tools.length = 0;
me.callParent();
if (items.length < titlePosition) {
titlePosition = items.length;
}
me.titlePosition = titlePosition;
// Insert the titleComponent at the specified position
me.insert(titlePosition, me.titleCmp);
me.on({
dblclick: me.onDblClick,
click: me.onClick,
element: 'el',
scope: me
});
},
initIconCmp: function() {
var me = this,
cls = [me.headerCls + '-icon', me.baseCls + '-icon', me.iconCls],
cfg;

if (me.glyph) {
cls.push(me.baseCls + '-glyph');
}
cfg = {
focusable: false,
src: Ext.BLANK_IMAGE_URL,
cls: cls,
baseCls: me.baseCls + '-icon',
id: me.id + '-iconEl',
iconCls: me.iconCls,
glyph: me.glyph
};
if (!Ext.isEmpty(me.icon)) {
delete cfg.iconCls;
cfg.src = me.icon;
}
me.iconCmp = new Ext.Img(cfg);
},
beforeRender: function() {
this.protoEl.unselectable();
this.callParent();
},
afterLayout: function() {
var me = this,
frameBR, frameTR, frameTL, xPos;
if (me.orientation === 'vertical') {
me.adjustTitlePosition();
frameTR = me.frameTR;
if (frameTR) {
// The corners sprite currently requires knowledge of the vertical header's
// width to correctly set the background position of the bottom right corner.
// TODO: rearrange the sprite so that this can be done with pure css.
frameBR = me.frameBR;
frameTL = me.frameTL;
xPos = (me.getWidth() - frameTR.getPadding('r') -
((frameTL) ? frameTL.getPadding('l') : me.el.getBorderWidth('l'))) + 'px';
frameBR.setStyle('background-position-x', xPos);
frameTR.setStyle('background-position-x', xPos);
}
if (Ext.isIE7 && Ext.isStrict && me.frame) {
// EXTJSIV-7283: framed header background is initally off in IE7 strict
// unless we repaint
me.el.repaint();
}
}
},
beforeLayout: function () {
this.callParent();
this.syncBeforeAfterTitleClasses();
},
adjustTitlePosition: function() {
var titleCmp = this.titleCmp,
titleEl;
if (!Ext.isIE9m && titleCmp) { // some Headers don't have a titleCmp, e.g. TabBar
// In IE9 and below we use a BasicImage filter to rotate the title
// element 90 degrees. The result is that what was the bottom left
// corner is positioned exactly where the top left corner was
// originally. Since this is the desired result, no additional
// positioning is needed in IE9 and below. In modern browsers,
// however, we use transform: rotate(90deg) to rotate the element.
// CSS3 also provides a way to specify the position the rotated element
// by changing the axis on which it is rotated using the transform-origin
// property, but the required transform origin varies based on the
// elements size, and would require some complex math to calculate.
// To achieve the desired rotated position in modern browsers we use
// a transform-origin of "0, 0" which means the top left corner of
// the element is the rotation axis. After rotating 90 degrees we
// simply move the element to the right by the same number of pixels
// as its width.
titleEl = titleCmp.el;
titleEl.setStyle('left', titleEl.getWidth() + 'px');
}
},
onTitleRender: function() {
if (this.orientation === 'vertical') {
this.titleCmp.el.setVertical(90);
}
},
// inherit docs
addUIClsToElement: function(cls) {
var me = this,
result = me.callParent(arguments),
classes = [me.baseCls + '-body-' + cls, me.baseCls + '-body-' + me.ui + '-' + cls],
array, i;
if (me.bodyCls) {
array = me.bodyCls.split(' ');
for (i = 0; i < classes.length; i++) {
if (!Ext.Array.contains(array, classes[i])) {
array.push(classes[i]);
}
}
me.bodyCls = array.join(' ');
} else {
me.bodyCls = classes.join(' ');
}
return result;
},
// inherit docs
removeUIClsFromElement: function(cls) {
var me = this,
result = me.callParent(arguments),
classes = [me.baseCls + '-body-' + cls, me.baseCls + '-body-' + me.ui + '-' + cls],
array, i;
if (me.bodyCls) {
array = me.bodyCls.split(' ');
for (i = 0; i < classes.length; i++) {
Ext.Array.remove(array, classes[i]);
}
me.bodyCls = array.join(' ');
}
return result;
},
// inherit docs
addUIToElement: function() {
var me = this,
array, cls;
me.callParent(arguments);
cls = me.baseCls + '-body-' + me.ui;
if (me.rendered) {
if (me.bodyCls) {
me.body.addCls(me.bodyCls);
} else {
me.body.addCls(cls);
}
} else {
if (me.bodyCls) {
array = me.bodyCls.split(' ');
if (!Ext.Array.contains(array, cls)) {
array.push(cls);
}
me.bodyCls = array.join(' ');
} else {
me.bodyCls = cls;
}
}
if (me.titleCmp && me.titleCmp.rendered) {
me.titleCmp.addCls(me.baseCls + '-text-container-' + me.ui);
}
},
// inherit docs
removeUIFromElement: function() {
var me = this,
array, cls;
me.callParent(arguments);
cls = me.baseCls + '-body-' + me.ui;
if (me.rendered) {
if (me.bodyCls) {
me.body.removeCls(me.bodyCls);
} else {
me.body.removeCls(cls);
}
} else {
if (me.bodyCls) {
array = me.bodyCls.split(' ');
Ext.Array.remove(array, cls);
me.bodyCls = array.join(' ');
} else {
me.bodyCls = cls;
}
}
if (me.titleCmp && me.titleCmp.rendered) {
me.titleCmp.removeCls(me.baseCls + '-text-container-' + me.ui);
}
},
onClick: function(e) {
this.fireClickEvent('click', e);
},
onDblClick: function(e){
this.fireClickEvent('dblclick', e);
},
fireClickEvent: function(type, e){
var toolCls = '.' + Ext.panel.Tool.prototype.baseCls;
if (!e.getTarget(toolCls)) {
this.fireEvent(type, this, e);
}
},
getFocusEl: function() {
return this.el;
},
getTargetEl: function() {
return this.body || this.frameBody || this.el;
},
applyTargetCls: function(targetCls) {
this.bodyTargetCls = targetCls;
},

setTitle: function(title) {
var me = this,
titleCmp = me.titleCmp;
me.title = title;
if (titleCmp.rendered) {
titleCmp.textEl.update(me.title || '&#160;');
titleCmp.updateLayout();
} else {
me.titleCmp.on({
render: function() {
me.setTitle(title);
},
single: true
});
}
},

getMinWidth: function() {
var me = this,
textEl = me.titleCmp.textEl.dom,
result,
tools = me.tools,
l, i;
// Measure text width as inline element so it doesn't stretch
textEl.style.display = 'inline';
result = textEl.offsetWidth;
textEl.style.display = '';
// Add tools width
if (tools && (l = tools.length)) {
for (i = 0; i < l; i++) {
if (tools[i].el) {
result += tools[i].el.dom.offsetWidth;
}
}
}
// Add iconWidth
if (me.iconCmp) {
result += me.iconCmp.el.dom.offsetWidth;
}
// Return with some space between title and tools/end of header.
return result + 10;
},

setIconCls: function(cls) {
var me = this,
isEmpty = !cls || !cls.length,
iconCmp = me.iconCmp;
me.iconCls = cls;
if (!me.iconCmp && !isEmpty) {
me.initIconCmp();
me.insert(0, me.iconCmp);
} else if (iconCmp) {
if (isEmpty) {
me.iconCmp.destroy();
delete me.iconCmp;
} else {
iconCmp.removeCls(iconCmp.iconCls);
iconCmp.addCls(cls);
iconCmp.iconCls = cls;
}
}
},

setIcon: function(icon) {
var me = this,
isEmpty = !icon || !icon.length,
iconCmp = me.iconCmp;
me.icon = icon;
if (!me.iconCmp && !isEmpty) {
me.initIconCmp();
me.insert(0, me.iconCmp);
} else if (iconCmp) {
if (isEmpty) {
me.iconCmp.destroy();
delete me.iconCmp;
} else {
iconCmp.setSrc(me.icon);
}
}
},

setGlyph: function(glyph) {
var me = this,
iconCmp = me.iconCmp;

if (!me.iconCmp) {
me.initIconCmp();
me.insert(0, me.iconCmp);
} else if (iconCmp) {
if (glyph) {
me.iconCmp.setGlyph(glyph);
} else {
me.iconCmp.destroy();
delete me.iconCmp;
}
}
},

getTools: function(){
return this.tools.slice();
},

addTool: function(tool) {
// Even though the defaultType is tool, it may be changed,
// so let's be safe and forcibly specify tool
this.add(Ext.ComponentManager.create(tool, 'tool'));
},
syncBeforeAfterTitleClasses: function() {
var me = this,
items = me.items,
childItems = items.items,
titlePosition = me.titlePosition,
itemCount = childItems.length,
itemGeneration = items.generation,
syncGen = me.syncBeforeAfterGen,
afterCls, beforeCls, i, item;
if (syncGen === itemGeneration) {
return;
}
me.syncBeforeAfterGen = itemGeneration;
for (i = 0; i < itemCount; ++i) {
item = childItems[i];
afterCls = item.afterTitleCls || (item.afterTitleCls = item.baseCls + '-after-title')
beforeCls = item.beforeTitleCls || (item.beforeTitleCls = item.baseCls + '-before-title')
if (!me.title || i < titlePosition) {
if (syncGen) {
item.removeCls(afterCls);
} // else first time we won't need to remove anything...
item.addCls(beforeCls);
} else if (i > titlePosition) {
if (syncGen) {
item.removeCls(beforeCls);
}
item.addCls(afterCls);
}
}
},

onAdd: function(component, index) {
var tools = this.tools;
this.callParent(arguments);
if (component.isTool) {
tools.push(component);
tools[component.type] = component;
}
},

initRenderData: function() {
return Ext.applyIf(this.callParent(), {
bodyCls: this.bodyCls,
bodyTargetCls: this.bodyTargetCls,
headerCls: this.headerCls
});
},
getDockName: function() {
return this.dock;
},

getFramingInfoCls: function(){
var me = this,
cls = me.callParent(),
owner = me.ownerCt;

if (!me.expanding && (owner && owner.collapsed) || me.isCollapsedExpander) {
cls += '-' + owner.collapsedCls; 
}
return cls + '-' + me.dock;
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/dd/DragDrop.js */
(function(Ext) {
Ext.define('Ext.dd.DragDrop', {
requires: ['Ext.dd.DragDropManager'],

constructor: function(id, sGroup, config) {
if(id) {
this.init(id, sGroup, config);
}
},


id: null,

config: null,

dragElId: null,

handleElId: null,

invalidHandleTypes: null,

invalidHandleIds: null,

invalidHandleClasses: null,

startPageX: 0,

startPageY: 0,

groups: null,

locked: false,

lock: function() {
this.locked = true;
},

moveOnly: false,

unlock: function() {
this.locked = false;
},

isTarget: true,

padding: null,

_domRef: null,

__ygDragDrop: true,

constrainX: false,

constrainY: false,

minX: 0,

maxX: 0,

minY: 0,

maxY: 0,

maintainOffset: false,

xTicks: null,

yTicks: null,

primaryButtonOnly: true,

available: false,

hasOuterHandles: false,

b4StartDrag: function(x, y) { },

startDrag: function(x, y) { },

b4Drag: function(e) { },

onDrag: function(e) { },

onDragEnter: function(e, id) { },

b4DragOver: function(e) { },

onDragOver: function(e, id) { },

b4DragOut: function(e) { },

onDragOut: function(e, id) { },

b4DragDrop: function(e) { },

onDragDrop: function(e, id) { },

onInvalidDrop: function(e) { },

b4EndDrag: function(e) { },

endDrag: function(e) { },

b4MouseDown: function(e) { },

onMouseDown: function(e) { },

onMouseUp: function(e) { },

onAvailable: function () {
},

defaultPadding: {
left: 0,
right: 0,
top: 0,
bottom: 0
},

constrainTo : function(constrainTo, pad, inContent){
if(Ext.isNumber(pad)){
pad = {left: pad, right:pad, top:pad, bottom:pad};
}
pad = pad || this.defaultPadding;
var b = Ext.get(this.getEl()).getBox(),
ce = Ext.get(constrainTo),
s = ce.getScroll(),
c,
cd = ce.dom,
xy,
topSpace,
leftSpace;
if(cd == document.body){
c = { x: s.left, y: s.top, width: Ext.Element.getViewWidth(), height: Ext.Element.getViewHeight()};
}else{
xy = ce.getXY();
c = {x : xy[0], y: xy[1], width: cd.clientWidth, height: cd.clientHeight};
}
topSpace = b.y - c.y;
leftSpace = b.x - c.x;
this.resetConstraints();
this.setXConstraint(leftSpace - (pad.left||0), // left
c.width - leftSpace - b.width - (pad.right||0), //right
this.xTickSize
);
this.setYConstraint(topSpace - (pad.top||0), //top
c.height - topSpace - b.height - (pad.bottom||0), //bottom
this.yTickSize
);
},

getEl: function() {
if (!this._domRef) {
this._domRef = Ext.getDom(this.id);
}
return this._domRef;
},

getDragEl: function() {
return Ext.getDom(this.dragElId);
},

init: function(id, sGroup, config) {
this.initTarget(id, sGroup, config);
Ext.EventManager.on(this.id, "mousedown", this.handleMouseDown, this);
// Ext.EventManager.on(this.id, "selectstart", Event.preventDefault);
},

initTarget: function(id, sGroup, config) {
// configuration attributes
this.config = config || {};
// create a local reference to the drag and drop manager
this.DDMInstance = Ext.dd.DragDropManager;
// initialize the groups array
this.groups = {};
// assume that we have an element reference instead of an id if the
// parameter is not a string
if (typeof id !== "string") {
id = Ext.id(id);
}
// set the id
this.id = id;
// add to an interaction group
this.addToGroup((sGroup) ? sGroup : "default");
// We don't want to register this as the handle with the manager
// so we just set the id rather than calling the setter.
this.handleElId = id;
// the linked element is the element that gets dragged by default
this.setDragElId(id);
// by default, clicked anchors will not start drag operations.
this.invalidHandleTypes = { A: "A" };
this.invalidHandleIds = {};
this.invalidHandleClasses = [];
this.applyConfig();
this.handleOnAvailable();
},

applyConfig: function() {
// configurable properties:
// padding, isTarget, maintainOffset, primaryButtonOnly
this.padding = this.config.padding || [0, 0, 0, 0];
this.isTarget = (this.config.isTarget !== false);
this.maintainOffset = (this.config.maintainOffset);
this.primaryButtonOnly = (this.config.primaryButtonOnly !== false);
},

handleOnAvailable: function() {
this.available = true;
this.resetConstraints();
this.onAvailable();
},

setPadding: function(iTop, iRight, iBot, iLeft) {
// this.padding = [iLeft, iRight, iTop, iBot];
if (!iRight && 0 !== iRight) {
this.padding = [iTop, iTop, iTop, iTop];
} else if (!iBot && 0 !== iBot) {
this.padding = [iTop, iRight, iTop, iRight];
} else {
this.padding = [iTop, iRight, iBot, iLeft];
}
},

setInitPosition: function(diffX, diffY) {
var el = this.getEl(),
dx, dy, p;
if (!this.DDMInstance.verifyEl(el)) {
return;
}
dx = diffX || 0;
dy = diffY || 0;
p = Ext.Element.getXY( el );
this.initPageX = p[0] - dx;
this.initPageY = p[1] - dy;
this.lastPageX = p[0];
this.lastPageY = p[1];
this.setStartPosition(p);
},

setStartPosition: function(pos) {
var p = pos || Ext.Element.getXY( this.getEl() );
this.deltaSetXY = null;
this.startPageX = p[0];
this.startPageY = p[1];
},

addToGroup: function(sGroup) {
this.groups[sGroup] = true;
this.DDMInstance.regDragDrop(this, sGroup);
},

removeFromGroup: function(sGroup) {
if (this.groups[sGroup]) {
delete this.groups[sGroup];
}
this.DDMInstance.removeDDFromGroup(this, sGroup);
},

setDragElId: function(id) {
this.dragElId = id;
},

setHandleElId: function(id) {
if (typeof id !== "string") {
id = Ext.id(id);
}
this.handleElId = id;
this.DDMInstance.regHandle(this.id, id);
},

setOuterHandleElId: function(id) {
if (typeof id !== "string") {
id = Ext.id(id);
}
Ext.EventManager.on(id, "mousedown", this.handleMouseDown, this);
this.setHandleElId(id);
this.hasOuterHandles = true;
},

unreg: function() {
Ext.EventManager.un(this.id, "mousedown", this.handleMouseDown, this);
this._domRef = null;
this.DDMInstance._remove(this);
},

destroy : function(){
this.unreg();
},

isLocked: function() {
return (this.DDMInstance.isLocked() || this.locked);
},

handleMouseDown: function(e, oDD){
var me = this;
if ((me.primaryButtonOnly && e.button != 0) || me.isLocked()) {
return;
}
me.DDMInstance.refreshCache(me.groups);
if (me.hasOuterHandles || me.DDMInstance.isOverTarget(e.getPoint(), me)) {
if (me.clickValidator(e)) {
// set the initial element position
me.setStartPosition();
me.b4MouseDown(e);
me.onMouseDown(e);
me.DDMInstance.handleMouseDown(e, me);
me.DDMInstance.stopEvent(e);
}
}
},
clickValidator: function(e) {
var target = e.getTarget();
return ( this.isValidHandleChild(target) &&
(this.id == this.handleElId ||
this.DDMInstance.handleWasClicked(target, this.id)) );
},

addInvalidHandleType: function(tagName) {
var type = tagName.toUpperCase();
this.invalidHandleTypes[type] = type;
},

addInvalidHandleId: function(id) {
if (typeof id !== "string") {
id = Ext.id(id);
}
this.invalidHandleIds[id] = id;
},

addInvalidHandleClass: function(cssClass) {
this.invalidHandleClasses.push(cssClass);
},

removeInvalidHandleType: function(tagName) {
var type = tagName.toUpperCase();
// this.invalidHandleTypes[type] = null;
delete this.invalidHandleTypes[type];
},

removeInvalidHandleId: function(id) {
if (typeof id !== "string") {
id = Ext.id(id);
}
delete this.invalidHandleIds[id];
},

removeInvalidHandleClass: function(cssClass) {
for (var i=0, len=this.invalidHandleClasses.length; i<len; ++i) {
if (this.invalidHandleClasses[i] == cssClass) {
delete this.invalidHandleClasses[i];
}
}
},

isValidHandleChild: function(node) {
var valid = true,
nodeName,
i, len;
// var n = (node.nodeName == "#text") ? node.parentNode : node;
try {
nodeName = node.nodeName.toUpperCase();
} catch(e) {
nodeName = node.nodeName;
}
valid = valid && !this.invalidHandleTypes[nodeName];
valid = valid && !this.invalidHandleIds[node.id];
for (i=0, len=this.invalidHandleClasses.length; valid && i<len; ++i) {
valid = !Ext.fly(node).hasCls(this.invalidHandleClasses[i]);
}
return valid;
},

setXTicks: function(iStartX, iTickSize) {
this.xTicks = [];
this.xTickSize = iTickSize;
var tickMap = {},
i;
for (i = this.initPageX; i >= this.minX; i = i - iTickSize) {
if (!tickMap[i]) {
this.xTicks[this.xTicks.length] = i;
tickMap[i] = true;
}
}
for (i = this.initPageX; i <= this.maxX; i = i + iTickSize) {
if (!tickMap[i]) {
this.xTicks[this.xTicks.length] = i;
tickMap[i] = true;
}
}
Ext.Array.sort(this.xTicks, this.DDMInstance.numericSort);
},

setYTicks: function(iStartY, iTickSize) {
this.yTicks = [];
this.yTickSize = iTickSize;
var tickMap = {},
i;
for (i = this.initPageY; i >= this.minY; i = i - iTickSize) {
if (!tickMap[i]) {
this.yTicks[this.yTicks.length] = i;
tickMap[i] = true;
}
}
for (i = this.initPageY; i <= this.maxY; i = i + iTickSize) {
if (!tickMap[i]) {
this.yTicks[this.yTicks.length] = i;
tickMap[i] = true;
}
}
Ext.Array.sort(this.yTicks, this.DDMInstance.numericSort);
},

setXConstraint: function(iLeft, iRight, iTickSize) {
this.leftConstraint = iLeft;
this.rightConstraint = iRight;
this.minX = this.initPageX - iLeft;
this.maxX = this.initPageX + iRight;
if (iTickSize) { this.setXTicks(this.initPageX, iTickSize); }
this.constrainX = true;
},

clearConstraints: function() {
this.constrainX = false;
this.constrainY = false;
this.clearTicks();
},

clearTicks: function() {
this.xTicks = null;
this.yTicks = null;
this.xTickSize = 0;
this.yTickSize = 0;
},

setYConstraint: function(iUp, iDown, iTickSize) {
this.topConstraint = iUp;
this.bottomConstraint = iDown;
this.minY = this.initPageY - iUp;
this.maxY = this.initPageY + iDown;
if (iTickSize) { this.setYTicks(this.initPageY, iTickSize); }
this.constrainY = true;
},

resetConstraints: function() {
// Maintain offsets if necessary
if (this.initPageX || this.initPageX === 0) {
// figure out how much this thing has moved
var dx = (this.maintainOffset) ? this.lastPageX - this.initPageX : 0,
dy = (this.maintainOffset) ? this.lastPageY - this.initPageY : 0;
this.setInitPosition(dx, dy);
// This is the first time we have detected the element's position
} else {
this.setInitPosition();
}
if (this.constrainX) {
this.setXConstraint( this.leftConstraint,
this.rightConstraint,
this.xTickSize );
}
if (this.constrainY) {
this.setYConstraint( this.topConstraint,
this.bottomConstraint,
this.yTickSize );
}
},

getTick: function(val, tickArray) {
if (!tickArray) {
// If tick interval is not defined, it is effectively 1 pixel,
// so we return the value passed to us.
return val;
} else if (tickArray[0] >= val) {
// The value is lower than the first tick, so we return the first
// tick.
return tickArray[0];
} else {
var i, len, next, diff1, diff2;
for (i=0, len=tickArray.length; i<len; ++i) {
next = i + 1;
if (tickArray[next] && tickArray[next] >= val) {
diff1 = val - tickArray[i];
diff2 = tickArray[next] - val;
return (diff2 > diff1) ? tickArray[i] : tickArray[next];
}
}
// The value is larger than the last tick, so we return the last
// tick.
return tickArray[tickArray.length - 1];
}
},

toString: function() {
return ("DragDrop " + this.id);
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/dd/DD.js */
(function(Ext) {
Ext.define('Ext.dd.DD', {
extend: 'Ext.dd.DragDrop',
requires: ['Ext.dd.DragDropManager'],

constructor: function(id, sGroup, config) {
if (id) {
this.init(id, sGroup, config);
}
},

scroll: true,

autoOffset: function(iPageX, iPageY) {
var x = iPageX - this.startPageX,
y = iPageY - this.startPageY;
this.setDelta(x, y);
},

setDelta: function(iDeltaX, iDeltaY) {
this.deltaX = iDeltaX;
this.deltaY = iDeltaY;
},

setDragElPos: function(iPageX, iPageY) {
// the first time we do this, we are going to check to make sure
// the element has css positioning
var el = this.getDragEl();
this.alignElWithMouse(el, iPageX, iPageY);
},

alignElWithMouse: function(el, iPageX, iPageY) {
var oCoord = this.getTargetCoord(iPageX, iPageY),
fly = el.dom ? el : Ext.fly(el, '_dd'),
elSize = fly.getSize(),
EL = Ext.Element,
vpSize,
aCoord,
newLeft,
newTop;
if (!this.deltaSetXY) {
vpSize = this.cachedViewportSize = { width: EL.getDocumentWidth(), height: EL.getDocumentHeight() };
aCoord = [
Math.max(0, Math.min(oCoord.x, vpSize.width - elSize.width)),
Math.max(0, Math.min(oCoord.y, vpSize.height - elSize.height))
];
fly.setXY(aCoord);
newLeft = this.getLocalX(fly);
newTop = fly.getLocalY();
this.deltaSetXY = [newLeft - oCoord.x, newTop - oCoord.y];
} else {
vpSize = this.cachedViewportSize;
this.setLocalXY(
fly,
Math.max(0, Math.min(oCoord.x + this.deltaSetXY[0], vpSize.width - elSize.width)),
Math.max(0, Math.min(oCoord.y + this.deltaSetXY[1], vpSize.height - elSize.height))
);
}
this.cachePosition(oCoord.x, oCoord.y);
this.autoScroll(oCoord.x, oCoord.y, el.offsetHeight, el.offsetWidth);
return oCoord;
},

cachePosition: function(iPageX, iPageY) {
if (iPageX) {
this.lastPageX = iPageX;
this.lastPageY = iPageY;
} else {
var aCoord = Ext.Element.getXY(this.getEl());
this.lastPageX = aCoord[0];
this.lastPageY = aCoord[1];
}
},

autoScroll: function(x, y, h, w) {
if (this.scroll) {
// The client height
var clientH = Ext.Element.getViewHeight(),
// The client width
clientW = Ext.Element.getViewWidth(),
// The amt scrolled down
st = this.DDMInstance.getScrollTop(),
// The amt scrolled right
sl = this.DDMInstance.getScrollLeft(),
// Location of the bottom of the element
bot = h + y,
// Location of the right of the element
right = w + x,
// The distance from the cursor to the bottom of the visible area,
// adjusted so that we don't scroll if the cursor is beyond the
// element drag constraints
toBot = (clientH + st - y - this.deltaY),
// The distance from the cursor to the right of the visible area
toRight = (clientW + sl - x - this.deltaX),
// How close to the edge the cursor must be before we scroll
// var thresh = (document.all) ? 100 : 40;
thresh = 40,
// How many pixels to scroll per autoscroll op. This helps to reduce
// clunky scrolling. IE is more sensitive about this ... it needs this
// value to be higher.
scrAmt = (document.all) ? 80 : 30;
// Scroll down if we are near the bottom of the visible page and the
// obj extends below the crease
if ( bot > clientH && toBot < thresh ) {
window.scrollTo(sl, st + scrAmt);
}
// Scroll up if the window is scrolled down and the top of the object
// goes above the top border
if ( y < st && st > 0 && y - st < thresh ) {
window.scrollTo(sl, st - scrAmt);
}
// Scroll right if the obj is beyond the right border and the cursor is
// near the border.
if ( right > clientW && toRight < thresh ) {
window.scrollTo(sl + scrAmt, st);
}
// Scroll left if the window has been scrolled to the right and the obj
// extends past the left border
if ( x < sl && sl > 0 && x - sl < thresh ) {
window.scrollTo(sl - scrAmt, st);
}
}
},

getTargetCoord: function(iPageX, iPageY) {
var x = iPageX - this.deltaX,
y = iPageY - this.deltaY;
if (this.constrainX) {
if (x < this.minX) {
x = this.minX;
}
if (x > this.maxX) {
x = this.maxX;
}
}
if (this.constrainY) {
if (y < this.minY) {
y = this.minY;
}
if (y > this.maxY) {
y = this.maxY;
}
}
x = this.getTick(x, this.xTicks);
y = this.getTick(y, this.yTicks);
return {x: x, y: y};
},

applyConfig: function() {
this.callParent();
this.scroll = (this.config.scroll !== false);
},

b4MouseDown: function(e) {
// this.resetConstraints();
this.autoOffset(e.getPageX(), e.getPageY());
},

b4Drag: function(e) {
this.setDragElPos(e.getPageX(), e.getPageY());
},
toString: function() {
return ("DD " + this.id);
},

getLocalX: function(el) {
return el.getLocalX();
},
setLocalXY: function(el, x, y) {
el.setLocalXY(x, y);
}
//////////////////////////////////////////////////////////////////////////
// Debugging ygDragDrop events that can be overridden
//////////////////////////////////////////////////////////////////////////

});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/dd/DDProxy.js */
(function(Ext) {
Ext.define('Ext.dd.DDProxy', {
extend: 'Ext.dd.DD',
statics: {

dragElId: "ygddfdiv"
},

constructor: function(id, sGroup, config) {
if (id) {
this.init(id, sGroup, config);
this.initFrame();
}
},

resizeFrame: true,

centerFrame: false,

createFrame: function() {
var self = this,
body = document.body,
div,
s;
if (!body || !body.firstChild) {
setTimeout( function() { self.createFrame(); }, 50 );
return;
}
div = this.getDragEl();
if (!div) {
div = document.createElement("div");
div.id = this.dragElId;
s = div.style;
s.position = "absolute";
s.visibility = "hidden";
s.cursor = "move";
s.border = "2px solid #aaa";
s.zIndex = 999;
// appendChild can blow up IE if invoked prior to the window load event
// while rendering a table. It is possible there are other scenarios
// that would cause this to happen as well.
body.insertBefore(div, body.firstChild);
}
},

initFrame: function() {
this.createFrame();
},
applyConfig: function() {
this.callParent();
this.resizeFrame = (this.config.resizeFrame !== false);
this.centerFrame = (this.config.centerFrame);
this.setDragElId(this.config.dragElId || Ext.dd.DDProxy.dragElId);
},

showFrame: function(iPageX, iPageY) {
var el = this.getEl(),
dragEl = this.getDragEl(),
s = dragEl.style;
this._resizeProxy();
if (this.centerFrame) {
this.setDelta( Math.round(parseInt(s.width, 10)/2),
Math.round(parseInt(s.height, 10)/2) );
}
this.setDragElPos(iPageX, iPageY);
Ext.fly(dragEl).show();
},

_resizeProxy: function() {
if (this.resizeFrame) {
var el = this.getEl();
Ext.fly(this.getDragEl()).setSize(el.offsetWidth, el.offsetHeight);
}
},
// overrides Ext.dd.DragDrop
b4MouseDown: function(e) {
var x = e.getPageX(),
y = e.getPageY();
this.autoOffset(x, y);
this.setDragElPos(x, y);
},
// overrides Ext.dd.DragDrop
b4StartDrag: function(x, y) {
// show the drag frame
this.showFrame(x, y);
},
// overrides Ext.dd.DragDrop
b4EndDrag: function(e) {
Ext.fly(this.getDragEl()).hide();
},
// overrides Ext.dd.DragDrop
// By default we try to move the element to the last location of the frame.
// This is so that the default behavior mirrors that of Ext.dd.DD.
endDrag: function(e) {
var lel = this.getEl(),
del = this.getDragEl();
// Show the drag frame briefly so we can get its position
del.style.visibility = "";
this.beforeMove();
// Hide the linked element before the move to get around a Safari
// rendering bug.
lel.style.visibility = "hidden";
Ext.dd.DDM.moveToEl(lel, del);
del.style.visibility = "hidden";
lel.style.visibility = "";
this.afterDrag();
},
beforeMove : function(){
},
afterDrag : function(){
},
toString: function() {
return ("DDProxy " + this.id);
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/dd/StatusProxy.js */
(function(Ext) {
Ext.define('Ext.dd.StatusProxy', {
extend: 'Ext.Component',
animRepair: false,
childEls: [
'ghost'
],
renderTpl: [
'<div class="' + Ext.baseCSSPrefix + 'dd-drop-icon"></div>' +
'<div id="{id}-ghost" class="' + Ext.baseCSSPrefix + 'dd-drag-ghost"></div>'
],

repairCls: Ext.baseCSSPrefix + 'dd-drag-repair',

constructor: function(config) {
var me = this;
config = config || {};
Ext.apply(me, {
hideMode: 'visibility',
hidden: true,
floating: true,
id: me.id || Ext.id(),
cls: Ext.baseCSSPrefix + 'dd-drag-proxy ' + this.dropNotAllowed,
shadow: config.shadow || false,
renderTo: Ext.getDetachedBody()
});
me.callParent(arguments);
this.dropStatus = this.dropNotAllowed;
},

dropAllowed : Ext.baseCSSPrefix + 'dd-drop-ok',

dropNotAllowed : Ext.baseCSSPrefix + 'dd-drop-nodrop',

setStatus : function(cssClass){
cssClass = cssClass || this.dropNotAllowed;
if (this.dropStatus != cssClass) {
this.el.replaceCls(this.dropStatus, cssClass);
this.dropStatus = cssClass;
}
},

reset : function(clearGhost){
var me = this,
clsPrefix = Ext.baseCSSPrefix + 'dd-drag-proxy ';
me.el.replaceCls(clsPrefix + me.dropAllowed, clsPrefix + me.dropNotAllowed);
me.dropStatus = me.dropNotAllowed;
if (clearGhost) {
me.ghost.update('');
}
},

update : function(html){
if (typeof html == "string") {
this.ghost.update(html);
} else {
this.ghost.update("");
html.style.margin = "0";
this.ghost.dom.appendChild(html);
}
var el = this.ghost.dom.firstChild;
if (el) {
Ext.fly(el).setStyle('float', 'none');
}
},

getGhost : function(){
return this.ghost;
},

hide : function(clear) {
this.callParent();
if (clear) {
this.reset(true);
}
},

stop : function(){
if (this.anim && this.anim.isAnimated && this.anim.isAnimated()) {
this.anim.stop();
}
},

sync : function(){
this.el.sync();
},

repair : function(xy, callback, scope) {
var me = this;
me.callback = callback;
me.scope = scope;
if (xy && me.animRepair !== false) {
me.el.addCls(me.repairCls);
me.el.hideUnders(true);
me.anim = me.el.animate({
duration: me.repairDuration || 500,
easing: 'ease-out',
to: {
x: xy[0],
y: xy[1]
},
stopAnimation: true,
callback: me.afterRepair,
scope: me
});
} else {
me.afterRepair();
}
},
// private
afterRepair : function() {
var me = this;

me.hide(true);
me.el.removeCls(me.repairCls);
if (typeof me.callback == "function") {
me.callback.call(me.scope || me);
}
delete me.callback;
delete me.scope;
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/dd/DragSource.js */
(function(Ext) {
Ext.define('Ext.dd.DragSource', {
extend: 'Ext.dd.DDProxy',
requires: [
'Ext.dd.StatusProxy',
'Ext.dd.DragDropManager'
],



dropAllowed : Ext.baseCSSPrefix + 'dd-drop-ok',

dropNotAllowed : Ext.baseCSSPrefix + 'dd-drop-nodrop',

animRepair: true,

repairHighlightColor: 'c3daf9',

constructor: function(el, config) {
this.el = Ext.get(el);
if(!this.dragData){
this.dragData = {};
}
Ext.apply(this, config);
if(!this.proxy){
this.proxy = new Ext.dd.StatusProxy({
id: this.el.id + '-drag-status-proxy',
animRepair: this.animRepair
});
}
this.callParent([this.el.dom, this.ddGroup || this.group,
{dragElId : this.proxy.id, resizeFrame: false, isTarget: false, scroll: this.scroll === true}]);
this.dragging = false;
},

getDragData : function(e){
return this.dragData;
},
// @private
onDragEnter : function(e, id){
var target = Ext.dd.DragDropManager.getDDById(id),
status;
this.cachedTarget = target;
if (this.beforeDragEnter(target, e, id) !== false) {
if (target.isNotifyTarget) {
status = target.notifyEnter(this, e, this.dragData);
this.proxy.setStatus(status);
} else {
this.proxy.setStatus(this.dropAllowed);
}
if (this.afterDragEnter) {

this.afterDragEnter(target, e, id);
}
}
},

beforeDragEnter: function(target, e, id) {
return true;
},
// @private
onDragOver: function(e, id) {
var target = this.cachedTarget || Ext.dd.DragDropManager.getDDById(id),
status;
if (this.beforeDragOver(target, e, id) !== false) {
if(target.isNotifyTarget){
status = target.notifyOver(this, e, this.dragData);
this.proxy.setStatus(status);
}
if (this.afterDragOver) {

this.afterDragOver(target, e, id);
}
}
},

beforeDragOver: function(target, e, id) {
return true;
},
// @private
onDragOut: function(e, id) {
var target = this.cachedTarget || Ext.dd.DragDropManager.getDDById(id);
if (this.beforeDragOut(target, e, id) !== false) {
if (target.isNotifyTarget) {
target.notifyOut(this, e, this.dragData);
}
this.proxy.reset();
if (this.afterDragOut) {

this.afterDragOut(target, e, id);
}
}
this.cachedTarget = null;
},

beforeDragOut: function(target, e, id){
return true;
},
// @private
onDragDrop: function(e, id){
var target = this.cachedTarget || Ext.dd.DragDropManager.getDDById(id);
if (this.beforeDragDrop(target, e, id) !== false) {
if (target.isNotifyTarget) {
if (target.notifyDrop(this, e, this.dragData) !== false) { // valid drop?
this.onValidDrop(target, e, id);
} else {
this.onInvalidDrop(target, e, id);
}
} else {
this.onValidDrop(target, e, id);
}
if (this.afterDragDrop) {

this.afterDragDrop(target, e, id);
}
}
delete this.cachedTarget;
},

beforeDragDrop: function(target, e, id){
return true;
},
// @private
onValidDrop: function(target, e, id){
this.hideProxy();
if(this.afterValidDrop){

this.afterValidDrop(target, e, id);
}
},
// @private
getRepairXY: function(e, data){
return this.el.getXY();
},
// @private
onInvalidDrop: function(target, e, id) {
// This method may be called by the DragDropManager.
// To preserve backwards compat, it only passes the event object
// Here we correct the arguments.
var me = this;

if (!e) {
e = target;
target = null;
id = e.getTarget().id;
}
if (me.beforeInvalidDrop(target, e, id) !== false) {
if (me.cachedTarget) {
if(me.cachedTarget.isNotifyTarget){
me.cachedTarget.notifyOut(me, e, me.dragData);
}
me.cacheTarget = null;
}
me.proxy.repair(me.getRepairXY(e, me.dragData), me.afterRepair, me);
if (me.afterInvalidDrop) {

me.afterInvalidDrop(e, id);
}
}
},
// @private
afterRepair: function() {
var me = this;
if (Ext.enableFx) {
me.el.highlight(me.repairHighlightColor);
}
me.dragging = false;
},

beforeInvalidDrop: function(target, e, id) {
return true;
},
// @private
handleMouseDown: function(e) {
if (this.dragging) {
return;
}
var data = this.getDragData(e);
if (data && this.onBeforeDrag(data, e) !== false) {
this.dragData = data;
this.proxy.stop();
this.callParent(arguments);
}
},

onBeforeDrag: function(data, e){
return true;
},

onStartDrag: Ext.emptyFn,
alignElWithMouse: function() {
this.proxy.ensureAttachedToBody(true);
return this.callParent(arguments);
},
// @private
startDrag: function(x, y) {
this.proxy.reset();
this.proxy.hidden = false;
this.dragging = true;
this.proxy.update("");
this.onInitDrag(x, y);
this.proxy.show();
},
// @private
onInitDrag: function(x, y) {
var clone = this.el.dom.cloneNode(true);
clone.id = Ext.id(); // prevent duplicate ids
this.proxy.update(clone);
this.onStartDrag(x, y);
return true;
},

getProxy: function() {
return this.proxy;
},

hideProxy: function() {
this.proxy.hide();
this.proxy.reset(true);
this.dragging = false;
},
// @private
triggerCacheRefresh: function() {
Ext.dd.DDM.refreshCache(this.groups);
},
// @private
b4EndDrag: function(e) {
},
// @private
endDrag : function(e){
this.onEndDrag(this.dragData, e);
},
// @private
onEndDrag : function(data, e){
},
// @private
autoOffset : function(x, y) {
this.setDelta(-12, -20);
},
destroy: function(){
this.callParent();
Ext.destroy(this.proxy);
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/panel/Proxy.js */
(function(Ext) {
Ext.define('Ext.panel.Proxy', {
alternateClassName: 'Ext.dd.PanelProxy',


moveOnDrag: true,

constructor: function(panel, config){
var me = this;


me.panel = panel;
me.id = me.panel.id +'-ddproxy';
Ext.apply(me, config);
},

insertProxy: true,
// private overrides
setStatus: Ext.emptyFn,
reset: Ext.emptyFn,
update: Ext.emptyFn,
stop: Ext.emptyFn,
sync: Ext.emptyFn,

getEl: function(){
return this.ghost.el;
},

getGhost: function(){
return this.ghost;
},

getProxy: function(){
return this.proxy;
},

hide : function(){
var me = this;

if (me.ghost) {
if (me.proxy) {
me.proxy.remove();
delete me.proxy;
}
// Unghost the Panel, do not move the Panel to where the ghost was
me.panel.unghost(null, me.moveOnDrag);
delete me.ghost;
}
},

show: function(){
var me = this,
panelSize;

if (!me.ghost) {
panelSize = me.panel.getSize();
me.panel.el.setVisibilityMode(Ext.Element.DISPLAY);
me.ghost = me.panel.ghost();
if (me.insertProxy) {
// bc Panels aren't absolute positioned we need to take up the space
// of where the panel previously was
me.proxy = me.panel.el.insertSibling({cls: Ext.baseCSSPrefix + 'panel-dd-spacer'});
me.proxy.setSize(panelSize);
}
}
},
// private
repair: function(xy, callback, scope) {
this.hide();
Ext.callback(callback, scope || this);
},

moveProxy : function(parentNode, before){
if (this.proxy) {
parentNode.insertBefore(this.proxy.dom, before);
}
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/panel/DD.js */
(function(Ext) {
Ext.define('Ext.panel.DD', {
extend: 'Ext.dd.DragSource',
requires: ['Ext.panel.Proxy'],
constructor : function(panel, cfg){
var me = this;

me.panel = panel;
me.dragData = {panel: panel};
me.panelProxy = new Ext.panel.Proxy(panel, cfg);
me.proxy = me.panelProxy.proxy;
me.callParent([panel.el, cfg]);
me.setupEl(panel);
},

setupEl: function(panel){
var me = this,
header = panel.header,
el = panel.body;

if (header) {
me.setHandleElId(header.id);
el = header.el;
}
if (el) {
el.setStyle('cursor', 'move');
me.scroll = false;
} else {
// boxready fires after first layout, so we'll definitely be rendered
panel.on('boxready', me.setupEl, me, {single: true});
}
},
showFrame: Ext.emptyFn,
startDrag: Ext.emptyFn,

b4StartDrag: function(x, y) {
this.panelProxy.show();
},

b4MouseDown: function(e) {
var x = e.getPageX(),
y = e.getPageY();

this.autoOffset(x, y);
},

onInitDrag : function(x, y){
this.onStartDrag(x, y);
return true;
},

createFrame : Ext.emptyFn,

getDragEl : function(e){
var ghost = this.panelProxy.ghost;
if (ghost) {
return ghost.el.dom;
}
},

endDrag : function(e){
this.panelProxy.hide();
this.panel.saveState();
},
autoOffset : function(x, y) {
x -= this.startPageX;
y -= this.startPageY;
this.setDelta(x, y);
},

// Override this, we don't want to repair on an "invalid" drop, the panel
// should main it's position
onInvalidDrop: function(target, e, id) {
var me = this;

if (me.beforeInvalidDrop(target, e, id) !== false) {
if (me.cachedTarget) {
if(me.cachedTarget.isNotifyTarget){
me.cachedTarget.notifyOut(me, e, me.dragData);
}
me.cacheTarget = null;
}
if (me.afterInvalidDrop) {

me.afterInvalidDrop(e, id);
}
}
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/layout/component/Dock.js */
(function(Ext) {
Ext.define('Ext.layout.component.Dock', {

extend: 'Ext.layout.component.Component',
alias: 'layout.dock',
alternateClassName: 'Ext.layout.component.AbstractDock',

type: 'dock',

horzAxisProps: {
name: 'horz',
oppositeName: 'vert',
dockBegin: 'left',
dockEnd: 'right',
horizontal: true,
marginBegin: 'margin-left',
maxSize: 'maxWidth',
minSize: 'minWidth',
pos: 'x',
setSize: 'setWidth',
shrinkWrapDock: 'shrinkWrapDockWidth',
size: 'width',
sizeModel: 'widthModel'
},
vertAxisProps: {
name: 'vert',
oppositeName: 'horz',
dockBegin: 'top',
dockEnd: 'bottom',
horizontal: false,
marginBegin: 'margin-top',
maxSize: 'maxHeight',
minSize: 'minHeight',
pos: 'y',
setSize: 'setHeight',
shrinkWrapDock: 'shrinkWrapDockHeight',
size: 'height',
sizeModel: 'heightModel'
},
initializedBorders: -1,
horizontalCollapsePolicy: { width: true, x: true },
verticalCollapsePolicy: { height: true, y: true },
finishRender: function () {
var me = this,
target, items;
me.callParent();
target = me.getRenderTarget();
items = me.getDockedItems();
me.finishRenderItems(target, items);
},
isItemBoxParent: function (itemContext) {
return true;
},
isItemShrinkWrap: function (item) {
return true;
},
noBorderClasses: [
Ext.baseCSSPrefix + 'docked-noborder-top',
Ext.baseCSSPrefix + 'docked-noborder-right',
Ext.baseCSSPrefix + 'docked-noborder-bottom',
Ext.baseCSSPrefix + 'docked-noborder-left'
],
noBorderClassesSides: {
top: Ext.baseCSSPrefix + 'docked-noborder-top',
right: Ext.baseCSSPrefix + 'docked-noborder-right',
bottom: Ext.baseCSSPrefix + 'docked-noborder-bottom',
left: Ext.baseCSSPrefix + 'docked-noborder-left'
},
borderWidthProps: {
top: 'border-top-width',
right: 'border-right-width',
bottom: 'border-bottom-width',
left: 'border-left-width'
},
handleItemBorders: function() {
var me = this,
owner = me.owner,
borders, docked,
lastItems = me.lastDockedItems,
oldBorders = me.borders,
currentGeneration = owner.dockedItems.generation,
noBorderClassesSides = me.noBorderClassesSides,
borderWidthProps = me.borderWidthProps,
i, ln, item, dock, side,
collapsed = me.collapsed;
if (me.initializedBorders == currentGeneration || (owner.border && !owner.manageBodyBorders)) {
return;
}
me.initializedBorders = currentGeneration;
// Borders have to be calculated using expanded docked item collection.
me.collapsed = false;
me.lastDockedItems = docked = me.getLayoutItems();
me.collapsed = collapsed;
borders = { top: [], right: [], bottom: [], left: [] };
for (i = 0, ln = docked.length; i < ln; i++) {
item = docked[i];
dock = item.dock;
if (item.ignoreBorderManagement) {
continue;
}
if (!borders[dock].satisfied) {
borders[dock].push(item);
borders[dock].satisfied = true;
}
if (!borders.top.satisfied && dock !== 'bottom') {
borders.top.push(item);
}
if (!borders.right.satisfied && dock !== 'left') {
borders.right.push(item);
}
if (!borders.bottom.satisfied && dock !== 'top') {
borders.bottom.push(item);
}
if (!borders.left.satisfied && dock !== 'right') {
borders.left.push(item);
}
}
if (lastItems) {
for (i = 0, ln = lastItems.length; i < ln; i++) {
item = lastItems[i];
if (!item.isDestroyed && !item.ignoreBorderManagement && !owner.manageBodyBorders) {
item.removeCls(me.noBorderClasses);
}
}
}
if (oldBorders) {
for (side in oldBorders) {
if (owner.manageBodyBorders && oldBorders[side].satisfied) {
owner.setBodyStyle(borderWidthProps[side], '');
}
}
}
for (side in borders) {
ln = borders[side].length;
if (!owner.manageBodyBorders) {
for (i = 0; i < ln; i++) {
borders[side][i].addCls(noBorderClassesSides[side]);
}
if ((!borders[side].satisfied && !owner.bodyBorder) || owner.bodyBorder === false) {
owner.addBodyCls(noBorderClassesSides[side]);
}
}
else if (borders[side].satisfied) {
owner.setBodyStyle(borderWidthProps[side], '1px');
}
}
me.borders = borders;
},
beforeLayoutCycle: function (ownerContext) {
var me = this,
owner = me.owner,
shrinkWrap = me.sizeModels.shrinkWrap,
shrinkWrapDock = owner.shrinkWrapDock,
collapsedHorz, collapsedVert;
if (owner.collapsed) {
if (owner.collapsedVertical()) {
collapsedVert = true;
ownerContext.measureDimensions = 1;
} else {
collapsedHorz = true;
ownerContext.measureDimensions = 2;
}
}
ownerContext.collapsedVert = collapsedVert;
ownerContext.collapsedHorz = collapsedHorz;
// If we are collapsed, we want to auto-layout using the placeholder/expander
// instead of the normal items/dockedItems. This must be done here since we could
// be in a box layout w/stretchmax which sets the width/heightModel to allow it to
// control the size.
if (collapsedVert) {
ownerContext.heightModel = shrinkWrap;
} else if (collapsedHorz) {
ownerContext.widthModel = shrinkWrap;
}

shrinkWrapDock = shrinkWrapDock === true ? 3 : (shrinkWrapDock || 0);
ownerContext.shrinkWrapDockHeight = (shrinkWrapDock & 1) && ownerContext.heightModel.shrinkWrap;
ownerContext.shrinkWrapDockWidth = (shrinkWrapDock & 2) && ownerContext.widthModel.shrinkWrap;
},
beginLayout: function(ownerContext) {
var me = this,
owner = me.owner,
docked = me.getLayoutItems(),
layoutContext = ownerContext.context,
dockedItemCount = docked.length,
dockedItems, i, item, itemContext, offsets,
collapsed, dock;
me.callParent(arguments);
// Cache the children as ContextItems (like a Container). Also setup to handle
// collapsed state:
collapsed = owner.getCollapsed();
if (collapsed !== me.lastCollapsedState && Ext.isDefined(me.lastCollapsedState)) {
// If we are collapsing...
if (me.owner.collapsed) {
ownerContext.isCollapsingOrExpanding = 1;
// Add the collapsed class now, so that collapsed CSS rules are applied before measurements are taken by the layout.
owner.addClsWithUI(owner.collapsedCls);
} else {
ownerContext.isCollapsingOrExpanding = 2;
// Remove the collapsed class now, before layout calculations are done.
owner.removeClsWithUI(owner.collapsedCls);
ownerContext.lastCollapsedState = me.lastCollapsedState;
}
}
me.lastCollapsedState = collapsed;
ownerContext.dockedItems = dockedItems = [];
for (i = 0; i < dockedItemCount; i++) {
item = docked[i];
if (item.rendered) {
dock = item.dock;
itemContext = layoutContext.getCmp(item);
itemContext.dockedAt = { x: 0, y: 0 };
itemContext.offsets = offsets = Ext.Element.parseBox(item.offsets || 0);
itemContext.horizontal = dock == 'top' || dock == 'bottom';
offsets.width = offsets.left + offsets.right;
offsets.height = offsets.top + offsets.bottom;
dockedItems.push(itemContext);
}
}
ownerContext.bodyContext = ownerContext.getEl('body');
},
beginLayoutCycle: function(ownerContext) {
var me = this,
docked = ownerContext.dockedItems,
len = docked.length,
owner = me.owner,
frameBody = owner.frameBody,
lastHeightModel = me.lastHeightModel,
i, item, dock;
me.callParent(arguments);
if (me.owner.manageHeight) {
// Reset in case manageHeight gets turned on during lifecycle.
// See below for why display could be set to non-default value.
if (me.lastBodyDisplay) {
owner.body.dom.style.display = me.lastBodyDisplay = '';
}
} else {
// When manageHeight is false, the body stretches the outer el by using wide margins to force it to
// accommodate the docked items. When overflow is visible (when panel is resizable and has embedded handles),
// the body must be inline-block so as not to collapse its margins
if (me.lastBodyDisplay !== 'inline-block') {
owner.body.dom.style.display = me.lastBodyDisplay = 'inline-block';
}
if (lastHeightModel && lastHeightModel.shrinkWrap &&
!ownerContext.heightModel.shrinkWrap) {
owner.body.dom.style.marginBottom = '';
}
}
if (ownerContext.widthModel.auto) {
if (ownerContext.widthModel.shrinkWrap) {
owner.el.setWidth(null);
}
owner.body.setWidth(null);
if (frameBody) {
frameBody.setWidth(null);
}
}
if (ownerContext.heightModel.auto) {
owner.body.setHeight(null);
//owner.el.setHeight(null); Disable this for now
if (frameBody) {
frameBody.setHeight(null);
}
}
// Each time we begin (2nd+ would be due to invalidate) we need to publish the
// known contentWidth/Height if we are collapsed:
if (ownerContext.collapsedVert) {
ownerContext.setContentHeight(0);
} else if (ownerContext.collapsedHorz) {
ownerContext.setContentWidth(0);
}
// dock: 'right' items, when a panel gets narrower get "squished". Moving them to
// left:0px avoids this!
for (i = 0; i < len; i++) {
item = docked[i].target;
dock = item.dock;
if (dock == 'right') {
item.setLocalX(0);
} else if (dock != 'left') {
continue;
}
// TODO - clear width/height?
}
},
calculate: function (ownerContext) {
var me = this,
measure = me.measureAutoDimensions(ownerContext, ownerContext.measureDimensions),
state = ownerContext.state,
horzDone = state.horzDone,
vertDone = state.vertDone,
bodyContext = ownerContext.bodyContext,
framing, horz, vert, forward, backward;
// make sure we can use these value w/o calling methods to get them
ownerContext.borderInfo || ownerContext.getBorderInfo();
ownerContext.paddingInfo || ownerContext.getPaddingInfo();
ownerContext.frameInfo || ownerContext.getFrameInfo();
bodyContext.borderInfo || bodyContext.getBorderInfo();
bodyContext.paddingInfo || bodyContext.getPaddingInfo();
// On CSS3 browsers, the border and padding frame the outer el. On non-CSS3
// browsers, the outer el has no border or padding - all that appears on the
// framing elements as padding and height. In CSS3, the border size effects the
// origin of the dockedItems but the padding does not (so that must be added in
// most of the time). In non-CSS3 mode, the dockedItems are outside the framing:
//
// ... top / left dockedItems ...
// <div id="...-ml" style="padding-left: border-radius-left;">
// <div id="...-mr" style="padding-right: border-radius-right;">
// <div id="...-mc" style="padding: extra;">
// ... body ...
// </div>
// </div>
// </div>
// ... bottom / right dockedItems ...
// 
// For the sake of sanity, we perform all the calculations in CSS3 mode. We test
// for the presence of non-CSS3 framing only when necessary.
//
if (!ownerContext.frameBorder) {
if (!(framing = ownerContext.framing)) {
ownerContext.frameBorder = ownerContext.borderInfo;
ownerContext.framePadding = ownerContext.paddingInfo;
} else {
// These values match what they would have been in CSS3.
ownerContext.frameBorder = framing.border;
ownerContext.framePadding = framing.padding;
}
}
// Start the axes so they are ready to proceed inwards (fixed-size) or outwards
// (shrinkWrap) and stash key property names as well:
horz = !horzDone &&
me.createAxis(ownerContext, measure.contentWidth, ownerContext.widthModel,
me.horzAxisProps, ownerContext.collapsedHorz);
vert = !vertDone &&
me.createAxis(ownerContext, measure.contentHeight, ownerContext.heightModel,
me.vertAxisProps, ownerContext.collapsedVert);
// We iterate forward and backward over the dockedItems at the same time based on
// whether an axis is shrinkWrap or fixed-size. For a fixed-size axis, the outer box
// axis is allocated to docked items in forward order and is reduced accordingly.
// To handle a shrinkWrap axis, the box starts at the inner (body) size and is used to
// size docked items in backwards order. This is because the last docked item shares
// an edge with the body. The item size is used to adjust the shrinkWrap axis outwards
// until the first docked item (at the outermost edge) is processed. This backwards
// order ensures that docked items never get an incorrect size for any dimension.
for (forward = 0, backward = ownerContext.dockedItems.length; backward--; ++forward) {
if (horz) {
me.dockChild(ownerContext, horz, backward, forward);
}
if (vert) {
me.dockChild(ownerContext, vert, backward, forward);
}
}

if (horz && me.finishAxis(ownerContext, horz)) {
state.horzDone = horzDone = horz;
}

if (vert && me.finishAxis(ownerContext, vert)) {
state.vertDone = vertDone = vert;
}
// Once all items are docked, the final size of the outer panel or inner body can
// be determined. If we can determine both width and height, we are done.
if (horzDone && vertDone && me.finishConstraints(ownerContext, horzDone, vertDone)) {
// Size information is published as we dock items but position is hard to do
// that way (while avoiding published multiple times) so we publish all the
// positions at the end.
me.finishPositions(ownerContext, horzDone, vertDone);
} else {
me.done = false;
}
},

createAxis: function (ownerContext, contentSize, sizeModel, axisProps, collapsedAxis) {
var me = this,
begin = 0,
owner = me.owner,
maxSize = owner[axisProps.maxSize],
minSize = owner[axisProps.minSize] || 0,
dockBegin = axisProps.dockBegin,
dockEnd = axisProps.dockEnd,
posProp = axisProps.pos,
sizeProp = axisProps.size,
hasMaxSize = maxSize != null, // exactly the same as "maxSize !== null && maxSize !== undefined"
shrinkWrap = sizeModel.shrinkWrap,
bodyContext, framing, padding, end;
if (shrinkWrap) {
// End position before adding docks around the content is content size plus the body borders in this axis.
// If collapsed in this axis, the body borders will not be shown.
if (collapsedAxis) {
end = 0;
} else {
bodyContext = ownerContext.bodyContext;
end = contentSize + bodyContext.borderInfo[sizeProp];
}
} else {
framing = ownerContext.frameBorder;
padding = ownerContext.framePadding;
begin = framing[dockBegin] + padding[dockBegin];
end = ownerContext.getProp(sizeProp) - (framing[dockEnd] + padding[dockEnd]);
}
return {
shrinkWrap: sizeModel.shrinkWrap,
sizeModel: sizeModel,
// An axis tracks start and end+1 px positions. eg 0 to 10 for 10px high
initialBegin: begin,
begin: begin,
end: end,
collapsed: collapsedAxis,
horizontal: axisProps.horizontal,
ignoreFrameBegin: null,
ignoreFrameEnd: null,
initialSize: end - begin,
maxChildSize: 0,
hasMinMaxConstraints: (minSize || hasMaxSize) && sizeModel.shrinkWrap,
minSize: minSize,
maxSize: hasMaxSize ? maxSize : 1e9,
bodyPosProp: me.owner.manageHeight ? posProp : axisProps.marginBegin,
dockBegin: dockBegin, // 'left' or 'top'
dockEnd: dockEnd, // 'right' or 'end'
posProp: posProp, // 'x' or 'y'
sizeProp: sizeProp, // 'width' or 'height'
setSize: axisProps.setSize,
shrinkWrapDock: ownerContext[axisProps.shrinkWrapDock],
sizeModelName: axisProps.sizeModel,
dockedPixelsEnd: 0
};
},

dockChild: function (ownerContext, axis, backward, forward) {
var me = this,
itemContext = ownerContext.dockedItems[axis.shrinkWrap ? backward : forward],
item = itemContext.target,
dock = item.dock, // left/top/right/bottom
sizeProp = axis.sizeProp,
pos, size;
if (item.ignoreParentFrame && ownerContext.isCollapsingOrExpanding) {
// collapsed window header margins may differ from expanded window header margins
// so we need to make sure the old cached values are not used in axis calculations
itemContext.clearMarginCache();
}
itemContext.marginInfo || itemContext.getMarginInfo(); // get marginInfo ready
if (dock == axis.dockBegin) {
if (axis.shrinkWrap) {
pos = me.dockOutwardBegin(ownerContext, itemContext, item, axis);
} else {
pos = me.dockInwardBegin(ownerContext, itemContext, item, axis);
}
} else if (dock == axis.dockEnd) {
if (axis.shrinkWrap) {
pos = me.dockOutwardEnd(ownerContext, itemContext, item, axis);
} else {
pos = me.dockInwardEnd(ownerContext, itemContext, item, axis);
}
} else {
if (axis.shrinkWrapDock) {
// we are still shrinkwrapping transversely... so we need to include the
// size of this item in the max calculation
size = itemContext.getProp(sizeProp) + itemContext.marginInfo[sizeProp];
axis.maxChildSize = Math.max(axis.maxChildSize, size);
pos = 0;
} else {
pos = me.dockStretch(ownerContext, itemContext, item, axis);
}
}
itemContext.dockedAt[axis.posProp] = pos;
},

dockInwardBegin: function (ownerContext, itemContext, item, axis) {
var pos = axis.begin,
sizeProp = axis.sizeProp,
ignoreParentFrame = item.ignoreParentFrame,
delta,
size, 
dock;
if (ignoreParentFrame) {
axis.ignoreFrameBegin = itemContext;
dock = item.dock;
// We need to move everything up by the border-width.
delta = ownerContext.frameBorder[dock];
// We need to move the header "up" by the padding as well.
pos -= delta + ownerContext.framePadding[dock];
}
if (!item.overlay) {
size = itemContext.getProp(sizeProp) + itemContext.marginInfo[sizeProp];
axis.begin += size;
if (ignoreParentFrame) {
axis.begin -= delta;
}
}
return pos;
},

dockInwardEnd: function (ownerContext, itemContext, item, axis) {
var sizeProp = axis.sizeProp,
size = itemContext.getProp(sizeProp) + itemContext.marginInfo[sizeProp],
pos = axis.end - size,
frameEnd;
if (!item.overlay) {
axis.end = pos;
}
if (item.ignoreParentFrame) {
axis.ignoreFrameEnd = itemContext;
frameEnd = ownerContext.frameBorder[item.dock];
pos += frameEnd + ownerContext.framePadding[item.dock];
axis.end += frameEnd;
}
return pos;
},

dockOutwardBegin: function (ownerContext, itemContext, item, axis) {
var pos = axis.begin,
sizeProp = axis.sizeProp,
size;
if (axis.collapsed) {
axis.ignoreFrameBegin = axis.ignoreFrameEnd = itemContext;
} else if (item.ignoreParentFrame) {
axis.ignoreFrameBegin = itemContext;
}
// NOTE - When shrinkWrapping an ignoreParentFrame, this must be the last item
// on the axis. Since that is so, we let finishAxis take this in to account.
if (!item.overlay) {
size = itemContext.getProp(sizeProp) + itemContext.marginInfo[sizeProp];
pos -= size;
axis.begin = pos;
}
return pos;
},

dockOutwardEnd: function (ownerContext, itemContext, item, axis) {
var pos = axis.end,
sizeProp = axis.sizeProp,
size;
size = itemContext.getProp(sizeProp) + itemContext.marginInfo[sizeProp];
if (axis.collapsed) {
axis.ignoreFrameBegin = axis.ignoreFrameEnd = itemContext;
} else if (item.ignoreParentFrame) {
axis.ignoreFrameEnd = itemContext;
}
// NOTE - When shrinkWrapping an ignoreParentFrame, this must be the last item
// on the axis. Since that is so, we let finishAxis take this in to account.
if (!item.overlay) {
axis.end = pos + size;
axis.dockedPixelsEnd += size;
}
return pos;
},

dockStretch: function (ownerContext, itemContext, item, axis) {
var dock = item.dock, // left/top/right/bottom (also used to index padding/border)
sizeProp = axis.sizeProp, // 'width' or 'height'
horizontal = dock == 'top' || dock == 'bottom',
border = ownerContext.frameBorder,
offsets = itemContext.offsets,
padding = ownerContext.framePadding,
endProp = horizontal ? 'right' : 'bottom',
startProp = horizontal ? 'left' : 'top',
pos = axis.begin + offsets[startProp],
margin, size;
if (item.stretch !== false) {
size = axis.end - pos - offsets[endProp];
if (item.ignoreParentFrame) {
// In CSS3, the border and padding need to be ignored specifically. In
// non-CSS3 / framing mode, the border and padding will be 0 **but** the
// header is not rendered inside the framing elements and so we do not
// want to do anything anyway!
pos -= padding[startProp] + border[startProp];
size += padding[sizeProp] + border[sizeProp];
}
margin = itemContext.marginInfo;
size -= margin[sizeProp];
itemContext[axis.setSize](size);
}
return pos;
},

finishAxis: function (ownerContext, axis) {
// If the maxChildSize is NaN it means at some point we tried to determine
// The size of a docked item but we couldn't, so just jump out straight
// away before doing any other processing
if (isNaN(axis.maxChildSize)) {
return false;
}

var axisBegin = axis.begin,
size = axis.end - axisBegin,
collapsed = axis.collapsed,
setSizeMethod = axis.setSize,
beginName = axis.dockBegin, // left or top
endName = axis.dockEnd, // right or bottom
padding = ownerContext.framePadding,
border = ownerContext.frameBorder,
borderBegin = border[beginName],
framing = ownerContext.framing,
framingBegin = framing && framing[beginName],
// The padding is in play unless the axis is collapsed.
paddingBegin = collapsed ? 0 : padding[beginName],
sizeProp = axis.sizeProp,
ignoreFrameBegin = axis.ignoreFrameBegin,
ignoreFrameEnd = axis.ignoreFrameEnd,
bodyContext = ownerContext.bodyContext,
extraPaddingBegin = Math.max(borderBegin + paddingBegin - framingBegin, 0),
bodyPos, bodySize, delta, dirty;
if (axis.shrinkWrap) {
// Since items docked left/top on a shrinkWrap axis go into negative coordinates,
// we apply a delta to all coordinates to adjust their relative origin back to
// a (0,0) inside the border.
bodySize = axis.initialSize;
if (framing) {
// In CSS3 mode, things are compartively simple because "framing" is just
// borders and padding. In non-CSS3 mode, however, the framing elements
// are given a size equal to the max of the border-width and border-radius
// and this pushes the body down accordingly. Further, the dockedItems are
// all rendered outside the framing elements, so their origin equals the
// ideal box origin. To translate this to match CSS3, we have to add on
// the border-top.
delta = -axisBegin + borderBegin + paddingBegin;
bodyPos = delta - framingBegin - extraPaddingBegin;
} else {
bodyPos = -axisBegin;
delta = bodyPos + paddingBegin;
}
if (!collapsed) {
size += padding[sizeProp];
}
if (ignoreFrameBegin) {
// When some component ignores the begin framing, we move everything "up"
// by that amount of framing. We also do not include that amount of the
// framing in the shrinkWrap size.
delta -= borderBegin;
bodyPos -= borderBegin;
// The item ignoring the framing must also escape the padding. Since the
// axis.delta includes the padding and we want to apply this to only the
// one item, we just poke its dockedAt.x/y property so that when we add
// axis.begin the padding will cancel out. (Note: when we are collapsed
// paddingBegin will be 0).

ignoreFrameBegin.dockedAt[axis.posProp] -= paddingBegin;
} else {
size += borderBegin;
}
if (collapsed) {
// in this case "ignoreFrameBegin === ignoreFrameEnd" so we can take the
// special cases out of the mix here...
} else if (ignoreFrameEnd) {
// When a component ignores the end framing, we simply move it further
// "down" by the end padding and we do not add the end framing to the
// shrinkWrap size.
ignoreFrameEnd.dockedAt[axis.posProp] += padding[endName];
} else {
size += border[endName];
}
axis.size = size; // we have to wait for min/maxWidth/Height processing
if (!axis.horizontal && !this.owner.manageHeight) {
// the height of the bodyEl will give the proper height to the outerEl so
// we don't need to set heights in the DOM
dirty = false;
}
} else {
// For a fixed-size axis, we started at the outer box and already have the
// proper origin... almost... except for the owner's border.
if (framing) {
// since dockedItems are rendered outside the framing, they have the
// proper origin already:
delta = 0;
bodyPos = axisBegin - framingBegin - extraPaddingBegin;
} else {
delta = -borderBegin;
bodyPos = axisBegin - paddingBegin - borderBegin;
}
// Body size is remaining space between ends of Axis.
bodySize = size;
}
axis.delta = delta;
bodyContext[setSizeMethod](bodySize, dirty);
bodyContext.setProp(axis.bodyPosProp, bodyPos);
return !isNaN(size);
},

beforeInvalidateShrinkWrapDock: function(itemContext, options){
var sizeModelName = options.axis.sizeModelName;
if (!itemContext[sizeModelName].constrainedMin) {
// if the child hit a min constraint, it needs to be at its configured size, so
// we leave the sizeModel alone
itemContext[sizeModelName] = Ext.layout.SizeModel.calculated;
}
},

afterInvalidateShrinkWrapDock: function(itemContext, options){
var axis = options.axis,
me = options.layout,
pos;
if (itemContext[axis.sizeModelName].calculated) {
pos = me.dockStretch(options.ownerContext, itemContext, itemContext.target, axis);
itemContext.setProp(axis.posProp, axis.delta + pos);
}
},


finishConstraints: function (ownerContext, horz, vert) {
var me = this,
sizeModels = me.sizeModels,
publishWidth = horz.shrinkWrap,
publishHeight = vert.shrinkWrap,
owner = me.owner,
dirty, height, width, heightModel, widthModel, size, 
minSize, maxSize, maxChildSize, desiredSize;
// In these calculations, maxChildSize will only be > 0 in the scenario where
// we are dock shrink wrapping in that direction, otherwise it is not measured.
// As such, the additions are done to simplify the logic, even though in most
// cases, it will have no impact on the overall result.

if (publishWidth) {
size = horz.size;
minSize = horz.collapsed ? 0 : horz.minSize;
maxSize = horz.maxSize;
maxChildSize = horz.maxChildSize;
desiredSize = Math.max(size, maxChildSize);
if (desiredSize > maxSize) {
widthModel = sizeModels.constrainedMax;
width = maxSize;
} else if (desiredSize < minSize) {
widthModel = sizeModels.constrainedMin;
width = minSize;
} else if (size < maxChildSize) {
widthModel = sizeModels.constrainedDock;
owner.dockConstrainedWidth = width = maxChildSize;
} else {
width = size;
}
}
if (publishHeight) {
size = vert.size;
minSize = vert.collapsed ? 0 : vert.minSize;
maxSize = vert.maxSize;
maxChildSize = vert.maxChildSize;
// For vertical docks, their weighting means the height is affected by top/bottom
// docked items, so we need to subtract them here
desiredSize = Math.max(size, maxChildSize + size - vert.initialSize);
if (desiredSize > maxSize) {
heightModel = sizeModels.constrainedMax;
height = maxSize;
} else if (desiredSize < minSize) {
heightModel = sizeModels.constrainedMin;
height = minSize;
} else if (size < maxChildSize) {
heightModel = sizeModels.constrainedDock;
owner.dockConstrainedHeight = height = maxChildSize;
} else {
if (!ownerContext.collapsedVert && !owner.manageHeight) {
// height of the outerEl is provided by the height (including margins)
// of the bodyEl, so this value does not need to be written to the DOM
dirty = false;
// so long as we set top and bottom margins on the bodyEl!
ownerContext.bodyContext.setProp('margin-bottom', vert.dockedPixelsEnd);
}
height = size;
}
}
// Handle the constraints...
if (widthModel || heightModel) {
// See ContextItem#init for an analysis of why this case is special. Basically,
// in this case, we only know the width and the height could be anything.
if (widthModel && heightModel &&
widthModel.constrainedMax && heightModel.constrainedByMin) {
ownerContext.invalidate({ widthModel: widthModel });
return false;
}
// To process a width or height other than that to which we have shrinkWrapped,
// we need to invalidate our component and carry forward w/these constrains...
// unless the ownerLayout wants these results and will invalidate us anyway.
if (!ownerContext.widthModel.calculatedFromShrinkWrap &&
!ownerContext.heightModel.calculatedFromShrinkWrap) {
// nope, just us to handle the constraint...
ownerContext.invalidate({ widthModel: widthModel, heightModel: heightModel });
return false;
}
// We have a constraint to deal with, so we just adjust the size models and
// allow the ownerLayout to invalidate us with its contribution to our final
// size...
} else {
// We're not invalidating, the ownerContext, so if we're shrink wrapping we'll need to
// tell any docked items to invalidate themselves if necessary.'
me.invalidateAxes(ownerContext, horz, vert);

}
// we only publish the sizes if we are not invalidating the result...
if (publishWidth) {
ownerContext.setWidth(width);
if (widthModel) {
ownerContext.widthModel = widthModel; // important to the ownerLayout
}
}
if (publishHeight) {
ownerContext.setHeight(height, dirty);
if (heightModel) {
ownerContext.heightModel = heightModel; // important to the ownerLayout
}
}
return true;
},


invalidateAxes: function(ownerContext, horz, vert){
var before = this.beforeInvalidateShrinkWrapDock,
after = this.afterInvalidateShrinkWrapDock,
horzSize = horz.end - horz.begin,
vertSize = vert.initialSize,
invalidateHorz = horz.shrinkWrapDock && horz.maxChildSize < horzSize,
invalidateVert = vert.shrinkWrapDock && vert.maxChildSize < vertSize,
dockedItems, len, i, itemContext, itemSize, isHorz, axis, sizeProp;
if (invalidateHorz || invalidateVert) {
if (invalidateVert) {
// For vertical, we need to reset the initial position because they are affected
// by the horizontally docked items
vert.begin = vert.initialBegin;
vert.end = vert.begin + vert.initialSize;
}
dockedItems = ownerContext.dockedItems;
for (i = 0, len = dockedItems.length; i < len; ++i) {
itemContext = dockedItems[i];
isHorz = itemContext.horizontal;
axis = null;
if (invalidateHorz && isHorz) {
sizeProp = horz.sizeProp;
itemSize = horzSize;
axis = horz;
} else if (invalidateVert && !isHorz) {
sizeProp = vert.sizeProp;
itemSize = vertSize;
axis = vert;
}

if (axis) {
// subtract any margins
itemSize -= itemContext.getMarginInfo()[sizeProp];
if (itemSize !== itemContext.props[sizeProp]) {
itemContext.invalidate({
before: before,
after: after,
axis: axis,
ownerContext: ownerContext,
layout: this
});
}
}
}
}
},

finishPositions: function (ownerContext, horz, vert) {
var dockedItems = ownerContext.dockedItems,
length = dockedItems.length,
deltaX = horz.delta,
deltaY = vert.delta,
index, itemContext;
for (index = 0; index < length; ++index) {
itemContext = dockedItems[index];
itemContext.setProp('x', deltaX + itemContext.dockedAt.x);
itemContext.setProp('y', deltaY + itemContext.dockedAt.y);
}
},
finishedLayout: function(ownerContext) {
var me = this,
target = ownerContext.target;
me.callParent(arguments);
if (!ownerContext.animatePolicy) {
if (ownerContext.isCollapsingOrExpanding === 1) {
target.afterCollapse(false);
} else if (ownerContext.isCollapsingOrExpanding === 2) {
target.afterExpand(false);
}
}
},
getAnimatePolicy: function(ownerContext) {
var me = this,
lastCollapsedState, policy;
if (ownerContext.isCollapsingOrExpanding == 1) {
lastCollapsedState = me.lastCollapsedState;
} else if (ownerContext.isCollapsingOrExpanding == 2) {
lastCollapsedState = ownerContext.lastCollapsedState;
}
if (lastCollapsedState == 'left' || lastCollapsedState == 'right') {
policy = me.horizontalCollapsePolicy;
} else if (lastCollapsedState == 'top' || lastCollapsedState == 'bottom') {
policy = me.verticalCollapsePolicy;
}
return policy;
},

getDockedItems: function(order, beforeBody) {
var me = this,
renderedOnly = (order === 'visual'),
all = renderedOnly ? Ext.ComponentQuery.query('[rendered]', me.owner.dockedItems.items) : me.owner.dockedItems.items,
sort = all && all.length && order !== false,
renderOrder,
dock, dockedItems, i, isBefore, length;
if (beforeBody == null) {
dockedItems = sort && !renderedOnly ? all.slice() : all;
} else {
dockedItems = [];
for (i = 0, length = all.length; i < length; ++i) {
dock = all[i].dock;
isBefore = (dock == 'top' || dock == 'left');
if (beforeBody ? isBefore : !isBefore) {
dockedItems.push(all[i]);
}
}
sort = sort && dockedItems.length;
}
if (sort) {
renderOrder = (order = order || 'render') == 'render';
Ext.Array.sort(dockedItems, function(a, b) {
var aw,
bw;
// If the two items are on opposite sides of the body, they must not be sorted by any weight value:
// For rendering purposes, left/top *always* sorts before right/bottom
if (renderOrder && ((aw = me.owner.dockOrder[a.dock]) !== (bw = me.owner.dockOrder[b.dock]))) {
// The two dockOrder values cancel out when two items are on opposite sides.
if (!(aw + bw)) {
return aw - bw;
}
}
aw = me.getItemWeight(a, order);
bw = me.getItemWeight(b, order);
if ((aw !== undefined) && (bw !== undefined)) {
return aw - bw;
}
return 0;
});
}
return dockedItems || [];
},
getItemWeight: function (item, order) {
var weight = item.weight || this.owner.defaultDockWeights[item.dock];
return weight[order] || weight;
},

getLayoutItems : function() {
var me = this,
items,
itemCount,
item,
i,
result;
if (me.owner.collapsed) {
result = me.owner.getCollapsedDockedItems();
} else {
items = me.getDockedItems('visual');
itemCount = items.length;
result = [];
for (i = 0; i < itemCount; i++) {
item = items[i];
if (!item.hidden) {
result.push(item);
}
}
}
return result;
},
// Content size includes padding but not borders, so subtract them off
measureContentWidth: function (ownerContext) {
var bodyContext = ownerContext.bodyContext;
return bodyContext.el.getWidth() - bodyContext.getBorderInfo().width;
},
measureContentHeight: function (ownerContext) {
var bodyContext = ownerContext.bodyContext;
return bodyContext.el.getHeight() - bodyContext.getBorderInfo().height;
},

redoLayout: function(ownerContext) {
var me = this,
owner = me.owner;

// If we are collapsing...
if (ownerContext.isCollapsingOrExpanding == 1) {
if (owner.reExpander) {
owner.reExpander.el.show();
}
// Add the collapsed class now, so that collapsed CSS rules are applied before measurements are taken by the layout.
owner.addClsWithUI(owner.collapsedCls);
ownerContext.redo(true);
} else if (ownerContext.isCollapsingOrExpanding == 2) {
// Remove the collapsed class now, before layout calculations are done.
owner.removeClsWithUI(owner.collapsedCls);
ownerContext.bodyContext.redo();
} 
},
// @private override inherited.
// We need to render in the correct order, top/left before bottom/right
renderChildren: function() {
var me = this,
items = me.getDockedItems(),
target = me.getRenderTarget();
me.handleItemBorders();
me.renderItems(items, target);
},

renderItems: function(items, target) {
var me = this,
dockedItemCount = items.length,
itemIndex = 0,
correctPosition = 0,
staticNodeCount = 0,
targetNodes = me.getRenderTarget().dom.childNodes,
targetChildCount = targetNodes.length,
i, j, targetChildNode, item;
// Calculate the number of DOM nodes in our target that are not our docked items
for (i = 0, j = 0; i < targetChildCount; i++) {
targetChildNode = targetNodes[i];
if (Ext.fly(targetChildNode).hasCls(Ext.baseCSSPrefix + 'resizable-handle')) {
break;
}
for (j = 0; j < dockedItemCount; j++) {
item = items[j];
if (item.rendered && item.el.dom === targetChildNode) {
break;
}
}
// Walked off the end of the docked items without matching the found child node;
// Then it's a static node.
if (j === dockedItemCount) {
staticNodeCount++;
}
}
// Now we go through our docked items and render/move them
for (; itemIndex < dockedItemCount; itemIndex++, correctPosition++) {
item = items[itemIndex];
// If we're now at the first right/bottom docked item, we jump over the body element.
//
// TODO: This is affected if users provide custom weight values to their
// docked items, which puts it out of (t,l,r,b) order. Avoiding a second
// sort operation here, for now, in the name of performance. getDockedItems()
// needs the sort operation not just for this layout-time rendering, but
// also for getRefItems() to return a logical ordering (FocusManager, CQ, et al).
if (itemIndex === correctPosition && (item.dock === 'right' || item.dock === 'bottom')) {
correctPosition += staticNodeCount;
}
// Same logic as Layout.renderItems()
if (item && !item.rendered) {
me.renderItem(item, target, correctPosition);
}
else if (!me.isValidParent(item, target, correctPosition)) {
me.moveItem(item, target, correctPosition);
}
}
},
undoLayout: function(ownerContext) {
var me = this,
owner = me.owner;

// If we are collapsing...
if (ownerContext.isCollapsingOrExpanding == 1) {
// We do not want to see the re-expander header until the final collapse is complete
if (owner.reExpander) {
owner.reExpander.el.hide();
}
// Add the collapsed class now, so that collapsed CSS rules are applied before measurements are taken by the layout.
owner.removeClsWithUI(owner.collapsedCls);
ownerContext.undo(true);
} else if (ownerContext.isCollapsingOrExpanding == 2) {
// Remove the collapsed class now, before layout calculations are done.
owner.addClsWithUI(owner.collapsedCls);
ownerContext.bodyContext.undo();
} 
},
sizePolicy: {
nostretch: {
setsWidth: 0,
setsHeight: 0
},
horz: { // item goes horizontally (top or bottom docked)
shrinkWrap: {
// This is how we manage the width of a top/bottom docked item when its
// shrinkWrapWidth and ours need to be maxed (calculatedFromShrinkWrap)
setsWidth: 1,
setsHeight: 0,
readsWidth: 1
},
stretch: {
setsWidth: 1,
setsHeight: 0
}
},
vert: { // item goes vertically (left or right docked)
shrinkWrap: {
setsWidth: 0,
setsHeight: 1,
readsHeight: 1
},
stretch: {
setsWidth: 0,
setsHeight: 1
}
},
stretchV: {
setsWidth: 0,
setsHeight: 1
},
// Circular dependency with partial auto-sized panels:
//
// If we have an autoHeight docked item being stretched horizontally (top/bottom),
// that stretching will determine its width and its width must be set before its
// autoHeight can be determined. If that item is docked in an autoWidth panel, the
// body will need its height set before it can determine its width, but the height
// of the docked item is needed to subtract from the panel height in order to set
// the body height.
//
// This same pattern occurs with autoHeight panels with autoWidth docked items on
// left or right. If the panel is fully auto or fully fixed, these problems don't
// come up because there is no dependency between the dimensions.
//
// Cutting the Gordian Knot: In these cases, we have to allow something to measure
// itself without full context. This is OK as long as the managed dimension doesn't
// effect the auto-dimension, which is often the case for things like toolbars. The
// managed dimension only effects overflow handlers and such and does not change the
// auto-dimension. To encourage the item to measure itself without waiting for the
// managed dimension, we have to tell it that the layout will also be reading that
// dimension. This is similar to how stretchmax works.
autoStretchH: {
readsWidth: 1,
setsWidth: 1,
setsHeight: 0
},
autoStretchV: {
readsHeight: 1,
setsWidth: 0,
setsHeight: 1
}
},
getItemSizePolicy: function (item, ownerSizeModel) {
var me = this,
policy = me.sizePolicy,
shrinkWrapDock = me.owner.shrinkWrapDock,
dock, vertical;
if (item.stretch === false) {
return policy.nostretch;
}
dock = item.dock;
vertical = (dock == 'left' || dock == 'right');
shrinkWrapDock = shrinkWrapDock === true ? 3 : (shrinkWrapDock || 0);
if (vertical) {
policy = policy.vert;
shrinkWrapDock = shrinkWrapDock & 1;
} else {
policy = policy.horz;
shrinkWrapDock = shrinkWrapDock & 2;
}
if (shrinkWrapDock) {
// Getting the size model is expensive, so only do so if we really need it
if (!ownerSizeModel) {
ownerSizeModel = me.owner.getSizeModel();
}
if (ownerSizeModel[vertical ? 'height' : 'width'].shrinkWrap) {
return policy.shrinkWrap;
}
}
return policy.stretch;
},

configureItem : function(item, pos) {
this.callParent(arguments);
item.addCls(Ext.baseCSSPrefix + 'docked');
item.addClsWithUI(this.getDockCls(item.dock));
},

getDockCls: function(dock) {
return 'docked-' + dock;
},
afterRemove : function(item) {
this.callParent(arguments);
if (this.itemCls) {
item.el.removeCls(this.itemCls + '-' + item.dock);
}
var dom = item.el.dom;
if (!item.destroying && dom) {
dom.parentNode.removeChild(dom);
}
this.childrenChanged = true;
},

borderCollapseMap: {

},

getBorderCollapseTable: function () {
var me = this,
map = me.borderCollapseMap,
owner = me.owner,
baseCls = owner.baseCls,
ui = owner.ui,
table;
map = map[baseCls] || (map[baseCls] = {});
table = map[ui];
if (!table) {
baseCls += '-' + ui + '-outer-border-';
map[ui] = table = [
0, // TRBL
baseCls + 'l', // 0001 = 1
baseCls + 'b', // 0010 = 2
baseCls + 'bl', // 0011 = 3
baseCls + 'r', // 0100 = 4
baseCls + 'rl', // 0101 = 5
baseCls + 'rb', // 0110 = 6
baseCls + 'rbl', // 0111 = 7
baseCls + 't', // 1000 = 8
baseCls + 'tl', // 1001 = 9
baseCls + 'tb', // 1010 = 10
baseCls + 'tbl', // 1011 = 11
baseCls + 'tr', // 1100 = 12
baseCls + 'trl', // 1101 = 13
baseCls + 'trb', // 1110 = 14
baseCls + 'trbl' // 1111 = 15
];
}
return table;
}
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/util/Memento.js */
(function(Ext) {
Ext.define('Ext.util.Memento', (function () {
function captureOne (src, target, prop, prefix) {
src[prefix ? prefix + prop : prop] = target[prop];
}
function removeOne (src, target, prop) {
delete src[prop];
}
function restoreOne (src, target, prop, prefix) {
var name = prefix ? prefix + prop : prop,
value = src[name];
if (value || src.hasOwnProperty(name)) {
restoreValue(target, prop, value);
}
}
function restoreValue (target, prop, value) {
if (Ext.isDefined(value)) {
target[prop] = value;
} else {
delete target[prop];
}
}
function doMany (doOne, src, target, props, prefix) {
if (src) {
if (Ext.isArray(props)) {
var p, pLen = props.length;
for (p = 0; p < pLen; p++) {
doOne(src, target, props[p], prefix);
}
} else {
doOne(src, target, props, prefix);
}
}
}
return {

data: null,

target: null,

constructor: function (target, props) {
if (target) {
this.target = target;
if (props) {
this.capture(props);
}
}
},

capture: function (props, target, prefix) {
var me = this;
doMany(captureOne, me.data || (me.data = {}), target || me.target, props, prefix);
},

remove: function (props) {
doMany(removeOne, this.data, null, props);
},

restore: function (props, clear, target, prefix) {
doMany(restoreOne, this.data, target || this.target, props, prefix);
if (clear !== false) {
this.remove(props);
}
},

restoreAll: function (clear, target) {
var me = this,
t = target || this.target,
data = me.data,
prop;
for (prop in data) {
if (data.hasOwnProperty(prop)) {
restoreValue(t, prop, data[prop]);
}
}
if (clear !== false) {
delete me.data;
}
}
};
}()));
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/panel/Panel.js */
(function(Ext) {
Ext.define('Ext.panel.Panel', {
extend: 'Ext.panel.AbstractPanel',
requires: [
'Ext.panel.Header',
'Ext.fx.Anim',
'Ext.util.KeyMap',
'Ext.panel.DD',
'Ext.XTemplate',
'Ext.layout.component.Dock',
'Ext.util.Memento'
],
alias: 'widget.panel',
alternateClassName: 'Ext.Panel',

collapsedCls: 'collapsed',

animCollapse: Ext.enableFx,

minButtonWidth: 75,

collapsed: false,

collapseFirst: true,

hideCollapseTool: false,

titleCollapse: undefined,



floatable: true,


collapsible: undefined,


closable: false,

closeAction: 'destroy',


placeholderCollapseHideMode: Ext.Element.VISIBILITY,

preventHeader: false,

header: undefined,

headerPosition: 'top',

frame: false,

frameHeader: true,




manageHeight: true,






constrain: false,

constrainHeader: false,


initComponent: function() {
var me = this;
me.addEvents(

'beforeclose',


'close',

"beforeexpand",

"beforecollapse",

"expand",

"collapse",

'titlechange',

'iconchange',


'iconclschange',

'glyphchange',

'float',

'unfloat'
);
if (me.collapsible) {
// Save state on these two events.
this.addStateEvents(['expand', 'collapse']);
}
if (me.unstyled) {
me.setUI('plain');
}
if (me.frame) {
me.setUI(me.ui + '-framed');
}
// Backwards compatibility
me.bridgeToolbars();
me.callParent();
me.collapseDirection = me.collapseDirection || me.headerPosition || Ext.Component.DIRECTION_TOP;
// Used to track hidden content elements during collapsed state
me.hiddenOnCollapse = new Ext.dom.CompositeElement();
},
beforeDestroy: function() {
var me = this;
Ext.destroy(
me.placeholder,
me.ghostPanel,
me.dd
);
me.callParent();
},
initAria: function() {
this.callParent();
this.initHeaderAria();
},
getFocusEl: function() {
return this.el;
},
initHeaderAria: function() {
var me = this,
el = me.el,
header = me.header;
if (el && header) {
el.dom.setAttribute('aria-labelledby', header.titleCmp.id);
}
},

getHeader: function() {
return this.header;
},

setTitle: function(newTitle) {
var me = this,
oldTitle = me.title,
header = me.header,
reExpander = me.reExpander,
placeholder = me.placeholder;
me.title = newTitle;
if (header) {
if (header.isHeader) {
header.setTitle(newTitle);
} else {
header.title = newTitle;
}
} else if (me.rendered) {
me.updateHeader();
}
if (reExpander) {
reExpander.setTitle(newTitle);
}
if (placeholder && placeholder.setTitle) {
placeholder.setTitle(newTitle);
}
me.fireEvent('titlechange', me, newTitle, oldTitle);
},

setIconCls: function(newIconCls) {
var me = this,
oldIconCls = me.iconCls,
header = me.header,
placeholder = me.placeholder;
me.iconCls = newIconCls;
if (header) {
if (header.isHeader) {
header.setIconCls(newIconCls);
} else {
header.iconCls = newIconCls;
}
} else {
me.updateHeader();
}
if (placeholder && placeholder.setIconCls) {
placeholder.setIconCls(newIconCls);
}
me.fireEvent('iconclschange', me, newIconCls, oldIconCls);
},


setIcon: function(newIcon) {
var me = this,
oldIcon = me.icon,
header = me.header,
placeholder = me.placeholder;
me.icon = newIcon;
if (header) {
if (header.isHeader) {
header.setIcon(newIcon);
} else {
header.icon = newIcon;
}
} else {
me.updateHeader();
}
if (placeholder && placeholder.setIcon) {
placeholder.setIcon(newIcon);
}
me.fireEvent('iconchange', me, newIcon, oldIcon);
},

setGlyph: function(newGlyph) {
var me = this,
oldGlyph = me.glyph,
header = me.header,
placeholder = me.placeholder;
me.glyph = newGlyph;
if (header) {
if (header.isHeader) {
header.setGlyph(newGlyph);
} else {
header.glyph = newGlyph;
}
} else {
me.updateHeader();
}
if (placeholder && placeholder.setGlyph) {
placeholder.setIcon(newGlyph);
}
me.fireEvent('glyphchange', me, newGlyph, oldGlyph);
},
bridgeToolbars: function() {
var me = this,
docked = [],
fbar,
fbarDefaults,
minButtonWidth = me.minButtonWidth;
function initToolbar (toolbar, pos, useButtonAlign) {
if (Ext.isArray(toolbar)) {
toolbar = {
xtype: 'toolbar',
items: toolbar
};
}
else if (!toolbar.xtype) {
toolbar.xtype = 'toolbar';
}
toolbar.dock = pos;
if (pos == 'left' || pos == 'right') {
toolbar.vertical = true;
}
// Legacy support for buttonAlign (only used by buttons/fbar)
if (useButtonAlign) {
toolbar.layout = Ext.applyIf(toolbar.layout || {}, {
// default to 'end' (right-aligned) if me.buttonAlign is undefined or invalid
pack: { left:'start', center:'center' }[me.buttonAlign] || 'end'
});
}
return toolbar;
}
// Short-hand toolbars (tbar, bbar and fbar plus new lbar and rbar):


if (me.tbar) {
docked.push(initToolbar(me.tbar, 'top'));
me.tbar = null;
}

if (me.bbar) {
docked.push(initToolbar(me.bbar, 'bottom'));
me.bbar = null;
}

if (me.buttons) {
me.fbar = me.buttons;
me.buttons = null;
}

if (me.fbar) {
fbar = initToolbar(me.fbar, 'bottom', true); // only we useButtonAlign
fbar.ui = 'footer';
// Apply the minButtonWidth config to buttons in the toolbar
if (minButtonWidth) {
fbarDefaults = fbar.defaults;
fbar.defaults = function(config) {
var defaults = fbarDefaults || {};
if ((!config.xtype || config.xtype === 'button' || (config.isComponent && config.isXType('button'))) &&
!('minWidth' in defaults)) {
defaults = Ext.apply({minWidth: minButtonWidth}, defaults);
}
return defaults;
};
}
docked.push(fbar);
me.fbar = null;
}

if (me.lbar) {
docked.push(initToolbar(me.lbar, 'left'));
me.lbar = null;
}

if (me.rbar) {
docked.push(initToolbar(me.rbar, 'right'));
me.rbar = null;
}
if (me.dockedItems) {
if (!Ext.isArray(me.dockedItems)) {
me.dockedItems = [me.dockedItems];
}
me.dockedItems = me.dockedItems.concat(docked);
} else {
me.dockedItems = docked;
}
},
isPlaceHolderCollapse: function(){
return this.collapseMode == 'placeholder';
},
onBoxReady: function(){
this.callParent();
if (this.collapsed) {
this.setHiddenDocked();
} 
},
beforeRender: function() {
var me = this,
wasCollapsed;
me.callParent();
// Add class-specific header tools.
// Panel adds collapsible and closable.
me.initTools();
// Dock the header/title unless we are configured specifically not to create a header
if (!(me.preventHeader || (me.header === false))) {
me.updateHeader();
}
// If we are rendering collapsed, we still need to save and modify various configs
if (me.collapsed) {
if (me.isPlaceHolderCollapse()) {
if (!me.hidden) {
me.setHiddenState(true);
// This will insert the placeholder Component into the ownerCt's child collection
// Its getRenderTree call which is calling this will then iterate again and
// recreate the child items array to include the new Component. Prevent the first
// collapse from firing
me.preventCollapseFire = true;
me.placeholderCollapse();
delete me.preventCollapseFire;
wasCollapsed = me.collapsed;
// Temporarily clear the flag so that the header is rendered with a collapse tool in it.
// Placeholder collapse panels never really collapse, they just hide. The tool is always
// a collapse tool.
me.collapsed = false;
}
} else {
me.beginCollapse();
me.addClsWithUI(me.collapsedCls);
}
}
// Restore the flag if we are being rendered initially placeholder collapsed.
if (wasCollapsed) {
me.collapsed = wasCollapsed;
}
},

initTools: function() {
var me = this,
tools = me.tools,
i, tool;
me.tools = [];
for (i = tools && tools.length; i; ) {
--i;
me.tools[i] = tool = tools[i];
tool.toolOwner = me;
}
// Add a collapse tool unless configured to not show a collapse tool
// or to not even show a header.
if (me.collapsible && !(me.hideCollapseTool || me.header === false || me.preventHeader)) {
me.collapseDirection = me.collapseDirection || me.headerPosition || 'top';
me.collapseTool = me.expandTool = Ext.widget({
xtype: 'tool',
handler: me.toggleCollapse,
scope: me
});
me.updateCollapseTool();
// Prepend collapse tool is configured to do so.
if (me.collapseFirst) {
me.tools.unshift(me.collapseTool);
}
}
// Add subclass-specific tools.
me.addTools();
// Make Panel closable.
if (me.closable) {
me.addClsWithUI('closable');
me.addTool(Ext.widget({
xtype : 'tool',
type: 'close',
handler: Ext.Function.bind(me.close, me, [])
}));
}
// Append collapse tool if needed.
if (me.collapseTool && !me.collapseFirst) {
me.addTool(me.collapseTool);
}
},

addTools: Ext.emptyFn,
updateCollapseTool: function () {
var me = this,
collapseTool = me.collapseTool;

if (collapseTool) {
if (me.collapsed && !me.isPlaceHolderCollapse()) {
collapseTool.setType('expand-' + me.getOppositeDirection(me.collapseDirection));
} else {
collapseTool.setType('collapse-' + me.collapseDirection);
}
}
},

close: function() {
if (this.fireEvent('beforeclose', this) !== false) {
this.doClose();
}
},
// @private
doClose: function() {
this.fireEvent('close', this);
this[this.closeAction]();
},

updateHeader: function(force) {
var me = this,
header = me.header,
title = me.title,
tools = me.tools,
icon = me.icon || me.iconCls,
vertical = me.headerPosition === 'left' || me.headerPosition === 'right';
if (Ext.isObject(header) || (header !== false && (force || (title || icon) || (tools && tools.length) || (me.collapsible && !me.titleCollapse)))) {
if (header && header.isHeader) {
header.show();
} else {
// Apply the header property to the header config
header = me.header = Ext.widget(Ext.apply({
xtype : 'header',
title : title,
titleAlign : me.titleAlign,
orientation : vertical ? 'vertical' : 'horizontal',
dock : me.headerPosition || 'top',
textCls : me.headerTextCls,
iconCls : me.iconCls,
icon : me.icon,
glyph : me.glyph,
baseCls : me.baseCls + '-header',
tools : tools,
ui : me.ui,
id : me.id + '_header',
overCls: me.headerOverCls,
indicateDrag: me.draggable,
frame : (me.frame || me.alwaysFramed) && me.frameHeader,
ignoreParentFrame : me.frame || me.overlapHeader,
ignoreBorderManagement: me.frame || me.ignoreHeaderBorderManagement,
ownerCt : me,
listeners : me.collapsible && me.titleCollapse ? {
click: me.toggleCollapse,
scope: me
} : null
}, me.header));
// Header's onAdd mutates the tools array.
// It replaces tool configs at each index with the instantiated tool
// It also injects the tool instances as properties keyed by their type.
me.addDocked(header, 0);
}
me.initHeaderAria();
} else if (header) {
header.hide();
}
},
// @inheritdoc
setUI: function(ui) {
var me = this;
me.callParent(arguments);
if (me.header && me.header.rendered) {
me.header.setUI(ui);
}
},
// @private
getDefaultContentTarget: function() {
return this.body;
},
getTargetEl: function() {
var me = this;
return me.body || me.protoBody || me.frameBody || me.el;
},
// the overrides below allow for collapsed regions inside the border layout to be hidden
// @inheritdoc
isVisible: function(deep){
var me = this;
if (me.collapsed && me.placeholder) {
return me.placeholder.isVisible(deep);
}
return me.callParent(arguments);
},
// @inheritdoc
onHide: function() {
var me = this;
if (me.collapsed && me.placeholder) {
me.placeholder.hide();
} else {
me.callParent(arguments);
}
},
// @inheritdoc
onShow: function() {
var me = this;
if (me.collapsed && me.isPlaceHolderCollapse()) {
// force hidden back to true, since this gets set by the layout
me.setHiddenState(true);
me.placeholderCollapse();
} else {
me.callParent(arguments);
}
},
onRemoved: function(destroying) {
var me = this;
// If we are removed but not being destroyed, ensure our placeholder is also removed but not destroyed
// If we are being destroyed, our destroy processing will destroy the placeholder.
// Must run before callParent because that breaks the ownerCt link
if (me.placeholder && !destroying) {
me.ownerCt.remove(me.placeholder, false);
}
me.callParent(arguments);
},

addTool: function(tools) {
if (!Ext.isArray(tools)) {
tools = [tools];
}
var me = this,
header = me.header,
t,
tLen = tools.length,
tool;
for (t = 0; t < tLen; t++) {
tool = tools[t];
tool.toolOwner = me;

if (header && header.isHeader) {
header.addTool(tool);
} else {
// only modify the tools array if the header isn't created,
// otherwise, defer to the header to manage
me.tools.push(tool);
}
}
me.updateHeader();
},
getOppositeDirection: function(d) {
var c = Ext.Component;
switch (d) {
case c.DIRECTION_TOP:
return c.DIRECTION_BOTTOM;
case c.DIRECTION_RIGHT:
return c.DIRECTION_LEFT;
case c.DIRECTION_BOTTOM:
return c.DIRECTION_TOP;
case c.DIRECTION_LEFT:
return c.DIRECTION_RIGHT;
}
},
getWidthAuthority: function() {
if (this.collapsed && this.collapsedHorizontal()) {
return 1; // the panel determine's its own width
}
return this.callParent();
},
getHeightAuthority: function() {
if (this.collapsed && this.collapsedVertical()) {
return 1; // the panel determine's its own height
}
return this.callParent();
},
collapsedHorizontal: function () {
var dir = this.getCollapsed();
return dir === 'left' || dir === 'right';
},
collapsedVertical: function () {
var dir = this.getCollapsed();
return dir === 'top' || dir === 'bottom';
},
restoreDimension: function(){
var dir = this.collapseDirection;
// If we're collapsing top/bottom, we want to restore the height
// If we're collapsing left/right, we want to restore the width
return (dir === 'top' || dir === 'bottom') ? 'height' : 'width'; 
},

getCollapsed: function() {
var me = this;
// The collapsed flag, when the Panel is collapsed acts as the direction in which the collapse took
// place. It can still be tested as truthy/falsy if only a truth value is required.
if (me.collapsed === true) {
return me.collapseDirection;
}
return me.collapsed;
},
getState: function() {
var me = this,
state = me.callParent(),
memento;
state = me.addPropertyToState(state, 'collapsed');
// If a collapse has taken place, use remembered values as the dimensions.
if (me.collapsed) {
memento = me.collapseMemento;
memento = memento && memento.data;
if (me.collapsedVertical()) {
if (state) {
delete state.height;
}
if (memento) {
state = me.addPropertyToState(state, 'height', memento.height);
}
} else {
if (state) {
delete state.width;
}
if (memento) {
state = me.addPropertyToState(state, 'width', memento.width);
}
}
}
return state;
},
findReExpander: function (direction) {
var me = this,
c = Ext.Component,
dockedItems = me.dockedItems.items,
dockedItemCount = dockedItems.length,
comp, i;

// never use the header if we're in collapseMode mini
if (me.collapseMode === 'mini') {
return;
}
switch (direction) {
case c.DIRECTION_TOP:
case c.DIRECTION_BOTTOM:
// Attempt to find a reExpander Component (docked in a horizontal orientation)
// Also, collect all other docked items which we must hide after collapse. 
for (i = 0; i < dockedItemCount; i++) {
comp = dockedItems[i];
if (!comp.hidden) {
if (comp.isHeader && (!comp.dock || comp.dock === 'top' || comp.dock === 'bottom')) {
return comp;
}
}
}
break;
case c.DIRECTION_LEFT:
case c.DIRECTION_RIGHT:
// Attempt to find a reExpander Component (docked in a vecrtical orientation)
// Also, collect all other docked items which we must hide after collapse. 
for (i = 0; i < dockedItemCount; i++) {
comp = dockedItems[i];
if (!comp.hidden) {
if (comp.isHeader && (comp.dock === 'left' || comp.dock === 'right')) {
return comp;
}
}
}
break;
default:
throw('Panel#findReExpander must be passed a valid collapseDirection');
}
},
getReExpander: function (direction) {
var me = this,
collapseDir = direction || me.collapseDirection,
reExpander = me.reExpander || me.findReExpander(collapseDir);
me.expandDirection = me.getOppositeDirection(collapseDir);
if (!reExpander) {
// We did not find a Header of the required orientation: create one.
me.reExpander = reExpander = me.createReExpander(collapseDir, {
dock: collapseDir,
cls: Ext.baseCSSPrefix + 'docked ' + me.baseCls + '-' + me.ui + '-collapsed',
isCollapsedExpander: true
});
me.dockedItems.insert(0, reExpander);
}
return reExpander;
},
createReExpander: function(direction, defaults) {
var me = this,
isLeft = direction === 'left',
isRight = direction === 'right',
isVertical = isLeft || isRight,
result = Ext.apply({
hideMode: 'offsets',
title: me.title || '&#160;',
titleAlign: me.titleAlign,
orientation: isVertical ? 'vertical' : 'horizontal',
textCls: me.headerTextCls,
icon: me.icon,
iconCls: me.iconCls,
glyph: me.glyph,
baseCls: me.self.prototype.baseCls + '-header',
ui: me.ui,
frame: me.frame && me.frameHeader,
ignoreParentFrame: me.frame || me.overlapHeader,
indicateDrag: me.draggable,
collapseImmune: true,
ownerCt: me.ownerCt,
ownerLayout: me.componentLayout,
margin: me.margin
}, defaults);

// If we're in mini mode, set the placeholder size to only 1px since
// we don't need it to show up.
if (me.collapseMode === 'mini') {
if (isVertical) {
result.width = 1;
} else {
result.height = 1;
}
}
// Create the re expand tool
// For UI consistency reasons, collapse:left reExpanders, and region: 'west' placeHolders
// have the re expand tool at the *top* with a bit of space.
if (!me.hideCollapseTool) {
if (isLeft || (isRight && me.isPlaceHolderCollapse())) {
// adjust the title position if the collapse tool needs to be at the
// top of a vertical header
result.titlePosition = 1;
}
result.tools = [{
xtype: 'tool',
type: 'expand-' + me.getOppositeDirection(direction),
uiCls: ['top'],
handler: me.toggleCollapse,
scope: me
}];
}
result = new Ext.panel.Header(result);
result.addClsWithUI(me.getHeaderCollapsedClasses(result));
return result;
},
// @private
// Create the class array to add to the Header when collpsed.
getHeaderCollapsedClasses: function(header) {
var me = this,
collapsedCls = me.collapsedCls,
collapsedClasses;
collapsedClasses = [ collapsedCls, collapsedCls + '-' + header.getDockName()];
if (me.border && (!me.frame || (me.frame && Ext.supports.CSS3BorderRadius))) {
collapsedClasses.push(collapsedCls + '-border-' + header.getDockName());
}
return collapsedClasses;
},

beginCollapse: function() {
var me = this,
lastBox = me.lastBox,
rendered = me.rendered,
collapseMemento = me.collapseMemento || (me.collapseMemento = new Ext.util.Memento(me)),
sizeModel = me.getSizeModel(),
header = me.header,
reExpander;
// When we collapse a panel, the panel is in control of one dimension (depending on
// collapse direction) and sets that on the component. We must restore the user's
// original value (including non-existance) when we expand. Using this technique, we
// mimic setCalculatedSize for the dimension we do not control and setSize for the
// one we do (only while collapsed).
// Additionally, the panel may have a shrink wrapped width and/or height. For shrinkWrapped
// panels this can be problematic, since a collapsed, shrink-wrapped panel has no way 
// of determining its width (or height if the collapse direction is horizontal). It is
// therefore necessary to capture both the width and height regardless of collapse direction.
// This allows us to set a configured width or height on the panel when it is collapsed,
// and it will be restored to an unconfigured-width shrinkWrapped state on expand.
collapseMemento.capture(['height', 'minHeight', 'width', 'minWidth']);
if (lastBox) {
collapseMemento.capture(me.restoreDimension(), lastBox, 'last.');
}
// If the panel has a shrinkWrapped height/width and is already rendered, configure its width/height as its calculated width/height,
// so that the collapsed header will have the same width or height as the panel did before it was collapsed.
// If the shrinkWrapped panel has not yet been rendered, as will be the case when a panel is initially configured with
// collapsed:true, we attempt to use the configured width/height, and fall back to minWidth or minHeight if
// width/height has not been configured, and fall back to a value of 100 if a minWidth/minHeight has not been configured.
if (me.collapsedVertical()) {
if (sizeModel.width.shrinkWrap) {
me.width = rendered ? me.getWidth() : me.width || me.minWidth || 100;
}
delete me.height;
me.minHeight = 0;
} else if (me.collapsedHorizontal()) {
if (sizeModel.height.shrinkWrap) {
me.height = rendered ? me.getHeight() : me.height || me.minHeight || 100;
}
delete me.width;
me.minWidth = 0;
}
if (me.ownerCt) {
me.ownerCt.getLayout().beginCollapse(me);
}
// Get a reExpander header. This will return the Panel Header if the Header is in the correct orientation
// If we are using the Header as the reExpander, change its UI to collapsed state
if (!me.isPlaceHolderCollapse() && header !== false) {
if (header === (reExpander = me.getReExpander())) {
header.collapseImmune = true;
header.getHierarchyState().collapseImmune = true;
header.addClsWithUI(me.getHeaderCollapsedClasses(header));
// Ensure that the reExpander has the correct framing applied.
if (header.rendered) {
header.updateFrame();
}
} else if (reExpander.el) {
// We're going to use a temporary reExpander: show it.
reExpander.el.show();
reExpander.hidden = false;
}
}
if (me.resizer) {
me.resizer.disable();
}
},
beginExpand: function() {
var me = this,
lastBox = me.lastBox,
collapseMemento = me.collapseMemento,
restoreDimension = this.restoreDimension(),
header = me.header,
reExpander;
if (collapseMemento) {
collapseMemento.restore(['minHeight', 'minWidth', restoreDimension]);
if (lastBox) {
collapseMemento.restore(restoreDimension, true, lastBox, 'last.');
}
}
if (me.ownerCt) {
me.ownerCt.getLayout().beginExpand(me);
}
if (!me.isPlaceHolderCollapse() && header !== false) {
// If we have been using our Header as the reExpander then restore the Header to expanded UI
if (header === (reExpander = me.getReExpander())) {
delete header.collapseImmune;
delete header.getHierarchyState().collapseImmune;
header.removeClsWithUI(me.getHeaderCollapsedClasses(header));
// Ensure that the reExpander has the correct framing applied.
if (header.rendered) {
header.expanding = true;
header.updateFrame();
delete header.expanding;
}
} else {
// We've been using a temporary reExpander: hide it.
reExpander.hidden = true;
reExpander.el.hide();
}
}
if (me.resizer) {
me.resizer.enable();
}
},

collapse: function(direction, animate) {
var me = this,
collapseDir = direction || me.collapseDirection,
ownerCt = me.ownerCt;
if (me.isCollapsingOrExpanding) {
return me;
}
if (arguments.length < 2) {
animate = me.animCollapse;
}
if (me.collapsed || me.fireEvent('beforecollapse', me, direction, animate) === false) {
return me;
}
if (ownerCt && me.isPlaceHolderCollapse()) {
return me.placeholderCollapse(direction, animate);
}
me.collapsed = collapseDir;
me.beginCollapse();
me.getHierarchyState().collapsed = true;
me.fireHierarchyEvent('collapse');
return me.doCollapseExpand(1, animate);
},
doCollapseExpand: function (flags, animate) {
var me = this,
originalAnimCollapse = me.animCollapse,
ownerLayout = me.ownerLayout;
// we need to temporarily set animCollapse to the animate value here because ContextItem
// uses the animCollapse property to determine if the collapse/expand should be animated
me.animCollapse = animate;
// Flag used by the layout ContextItem to impose an animation policy based upon the
// collapse direction and the animCollapse setting.
me.isCollapsingOrExpanding = flags;
// The x-animating-size class sets overflow:hidden so that overflowing
// content is clipped during animation.
if (animate) {
me.addCls(Ext.baseCSSPrefix + 'animating-size');
}
if (ownerLayout && !animate) {
ownerLayout.onContentChange(me);
} else {
me.updateLayout({ isRoot: true });
}
// set animCollapse back to its original value
me.animCollapse = originalAnimCollapse;
return me;
},

afterCollapse: function(animated) {
var me = this,
ownerLayout = me.ownerLayout;
me.isCollapsingOrExpanding = 0;
me.updateCollapseTool();
// The x-animating-size class sets overflow:hidden so that overflowing
// content is clipped during animation.
if (animated) {
me.removeCls(Ext.baseCSSPrefix + 'animating-size');
}
if (ownerLayout && animated) {
ownerLayout.onContentChange(me);
}
me.setHiddenDocked();
me.fireEvent('collapse', me);
},

setHiddenDocked: function(){
// Hide Panel content except reExpander using visibility to prevent focusing of contained elements.
// Track what we hide to re-show on expand
var me = this,
toHide = me.hiddenOnCollapse,
items = me.getDockedItems(),
len = items.length,
i = 0,
item, reExpander;

if (me.header !== false) {
reExpander = me.getReExpander();
}

toHide.add(me.body);
for (; i < len; i++) {
item = items[i];
if (item && item !== reExpander && item.el) {
toHide.add(item.el);
}
}
toHide.setStyle('visibility', 'hidden');
},

restoreHiddenDocked: function(){
var toShow = this.hiddenOnCollapse;
// Re-show Panel content which was hidden after collapse.
toShow.setStyle('visibility', '');
toShow.clear();
},
getPlaceholder: function(direction) {
var me = this,
collapseDir = direction || me.collapseDirection,
listeners = null,
placeholder = me.placeholder,
floatable = me.floatable,
titleCollapse = me.titleCollapse;
if (!placeholder) {
if (floatable || (me.collapsible && titleCollapse)) {
listeners = {
click: {
// titleCollapse needs to take precedence over floatable
fn: (!titleCollapse && floatable) ? me.floatCollapsedPanel : me.toggleCollapse,
element: 'el',
scope: me
}
};
}
me.placeholder = placeholder = Ext.widget(me.createReExpander(collapseDir, {
id: me.id + '-placeholder',
listeners: listeners
}));
}
// User created placeholder was passed in
if (!placeholder.placeholderFor) {
// Handle the case of a placeholder config
if (!placeholder.isComponent) {
me.placeholder = placeholder = me.lookupComponent(placeholder);
}
Ext.applyIf(placeholder, {
margins: me.margins,
placeholderFor: me
});
placeholder.addCls([Ext.baseCSSPrefix + 'region-collapsed-placeholder', Ext.baseCSSPrefix + 'region-collapsed-' + collapseDir + '-placeholder', me.collapsedCls]);
}
return placeholder;
},
placeholderCollapse: function(direction, animate) {
var me = this,
ownerCt = me.ownerCt,
collapseDir = direction || me.collapseDirection,
floatCls = Ext.baseCSSPrefix + 'border-region-slide-in',
placeholder = me.getPlaceholder(collapseDir),
slideInDirection;
me.isCollapsingOrExpanding = 1;
// Upcoming layout run will ignore this Component
me.setHiddenState(true);
me.collapsed = collapseDir;
if (placeholder.rendered) {
// We may have been added to another Container from that in which we rendered the placeholder
if (placeholder.el.dom.parentNode !== me.el.dom.parentNode) {
me.el.dom.parentNode.insertBefore(placeholder.el.dom, me.el.dom);
}
placeholder.hidden = false;
placeholder.el.show();
ownerCt.updateLayout();
} else {
ownerCt.insert(ownerCt.items.indexOf(me), placeholder);
}
if (me.rendered) {
// We MUST NOT hide using display because that resets all scroll information.
me.el.setVisibilityMode(me.placeholderCollapseHideMode);
if (animate) {
me.el.addCls(floatCls);
placeholder.el.hide();
slideInDirection = me.convertCollapseDir(collapseDir);
me.el.slideOut(slideInDirection, {
preserveScroll: true,
duration: Ext.Number.from(animate, Ext.fx.Anim.prototype.duration),
listeners: {
afteranimate: function() {
me.el.removeCls(floatCls);

placeholder.el.show().setStyle('display', 'none').slideIn(slideInDirection, {
easing: 'linear',
duration: 100,
listeners: {
afteranimate: function() {
placeholder.focus();
me.isCollapsingOrExpanding = 0;
me.fireEvent('collapse', me);
}
}
});
}
}
});
} else {
me.el.hide();
me.isCollapsingOrExpanding = 0;
me.fireEvent('collapse', me);
}
} else {
me.isCollapsingOrExpanding = 0;
if (!me.preventCollapseFire) {
me.fireEvent('collapse', me);
}
}
return me;
},
floatCollapsedPanel: function() {
var me = this,
placeholder = me.placeholder,
ps = placeholder.getSize(),
myBox,
floatCls = Ext.baseCSSPrefix + 'border-region-slide-in',
collapsed = me.collapsed,
layoutOwner = me.ownerCt || me,
slideDirection;
if (me.isSliding) {
return;
}
// Already floated
if (me.el.hasCls(floatCls)) {
me.slideOutFloatedPanel();
return;
}
me.isSliding = true;
// Lay out in fully expanded mode to ensure we are at the correct size, and collect our expanded box
placeholder.el.hide();
placeholder.hidden = true;
me.el.show();
me.setHiddenState(false);
me.collapsed = false;
layoutOwner.updateLayout();
myBox = me.getBox(false, true);
// Then go back immediately to collapsed state from which to initiate the float into view.
placeholder.el.show();
placeholder.hidden = false;
me.el.hide();
me.setHiddenState(true);
me.collapsed = collapsed;
layoutOwner.updateLayout();
me.slideOutTask = me.slideOutTask || new Ext.util.DelayedTask(me.slideOutFloatedPanel, me);
placeholder.el.on('mouseleave', me.onMouseLeaveFloated, me);
me.el.on('mouseleave', me.onMouseLeaveFloated, me);
placeholder.el.on('mouseenter', me.onMouseEnterFloated, me);
me.el.on('mouseenter', me.onMouseEnterFloated, me);
me.el.addCls(floatCls);
me.floated = true;
// Hide collapse tool in header if there is one (we might be headerless)
if (me.collapseTool) {
me.collapseTool.el.hide();
}
switch (me.collapsed) {
case 'top':
me.setLocalXY(myBox.x, myBox.y + ps.height - 1);
break;
case 'right':
me.setLocalXY(myBox.x - ps.width + 1, myBox.y);
break;
case 'bottom':
me.setLocalXY(myBox.x, myBox.y - ps.height + 1);
break;
case 'left':
me.setLocalXY(myBox.x + ps.width - 1, myBox.y);
break;
}
slideDirection = me.convertCollapseDir(me.collapsed);
// Remember how we are really collapsed so we can restore it, but also so we can
// become a layoutRoot while we are floated:
me.floatedFromCollapse = me.collapsed;
me.collapsed = false;
me.setHiddenState(false);
me.el.slideIn(slideDirection, {
preserveScroll: true,
duration: Ext.Number.from(me.animCollapse, Ext.fx.Anim.prototype.duration),
listeners: {
afteranimate: function() {
me.isSliding = false;
me.fireEvent('float', me);
}
}
});
},
onMouseLeaveFloated: function(e) {
this.slideOutTask.delay(500);
},
onMouseEnterFloated: function(e) {
this.slideOutTask.cancel();
},
isLayoutRoot: function() {
if (this.floatedFromCollapse) {
return true;
}
return this.callParent();
},
slideOutFloatedPanel: function() {
var me = this,
compEl = this.el,
collapseDirection;
if (me.isSliding || me.isDestroyed) {
return;
}
me.isSliding = true;
me.floated = false;
me.slideOutFloatedPanelBegin();
if (typeof me.collapsed == 'string') {
collapseDirection = me.convertCollapseDir(me.collapsed);
}
compEl.slideOut(collapseDirection, {
preserveScroll: true,
duration: Ext.Number.from(me.animCollapse, Ext.fx.Anim.prototype.duration),
listeners: {
afteranimate: function() {
me.slideOutFloatedPanelEnd();
// this would be in slideOutFloatedPanelEnd except that the only other
// caller removes this cls later
me.el.removeCls(Ext.baseCSSPrefix + 'border-region-slide-in');
}
}
});
},

slideOutFloatedPanelBegin: function() {
var me = this,
placeholderEl = me.placeholder.el,
el = me.el;
me.collapsed = me.floatedFromCollapse;
me.setHiddenState(true);
me.floatedFromCollapse = null;
// Remove mouse leave/enter monitors
placeholderEl.un('mouseleave', me.onMouseLeaveFloated, me);
el.un('mouseleave', me.onMouseLeaveFloated, me);
placeholderEl.un('mouseenter', me.onMouseEnterFloated, me);
el.un('mouseenter', me.onMouseEnterFloated, me);
},

slideOutFloatedPanelEnd: function() {
var me = this;
if (me.collapseTool) {
me.collapseTool.el.show();
}
me.slideOutTask.cancel();
me.isSliding = false;
me.fireEvent('unfloat', me);
},

expand: function(animate) {
var me = this;
if (me.isCollapsingOrExpanding) {
return me;
}
if (!arguments.length) {
animate = me.animCollapse;
}
if (!me.collapsed && !me.floatedFromCollapse) {
return me;
}
if (me.fireEvent('beforeexpand', me, animate) === false) {
return me;
}
delete this.getHierarchyState().collapsed;
if (me.isPlaceHolderCollapse()) {
return me.placeholderExpand(animate);
}
me.restoreHiddenDocked();
me.beginExpand();
me.collapsed = false;
return me.doCollapseExpand(2, animate);
},
placeholderExpand: function(animate) {
var me = this,
collapseDir = me.collapsed,
floatCls = Ext.baseCSSPrefix + 'border-region-slide-in',
finalPos,
floatedPos,
center = me.ownerLayout ? me.ownerLayout.centerRegion: null;
// Layouts suspended - don't bother with animation shenanigans
if (Ext.AbstractComponent.layoutSuspendCount) {
animate = false;
}
if (me.floatedFromCollapse) {
floatedPos = me.getPosition(true);
// these are the same cleanups performed by the normal slideOut mechanism:
me.slideOutFloatedPanelBegin();
me.slideOutFloatedPanelEnd();
me.floated = false;
}
if (animate) {
// Expand me and hide the placeholder
Ext.suspendLayouts();
me.placeholder.hide();
me.el.show();
me.collapsed = false;
me.setHiddenState(false);
// Stop the center region from moving when layed out without the placeholder there.
// Unless we are expanding from a floated out situation. In that case, it's layed out immediately.
if (center && !floatedPos) {
center.hidden = true;
}
Ext.resumeLayouts(true);
center.hidden = false;
me.el.addCls(floatCls);
// At this point, this Panel is arranged in its correct, expanded layout.
// The center region has not been affected because it has been flagged as hidden.
//
// If we are proceeding from floated, the center region has also been arranged
// in its new layout to accommodate this expansion, so no further layout is needed, just
// element animation.
//
// If we are proceeding from fully collapsed, the center region has *not* been relayed out because
// the UI look and feel dictates that it stays stable until the expanding panel has slid in all the
// way, and *then* it snaps into place.
me.isCollapsingOrExpanding = 2;
// Floated, move it back to the floated pos, and thence into the correct place
if (floatedPos) {
finalPos = me.getXY();
me.setLocalXY(floatedPos[0], floatedPos[1]);
me.setXY([finalPos[0], finalPos[1]], {
duration: Ext.Number.from(animate, Ext.fx.Anim.prototype.duration),
listeners: {
afteranimate: function() {
me.el.removeCls(floatCls);
me.isCollapsingOrExpanding = 0;
me.fireEvent('expand', me);
}
}
});
}
// Not floated, slide it in to the correct place
else {
me.el.hide();
me.placeholder.el.show();
me.placeholder.hidden = false;
// Slide this Component's el back into place, after which we lay out AGAIN
me.setHiddenState(false);
me.el.slideIn(me.convertCollapseDir(collapseDir), {
preserveScroll: true,
duration: Ext.Number.from(animate, Ext.fx.Anim.prototype.duration),
listeners: {
afteranimate: function() {
// the ordering of these two lines appears to be important in
// IE9. There is an odd expand issue in IE 9 in the border layout
// example that causes the index1 child of the south dock region
// to get 'hidden' after a collapse / expand cycle. See
// EXTJSIV-5318 for details
me.el.removeCls(floatCls);
me.placeholder.hide();
// The center region has been left in its larger size, so a layout is needed now
me.updateLayout();
me.isCollapsingOrExpanding = 0;
me.fireEvent('expand', me);
}
}
});
}
} else {
me.floated = me.collapsed = false;
me.el.removeCls(floatCls);
Ext.suspendLayouts();
me.placeholder.hide();
me.show();
Ext.resumeLayouts(true);
me.fireEvent('expand', me);
}
return me;
},

afterExpand: function(animated) {
var me = this,
ownerLayout = me.ownerLayout;
me.isCollapsingOrExpanding = 0;
me.updateCollapseTool();
// The x-animating-size class sets overflow:hidden so that overflowing
// content is clipped during animation.
if (animated) {
me.removeCls(Ext.baseCSSPrefix + 'animating-size');
}
if (ownerLayout && animated) {
ownerLayout.onContentChange(me);
}
me.fireEvent('expand', me);
me.fireHierarchyEvent('expand');
},

// @inheritdoc
setBorder: function(border, targetEl) {
if (targetEl) {
// skip out here, the panel will set the border on the body/header during rendering
return;
}

var me = this,
header = me.header;

if (!border) {
border = 0;
} else if (border === true) {
border = '1px';
} else {
border = me.unitizeBox(border);
}

if (header) {
if (header.isHeader) {
header.setBorder(border);
} else {
header.border = border;
}
}

if (me.rendered && me.bodyBorder !== false) {
me.body.setStyle('border-width', border);
}
me.updateLayout();

me.border = border;
},

toggleCollapse: function() {
return (this.collapsed || this.floatedFromCollapse) ? this.expand() : this.collapse();
},
// @private
getKeyMap : function() {
return this.keyMap || (this.keyMap = new Ext.util.KeyMap(Ext.apply({
target: this.el
}, this.keys)));
},
// @private
initDraggable : function() {

// For just simple dragging like Windows
if (this.simpleDrag) {
this.initSimpleDraggable();
}
// For DD package aware dragging of Panels
else {

this.dd = new Ext.panel.DD(this, Ext.isBoolean(this.draggable) ? null : this.draggable);
}
},

initSimpleDraggable: function() {
var me = this,
ddConfig, dd;
if (!me.header) {
me.updateHeader(true);
}

if (me.header) {
ddConfig = Ext.applyIf({
el: me.el,
delegate: '#' + Ext.escapeId(me.header.id)
}, me.draggable);
// Add extra configs if Window is specified to be constrained
if (me.constrain || me.constrainHeader) {
ddConfig.constrain = me.constrain;
ddConfig.constrainDelegate = me.constrainHeader;
ddConfig.constrainTo = me.constrainTo || me.container;
}
dd = me.dd = new Ext.util.ComponentDragger(this, ddConfig);
me.relayEvents(dd, ['dragstart', 'drag', 'dragend']);
if (me.maximized) {
dd.disable();
}
}
},

// @private
// helper function for ghost
ghostTools : function() {
var tools = [],
header = this.header,
headerTools = header ? header.query('tool[hidden=false]') : [],
t, tLen, tool;
if (headerTools.length) {
t = 0;
tLen = headerTools.length;
for (; t < tLen; t++) {
tool = headerTools[t];
// Some tools can be full components, and copying them into the ghost
// actually removes them from the owning panel. You could also potentially
// end up with duplicate DOM ids as well. To avoid any issues we just make
// a simple bare-minimum clone of each tool for ghosting purposes.
tools.push({
type: tool.type
});
}
} else {
tools = [{
type: 'placeholder'
}];
}
return tools;
},
// @private
// used for dragging
ghost: function(cls) {
var me = this,
ghostPanel = me.ghostPanel,
box = me.getBox(),
header;
if (!ghostPanel) {
ghostPanel = new Ext.panel.Panel({
renderTo: Ext.getBody(),
floating: {
shadow: false
},
frame: me.frame && !me.alwaysFramed,
alwaysFramed: me.alwaysFramed,
overlapHeader: me.overlapHeader,
headerPosition: me.headerPosition,
baseCls: me.baseCls,
cls: me.baseCls + '-ghost ' + (cls ||'')
});
me.ghostPanel = ghostPanel;
} else {
ghostPanel.el.show();
}
me.ghostPanel.hidden = false;
ghostPanel.floatParent = me.floatParent;
if (me.floating) {
ghostPanel.zIndexManager.assignZIndices();
} else {
ghostPanel.toFront();
}
if (!(me.preventHeader || (me.header === false))) {
header = ghostPanel.header;
// restore options
if (header) {
header.suspendLayouts();
Ext.Array.forEach(header.query('tool'), header.remove, header);
header.resumeLayouts();
}
ghostPanel.addTool(me.ghostTools());
ghostPanel.setTitle(me.title);
if (me.iconCls) {
ghostPanel.setIconCls(me.iconCls);
} else if (me.icon) {
ghostPanel.setIcon(me.icon);
} else if (me.glyph) {
ghostPanel.setGlyph(me.glyph);
}

ghostPanel.header.addCls(Ext.baseCSSPrefix + 'header-ghost');
}
ghostPanel.setPagePosition(box.x, box.y);
ghostPanel.setSize(box.width, box.height);
me.el.hide();
return ghostPanel;
},
// @private
unghost: function(show, matchPosition) {
var me = this;
if (!me.ghostPanel) {
return;
}
if (show !== false) {
// Show el first, so that position adjustment in setPagePosition
// will work when relative positioned elements have their XY read.
me.el.show();
if (matchPosition !== false) {
me.setPagePosition(me.ghostPanel.getXY());
if (me.hideMode == 'offsets') {
// clear the hidden style because we just repositioned
delete me.el.hideModeStyles;
}
}
Ext.defer(me.focus, 10, me);
}
me.ghostPanel.el.hide();
me.ghostPanel.hidden = true;
},
beginDrag: function() {
if (this.floatingDescendants) {
this.floatingDescendants.hide();
}
},
endDrag: function() {
if (this.floatingDescendants) {
this.floatingDescendants.show();
}
},
initResizable: function() {
this.callParent(arguments);
if (this.collapsed) {
this.resizer.disable();
}
},

convertCollapseDir: function(collapseDir) {
return collapseDir.substr(0, 1);
}
}, function() {
this.prototype.animCollapse = Ext.enableFx;
});
})(this.Ext4 || (this.Ext4 = {}));

/* *** /var/www/library/ext/4.2.1.883/src/window/Window.js */
(function(Ext) {
Ext.define('Ext.window.Window', {
extend: 'Ext.panel.Panel',
alternateClassName: 'Ext.Window',
requires: ['Ext.util.ComponentDragger', 'Ext.util.Region', 'Ext.EventManager'],
alias: 'widget.window',












baseCls: Ext.baseCSSPrefix + 'window',

resizable: true,

draggable: true,

constrain: false,

constrainHeader: false,


plain: false,

minimizable: false,

maximizable: false,
// inherit docs
minHeight: 50,
// inherit docs
minWidth: 50,

expandOnShow: true,
// inherited docs, same default
collapsible: false,

closable: true,

hidden: true,

autoRender: true,

hideMode: 'offsets',

floating: true,
itemCls: Ext.baseCSSPrefix + 'window-item',

initialAlphaNum: /^[a-z0-9]/,
overlapHeader: true,
ignoreHeaderBorderManagement: true,
// Flag to Renderable to always look up the framing styles for this Component
alwaysFramed: true,

// Buffer this so we don't recreate the same object
isRootCfg: {
isRoot: true 
},

isWindow: true,
// @private
initComponent: function() {
var me = this;
// Explicitly set frame to false, since alwaysFramed is
// true, we only want to lookup framing in a specific instance
me.frame = false;
me.callParent();
me.addEvents(



'resize',

'maximize',

'minimize',

'restore'
);
if (me.plain) {
me.addClsWithUI('plain');
}
if (me.modal) {
me.ariaRole = 'dialog';
}
me.addStateEvents(['maximize', 'restore', 'resize', 'dragend']);
},
getElConfig: function () {
var me = this,
elConfig;
elConfig = me.callParent();
elConfig.tabIndex = -1;
return elConfig;
},
// State Management

// @private
getState: function() {
var me = this,
state = me.callParent() || {},
maximized = !!me.maximized,
ghostBox = me.ghostBox,
pos;

state.maximized = maximized;
if (maximized) {
pos = me.restorePos;
} else if (ghostBox) {
// If we're animating a show, it will be from offscreen, so
// grab the position from the final box
pos = [ghostBox.x, ghostBox.y];
} else {
pos = me.getPosition();
}
Ext.apply(state, {
size: maximized ? me.restoreSize : me.getSize(),
pos: pos
});
return state;
},
applyState: function(state){
var me = this;
if (state) {
me.maximized = state.maximized;
if (me.maximized) {
me.hasSavedRestore = true;
me.restoreSize = state.size;
me.restorePos = state.pos;
} else {
Ext.apply(me, {
width: state.size.width,
height: state.size.height,
x: state.pos[0],
y: state.pos[1]
});
}
}
},
// @private
onRender: function(ct, position) {
var me = this;
me.callParent(arguments);
me.focusEl = me.el;
// Double clicking a header will toggleMaximize
if (me.maximizable) {
me.header.on({
scope: me,
dblclick: me.toggleMaximize
});
}
},
// @private
afterRender: function() {
var me = this,
header = me.header,
keyMap;
me.callParent();
// Initialize
if (me.maximized) {
me.maximized = false;
me.maximize();
if (header) {
header.removeCls(header.indicateDragCls)
}
}
if (me.closable) {
keyMap = me.getKeyMap();
keyMap.on(27, me.onEsc, me);
} else {
keyMap = me.keyMap;
}
if (keyMap && me.hidden) {
keyMap.disable();
}
},
// Override. Windows are always simple draggable, they do not use Ext.Panel.DDs
// The dd property in a Window is always a ComponentDragger
initDraggable: function() {

this.initSimpleDraggable();
},
initResizable: function(){
this.callParent(arguments);
if (this.maximized) {
this.resizer.disable();
}
},
// @private
onEsc: function(k, e) {
// Only process ESC if the FocusManager is not doing it
if (!Ext.FocusManager || !Ext.FocusManager.enabled || Ext.FocusManager.focusedCmp === this) {
e.stopEvent();
this.close();
}
},
// @private
beforeDestroy: function() {
var me = this;
if (me.rendered) {
delete this.animateTarget;
me.hide();
Ext.destroy(
me.keyMap
);
}
me.callParent();
},

addTools: function() {
var me = this;
// Call Panel's initTools
me.callParent();
if (me.minimizable) {
me.addTool({
type: 'minimize',
handler: Ext.Function.bind(me.minimize, me, [])
});
}
if (me.maximizable) {
me.addTool({
type: 'maximize',
handler: Ext.Function.bind(me.maximize, me, [])
});
me.addTool({
type: 'restore',
handler: Ext.Function.bind(me.restore, me, []),
hidden: true
});
}
},

getFocusEl: function() {
return this.getDefaultFocus();
},

getDefaultFocus: function() {
var me = this,
result,
defaultComp = me.defaultButton || me.defaultFocus,
selector;
if (defaultComp !== undefined) {
// Number is index of Button
if (Ext.isNumber(defaultComp)) {
result = me.query('button')[defaultComp];
}
// String is ID or CQ selector
else if (Ext.isString(defaultComp)) {
selector = defaultComp;

// Try id/itemId match if selector begins with alphanumeric
if (selector.match(me.initialAlphaNum)) {
result = me.down('#' + selector);
}
// If not found, use as selector
if (!result) {
result = me.down(selector);
}
}
// Otherwise, if it's got a focus method, use it
else if (defaultComp.focus) {
result = defaultComp;
}
}
return result || me.el;
},

onFocus: function() {
var me = this,
focusDescendant;
// If the FocusManager is enabled, then we must noy jumpt to focus the default focus. We must focus the Window
if ((Ext.FocusManager && Ext.FocusManager.enabled) || ((focusDescendant = me.getDefaultFocus()) === me)) {
me.callParent(arguments);
} else {
focusDescendant.focus();
}
},
onShow: function() {
var me = this;
me.callParent(arguments);
if (me.expandOnShow) {
me.expand(false);
}
me.syncMonitorWindowResize();
if (me.keyMap) {
me.keyMap.enable();
}
},
// @private
doClose: function() {
var me = this;
// Being called as callback after going through the hide call below
if (me.hidden) {
me.fireEvent('close', me);
if (me.closeAction == 'destroy') {
this.destroy();
}
} else {
// close after hiding
me.hide(me.animateTarget, me.doClose, me);
}
},
// @private
afterHide: function() {
var me = this;
// No longer subscribe to resizing now that we're hidden
me.syncMonitorWindowResize();
// Turn off keyboard handling once window is hidden
if (me.keyMap) {
me.keyMap.disable();
}
// Perform superclass's afterHide tasks.
me.callParent(arguments);
},
// @private
onWindowResize: function() {
var me = this,
sizeModel;
if (me.maximized) {
me.fitContainer();
} else {
sizeModel = me.getSizeModel();
if (sizeModel.width.natural || sizeModel.height.natural) {
me.updateLayout();
}
me.doConstrain();
}
},

minimize: function() {
this.fireEvent('minimize', this);
return this;
},

resumeHeaderLayout: function(changed) {
this.header.resumeLayouts(changed ? this.isRootCfg : null); 
},
afterCollapse: function() {
var me = this,
header = me.header,
tools = me.tools;
if (header && me.maximizable) {
header.suspendLayouts();
tools.maximize.hide();
tools.restore.hide();
this.resumeHeaderLayout(true);
}
if (me.resizer) {
me.resizer.disable();
}
me.callParent(arguments);
},
afterExpand: function() {
var me = this,
header = me.header,
tools = me.tools,
changed;

if (header) {
header.suspendLayouts();
if (me.maximized) {
tools.restore.show();
changed = true;
} else if (me.maximizable) {
tools.maximize.show();
changed = true;
}
this.resumeHeaderLayout(changed);
}
if (me.resizer) {
me.resizer.enable();
}
me.callParent(arguments);
},

maximize: function(animate) {
var me = this,
header = me.header,
tools = me.tools,
changed;
if (!me.maximized) {
me.expand(false);
if (!me.hasSavedRestore) {
me.restoreSize = me.getSize();
me.restorePos = me.getPosition(true);
}
// Manipulate visibility of header tools if there is a header
if (header) {
header.suspendLayouts();
if (tools.maximize) {
tools.maximize.hide();
changed = true;
}
if (tools.restore) {
tools.restore.show();
changed = true;
}
if (me.collapseTool) {
me.collapseTool.hide();
changed = true;
}
me.resumeHeaderLayout(changed);
}
me.maximized = true;
me.el.disableShadow();
if (me.dd) {
me.dd.disable();
if (header) {
header.removeCls(header.indicateDragCls)
}
}
if (me.resizer) {
me.resizer.disable();
}

me.el.addCls(Ext.baseCSSPrefix + 'window-maximized');
me.container.addCls(Ext.baseCSSPrefix + 'window-maximized-ct');
me.syncMonitorWindowResize();
me.fitContainer(animate = (animate || !!me.animateTarget) ? {
callback: function() {
me.fireEvent('maximize', me);
}
} : null);
if (!animate) {
me.fireEvent('maximize', me);
}
}
return me;
},

restore: function(animate) {
var me = this,
tools = me.tools,
header = me.header,
newBox = me.restoreSize,
changed;
if (me.maximized) {
me.hasSavedRestore = null;
me.removeCls(Ext.baseCSSPrefix + 'window-maximized');
// Manipulate visibility of header tools if there is a header
if (header) {
header.suspendLayouts();
if (tools.restore) {
tools.restore.hide();
changed = true;
}
if (tools.maximize) {
tools.maximize.show();
changed = true;
}
if (me.collapseTool) {
me.collapseTool.show();
changed = true;
}
me.resumeHeaderLayout(changed);
}
me.maximized = false;
// Restore the position/sizing
newBox.x = me.restorePos[0];
newBox.y = me.restorePos[1];
me.setBox(newBox, animate = (animate || !!me.animateTarget) ? {
callback: function() {
me.el.enableShadow(true);
me.fireEvent('restore', me);
}
} : null);
// Unset old position/sizing
me.restorePos = me.restoreSize = null;
// Allow users to drag and drop again
if (me.dd) {
me.dd.enable();
if (header) {
header.addCls(header.indicateDragCls)
}
}

if (me.resizer) {
me.resizer.enable();
}
me.container.removeCls(Ext.baseCSSPrefix + 'window-maximized-ct');
me.syncMonitorWindowResize();
if (!animate) {
me.el.enableShadow(true);
me.fireEvent('restore', me);
}
}
return me;
},

syncMonitorWindowResize: function () {
var me = this,
currentlyMonitoring = me._monitoringResize,
// all the states where we should be listening to window resize:
yes = me.monitorResize || me.constrain || me.constrainHeader || me.maximized,
// all the states where we veto this:
veto = me.hidden || me.destroying || me.isDestroyed;
if (yes && !veto) {
// we should be listening...
if (!currentlyMonitoring) {
// but we aren't, so set it up.
// Delay so that we jump over any Viewport resize activity
Ext.EventManager.onWindowResize(me.onWindowResize, me, {delay: 1});
me._monitoringResize = true;
}
} else if (currentlyMonitoring) {
// we should not be listening, but we are, so tear it down
Ext.EventManager.removeResizeListener(me.onWindowResize, me);
me._monitoringResize = false;
}
},

toggleMaximize: function() {
return this[this.maximized ? 'restore': 'maximize']();
}
});
})(this.Ext4 || (this.Ext4 = {}));

